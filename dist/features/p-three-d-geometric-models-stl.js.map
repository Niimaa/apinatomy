{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6********************","webpack:///webpack/bootstrap 467eaae0cc717fc5d58e?85f0********************","webpack:///external \"jquery\"?0b76********************","webpack:///external \"three-js\"?e59f********","webpack:///./src/features/p-three-d-geometric-models-stl.es6.js","webpack:///./src/util/STLLoader.js"],"names":[],"mappings":"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","file":"features/p-three-d-geometric-models-stl.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"jquery\"), require(\"three-js\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"jquery\", \"three-js\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"jquery\"), require(\"three-js\")) : factory(root[\"jquery\"], root[\"three-js\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_15__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 467eaae0cc717fc5d58e\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"jquery\"\n ** module id = 2\n ** module chunks = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 50 52 53 56 57 58\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_15__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"three-js\"\n ** module id = 15\n ** module chunks = 1 5 11 13 14 16 17 18 19 20 21 23 24\n **/","define([\n\t'jquery',\n\t'three-js',\n\t'../util/STLLoader.js'\n], function ($, THREE) {\n\t'use strict';\n\n\n\t/* the plugin */\n\tvar plugin = $.circuitboard.plugin.do('three-d-geometric-models-stl', {\n\t\trequires: ['three-d-geometric-models']\n\t});\n\n\n\t/* the loader */\n\tplugin.add('Circuitboard.threeJsLoaders.stl', THREE.STLLoader);\n\n\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/features/p-three-d-geometric-models-stl.es6.js\n **/","/**\n * @author aleeper / http://adamleeper.com/\n * @author mrdoob / http://mrdoob.com/\n * @author gero3 / https://github.com/gero3\n *\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * Limitations:\n *    Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *    There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *    ASCII decoding assumes file is UTF-8. Seems to work for the examples...\n *\n * Usage:\n *    var loader = new THREE.STLLoader();\n *    loader.addEventListener( 'load', function ( event ) {\n *\n * \t\tvar geometry = event.content;\n * \t\tscene.add( new THREE.Mesh( geometry ) );\n *\n * \t} );\n *    loader.load( './models/stl/slotted_disk.stl' );\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  ... // use the same code to load STL as above\n *  var geometry = event.content;\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });\n *  } else { .... }\n * var mesh = new THREE.Mesh( geometry, material );\n */\n\n\n/* jshint ignore:start */\n\ndefine(['three-js'], function (THREE) {\n\n\n\tTHREE.STLLoader = function () {};\n\n\tTHREE.STLLoader.prototype = {\n\n\t\tconstructor: THREE.STLLoader\n\n\t};\n\n\tTHREE.STLLoader.prototype.load = function (url, callback) {\n\n\t\tvar scope = this;\n\n\t\tvar xhr = new XMLHttpRequest();\n\n\t\tfunction onloaded(event) {\n\n\t\t\tif (event.target.status === 200 || event.target.status === 0) {\n\n\t\t\t\tvar geometry = scope.parse(event.target.response || event.target.responseText);\n\n\t\t\t\tscope.dispatchEvent({ type: 'load', content: geometry });\n\n\t\t\t\tif (callback) callback(geometry);\n\n\t\t\t} else {\n\n\t\t\t\tscope.dispatchEvent({\n\t\t\t\t\ttype: 'error',\n\t\t\t\t\tmessage: 'Couldn\\'t load URL [' + url + ']',\n\t\t\t\t\tresponse: event.target.statusText\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t}\n\n\t\txhr.addEventListener('load', onloaded, false);\n\n\t\txhr.addEventListener('progress', function (event) {\n\n\t\t\tscope.dispatchEvent({ type: 'progress', loaded: event.loaded, total: event.total });\n\n\t\t}, false);\n\n\t\txhr.addEventListener('error', function () {\n\n\t\t\tscope.dispatchEvent({ type: 'error', message: 'Couldn\\'t load URL [' + url + ']' });\n\n\t\t}, false);\n\n\t\tif (xhr.overrideMimeType) xhr.overrideMimeType('text/plain; charset=x-user-defined');\n\t\txhr.open('GET', url, true);\n\t\txhr.responseType = 'arraybuffer';\n\t\txhr.send(null);\n\n\t};\n\n\tTHREE.STLLoader.prototype.parse = function (data) {\n\n\n\t\tvar isBinary = function () {\n\n\t\t\tvar expect, face_size, n_faces, reader;\n\t\t\treader = new DataView(binData);\n\t\t\tface_size = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8);\n\t\t\tn_faces = reader.getUint32(80, true);\n\t\t\texpect = 80 + (32 / 8) + (n_faces * face_size);\n\t\t\treturn expect === reader.byteLength;\n\n\t\t};\n\n\t\tvar binData = this.ensureBinary(data);\n\n\t\treturn isBinary()\n\t\t\t\t? this.parseBinary(binData)\n\t\t\t\t: this.parseASCII(this.ensureString(data));\n\n\t};\n\n\tTHREE.STLLoader.prototype.parseBinary = function (data) {\n\n\t\tvar reader = new DataView(data);\n\t\tvar faces = reader.getUint32(80, true);\n\n\t\tvar r, g, b, hasColors = false, colors;\n\t\tvar defaultR, defaultG, defaultB, alpha;\n\n\t\t// process STL header\n\t\t// check for default color in header (\"COLOR=rgba\" sequence).\n\t\tfor (var index = 0; index < 80 - 10; index++) {\n\n\t\t\tif ((reader.getUint32(index, false) == 0x434F4C4F /*COLO*/) &&\n\t\t\t\t\t(reader.getUint8(index + 4) == 0x52 /*'R'*/) &&\n\t\t\t\t\t(reader.getUint8(index + 5) == 0x3D /*'='*/)) {\n\n\t\t\t\thasColors = true;\n\t\t\t\tcolors = new Float32Array(faces * 3 * 3);\n\n\t\t\t\tdefaultR = reader.getUint8(index + 6) / 255;\n\t\t\t\tdefaultG = reader.getUint8(index + 7) / 255;\n\t\t\t\tdefaultB = reader.getUint8(index + 8) / 255;\n\t\t\t\talpha = reader.getUint8(index + 9) / 255;\n\t\t\t}\n\t\t}\n\n\t\tvar dataOffset = 84;\n\t\tvar faceLength = 12 * 4 + 2;\n\n\t\tvar offset = 0;\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\tvar vertices = new Float32Array(faces * 3 * 3);\n\t\tvar normals = new Float32Array(faces * 3 * 3);\n\n\t\tfor (var face = 0; face < faces; face++) {\n\n\t\t\tvar start = dataOffset + face * faceLength;\n\t\t\tvar normalX = reader.getFloat32(start, true);\n\t\t\tvar normalY = reader.getFloat32(start + 4, true);\n\t\t\tvar normalZ = reader.getFloat32(start + 8, true);\n\n\t\t\tif (hasColors) {\n\n\t\t\t\tvar packedColor = reader.getUint16(start + 48, true);\n\n\t\t\t\tif ((packedColor & 0x8000) === 0) { // facet has its own unique color\n\n\t\t\t\t\tr = (packedColor & 0x1F) / 31;\n\t\t\t\t\tg = ((packedColor >> 5) & 0x1F) / 31;\n\t\t\t\t\tb = ((packedColor >> 10) & 0x1F) / 31;\n\t\t\t\t} else {\n\n\t\t\t\t\tr = defaultR;\n\t\t\t\t\tg = defaultG;\n\t\t\t\t\tb = defaultB;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var i = 1; i <= 3; i++) {\n\n\t\t\t\tvar vertexstart = start + i * 12;\n\n\t\t\t\tvertices[offset] = reader.getFloat32(vertexstart, true);\n\t\t\t\tvertices[offset + 1] = reader.getFloat32(vertexstart + 4, true);\n\t\t\t\tvertices[offset + 2] = reader.getFloat32(vertexstart + 8, true);\n\n\t\t\t\tnormals[offset] = normalX;\n\t\t\t\tnormals[offset + 1] = normalY;\n\t\t\t\tnormals[offset + 2] = normalZ;\n\n\t\t\t\tif (hasColors) {\n\t\t\t\t\tcolors[offset] = r;\n\t\t\t\t\tcolors[offset + 1] = g;\n\t\t\t\t\tcolors[offset + 2] = b;\n\t\t\t\t}\n\n\t\t\t\toffset += 3;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));\n\t\tgeometry.addAttribute('normal', new THREE.BufferAttribute(normals, 3));\n\n\t\tif (hasColors) {\n\t\t\tgeometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));\n\t\t\tgeometry.hasColors = true;\n\t\t\tgeometry.alpha = alpha;\n\t\t}\n\n\t\treturn geometry;\n\n\t};\n\n\tTHREE.STLLoader.prototype.parseASCII = function (data) {\n\n\t\tvar geometry, length, normal, patternFace, patternNormal, patternVertex, result, text;\n\t\tgeometry = new THREE.Geometry();\n\t\tpatternFace = /facet([\\s\\S]*?)endfacet/g;\n\n\t\twhile (( result = patternFace.exec(data) ) !== null) {\n\n\t\t\ttext = result[0];\n\t\t\tpatternNormal = /normal[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;\n\n\t\t\twhile (( result = patternNormal.exec(text) ) !== null) {\n\n\t\t\t\tnormal = new THREE.Vector3(parseFloat(result[1]), parseFloat(result[3]), parseFloat(result[5]));\n\n\t\t\t}\n\n\t\t\tpatternVertex = /vertex[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;\n\n\t\t\twhile (( result = patternVertex.exec(text) ) !== null) {\n\n\t\t\t\tgeometry.vertices.push(new THREE.Vector3(parseFloat(result[1]), parseFloat(result[3]), parseFloat(result[5])));\n\n\t\t\t}\n\n\t\t\tlength = geometry.vertices.length;\n\n\t\t\tgeometry.faces.push(new THREE.Face3(length - 3, length - 2, length - 1, normal));\n\n\t\t}\n\n\t\tgeometry.computeBoundingBox();\n\t\tgeometry.computeBoundingSphere();\n\n\t\treturn geometry;\n\n\t};\n\n\tTHREE.STLLoader.prototype.ensureString = function (buf) {\n\n\t\tif (typeof buf !== \"string\") {\n\t\t\tvar array_buffer = new Uint8Array(buf);\n\t\t\tvar str = '';\n\t\t\tfor (var i = 0; i < buf.byteLength; i++) {\n\t\t\t\tstr += String.fromCharCode(array_buffer[i]); // implicitly assumes little-endian\n\t\t\t}\n\t\t\treturn str;\n\t\t} else {\n\t\t\treturn buf;\n\t\t}\n\n\t};\n\n\tTHREE.STLLoader.prototype.ensureBinary = function (buf) {\n\n\t\tif (typeof buf === \"string\") {\n\t\t\tvar array_buffer = new Uint8Array(buf.length);\n\t\t\tfor (var i = 0; i < buf.length; i++) {\n\t\t\t\tarray_buffer[i] = buf.charCodeAt(i) & 0xff; // implicitly assumes little-endian\n\t\t\t}\n\t\t\treturn array_buffer.buffer || array_buffer;\n\t\t} else {\n\t\t\treturn buf;\n\t\t}\n\n\t};\n\n\tTHREE.EventDispatcher.prototype.apply(THREE.STLLoader.prototype);\n\n\tif (typeof DataView === 'undefined') {\n\n\t\tDataView = function (buffer, byteOffset, byteLength) {\n\n\t\t\tthis.buffer = buffer;\n\t\t\tthis.byteOffset = byteOffset || 0;\n\t\t\tthis.byteLength = byteLength || buffer.byteLength || buffer.length;\n\t\t\tthis._isString = typeof buffer === \"string\";\n\n\t\t}\n\n\t\tDataView.prototype = {\n\n\t\t\t_getCharCodes: function (buffer, start, length) {\n\t\t\t\tstart = start || 0;\n\t\t\t\tlength = length || buffer.length;\n\t\t\t\tvar end = start + length;\n\t\t\t\tvar codes = [];\n\t\t\t\tfor (var i = start; i < end; i++) {\n\t\t\t\t\tcodes.push(buffer.charCodeAt(i) & 0xff);\n\t\t\t\t}\n\t\t\t\treturn codes;\n\t\t\t},\n\n\t\t\t_getBytes: function (length, byteOffset, littleEndian) {\n\n\t\t\t\tvar result;\n\n\t\t\t\t// Handle the lack of endianness\n\t\t\t\tif (littleEndian === undefined) {\n\n\t\t\t\t\tlittleEndian = this._littleEndian;\n\n\t\t\t\t}\n\n\t\t\t\t// Handle the lack of byteOffset\n\t\t\t\tif (byteOffset === undefined) {\n\n\t\t\t\t\tbyteOffset = this.byteOffset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbyteOffset = this.byteOffset + byteOffset;\n\n\t\t\t\t}\n\n\t\t\t\tif (length === undefined) {\n\n\t\t\t\t\tlength = this.byteLength - byteOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// Error Checking\n\t\t\t\tif (typeof byteOffset !== 'number') {\n\n\t\t\t\t\tthrow new TypeError('DataView byteOffset is not a number');\n\n\t\t\t\t}\n\n\t\t\t\tif (length < 0 || byteOffset + length > this.byteLength) {\n\n\t\t\t\t\tthrow new Error('DataView length or (byteOffset+length) value is out of bounds');\n\n\t\t\t\t}\n\n\t\t\t\tif (this.isString) {\n\n\t\t\t\t\tresult = this._getCharCodes(this.buffer, byteOffset, byteOffset + length);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult = this.buffer.slice(byteOffset, byteOffset + length);\n\n\t\t\t\t}\n\n\t\t\t\tif (!littleEndian && length > 1) {\n\n\t\t\t\t\tif (!(result instanceof Array)) {\n\n\t\t\t\t\t\tresult = Array.prototype.slice.call(result);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresult.reverse();\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\n\t\t\t},\n\n\t\t\t// Compatibility functions on a String Buffer\n\n\t\t\tgetFloat64: function (byteOffset, littleEndian) {\n\n\t\t\t\tvar b = this._getBytes(8, byteOffset, littleEndian),\n\n\t\t\t\t\t\tsign = 1 - (2 * (b[7] >> 7)),\n\t\t\t\t\t\texponent = ((((b[7] << 1) & 0xff) << 3) | (b[6] >> 4)) - ((1 << 10) - 1),\n\n\t\t\t\t// Binary operators such as | and << operate on 32 bit values, using + and Math.pow(2) instead\n\t\t\t\t\t\tmantissa = ((b[6] & 0x0f) * Math.pow(2, 48)) + (b[5] * Math.pow(2, 40)) + (b[4] * Math.pow(2, 32)) +\n\t\t\t\t\t\t\t\t(b[3] * Math.pow(2, 24)) + (b[2] * Math.pow(2, 16)) + (b[1] * Math.pow(2, 8)) + b[0];\n\n\t\t\t\tif (exponent === 1024) {\n\t\t\t\t\tif (mantissa !== 0) {\n\t\t\t\t\t\treturn NaN;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn sign * Infinity;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (exponent === -1023) { // Denormalized\n\t\t\t\t\treturn sign * mantissa * Math.pow(2, -1022 - 52);\n\t\t\t\t}\n\n\t\t\t\treturn sign * (1 + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);\n\n\t\t\t},\n\n\t\t\tgetFloat32: function (byteOffset, littleEndian) {\n\n\t\t\t\tvar b = this._getBytes(4, byteOffset, littleEndian),\n\n\t\t\t\t\t\tsign = 1 - (2 * (b[3] >> 7)),\n\t\t\t\t\t\texponent = (((b[3] << 1) & 0xff) | (b[2] >> 7)) - 127,\n\t\t\t\t\t\tmantissa = ((b[2] & 0x7f) << 16) | (b[1] << 8) | b[0];\n\n\t\t\t\tif (exponent === 128) {\n\t\t\t\t\tif (mantissa !== 0) {\n\t\t\t\t\t\treturn NaN;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn sign * Infinity;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (exponent === -127) { // Denormalized\n\t\t\t\t\treturn sign * mantissa * Math.pow(2, -126 - 23);\n\t\t\t\t}\n\n\t\t\t\treturn sign * (1 + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);\n\t\t\t},\n\n\t\t\tgetInt32: function (byteOffset, littleEndian) {\n\t\t\t\tvar b = this._getBytes(4, byteOffset, littleEndian);\n\t\t\t\treturn (b[3] << 24) | (b[2] << 16) | (b[1] << 8) | b[0];\n\t\t\t},\n\n\t\t\tgetUint32: function (byteOffset, littleEndian) {\n\t\t\t\treturn this.getInt32(byteOffset, littleEndian) >>> 0;\n\t\t\t},\n\n\t\t\tgetInt16: function (byteOffset, littleEndian) {\n\t\t\t\treturn (this.getUint16(byteOffset, littleEndian) << 16) >> 16;\n\t\t\t},\n\n\t\t\tgetUint16: function (byteOffset, littleEndian) {\n\t\t\t\tvar b = this._getBytes(2, byteOffset, littleEndian);\n\t\t\t\treturn (b[1] << 8) | b[0];\n\t\t\t},\n\n\t\t\tgetInt8: function (byteOffset) {\n\t\t\t\treturn (this.getUint8(byteOffset) << 24) >> 24;\n\t\t\t},\n\n\t\t\tgetUint8: function (byteOffset) {\n\t\t\t\treturn this._getBytes(1, byteOffset)[0];\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\n});\n\n/* jshint ignore:end */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/util/STLLoader.js\n ** module id = 54\n ** module chunks = 20\n **/"],"sourceRoot":""}