/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(47);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(48);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(71)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-tile-skin.scss", function() {
			var newContent = require("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-tile-skin.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(39), __webpack_require__(4), __webpack_require__(3), __webpack_require__(70)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, P, Kefir, U) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('tile-shrink-when-hidden', {
			requires: ['tile-hidden']
		}).modify('Tile.prototype');
	
		/* default DOM manipulation */
		plugin.add('shrinkWhenHidden', function (hidden) {
			var _this = this;
	
			var flexGrowFrom = parseFloat(U.defOr(this.element.data('amyFlexGrowTarget'), 1));
			var flexGrowTo = hidden ? 0 : this.open ? this.weightWhenOpen() : this.weightWhenClosed();
			this.element.data('amyFlexGrowTarget', flexGrowTo);
			var rowFlexGrowTo = 0;
			this.element.parent().children().each(function () {
				rowFlexGrowTo += parseFloat(U.defOr($(this).data('amyFlexGrowTarget'), 1));
			});
			var rowFlexGrowFrom = rowFlexGrowTo - flexGrowTo + flexGrowFrom;
			if (flexGrowTo > 0) {
				this.element.css('display', 'flex');
			}
			if (rowFlexGrowTo > 0) {
				this.element.parent().css('display', 'flex');
			}
			return P.all([new P(function (resolve) {
				_this.element.velocity({ flexGrow: [flexGrowTo, flexGrowFrom] }, { complete: resolve, duration: 300 });
			}), new P(function (resolve) {
				_this.element.parent().velocity({ flexGrow: [rowFlexGrowTo, rowFlexGrowFrom] }, { complete: resolve, duration: 300 });
			})]).tap(function () {
				if (flexGrowTo === 0) {
					_this.element.css('display', 'none');
				}
				if (rowFlexGrowTo === 0) {
					_this.element.parent().css('display', 'none');
				}
			});
		});
	
		/* react to a tile opening or closing by changing its weight accordingly */
		plugin.append('construct', function () {
			var _this2 = this;
	
			/* make the tile grow/shrink based on hidden-ness */
			this.p('hidden').changes().onValue(function (hidden) {
				_this2.shrinkWhenHidden(hidden).then(function () {
					if (hidden) {
						finishedHidingBus.emit();
					} else {
						finishedShowingBus.emit();
					}
				});
			});
	
			var finishedHidingBus = Kefir.bus();
			var finishedShowingBus = Kefir.bus();
	
			/* create a property that tells if a tile is 'fully open', i.e., also the animation is done */
			this.newProperty('fullyHidden', { settable: false, initial: this.hidden }).plug(this.p('hidden').value(false)).plug(finishedHidingBus.mapTo(true));
	
			/* create a property that tells if a tile is 'fully open', i.e., also the animation is done */
			this.newProperty('fullyVisible', { settable: false, initial: !this.hidden }).plug(this.p('hidden').not().value(false)).plug(finishedShowingBus.mapTo(true));
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(39), __webpack_require__(40)], __WEBPACK_AMD_DEFINE_RESULT__ = function (P, defer) {
		'use strict';
	
		var U = {
	
			//// create a new class, given a constructor and possible prototype
			//newClass(constructor, prototype = {}) {
			//	constructor.prototype = prototype;
			//	constructor.prototype.constructor = constructor;
			//	return constructor;
			//}, // Already made redundant by ES6; TODO: do same for `newSubclass`
	
			// create a new subclass, given a superclass, constructor and possible prototype
			newSubclass: function newSubclass(superClass, constructorMaker) {
				var prototype = arguments[2] === undefined ? {} : arguments[2];
	
				var constructor = constructorMaker(superClass.prototype.constructor);
				constructor.prototype = Object.create(superClass.prototype);
				U.extend(constructor.prototype, prototype);
				constructor.prototype.constructor = constructor;
				return constructor;
			},
	
			// extend the first passed object with the properties
			// of the other objects, from left to right, and returns
			// the first passed object
			extend: function extend(obj1) {
				for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
					rest[_key - 1] = arguments[_key];
				}
	
				rest.forEach(function (obj) {
					for (var key in obj) {
						if (obj.hasOwnProperty(key)) {
							Object.defineProperty(obj1, key, Object.getOwnPropertyDescriptor(obj, key));
						}
					}
				});
				return obj1;
			},
	
			// create a function that returns the value of
			// a specific field from a given object
			field: function field(name) {
				return function (obj) {
					return obj[name];
				};
			},
	
			// create a function that returns the value of
			// a specific field from a given object
			call: function call(fn) {
				for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
					args[_key2 - 1] = arguments[_key2];
				}
	
				return fn.apply(undefined, args);
			},
	
			// a function that returns its first argument
			id: function id(v) {
				return v;
			},
	
			// get the object `obj[name]`; if `obj[name]` is not
			// defined, give it a default value first; if the given value
			// is a function, it is called, and its result is used
			getDef: function getDef(obj, name, value) {
				if (U.isUndefined(obj[name])) {
					if (typeof value === 'function') {
						value = value();
					}
					obj[name] = value;
				}
				return obj[name];
			},
	
			// get the object `obj[name]`; if `obj[name]` is not
			// a (plain) object, make it an empty object first
			object: function object(obj, name) {
				return U.getDef(obj, name, {});
			},
	
			// get the array `obj[name]`; if `obj[name]` is not
			// an array, make it an empty array first
			array: function array(obj, name) {
				return U.getDef(obj, name, []);
			},
	
			// pull a value from an array
			pull: function pull(arr, val) {
				var i = arr.indexOf(val);
				if (i !== -1) {
					arr.splice(i);
				}
			},
	
			// empty out an array
			makeEmpty: function makeEmpty(arr) {
				while (arr.length > 0) {
					arr.pop();
				}
			},
	
			// `Function.bind`, but taking an array like `Function.apply` does
			bindA: function bindA(fn, ctx, args) {
				return fn.bind.apply(fn, [ctx].concat(args));
			},
	
			// `Function.bind`, but only having to specify the context-object once
			bind: function bind(obj, m) {
				for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
					args[_key3 - 2] = arguments[_key3];
				}
	
				return U.bindA(obj[m], obj, args);
			},
	
			// allows the Function constructor to be used
			// with an array of formal parameters
			applyConstructor: function applyConstructor(ConstructorFn, args) {
				var NewConstructorFn = ConstructorFn.bind.apply(ConstructorFn, [null].concat(args));
				return new NewConstructorFn();
			},
	
			// a simple `assert` function, to express a
			// condition that is expected to be true
			assert: function assert(condition, message) {
				if (!condition) {
					throw new Error(message || 'Assertion failed');
				}
			},
	
			// test if a value is `undefined`
			isUndefined: function isUndefined(val) {
				return typeof val === 'undefined';
			},
	
			// test if a value is defined (not `undefined`)
			isDefined: function isDefined(val) {
				return typeof val !== 'undefined';
			},
	
			// test if a value is a plain object
			isPlainObject: function isPlainObject(val) {
				return typeof val === 'object' && val.constructor === Object;
			},
	
			// test if a value is a function
			isFunction: function isFunction(val) {
				return typeof val === 'function';
			},
	
			// extract an array of values from an object
			objValues: function objValues(obj) {
				return Object.keys(obj).map(function (key) {
					return obj[key];
				});
			},
	
			// enable an HTML element to serve as anchor for absolutely positioned children
			makePositioned: function makePositioned(element) {
				if (element.css('position') === 'static') {
					element.css('position', 'relative');
				}
			},
	
			// return the first parameter that is not 'undefined'
			defOr: function defOr() {
				for (var _len4 = arguments.length, values = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
					values[_key4] = arguments[_key4];
				}
	
				for (var i = 0; i < values.length; i += 1) {
					if (U.isDefined(values[i])) {
						return values[i];
					}
				}
			},
	
			// Returns a function, that, as long as it continues to be invoked, will not
			// be triggered. The function will actually be invoked after it stops being called
			// for N milliseconds. Every invocation returns a promise to the eventual result.
			debounce: function debounce(func, wait, context) {
				var timeout;
				var deferred = defer();
				return function () {
					var _this = this;
	
					for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
						args[_key5] = arguments[_key5];
					}
	
					var laterFn = function laterFn() {
						timeout = null;
						deferred.resolve(func.apply(context || _this, args));
						deferred = defer();
					};
					clearTimeout(timeout);
					timeout = setTimeout(laterFn, wait);
					return deferred.promise;
				};
			},
	
			// Returns a function, that will only be triggered once per synchronous 'stack'.
			oncePerStack: function oncePerStack(func, context) {
				var notRunYet = true;
				var result = function result() {
					for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
						args[_key6] = arguments[_key6];
					}
	
					if (notRunYet) {
						notRunYet = false;
						setTimeout(function () {
							notRunYet = true;
						}, 0);
						func.apply(context || this, args);
					}
				};
				result.allowAdditionalCall = function () {
					notRunYet = true;
				};
				return result;
			},
	
			/*  Create a new cache to manage a specific value that is costly to compute or retrieve.    */
			/*  It ensures that the retrieval function is not called only once per stack, and uses a    */
			/*  cache to return a known value in between. It is also able to notify you when the value  */
			/*  has actually changed. It does so using `===` comparison, but you can provide your own   */
			/*  comparison function.                                                                    */
			cached: function cached(_ref) {
				var retrieve = _ref.retrieve;
				var isEqual = _ref.isEqual;
	
				/* normalize parameters */
				isEqual = isEqual || function (a, b) {
					return a === b;
				};
	
				/* keep a cache and give it an initial value */
				var cache;
	
				/* how to retrieve a new value, and process it if it is new */
				function retrieveValue() {
					var newValue = retrieve();
					var oldValue = cache;
					if (!isEqual(newValue, oldValue)) {
						cache = newValue;
						onChange.forEach(function (fn) {
							return fn(newValue, oldValue);
						});
					}
				}
	
				/* retrieve a value at most once per stack */
				var oncePerStackSetValue = U.oncePerStack(retrieveValue);
	
				/*  the resulting function possibly performs retrieval,             */
				/*  and always returns the cache (which may contain the new value)  */
				var resultFn = function resultFn() {
					oncePerStackSetValue();
					return cache;
				};
	
				/* allow an onChange callback to be set */
				var onChange = [];
				resultFn.onChange = function (cb) {
					onChange.push(cb);
					return resultFn;
				};
	
				/* allow breaking of the cache, allowing multiple calls per stack */
				resultFn.allowAdditionalCall = function () {
					oncePerStackSetValue.allowAdditionalCall();
				};
	
				/* retrieve the first value right now */
				oncePerStackSetValue();
	
				return resultFn;
			},
	
			promisify: function promisify(obj, method) {
				return function () {
					for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
						args[_key7] = arguments[_key7];
					}
	
					return new P(function (resolve, reject) {
						try {
							obj[method].apply(obj, args.concat(resolve));
						} catch (error) {
							reject(error);
						}
					});
				};
			},
	
			findIndex: function findIndex(array, pred) {
				for (var i = 0; i < array.length; ++i) {
					if (pred(array[i], i, array)) {
						return i;
					}
				}
				return -1;
			},
	
			// this `memoize` function is SLOW, as it uses linear search
			memoize: function memoize(fn) {
				var keys = [];
				var cache = [];
				return function () {
					for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
						args[_key8] = arguments[_key8];
					}
	
					/* check the cache */
					var index = U.findIndex(keys, function (key) {
						return key.every(function (v, i) {
							return v === args[i];
						});
					});
					if (index >= 0) {
						return cache[index];
					}
	
					/* no cache hit; compute value, store and return */
					var result = fn.apply(this, args);
					keys.push(args);
					cache.push(result);
					return result;
				};
			},
	
			getQueryVariable: function getQueryVariable(variable) {
				var query = window.location.search.substring(1);
				var vars = query.split('&');
				for (var i = 0; i < vars.length; ++i) {
					var pair = vars[i].split('=');
					if (pair[0] === variable) {
						return pair[1];
					}
				}
				return null;
			}
	
		};
	
		var EPS = 0.000001;
		var sortOfEqual = function sortOfEqual(a, b) {
			return b - EPS < a && a < b + EPS;
		};
	
		/* HTML element position */
		U.Position = function Position(top, left) {
			_classCallCheck(this, Position);
	
			this.top = top;
			this.left = left;
		};
		U.Position.subtract = function (a, b) {
			return new U.Position(a.top - b.top, a.left - b.left);
		};
		U.Position.equals = function (a, b) {
			return U.isDefined(a) && U.isDefined(b) && sortOfEqual(a.top, b.top) && sortOfEqual(a.left, b.left);
		};
	
		/* HTML element size */
		U.Size = function Size(height, width) {
			_classCallCheck(this, Size);
	
			this.height = height;
			this.width = width;
		};
		U.Size.equals = function (a, b) {
			return U.isDefined(a) && U.isDefined(b) && sortOfEqual(a.height, b.height) && sortOfEqual(a.width, b.width);
		};
	
		return U;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	function _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(3), __webpack_require__(72), __webpack_require__(73), __webpack_require__(74)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, U, Kefir, TWEEN, KefirJQuery) {
	
		/* Kefir jQuery plugin ********************************************************************************************/
	
		KefirJQuery.init(Kefir, $);
	
		/* EventStream generators *****************************************************************************************/
	
		// This method works with events that can have only one subscriber,
		// that can be un-subscribed by setting the subscriber to `null`.
		// This function is memoized, so only one subscription is taken,
		// and the same stream for it returned for each request.
		Kefir.fromOnNull = U.memoize(function fromOnNull(obj, eventName) {
			return Kefir.fromBinder(function (emitter) {
				obj.on(eventName, emitter.emit);
				return function () {
					obj.on(eventName, null);
				};
			});
		});
	
		var requestAnimationFrameFn = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (f) {
			window.setTimeout(f, 1000 / 60);
		};
		Kefir.animationFrames = function animationFrames() {
			return Kefir.fromBinder(function (emitter) {
	
				/* self-calling animation-frame loop */
				var subscribed = true;
				(function iterationFn() {
					requestAnimationFrameFn(function () {
						emitter.emit();
						if (subscribed) {
							iterationFn();
						}
					});
				})();
	
				/* unsubscribe function */
				return function () {
					subscribed = false;
				};
			});
		};
	
		Kefir.tween = function tween(objStart, objEnd, _ref) {
			var duration = _ref.duration;
			var delay = _ref.delay;
			var easing = _ref.easing;
	
			/* the tween */
			var tw = new TWEEN.Tween(objStart).to(objEnd, duration);
	
			/* the returned bus */
			var bus = Kefir.bus();
	
			/* a local function to plug in other streams, keeping track in order to 'end' the bus */
			var addStream = (function () {
				var chainedStreams = 0;
				return function (stream) {
					chainedStreams += 1;
					bus.plug(stream);
					stream.onEnd(function () {
						chainedStreams -= 1;
						if (chainedStreams === 0) {
							bus.end();
						}
					});
				};
			})();
	
			/* main stream */
			addStream(Kefir.fromBinder(function (emitter) {
				if (easing) {
					tw.easing(easing);
				}
				if (delay) {
					tw.delay(delay);
				}
				tw.onUpdate(function () {
					emitter.emit(this);
				});
				tw.onComplete(emitter.end);
			}));
	
			/* adding tween-specific properties to the returned bus */
			bus.tween = tw;
			bus.start = function () {
				tw.start();
				return bus;
			};
			bus.chain = function (other) {
				addStream(other);
				tw.chain(other.tween);
				return bus;
			};
	
			/* returning the bus */
			return bus;
		};
	
		Kefir.keyPress = function keyPress(keyCode) {
			return $(window).asKefirStream('keypress').filter(function (e) {
				return e.keyCode === keyCode;
			});
		};
	
		Kefir.once = function once(value) {
			return Kefir.fromBinder(function (emitter) {
				emitter.emit(value);
				emitter.end();
			});
			//return Kefir.constant(value); // TODO: replace all 'once' calls with 'constant' calls; then remove 'once'
		};
	
		Kefir.fromArray = function fromArray(array) {
			return Kefir.fromBinder(function (emitter) {
				array.forEach(emitter.emit);
				emitter.end();
			});
		};
	
		/* EventStream converters *****************************************************************************************/
	
		// This creates a 'window of opportunity' to limit other streams by.
		// This window is provided by the `pacing` observable. An optional `handler`
		// parameter can be given to do some setup and some breakdown. It is passed a function as an argument
		// that should be called *once* in the place where other streams can do their
		// thing. It returns a function used to wrap other streams. It does not
		// return a stream.
		Kefir.limiter = function limiter(pacing) {
			var handler = arguments[1] === undefined ? U.call : arguments[1];
	
			var wantedBus = Kefir.bus();
			var open = Kefir.bus();
			var close = Kefir.bus();
	
			/* takes 'this' stream as pacing for a window of opportunity for other streams */
			pacing.filterBy(wantedBus.toProperty(false)).onValue(function () {
				handler(function () {
					open.emit();
					wantedBus.emit(false);
					close.emit();
				});
			});
	
			/* returns a function to wrap a stream in this wrapper */
			return function (stream) {
				var _ref2 = arguments[1] === undefined ? {} : arguments[1];
	
				var buffer = _ref2.buffer;
	
				wantedBus.plug(stream.mapTo(true));
				return Kefir.constant(true).take(1).concat(close).flatMapLatest(function () {
					var accumulator = function accumulator(arr, val) {
						return buffer ? arr.concat([val]) : [val];
					};
					return stream.takeUntilBy(open).reduce(accumulator, []).flatMap(Kefir.fromArray);
				});
			};
		};
	
		// This restricts a given stream to a wrapper stream created with the method above.
		// All its original events are now fired inside the provided window. Set `options.buffer`
		// to `true` if all its events should be buffered and released inside the next window.
		// Otherwise, only the last event is retained.
		Kefir.Observable.prototype.limitedBy = function limitedBy(wrapper, options) {
			return wrapper(this, options);
		};
	
		// convert to a stream of 1-or-2 element arrays;
		// the first is just the element at that point in the stream
		// the second is the previous element in the stream, if there is one
		Kefir.Observable.prototype.newOld = function newOld() {
			return Kefir.fromArray([null, null]).concat(this).slidingWindow(2).map(function (_ref3) {
				var _ref32 = _slicedToArray(_ref3, 2);
	
				var a = _ref32[0];
				var b = _ref32[1];
				return [b, a];
			});
		};
	
		// This is a cheap version of the limiter defined above. TODO: use the limiter where this is now used
		Kefir.Stream.prototype.holdUntil = function holdUntil(pacing) {
			var _this = this;
	
			return Kefir.fromBinder(function (emitter) {
				var buffer = [];
				var unsubscribeToThis = _this.onValue(function (value) {
					buffer.push(value);
				});
				var unsubscribeToPacing = pacing.onValue(function () {
					if (buffer.length > 0) {
						var oldBuffer = buffer;
						buffer = [];
						oldBuffer.forEach(emitter.emit);
					}
				});
				return function () {
					unsubscribeToThis();
					unsubscribeToPacing();
					buffer = null;
				};
			});
		};
	
		// This filters an observable to only let through values equal to the given value.
		Kefir.Observable.prototype.value = function (value, comparator) {
			comparator = comparator || function (e) {
				return e === value;
			};
			return this.skipDuplicates().filter(comparator);
		};
	
		// This makes a subscription to an observable that doesn't do anything
		Kefir.Observable.prototype.run = function () {
			var _this2 = this;
	
			var doNothing = function doNothing() {};
			this.onValue(doNothing);
			return function () {
				_this2.offValue(doNothing);
			};
		};
	
		// This is a 'smart' .stopPropagation, marking events with a label
		// and skipping those that already have that label.
		Kefir.Stream.prototype.skipPropagation = function (label) {
			return this.filter(function (event) {
				return !U.array(event.originalEvent, '_onlyOnceFor')[label];
			}).map(function (event) {
				U.array(event.originalEvent, '_onlyOnceFor')[label] = true;
			});
		};
	
		// Filter events to only certain keys / buttons. Can be a predicate function or single number.
		Kefir.Stream.prototype.which = function (buttonId) {
			var pred = typeof buttonId === 'function' ? buttonId : function (b) {
				return b === buttonId;
			};
			return this.filter(function (e) {
				return pred(e.which);
			});
		};
	
		/* EventStream generators *****************************************************************************************/
	
		$.fn.mouseDrag = function mouseDrag() {
			var _ref4 = arguments[0] === undefined ? {} : arguments[0];
	
			var threshold = _ref4.threshold;
	
			return $(this).asKefirStream('mousedown').flatMap(function (mouseDownEvent) {
				var stream = $(document).asKefirStream('mousemove');
				if (threshold) {
					var crossed = false;
					stream = stream.filter(function (mouseMoveEvent) {
						// TODO: don't use 'filter', but something like 'skipUntil' or 'flatMap'
						if (crossed) {
							return true;
						}
						var dx = mouseDownEvent.pageX - mouseMoveEvent.pageX;
						var dy = mouseDownEvent.pageY - mouseMoveEvent.pageY;
						if (dx * dx + dy * dy > threshold * threshold) {
							return crossed = true;
						}
						return false;
					});
				}
				return stream.takeUntilBy($(document).asKefirStream('mouseup')).map(function (mouseMoveEvent) {
					return { mouseDownEvent: mouseDownEvent, mouseMoveEvent: mouseMoveEvent };
				});
			});
		};
	
		$.fn.mouseClick = function mouseClick() {
			var _ref5 = arguments[0] === undefined ? {} : arguments[0];
	
			var threshold = _ref5.threshold;
	
			return $(this).asKefirStream('mousedown').flatMap(function (mouseDownEvent) {
				var untilStream = $(document).asKefirStream('mousemove');
				if (threshold) {
					var crossed = false;
					untilStream = untilStream.filter(function (mouseMoveEvent) {
						if (crossed) {
							return true;
						}
						var dx = mouseDownEvent.pageX - mouseMoveEvent.pageX;
						var dy = mouseDownEvent.pageY - mouseMoveEvent.pageY;
						if (dx * dx + dy * dy > threshold * threshold) {
							return crossed = true;
						}
						return false;
					});
				}
				return $(document).asKefirStream('mouseup').take(1).takeUntilBy(untilStream);
			});
		};
	
		$.fn.mouseWheel = function mouseWheel() {
			return $(this).asKefirStream('mousewheel DOMMouseScroll');
		};
	
		return Kefir;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(3), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, U, Kefir) {
	
		/** {@export}{@class KefirSignalHandler}
	  * Use this as a subclass (or just mix it in) to provide support for
	  * events and observable properties through Kefir.js.
	  */
		var KefirSignalHandler = (function () {
			function KefirSignalHandler() {
				_classCallCheck(this, KefirSignalHandler);
	
				this._events = {};
				this._properties = {};
				this._propertyBusses = {};
			}
	
			_createClass(KefirSignalHandler, [{
				key: 'newEvent',
	
				/** {@public}{@method}
	    * Declares a new event stream for this object.
	    *
	    * @param  {String}        name    - the name of the event, used to trigger or subscribe to it
	    * @param  {Kefir.Stream} [source] - another event stream to automatically trigger this event
	    *
	    * @return {Kefir.Bus} - the created event stream
	    */
				value: function newEvent(name) {
					var _ref = arguments[1] === undefined ? {} : arguments[1];
	
					var source = _ref.source;
	
					/* is the event name already taken? */
					U.assert(!this._events[name], 'There is already an event \'' + name + '\' on this object.');
					U.assert(!this._properties[name], 'There is already a property \'' + name + '\' on this object.');
	
					/* define the event stream */
					var bus = Kefir.bus();
					if (source) {
						bus.plug(source);
					}
					return this._events[name] = bus;
				}
			}, {
				key: 'event',
	
				/** {@public}{@method}
	    * Retrieve an event stream by name. If the name of a property is given, a stream
	    * based on changes to that property is returned.
	    *
	    * @param  {String}  name - the name of the event stream to retrieve
	    * @return {Kefir.Stream} - the event stream associated with the given name
	    */
				value: function event(name) {
	
					/* does the event exist? */
					U.assert(this._events[name], 'There is no event \'' + name + '\' on this object.');
	
					/* return it */
					return this._events[name];
				}
			}, {
				key: 'property',
	
				/** {@public}{@method}
	    * Retrieve a property by name.
	    *
	    * @param  {String} name - the name of the property to retrieve
	    * @return {Kefir.Property} - the property associated with the given name
	    */
				value: function property(name) {
					return this._properties[name];
				}
			}, {
				key: 'p',
	
				/** @alias property */
				value: function p(name) {
					return this._properties[name];
				}
			}, {
				key: 'newProperty',
	
				/** {@public}{@method}
	    * This method defines a new property on this object.
	    *
	    * @param  {String}                   name           - the name of the event stream to retrieve
	    * @param  {Boolean}                 [settable=true] - whether the value can be manually set
	    * @param  {*}                       [initial]       - the initial value of this property
	    * @param  {function(*,*):Boolean}   [isEqual]       - a predicate function by which to test for duplicate values
	    *
	    * @return {Kefir.Property} - the property associated with the given name
	    */
				value: function newProperty(name) {
					var _ref2 = arguments[1] === undefined ? {} : arguments[1];
	
					var settable = _ref2.settable;
					var initial = _ref2.initial;
					var isEqual = _ref2.isEqual;
	
					/* is the property name already taken? */
					U.assert(!this._events[name], 'There is already an event \'' + name + '\' on this object.');
					U.assert(!this._properties[name], 'There is already a property \'' + name + '\' on this object.');
	
					/* default value for 'settable' */
					if (U.isUndefined(settable)) {
						settable = true;
					}
	
					/* define the bus which manages the property */
					var bus = Kefir.bus();
	
					/* define the property itself, and give it additional methods */
					var property = this._properties[name] = bus.toProperty(initial).skipDuplicates(isEqual);
					property.plug = function (observable) {
						bus.plug(observable);return property;
					};
					property.unplug = function (observable) {
						bus.unplug(observable);return property;
					};
					property.get = function () {
						return property._current;
					}; // TODO: accessing private field of Kefir property; don't
					if (settable) {
						property.set = function (value) {
							bus.emit(value);return property;
						};
					}
	
					/* add the property to the object interface */
					Object.defineProperty(this, name, {
						get: property.get,
						set: settable ? property.set : undefined
					});
	
					/* make the property active; it doesn't work if this isn't done (the nature of Kefir.js) */
					property.run();
					if (this._events['destroy']) {
						this.event('destroy').onValue(function () {
							bus.end();
						});
					}
	
					/* return the property */
					return property;
				}
			}, {
				key: 'trigger',
	
				/** {@public}{@method}
	    * Trigger an event for all subscribers.
	    *
	    * @param {String} name  - the name of the event stream to trigger
	    * @value {*}      value - the value to attach to the event
	    */
				value: function trigger(name, value) {
	
					/* does the event stream exist? */
					U.assert(this._events[name], 'There is no event \'' + name + '\' on this object.');
	
					/* push the value to the stream */
					this._events[name].emit(value);
				}
			}, {
				key: 'on',
	
				/** {@public}{@method}
	    * This method selects an existing stream or property, and then
	    * either returns it, or creates a subscription to it, depending
	    * on whether a callback is provided.
	    *
	    * @param {String}            name                 - the name of the event or property to subscribe to
	    * @param {*}                [expectedValue]       - if provided, filters the stream by === equality with this value;
	    *                                                   this may not be a plain object
	    * @param {Object}           [options]             - a plain object for providing additional options
	    * @param {Boolean}          [options.once=false]  - whether the stream ends after one event
	    * @param {function(*):void} [callback]            - if provided, subscribes to this stream with the this callback
	    *
	    * @return {Kefir.Observable|function():undefined} - if no `callback` is provided, the specified event stream
	    *                                                   or property; otherwise, a function to unsubscribe to said
	    *                                                   stream or property
	    */
				value: function on(name, expectedValue, options, callback) {
					var argsObj = this._gatherOnArguments(name, expectedValue, options, callback);
					return this._on(argsObj);
				}
			}, {
				key: '_on',
	
				/** {@private}{@method}
	    * This method does the main work for {@link on}, but accepts
	    * the parameters as one object, so it doesn't have to deal with parameter ordering.
	    *
	    * @return {Kefir.Observable|function():void}
	    */
				value: function _on(_ref3) {
					var name = _ref3.name;
					var expectedValue = _ref3.expectedValue;
					var callback = _ref3.callback;
	
					/* does an event or property by this name exist? */
					U.assert(this._events[name] || this._properties[name], 'There is no event or property \'' + name + '\' on this object.');
	
					/* process name */
					var result = this._events[name] || this._properties[name];
	
					/* process expectedValue */
					if (U.isDefined(expectedValue)) {
						result = result.filter(function (v) {
							return v === expectedValue;
						});
					}
	
					/* process callback */
					if (callback) {
						result = result.onValue(callback);
					}
	
					return result;
				}
			}, {
				key: '_gatherOnArguments',
	
				/** {@private}{@method}
	    * Process the arguments accepted by {@link on}.
	    *
	    * @return {Object}
	    */
				value: function _gatherOnArguments() {
					for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
						args[_key] = arguments[_key];
					}
	
					var result = { name: args.shift() };
	
					/* test for expected value argument */
					if (U.isDefined(args[0]) && !U.isFunction(args[0]) && !U.isPlainObject(args[0])) {
						result.expectedValue = args.shift();
					}
	
					/* test for callback function */
					if (U.isDefined(args[0]) && U.isFunction(args[0])) {
						result.callback = args.shift();
					}
	
					return result;
				}
			}]);
	
			return KefirSignalHandler;
		})();
	
		return KefirSignalHandler;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	var button = {
		LEFT: 1,
		MIDDLE: 2,
		RIGHT: 3
	};
	
	exports.button = button;
	var key = {
		BACKSPACE: 8,
		TAB: 9,
		ENTER: 13,
		SHIFT: 16,
		CTRL: 17,
		ALT: 18,
		PAUSE: 19,
		CAPS_LOCK: 20,
		ESCAPE: 27,
		SPACE: 32,
		PAGE_UP: 33,
		PAGE_DOWN: 34,
		END: 35,
		HOME: 36,
		LEFT_ARROW: 37,
		UP_ARROW: 38,
		RIGHT_ARROW: 39,
		DOWN_ARROW: 40,
		INSERT: 45,
		DELETE: 46,
		0: 48,
		1: 49,
		2: 50,
		3: 51,
		4: 52,
		5: 53,
		6: 54,
		7: 55,
		8: 56,
		9: 57,
		A: 65,
		B: 66,
		C: 67,
		D: 68,
		E: 69,
		F: 70,
		G: 71,
		H: 72,
		I: 73,
		J: 74,
		K: 75,
		L: 76,
		M: 77,
		N: 78,
		O: 79,
		P: 80,
		Q: 81,
		R: 82,
		S: 83,
		T: 84,
		U: 85,
		V: 86,
		W: 87,
		X: 88,
		Y: 89,
		Z: 90,
		LEFT_META: 91,
		RIGHT_META: 92,
		SELECT: 93,
		NUMPAD_0: 96,
		NUMPAD_1: 97,
		NUMPAD_2: 98,
		NUMPAD_3: 99,
		NUMPAD_4: 100,
		NUMPAD_5: 101,
		NUMPAD_6: 102,
		NUMPAD_7: 103,
		NUMPAD_8: 104,
		NUMPAD_9: 105,
		MULTIPLY: 106,
		ADD: 107,
		SUBTRACT: 109,
		DECIMAL: 110,
		DIVIDE: 111,
		F1: 112,
		F2: 113,
		F3: 114,
		F4: 115,
		F5: 116,
		F6: 117,
		F7: 118,
		F8: 119,
		F9: 120,
		F10: 121,
		F11: 122,
		F12: 123,
		NUM_LOCK: 144,
		SCROLL_LOCK: 145,
		SEMICOLON: 186,
		EQUALS: 187,
		COMMA: 188,
		DASH: 189,
		PERIOD: 190,
		FORWARD_SLASH: 191,
		GRAVE_ACCENT: 192,
		OPEN_BRACKET: 219,
		BACK_SLASH: 220,
		CLOSE_BRACKET: 221,
		SINGLE_QUOTE: 222
	};
	exports.key = key;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(39), __webpack_require__(41), __webpack_require__(42)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, P, newWidgetType, deltaJs) {
		'use strict';
	
		/* create $.circuitboard object if it doesn't exist */
		$.circuitboard = { plugin: deltaJs };
	
		/* create the classes directly circuitboard related */
		var CircuitboardP = newWidgetType('Circuitboard', {
			cssClass: 'circuitboard',
			filter: function filter() {
				return P.resolve(true) // don't hide any entities
				;
			} });
		var TilemapP = newWidgetType('Tilemap', {
			cssClass: 'tilemap'
		});
		var TileP = newWidgetType('Tile', {
			cssClass: 'tile'
		});
	
		/* put those classes on the $.circuitboard object */
		CircuitboardP.then(function (c) {
			$.circuitboard.Circuitboard = c;
		});
		TilemapP.then(function (c) {
			$.circuitboard.Tilemap = c;
		});
		TileP.then(function (c) {
			$.circuitboard.Tile = c;
		});
	
		/*  return the static `$.circuitboard` object,         */
		/*  through which plugins can be applied and selected  */
		return $.circuitboard;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
		value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	/* to retrieve an array of promises to models, given an array of ids */
	exports.getLyphModels = getLyphModels;
	exports.provideLyphsFromServer = provideLyphsFromServer;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _jquery = __webpack_require__(38);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _bluebird = __webpack_require__(39);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	var _utilMiscEs6Js = __webpack_require__(3);
	
	var _utilMiscEs6Js2 = _interopRequireDefault(_utilMiscEs6Js);
	
	var _utilDeferEs6Js = __webpack_require__(40);
	
	var _utilDeferEs6Js2 = _interopRequireDefault(_utilDeferEs6Js);
	
	var _utilMainDeltajsEs6Js = __webpack_require__(42);
	
	var _utilMainDeltajsEs6Js2 = _interopRequireDefault(_utilMainDeltajsEs6Js);
	
	/* the type of entity we can retrieve with this module */
	var TYPE = 'lyph';
	
	/* the class of FMA models, implementing the interface expected by ApiNATOMY */
	var LyphModel = _utilMainDeltajsEs6Js2['default'].vp('LyphModel', (function () {
		function LyphModel(fields) {
			_classCallCheck(this, LyphModel);
	
			_utilMiscEs6Js2['default'].extend(this, fields);
		}
	
		_createClass(LyphModel, [{
			key: 'type',
			get: function () {
				return TYPE;
			}
		}, {
			key: 'getChildIds',
			value: function getChildIds() {
				return this.children.map(function (child) {
					return child.child.id;
				});
			}
		}, {
			key: 'getModels',
			value: function getModels(ids) {
				return getLyphModels(ids, { port: this._serverPort });
			}
		}]);
	
		return LyphModel;
	})());
	
	/* storing and retrieving 'deferreds' to models */
	var _getDeferred = (function () {
		var _deferredCache = {};
		return function (id) {
			if (!_deferredCache[id]) {
				_deferredCache[id] = (0, _utilDeferEs6Js2['default'])();
			}
			return _deferredCache[id];
		};
	})();
	
	function preparePromise(id) {
		if (!_getDeferred(id).alreadyRequested) {
			_getDeferred(id).alreadyRequested = true;
	
			/* make some info available from the promise itself */
			_getDeferred(id).promise.id = id;
			_getDeferred(id).promise.type = TYPE;
	
			/* note that this id was new */
			return { isNew: true };
		}
	
		/* note that this id was not new */
		return { isNew: false };
	}
	function getLyphModels(ids) {
		var options = arguments[1] === undefined ? {} : arguments[1];
	
		/* accept an array of ids or a single id */
		var returnArray = undefined;
		if (typeof ids === 'string') {
			returnArray = false;
			ids = [ids];
		} else {
			returnArray = true;
		}
	
		/* if nothing is requested, return nothing */
		if (ids.length === 0) {
			return returnArray ? [] : null;
		}
	
		/* gather the ids that we have not requested from the server before */
		var newIds = [];
		ids.filter(function (id) {
			return preparePromise(id).isNew;
		}).forEach(function (id) {
			newIds.push(id);
		});
	
		if (options.root && newIds.length === 1 && newIds[0] === 'root') {
			_getDeferred('root').resolve(new LyphModel({
				id: 'root',
				children: [{ child: { id: options.root } }],
				_serverPort: options.port
			}));
		} else {
	
			/* request and build the model objects belonging to any new ids */
			if (newIds.length > 0) {
				_bluebird2['default'].resolve(_jquery2['default'].ajax({
					url: 'http://open-physiology.org:' + options.port + '/lyph/' + newIds.join(',') + '?array=yes&correlations=yes',
					dataType: 'jsonp'
				})).each(function (model) {
					/* resolve the corresponding promise */
					model._serverPort = options.port;
					_getDeferred(model.id).resolve(new LyphModel(model));
				}).error(function (err) {
					console.error('There seems to be something wrong with the server.', err);
				});
			}
		}
	
		/* return an array of promises to all requested ids */
		if (returnArray) {
			return ids.map(function (id) {
				return _getDeferred(id).promise;
			});
		} else {
			return _getDeferred(ids[0]).promise;
		}
	}
	
	function provideLyphsFromServer(lyphs) {
		var options = arguments[1] === undefined ? {} : arguments[1];
	
		lyphs.forEach(function (model) {
			if (preparePromise(model.id).isNew) {
				model._serverPort = options.port;
				_getDeferred(model.id).resolve(new LyphModel(model));
			}
		});
	
		/* return an array of promises to all requested ids */
		return lyphs.map(function (_ref) {
			var id = _ref.id;
			return _getDeferred(id).promise;
		});
	}

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(39)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, P) {
		'use strict';
	
		/* to retrieve the path models relating to the given ids from the server */
		return function (_ref) {
			var port = _ref.port;
			return function fetchPathsFor(ids) {
	
				/* removing 'root' */
				var s = new Set(ids);s['delete']('root');
				ids = [].concat(_toConsumableArray(s));
	
				/* if the list of ids is empty, return an empty object */
				if (ids.length === 0) {
					return P.resolve({});
				}
	
				/* make actual query to server */
				return P.resolve($.ajax({
					url: 'http://open-physiology.org:' + port + '/nifs/?lyphs=' + ids.join(','),
					dataType: 'jsonp'
				})).then(function (arr) {
	
					console.log(ids, arr);
	
					/* check for errors */
					if (arr.Error) {
						throw arr.Error;
					}
	
					/* transform the data to correspond to expected format */
					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;
	
					try {
						for (var _iterator = arr[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							var path = _step.value;
	
							var newNiflings = [];
							for (var i = path.niflings.length - 1; i >= 0; --i) {
								if (path.niflings[i].fma1_lyph && path.niflings[i].fma2_lyph) {
									path.niflings[i].path = [path.niflings[i].fma1_lyph, path.niflings[i].fma2_lyph];
									newNiflings.push(path.niflings[i]);
								}
							}
							path.niflings = newNiflings;
							path.path = [path.fma1_lyph, path.fma2_lyph];
						}
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator['return']) {
								_iterator['return']();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}
	
					return { nif: arr };
				})['catch'](function (err) {
					console.error('Something went wrong while fetching NIF connections from the server:', err);
					throw err;
				});
			};
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(39), __webpack_require__(4), __webpack_require__(3), __webpack_require__(40),
	//'../util/nested-flex-grow.es6.js',
	__webpack_require__(43)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, P, Kefir, U, defer) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('core', {
			'if': true
		});
	
		/* Circuitboard */
		plugin.modify('Circuitboard.prototype').add('allTiles', function () {
			var _this = this;
	
			var tiles = {};
	
			Object.keys(this._p_circuitboardCore_tilesByModelId).forEach(function (id) {
				tiles[id] = _this._p_circuitboardCore_tilesByModelId[id].promise;
			});
	
			return tiles;
		}).add('tile', function (tileSelector) {
	
			return U.getDef(this._p_circuitboardCore_tilesByModelId, tileSelector, defer).promise;
		}).add('construct', function () {
	
			this._p_circuitboardCore_tilesByModelId = {};
	
			// create the root tilemap
			$('<div/>').appendTo(this.element).css('flex-grow', 1).tilemap({
				model: this.options.model,
				parent: this
			}).tilemap('instance');
		}).append('construct', function () {
	
			this.newTiles = Kefir.bus();
		}).add('_registerTile', function _registerTile(tile) {
	
			// called by the Tile constructor
	
			U.getDef(this._p_circuitboardCore_tilesByModelId, tile.model.id, defer).resolve(tile);
	
			this.newTiles.emit(tile);
		});
	
		/* Tilemap */
		plugin.modify('Tilemap.prototype').add('refreshTiles', function () {
			var _this2 = this;
	
			/* sanity check */
			U.assert(U.isDefined(this.model), 'An ApiNATOMY tilemap should have a model.');
	
			/* render the new tilemap (through a promise chain, returning the final promise) */
			return P.resolve(this.model)
			/* get the id's of all child models */
			.call('getChildIds')
			/* filter out the ids of children that ought not be displayed */
			.map(function (id) {
				return P.resolve(_this2.circuitboard.options.filter(id, U.bind(P.resolve(_this2.model).value(), 'getModels', id))).then(function (show) {
					return { id: id, show: show };
				});
			}).filter(U.field('show')).map(U.field('id'))
			/* get promises to all child entities */
			.then(function (ids) {
				return P.resolve(_this2.model).value().getModels(ids);
			})
			/* create a tile for each child entity */
			.then(function (childrenToDisplay) {
				/* remove all old tiles */
				_this2.element.children().empty();
				_this2.element.empty();
	
				/* render and store references to the new tiles */
				_this2._p_tilemapCore_tiles = [];
				var rowCount = Math.floor(Math.sqrt(childrenToDisplay.length));
				var colCount = Math.ceil(childrenToDisplay.length / rowCount);
				_this2.element.css('flex-grow', childrenToDisplay);
				while (rowCount--) {
					var row = $('<div/>').addClass('tilerow').appendTo(_this2.element);
					for (var column = 0; column < colCount && childrenToDisplay.length > 0; column += 1) {
						$('<div/>').tile({
							model: childrenToDisplay.shift(),
							parent: _this2
						}).appendTo(row).css('flex-grow', 1).data('artefact');
					}
				}
			})
			/* signal that the tiles have been (re)rendered */
			.then(function () {
				_this2.trigger('tiles-refreshed');
			});
		}).add('construct', function () {
			var _this3 = this;
	
			this.newEvent('tiles-refreshed');
	
			this._p_tilemapCore_tiles = null;
			Object.defineProperty(this, 'tiles', { get: function get() {
					return _this3._p_tilemapCore_tiles;
				} });
			this.refreshTiles();
		});
	
		/* Tile */
		plugin.modify('Tile.prototype').add('populateInnerTilemap', function populateInnerTilemap() {
	
			if (!this._p_tileCore_tilemap) {
				this._p_tileCore_tilemap = this.dom.tilemap({
					model: this.options.model,
					parent: this
				}).tilemap('instance');
			}
		}).add('construct', function () {
			var _this4 = this;
	
			this._p_tileCore_tilemap = null;
	
			/* support certain DOM-event subscriptions from the tile object itself */
			['mouseover', 'mouseout', 'mouseenter', 'mouseleave'].forEach(function (event) {
				_this4.newEvent(event, { source: _this4.element.asKefirStream(event) });
			});
			this.newEvent('click', {
				source: this.element.mouseClick({ threshold: this.circuitboard.options.dragThreshold })
			});
	
			/* a field to hold the innermost HTML content element still belonging to this tile */
			this.dom = this.element;
	
			/* an element id for quick jQuery lookups */
			this.element.attr('id', this.id);
	
			/* notify the circuitboard of this new tile */
			this.circuitboard._registerTile(this);
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	function _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(75), __webpack_require__(3), __webpack_require__(4), __webpack_require__(45), __webpack_require__(46), __webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, color, U, Kefir, defaults) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('tile-skin', {
			requires: ['tile-open', 'position-tracking']
		}).modify('Tile.prototype');
	
		/* tile styling defaults generator */
		var applyStyleDefaults = defaults({
			'&': {
				backgroundColor: ' parentBackgroundColor || \'darkgray\'                                                                                                                                       ',
				borderColor: ' color(`[\'&\'].backgroundColor`).luminance() > 0.5  &&  color(`[\'&\'].backgroundColor`).darken(30).css()  ||  color(`[\'&\'].backgroundColor`).brighten(30).css() ',
				color: ' color(`[\'&\'].backgroundColor`).luminance() > 0.5  &&  \'black\'                                          ||  \'white\'                                           '
			},
			'& > header': {
				borderColor: ' `[\'&\'].borderColor` '
			},
			'& > icon-btn': {
				backgroundColor: ' `[\'&\'].backgroundColor` '
			}
		}, { color: color, parentBackgroundColor: null });
	
		/* make tiles look nice, with a header, content section, and CSS styling derived from the model */
		plugin.append('construct', function () {
			var _this = this;
	
			/*  create the header and content elements, and reroute the  */
			/* 'dom' property to the new content element                 */
			var origElement = this.dom;
			origElement.addClass('skinned-tile');
			this._p_tileSkin_headerElement = $('<header/>').appendTo(origElement);
			this.dom = $('<section/>').appendTo(origElement);
	
			/* put the name of the model in the header element */
			//this._p_tileSkin_headerElement.text(this.model.id);
			this.model.then(function (model) {
				_this._p_tileSkin_headerElement.text(model.name);
				_this._p_tileSkin_headerElement.attr('title', '' + model.id + ' - ' + model.name + ' (' + model.children.length + ' child lyphs)');
			});
	
			/* take any css rules from the model and apply them to the tile */
			this.skinnedElement = this.model.get('tile').get('normal').get('css')['catch'](function () {
				return {};
			}) // There is no given css object? Then use an empty object.
			.then(function (css) {
				var parent = _this.closestAncestorByType('Tile');
				if (parent) {
					return parent.skinnedElement.then(function (skinnedParentElement) {
						var parentBackgroundColor = color(skinnedParentElement.css('backgroundColor')).luminance() > 0.5 ? 'darkgray' : 'lightgray';
						_this.element.amyPutCssRules(applyStyleDefaults(css, { parentBackgroundColor: parentBackgroundColor }));
						return _this.element;
					});
				} else {
					_this.element.amyPutCssRules(applyStyleDefaults(css, { parentBackgroundColor: null }));
					return _this.element;
				}
			});
	
			/* when the tile is closed, make the font size dynamic */
			Kefir.merge([this.on('size').filterBy(this.p('open').not()), this.p('open').value(false).map(function () {
				return _this.size;
			})]).onValue(function (size) {
				_this._p_tileSkin_headerElement // formula gotten experimentally
				.css('fontSize', Math.min(0.2 * Math.pow(size.height, 1.01), 0.13 * Math.pow(size.width, 1.01)));
				// We're growing / shrinking the font size in proportion to the (1.01)st power of the tile size.
				// Making the font grow/shrink just a tiny bit faster than the tile prevents an awkward 'flickering'
				// between different line-breaks that would otherwise happen sometimes.
			});
	
			/* the 'headerSize' observable */
			this.newProperty('headerSize', {
				settable: false,
				isEqual: U.Size.equals
			}).plug(Kefir.combine([this.p('size'), this.p('fullyOpen'), this.p('fullyClosed')]).map(function (_ref) {
				var _ref2 = _slicedToArray(_ref, 1);
	
				var size = _ref2[0];
				return new U.Size(_this._p_tileSkin_headerElement.height(), size.width);
			}));
	
			/* the 'headerPosition' observable */
			this.newProperty('headerPosition', {
				settable: false
			}).plug(this.on('position'));
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('tile-spacing', {
			requires: ['core']
		}).modify('Tilemap.prototype');
	
		/* reset the tile-spacing in the DOM */
		plugin.update('refreshTiles', function (old) {
			return function () {
				var _this = this;
	
				return old.call(this).then(function () {
					_this.element.css('margin', _this.circuitboard.options.tilemapMargin);
					_this.element.children().css('margin-bottom', _this.circuitboard.options.tileSpacing);
					_this.element.children().children().css('margin-right', _this.circuitboard.options.tileSpacing);
				});
			};
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(6), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, _ref) {
		'use strict';
	
		var button = _ref.button;
		var plugin = $.circuitboard.plugin['do']('tile-click-to-open', {
			requires: ['tile-open']
		}).modify('Tile.prototype');
	
		/* When a tile is clicked, it is opened/closed. */
		plugin.append('construct', function () {
			var _this = this;
	
			this.on('click').which(button.LEFT).skipPropagation('tile-left-click') // only register this event for the inner-most tile
			.onValue(function () {
				_this.open = !_this.open;
			});
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('tile-weight', {
			requires: ['core']
		}).modify('Tile.prototype');
	
		/*  gives tiles a `weight` which reflects the screen area they take up  */
		/*  in relation to other tiles in the same tilemap                      */
		plugin.append('construct', function () {});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	// TODO: this is now done in 'tile-grow-when-' deltas

	///* the 'weight' observable */
	//this.newProperty('weight', { initial: 1 });

	///* enact 'weight' on the DOM */
	//this.p('weight').onValue((w) => { this.element.amyNestedFlexGrow(w) });

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, U) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('tile-active', {
			requires: ['core']
		}).modify('Tile.prototype');
	
		/*  For all tiles that share the same model, only one can be 'active'.  */
		/*  If one of them is visible, one of them is active.                   */
		plugin.append('construct', function () {
			var _this = this;
	
			/* only interesting if the tile has a model */
			if (!this.model) {
				return;
			}
	
			/* the 'active' property */
			this.newProperty('active', { initial: false });
	
			/* convenience function for activating the first tile in the model queue and deactivating the second */
			var _activateProperTile = function _activateProperTile() {
				var tiles = _this.model._p_amyActiveTileQueue;
				if (tiles[1]) {
					tiles[1].active = false;
				}
				if (tiles[0]) {
					tiles[0].active = true;
				}
			};
	
			/* put this tile in the queue of potentially active tiles */
			U.array(this.model, '_p_amyActiveTileQueue').push(this);
			_activateProperTile();
			this.on('destroy').take(1).onValue(function () {
				var index = _this.model._p_amyActiveTileQueue.indexOf(_this);
				_this.model._p_amyActiveTileQueue.splice(index, 1);
				_activateProperTile();
			});
	
			/* make setting the 'active' property affect the tile queue on the model */
			this.p('active').value(true).onValue(function () {
				var index = _this.model._p_amyActiveTileQueue.indexOf(_this);
				if (index !== 0) {
					_this.model._p_amyActiveTileQueue.splice(index, 1);
					_this.model._p_amyActiveTileQueue.unshift(_this);
					_activateProperTile();
				}
			});
	
			/* automatically (un)set the CSS class 'active' */
			this.on('active').onValue(function (a) {
				_this.element.toggleClass('active', a);
			});
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('tile-open', {
			requires: ['core']
		}).modify('Tile.prototype');
	
		/* allow a tile to be `open` (or closed) */
		plugin.append('construct', function () {
			var _this = this;
	
			/* the 'open' observable */
			this.newProperty('open', { initial: false });
	
			/* when the tile opens, populate the inner tilemap */
			this.p('open').value(true).take(1).onValue(function () {
				_this.populateInnerTilemap();
			}); // TODO: delay by opening-animation time
	
			/* manage the CSS class 'open' */
			this.p('open').onValue(function (o) {
				_this.element.toggleClass('open', o);
			});
	
			/* if this tile closes, all its children close */
			this.p('open').value(false).onValue(function () {
				_this.closestDescendantsByType('Tile').forEach(function (tile) {
					tile.open = false;
				});
			});
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(39), __webpack_require__(4), __webpack_require__(70)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, P, Kefir) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('tile-grow-when-open', {
			requires: ['tile-open']
		}).modify('Tile.prototype');
	
		/* default flex-grow values for open / closed tiles */
		plugin.add('weightWhenOpen', function () {
			return this.circuitboard.options.weightWhenOpen || 2;
		}).add('weightWhenClosed', function () {
			return 1;
		});
	
		plugin.add('growWhenOpen', function (open) {
			var _this = this;
	
			var flexGrowFrom = parseFloat(this.element.data('amyFlexGrowTarget') || 1);
			var flexGrowTo = open ? this.weightWhenOpen() : this.weightWhenClosed();
			this.element.data('amyFlexGrowTarget', flexGrowTo);
			var rowFlexGrowTo = 0;
			this.element.parent().children().each(function () {
				rowFlexGrowTo += parseFloat($(this).data('amyFlexGrowTarget') || 1);
			});
			var rowFlexGrowFrom = rowFlexGrowTo - flexGrowTo + flexGrowFrom;
			return P.all([new P(function (resolve) {
				_this.element.velocity({ flexGrow: [flexGrowTo, flexGrowFrom] }, { complete: resolve, duration: 300 });
			}), new P(function (resolve) {
				_this.element.parent().velocity({ flexGrow: [rowFlexGrowTo, rowFlexGrowFrom] }, { complete: resolve, duration: 300 });
			})]);
		});
	
		plugin.append('construct', function () {
			var _this2 = this;
	
			/* make the tile grow/shrink based on open-ness */
			this.p('open').changes().onValue(function (open) {
				_this2.growWhenOpen(open).then(function () {
					if (open) {
						finishedOpeningBus.emit();
					} else {
						finishedClosingBus.emit();
					}
				});
			});
	
			var finishedOpeningBus = Kefir.bus();
			var finishedClosingBus = Kefir.bus();
	
			/* create a property that tells if a tile is 'fully open', i.e., also the animation is done */
			this.newProperty('fullyOpen', { settable: false, initial: this.open }).plug(this.p('open').value(false)).plug(finishedOpeningBus.mapTo(true));
	
			/* create a property that tells if a tile is 'fully open', i.e., also the animation is done */
			this.newProperty('fullyClosed', { settable: false, initial: !this.open }).plug(this.p('open').not().value(false)).plug(finishedClosingBus.mapTo(true));
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(39), __webpack_require__(4), __webpack_require__(3), __webpack_require__(70)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, P, Kefir, U) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('tile-grow-when-maximized', {
			requires: ['tile-maximized']
		}).modify('Tile.prototype');
	
		plugin.add('growWhenMaximized', function (maximized) {
			var _this = this;
	
			/* check current flex-grow for all tile rows */
			this.closestAncestorByType('Tilemap').element.children().each(function (__, rowElement) {
				var rowPrevFlexGrow = 0;
				$(rowElement).children().each(function (__, e) {
					rowPrevFlexGrow += parseFloat(U.defOr($(e).data('amyFlexGrowTarget'), 1));
				});
				$(rowElement).data('amyPrevFlexGrow', rowPrevFlexGrow);
			});
	
			/* create animations for every tile except this one */
			var promises = [];
			this.closestAncestorByType('Tilemap').children.filter(function (t) {
				return t !== _this;
			}).forEach(function (sibling) {
				var flexGrowFrom = parseFloat(U.defOr(sibling.element.data('amyFlexGrowTarget'), 1));
				var flexGrowTo = maximized ? 0 : sibling.hidden ? 0 : sibling.open ? sibling.weightWhenOpen() : sibling.weightWhenClosed();
				sibling.element.data('amyFlexGrowTarget', flexGrowTo);
				if (flexGrowTo > 0) {
					sibling.element.css({
						display: 'flex',
						marginRight: _this.circuitboard.options.tileSpacing
					});
				}
				promises.push(new P(function (resolve) {
					sibling.element.velocity({ flexGrow: [flexGrowTo, flexGrowFrom] }, { complete: resolve, duration: 300 });
				}).tap(function () {
					if (flexGrowTo === 0) {
						sibling.element.css({
							display: 'none',
							marginRight: '0'
						});
					}
				}));
			});
	
			/* create animations for all tile rows */
			this.closestAncestorByType('Tilemap').element.children().each(function (__, rowElement) {
				var rowFlexGrowTo = 0;
				$(rowElement).children().each(function (__, e) {
					rowFlexGrowTo += parseFloat(U.defOr($(e).data('amyFlexGrowTarget'), 1));
				});
				var rowFlexGrowFrom = $(rowElement).data('amyPrevFlexGrow');
				if (rowFlexGrowTo > 0) {
					$(rowElement).css('display', 'flex');
				}
				if (!maximized) {
					$(rowElement).css('marginBottom', _this.circuitboard.options.tileSpacing);
				}
				promises.push(new P(function (resolve) {
					$(rowElement).velocity({ flexGrow: [rowFlexGrowTo, rowFlexGrowFrom] }, { complete: resolve, duration: 300 });
				}).tap(function () {
					if (rowFlexGrowTo === 0) {
						$(rowElement).css('display', 'none');
					}
					if (maximized) {
						$(rowElement).css('marginBottom', '0');
					}
				}));
			});
	
			if (!maximized) {
				this.element.css('marginRight', this.circuitboard.options.tileSpacing);
			}
			return P.all(promises).tap(function () {
				if (maximized) {
					_this.element.css('marginRight', '0');
				}
			});
		});
	
		plugin.append('construct', function () {
			var _this2 = this;
	
			/* make the tile grow/shrink based on maximized-ness */
			this.p('maximized').changes().onValue(function (maximized) {
				_this2.growWhenMaximized(maximized).then(function () {
					if (maximized) {
						finishedMaximizingBus.emit();
					} else {
						finishedNotMaximizingBus.emit();
					}
				});
			});
	
			var finishedMaximizingBus = Kefir.bus();
			var finishedNotMaximizingBus = Kefir.bus();
	
			/* create a property that tells if a tile is 'fully maximized', i.e., also the animation is done */
			this.newProperty('fullyMaximized', { settable: false, initial: this.maximized }).plug(this.p('maximized').value(false)).plug(finishedMaximizingBus.mapTo(true));
	
			/* create a property that tells if a tile is 'fully not maximized', i.e., also the animation is done */
			this.newProperty('fullyNotMaximized', { settable: false, initial: !this.maximized }).plug(this.p('maximized').not().value(false)).plug(finishedNotMaximizingBus.mapTo(true));
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, U) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('tile-open-active', {
			resolves: ['tile-open', 'tile-active']
		}).modify('Tile.prototype');
	
		/* makes a tile active when it is open, and closes tiles that are deactivated */
		plugin.append('construct', function () {
			var _this = this;
	
			/* only interesting if the tile has an `active` property */
			if (U.isUndefined(this.active)) {
				return;
			}
	
			/* when a tile is opened, it becomes active */
			this.on('open').value(true).onValue(function () {
				_this.active = true;
			});
	
			/* when a tile is de-activated, it becomes closed */
			this.on('active').value(false).onValue(function () {
				_this.open = false;
			});
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(39), __webpack_require__(49)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, P) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('tile-skin-grow-when-open', {
			resolves: ['tile-skin', 'tile-grow-when-open'],
			after: ['tile-hidden']
		}).modify('Tile.prototype');
	
		///*  react to a tile opening or closing by      */
		///*  timely showing/hiding the content section  */
		///*  to ensure smooth transition animation      */
		//plugin.append('construct', function () {
		//	var sectionElement = this.element.children('section');
		//	this.p('open').value(true).onValue(() => {
		//		sectionElement.css('opacity', 0);
		//	});
		//	this.p('fullyOpen').onValue((open) => {
		//		if (open) {
		//			sectionElement.css('visibility', 'visible');
		//			sectionElement.css('opacity', 1);
		//		} else {
		//			sectionElement.css('visibility', 'hidden');
		//			sectionElement.css('opacity', 0);
		//		}
		//	});
		//});
	
		plugin.append('construct', function () {
			var flexGrowFrom = 1;
			var rowFlexGrowFrom = this.element.parent().children().length;
			this.element.velocity({ flexGrow: [flexGrowFrom, flexGrowFrom] }, { duration: 1 });
			this.element.parent().velocity({ flexGrow: [rowFlexGrowFrom, rowFlexGrowFrom] }, { duration: 1 });
		});
	
		plugin.replace('growWhenOpen', function (open) {
			var _this = this;
	
			var openCloseTransition = function openCloseTransition() {
				var flexGrowFrom = parseFloat(_this.element.data('amyFlexGrowTarget') || 1);
				var flexGrowTo = _this.hidden ? 0 : open ? _this.weightWhenOpen() : _this.weightWhenClosed();
				_this.element.data('amyFlexGrowTarget', flexGrowTo);
				var rowFlexGrowTo = 0;
				_this.element.parent().children().each(function () {
					rowFlexGrowTo += parseFloat($(this).data('amyFlexGrowTarget') || 1);
				});
				var rowFlexGrowFrom = rowFlexGrowTo - flexGrowTo + flexGrowFrom;
				return P.all([new P(function (resolve) {
					_this.element.velocity({ flexGrow: [flexGrowTo, flexGrowFrom] }, { complete: resolve, duration: 300 });
				}), new P(function (resolve) {
					_this.element.parent().velocity({ flexGrow: [rowFlexGrowTo, rowFlexGrowFrom] }, { complete: resolve, duration: 300 });
				})]);
			};
			// TODO: get the above with delta 'replace' operation that provides previous implementation
	
			var sectionElement = this.element.children('section');
			if (open) {
				sectionElement.css({ visibility: 'hidden', opacity: 0 });
				return openCloseTransition().then(function () {
					return new P(function (resolve) {
						sectionElement.css('visibility', 'visible');
						sectionElement.velocity({ opacity: [1, 0] }, { complete: resolve, duration: 200 });
					});
				});
			} else {
				sectionElement.css('visibility', 'visible');
				return openCloseTransition().then(function () {
					sectionElement.css('visibility', 'hidden');
				});
			}
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(3), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, U, Kefir) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('position-tracking', {
			requires: ['core', 'tile-grow-when-open', 'tile-grow-when-maximized', 'tile-shrink-when-hidden']
		});
	
		/* a stream limiter, setting up a window for calculating element offsets */
		plugin.add('Circuitboard.prototype._posTrackingWindow', U.call);
		plugin.append('Circuitboard.prototype.construct', function () {
			this._posTrackingLimiter = Kefir.limiter(Kefir.merge([Kefir.once(), Kefir.interval(100)]), this._posTrackingWindow.bind(this));
		});
	
		plugin.append('Tile.prototype.construct', function () {
	
			this.newProperty('animationIdle', { settable: false, initial: true }).plug(Kefir.and([this.p('fullyOpen').or(this.p('fullyClosed')), this.p('fullyHidden').or(this.p('fullyVisible')), this.p('fullyMaximized').or(this.p('fullyNotMaximized'))]));
		});
	
		/* the 'offset' observable */
		plugin.append('Circuitboard.prototype.construct', function () {
			var _this = this;
	
			this.newProperty('offset', {
				settable: false,
				isEqual: U.Position.equals,
				initial: this.element.offset()
			}).plug(Kefir.merge([Kefir.once(), Kefir.interval(1000)
			// TODO: allow outside stream to trigger this
			]).limitedBy(this._posTrackingLimiter).map(function () {
				return _this.element.offset();
			}));
		}).append('Tilemap.prototype.construct', function () {
			var _this2 = this;
	
			this.newProperty('offset', {
				settable: false,
				isEqual: U.Position.equals,
				initial: this.element.offset()
			}).plug(Kefir.merge([Kefir.once(), this.parent.p('size').changes(), this.parent.p('offset').changes()]).limitedBy(this.circuitboard._posTrackingLimiter).map(function () {
				return _this2.element.offset();
			}));
		}).append('Tile.prototype.construct', function () {
			var _this3 = this;
	
			this.newProperty('offset', {
				settable: false,
				isEqual: U.Position.equals,
				initial: this.element.offset()
			}).plug(Kefir.merge([Kefir.once(), this.parent.p('size').changes(), this.parent.p('offset').changes(), this.parent.on('reorganize'), this.p('animationIdle').value(true), Kefir.interval(1000) //.filterBy(this.p('animationIdle')) // backup timer
			]) //.filter(() => !this._offsetUpdated)
			.limitedBy(this.circuitboard._posTrackingLimiter).map(function () {
				_this3._offsetUpdated = true;
				return _this3.element.offset();
			}));
	
			///* making sure size is only updated once every 100ms, to keep things fast */
			//this._offsetUpdated = false; // TODO: write Kefir modifier to do this more easily; using .throttle doesn't work
			//Kefir.interval(100).onValue(() => { this._offsetUpdated = false });
		});
	
		/* the 'position' observable */
		plugin.append('Circuitboard.prototype.construct', function () {
	
			/* for completeness sake; it's (0, 0) by definition */
			this.newProperty('position', {
				settable: false,
				initial: new U.Position(0, 0)
			});
		}).append('Tilemap.prototype.construct', function () {
			var _this4 = this;
	
			this.newProperty('position', {
				settable: false,
				isEqual: U.Position.equals
			}).plug(Kefir.merge([Kefir.once(), this.p('offset').changes(), this.circuitboard.p('offset').changes()]).map(function () {
				return U.Position.subtract(_this4.offset, _this4.circuitboard.offset);
			}));
		}).append('Tile.prototype.construct', function () {
			var _this5 = this;
	
			this.newProperty('position', {
				settable: false,
				isEqual: U.Position.equals
			}).plug(Kefir.merge([Kefir.once(), this.p('offset').changes(), this.circuitboard.p('offset').changes(), this.p('animationIdle').value(true), Kefir.interval(1000) //.filterBy(this.p('animationIdle')) // backup timer
			]) //.filter(() => !this._positionUpdated)
			.map(function () {
				_this5._positionUpdated = true;
				return U.Position.subtract(_this5.offset, _this5.circuitboard.offset);
			}));
	
			///* making sure size is only updated once every 100ms, to keep things fast */
			//this._positionUpdated = false; // TODO: write Kefir modifier to do this more easily; using .throttle doesn't work
			//Kefir.interval(100).onValue(() => { this._positionUpdated = false });
		});
	
		/* the 'size' observable */
		plugin.append('Circuitboard.prototype.construct', function () {
			var _this6 = this;
	
			this.newProperty('size', {
				settable: false,
				isEqual: U.Size.equals
			}).plug(Kefir.merge([Kefir.once(), this.options.resizeEvent || $(window).asKefirStream('resize')]).map(function () {
				return new U.Size(_this6.element.height(), _this6.element.width());
			}));
		}).append('Tilemap.prototype.construct', function () {
			var _this7 = this;
	
			this.newProperty('size', {
				settable: false,
				isEqual: U.Size.equals
			}).plug(Kefir.merge([Kefir.once(), this.parent.p('size').changes()]).map(function () {
				return new U.Size(_this7.element.height(), _this7.element.width());
			}));
		}).append('Tile.prototype.construct', function () {
			var _this8 = this;
	
			this.newProperty('size', {
				settable: false,
				isEqual: U.Size.equals
			}).plug(Kefir.merge([Kefir.once(), this.parent.p('size').changes(), this.parent.on('reorganize'), this.p('animationIdle').value(true), Kefir.interval(1000) //.filterBy(this.p('animationIdle')) // backup timer
			]) //.filter(() => !this._sizeUpdated)
			.map(function () {
				_this8._sizeUpdated = true;
				return new U.Size(_this8.element.height(), _this8.element.width());
			}));
	
			///* making sure size is only updated once every 100ms, to keep things fast */
			//this._sizeUpdated = false; // TODO: write Kefir modifier to do this more easily; using .throttle doesn't work
			//Kefir.interval(100).onValue(() => { this._sizeUpdated = false });
		});
	
		/*  if the size of any tile changes, trigger the 'reorganize'     */
		/*  event on the parent tilemap, so that sibling tiles can react  */
		plugin.append('Tilemap.prototype.construct', function () {
	
			this.newEvent('reorganize');
		}).append('Tile.prototype.construct', function () {
			var _this9 = this;
	
			this.p('size').onValue(function () {
				_this9.parent.trigger('reorganize');
			});
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(4), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, Kefir) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('transition-position-tracking', {
			resolves: ['position-tracking', 'tile-grow-when-open']
		});
	
		/* make sure that positioning is updated during CSS3 transition animations */
		plugin.append('Tile.prototype.construct', function () {});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	// TODO: maybe just remove this whole delta

	//this.on('weight').changes().flatMapLatest(
	//	() => Kefir.animationFrames().takeUntilBy(this.element.asKefirStream('transitionend webkitTransitionEnd').merge(Kefir.later(300)))
	//).onValue(() => { this.trigger('reset-positioning') });

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(3), __webpack_require__(51)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, U) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('tile-hidden', {
			requires: ['tile-open']
		}).modify('Tile.prototype');
	
		/* allows a tile to be `hidden` */
		plugin.append('construct', function () {
			var _this = this;
	
			/* the 'visible' and 'hidden' properties */
			this.newProperty('visible', { initial: U.defOr(this.circuitboard.options.initialTileVisibility, true) });
			this.newProperty('hidden').plug(this.p('visible').not());
			this.p('visible').plug(this.p('hidden').not());
	
			/* set initial visibility */
			if (this.hidden) {
				var flexGrowTo = 0;
				this.element.data('amyFlexGrowTarget', flexGrowTo);
				this.element.css('display', 'none');
				this.element.css('flexGrow', flexGrowTo);
				var rowFlexGrowTo = 0;
				this.element.parent().children().each(function () {
					rowFlexGrowTo += parseFloat(U.defOr($(this).data('amyFlexGrowTarget'), 0));
				});
				this.element.parent().css('flexGrow', rowFlexGrowTo);
				if (rowFlexGrowTo > 0) {
					this.element.parent().css('display', 'flex');
				} else {
					this.element.parent().css('display', 'none');
				}
			}
	
			/* enact tile hiding on the DOM */
			this.p('hidden').merge(this.on('destroy').mapTo(true)).onValue(function (hidden) {
	
				_this.element.toggleClass('hidden', hidden);
	
				///* assign the .right-most class */
				//let ch = this.element.parent().children().filter(`:not(.hidden)`);
				//ch.removeClass('right-most');
				//ch.last().addClass('right-most');
			});
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, Kefir) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('tile-hidden', {
			requires: ['tile-open', 'tile-hidden', 'tile-maximized']
		}).modify('Tile.prototype');
	
		/* allows a tile to be `hidden` */
		plugin.append('construct', function () {});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	// TODO

	///* the 'effectively-visible' */
	//this.newProperty('effectively-visible').plug(Kefir.combine([
	//	this.p('visible'),
	//	this.parent.p('open'),
	//	this.parent.p('visible')
	//], (v, po, pv) => v && po && pv));
	//
	//this.p('effectively-visible').onValue((v) => {
	//	console.log(this.model.id, '--', v);
	//});

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(53)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('tile-maximized', {
			requires: ['core']
		}).modify('Tile.prototype');
	
		/* allows a tile to be 'maximized' (by hiding all other tiles) */
		plugin.append('construct', function () {
	
			/* the 'maximized' observable */
			this.newProperty('maximized', { initial: false });
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(6), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, _ref) {
		'use strict';
	
		var button = _ref.button;
		var plugin = $.circuitboard.plugin['do']('tile-middleclick-to-maximize', {
			requires: ['tile-maximized']
		}).modify('Tile.prototype');
	
		/* When a tile is middle-clicked, it is maximized/un-maximized. */
		plugin.append('construct', function () {
			var _this = this;
	
			this.on('click').which(button.MIDDLE).skipPropagation('tile-middle-click') // only register this event for the inner-most tile
			.onValue(function () {
				_this.maximized = !_this.maximized;
			});
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(39), __webpack_require__(75), __webpack_require__(3), __webpack_require__(6), __webpack_require__(55)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, P, color, U, _ref) {
		'use strict';
	
		var button = _ref.button;
		/* the plugin */
		var plugin = $.circuitboard.plugin['do']('tile-buttons', {
			requires: ['core'],
			after: ['tile-skin']
		});
	
		plugin.add('Tile.prototype.addButton', function (_ref2) {
			var name = _ref2.name;
			var icon = _ref2.icon;
	
			/* if it's not there yet, create a <div> that holds all the buttons */
			if (!this._buttonHolder) {
				U.makePositioned(this.element);
				this._buttonHolder = $('<div class="tile-button-holder">').appendTo(this.element);
			}
	
			/* create the button itself */
			var buttonElement = $('<div class="tile-button ' + name + '">').appendTo(this._buttonHolder);
	
			/* determine the icon coloring based on background color */
			(this.skinnedElement || P.resolve(this.element)).then(function (element) {
				if (typeof icon === 'string') {
					buttonElement.css('background-image', 'url(' + icon + ')');
				} else {
					var lightBackground = color(element.css('backgroundColor')).luminance() > 0.5;
					buttonElement.addClass(lightBackground ? 'black' : 'white').css('background-image', 'url(' + (lightBackground ? icon.black : icon.white) + ')');
				}
			});
	
			/* create the button-click-event */
			this.newEvent('tile-button:' + name, {
				source: buttonElement.mouseClick({ threshold: this.circuitboard.options.dragTheshold }).which(button.LEFT).skipPropagation('tile-left-click') // only register this event for the inner-most element
			});
	
			/* return the event-stream for convenient chaining-notation */
			return this.event('tile-button:' + name);
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('tile-button-to-hide', {
			requires: ['tile-buttons', 'tile-shrink-when-hidden', 'tile-grow-when-maximized']
		}).modify('Tile.prototype');
	
		plugin.append('construct', function () {
			var _this = this;
	
			this.addButton({ name: 'hide', icon: {
					white: __webpack_require__(76),
					black: __webpack_require__(77)
				} }).onValue(function () {
				_this.maximized = false;
				_this.p('fullyNotMaximized').value(true).onValue(function () {
					_this.hidden = !_this.hidden;
				});
			});
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('tile-button-to-maximize', {
			requires: ['tile-buttons', 'tile-grow-when-maximized', 'tile-shrink-when-hidden']
		}).modify('Tile.prototype');
	
		plugin.append('construct', function () {
			var _this = this;
	
			this.addButton({ name: 'maximize', icon: {
					white: __webpack_require__(78),
					black: __webpack_require__(79)
				} }).onValue(function () {
				_this.hidden = false;
				_this.p('fullyVisible').value(true).onValue(function () {
					_this.maximized = !_this.maximized;
				});
			});
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('tile-button-to-unhide-children', {
			requires: ['tile-buttons', 'tile-shrink-when-hidden', 'tile-grow-when-maximized']
		}).modify('Tile.prototype');
	
		plugin.append('construct', function () {
			var _this = this;
	
			this.addButton({ name: 'unhide-children', icon: {
					white: __webpack_require__(80),
					black: __webpack_require__(81)
				} }).onValue(function () {
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;
	
				try {
					for (var _iterator = _this.closestDescendantsByType('Tile')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var child = _step.value;
	
						child.hidden = false;
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator['return']) {
							_iterator['return']();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
			});
	
			this.p('open').onValue(function (open) {
				_this._buttonHolder.find('.unhide-children').css('display', open ? 'block' : 'none');
			});
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(39), __webpack_require__(75), __webpack_require__(3), __webpack_require__(57)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, P, color, U) {
		'use strict';
	
		/* the plugin */
		var plugin = $.circuitboard.plugin['do']('tile-child-count-if-closed', {
			requires: ['core', 'tile-open', 'tile-skin']
		});
	
		plugin.append('Tile.prototype.construct', function () {
			var _this = this;
	
			/* create a <div> to hold the child counter */
			U.makePositioned(this.element);
			this.model.get('children').get('length').then(function (childCount) {
				if (childCount > 0) {
					_this._childCounter = $('<div class="tile-child-counter">').text(childCount).attr('title', '' + childCount + ' child lyphs').appendTo(_this.element);
				}
			});
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	function _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(39), __webpack_require__(4), __webpack_require__(59), __webpack_require__(3), __webpack_require__(60), __webpack_require__(61), __webpack_require__(62)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, P, Kefir, Graph, U, D3GroupP, D3VertexP) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('tile-glyphs', {
			requires: ['d3']
		});
	
		////////////////////////////////////////////////////////////////////////////////////////////////
	
		plugin.append('Tile.prototype.construct', function () {
			var _this = this;
	
			var D3Group = D3GroupP.value();
	
			/* create the tile-specific graph group */
			this._p_glyph_d3group = new D3Group({
				parent: this,
				gravityFactor: 1,
				chargeFactor: 1
			});
			Kefir.combine([this.p('headerSize'), this.p('headerPosition')]).onValue(function (_ref) {
				var _ref2 = _slicedToArray(_ref, 2);
	
				var size = _ref2[0];
				var position = _ref2[1];
	
				var AREA_MARGIN = 9;
	
				var top = undefined,
				    left = undefined,
				    height = undefined,
				    width = undefined;
				if (size.height < 2 * AREA_MARGIN + 1) {
					top = size.height / 2;
					height = 1;
				} else {
					top = position.top + AREA_MARGIN;
					height = size.height - 2 * AREA_MARGIN;
				}
				if (size.width < 2 * AREA_MARGIN + 1) {
					left = size.width / 2;
					width = 1;
				} else {
					left = position.left + AREA_MARGIN;
					width = size.width - 2 * AREA_MARGIN;
				}
	
				_this._p_glyph_d3group.setRegion({ top: top, left: left, height: height, width: width });
			});
		}).add('Tile.prototype.addGlyph', function (_ref3) {
			var tooltipText = _ref3.tooltipText;
			var shape = _ref3.shape;
	
			var D3Vertex = D3VertexP.value();
			var vertex = new D3Vertex({
				parent: this,
				cssClass: 'glyph',
				radius: 16,
				tooltipText: tooltipText,
				shape: shape
			});
			vertex.visible = false; // initially not visible
			this._p_glyph_d3group.addVertex(vertex);
			return vertex;
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	function _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(64), __webpack_require__(3), __webpack_require__(4), __webpack_require__(65), __webpack_require__(66)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, d3, U, Kefir) {
		'use strict';
	
		var plugin = $.circuitboard.plugin['do']('d3', {
			requires: ['core', 'position-tracking']
		}).modify('Circuitboard.prototype');
	
		plugin.append('construct', function () {
			var _this = this;
	
			this._p_d3_vertices = {};
			this._p_d3_edges = {};
	
			/*  superimpose an `svg` canvas on top of the circuitboard                  */
			/*  the inner `svg` translates everything one pixel down and to the right,  */
			/*  to correspond with tile positioning                                     */
			var svgElement = $('<svg class="d3">').appendTo(this.element).append('<svg x="1" y="1">').children();
	
			/*  enable the circuitboard element to serve as anchor  */
			/*  for absolutely positioned children                  */
			U.makePositioned(this.element);
	
			/* create the force layout */
			this.d3Force = d3.layout.force().gravity(0).charge(function (d) {
				return -2 * Math.max(d.group.region.width, d.group.region.height) * U.defOr(d.group.chargeFactor, 1) * U.defOr(d.chargeFactor, 1);
			}).chargeDistance(200).linkDistance(function (d) {
				return (d.group.region.width + d.group.region.height) * U.defOr(d.group.linkDistanceFactor, 1) * U.defOr(d.linkDistanceFactor, 1) / Math.sqrt(d.group.vertices.length || 1);
			}).linkStrength(function (d) {
				return 0.8 * U.defOr(d.group.linkStrengthFactor, 1);
			});
	
			/* auto-resize the force-layout canvas */
			this.on('size').map(function (v) {
				return [v.width, v.height];
			}).onValue(function (s) {
				_this.d3Force.size(s);
			});
	
			/* create corresponding svg elements */
			var svg = d3.select(svgElement[0]);
			var edges = svg.selectAll('.edge');
			var vertices = svg.selectAll('.vertex');
	
			/* visible vertices and edges */
			var visibleVertices, visibleEdges;
	
			/* keep track of whether the graph is stable; if not, do not fire 'tick' events */
			var graphStable = Kefir.bus();
			graphStable.emit(true);
			this.updateGraph = function () {
				graphStable.emit(false);
			};
	
			/* update the graph to account for new and/or removed vertices and/or edges */
			graphStable.filter(function (v) {
				return !v;
			}).debounce(200).onValue(function () {
				// using the d3 general update pattern:
				// http://bl.ocks.org/mbostock/3808218
	
				/* gather the vertices/edges that ought to be visible */
				visibleVertices = U.objValues(_this._p_d3_vertices).filter(function (v) {
					return v.visible;
				});
				visibleEdges = U.objValues(_this._p_d3_edges);
	
				/* restart the force */
				_this.d3Force.nodes(visibleVertices).links(visibleEdges).start();
	
				/* vertices */
				vertices = svg.selectAll('.vertex').data(visibleVertices, function (d) {
					return d.graphId;
				});
				vertices.enter().append(function (d) {
					return d.element[0];
				}).classed('vertex', true).classed('edge', false).call(_this.d3Force.drag) // all vertices can be dragged around
				.append('svg:title').text(function (d) {
					return d.options.tooltipText;
				});
				vertices.exit().remove();
	
				/* edges */
				edges = svg.selectAll('.edge').data(visibleEdges, function (d) {
					return d.graphId;
				});
				edges.enter().append(function (d) {
					return d.element[0];
				}).classed('edge', true).classed('vertex', false);
				edges.exit().remove();
	
				/* define a nice visual z-order for the svg elements */
				svg.selectAll('.vertex, .edge').sort(function (a, b) {
					return a.graphZIndex < b.graphZIndex ? -1 : a.graphZIndex === b.graphZIndex ? 0 : 1;
				});
	
				graphStable.emit(true);
			});
	
			/* a property for which vertex (if any) is being dragged */
			var currentEventData = function currentEventData() {
				return d3.select(d3.event.sourceEvent.target.parentElement).data()[0];
			};
			this.newProperty('draggingVertex', { initial: null }).plug(Kefir.merge([Kefir.fromOnNull(this.d3Force.drag(), 'dragstart').map(currentEventData), Kefir.fromOnNull(this.d3Force.drag(), 'dragend').mapTo(null)]));
	
			/* add a 'dragging' css class to a vertex being dragged */
			this.p('draggingVertex').newOld().onValue(function (_ref) {
				var _ref2 = _slicedToArray(_ref, 2);
	
				var newVertex = _ref2[0];
				var oldVertex = _ref2[1];
	
				if (newVertex) {
					newVertex.element.addSvgClass('dragging');
				}
				if (oldVertex) {
					oldVertex.element.removeSvgClass('dragging');
				}
			});
	
			/* the 'd3-tick' event-stream, and performing animation on a tick */
			this.newEvent('d3-tick', { source: Kefir.fromOnNull(this.d3Force, 'tick') }).filterBy(graphStable).onValue(function (e) {
				/* dampening factor */
				var k = 0.1 * e.alpha;
	
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;
	
				try {
					for (var _iterator = visibleVertices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var d = _step.value;
	
						var x = d.x,
						    y = d.y;
						x += k * d.group.gravityFactor * (d.group.region.left + 0.5 * d.group.region.width - x);
						y += k * d.group.gravityFactor * (d.group.region.top + 0.5 * d.group.region.height - y);
						x = Math.min(Math.max(x, d.group.region.left), d.group.region.left + d.group.region.width);
						y = Math.min(Math.max(y, d.group.region.top), d.group.region.top + d.group.region.height);
						d.x = x;
						d.y = y;
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator['return']) {
							_iterator['return']();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
	
				/* update the visible vertices and edges */
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;
	
				try {
					for (var _iterator2 = visibleVertices[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var d = _step2.value;
						d.updateVisualization();
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2['return']) {
							_iterator2['return']();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
	
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;
	
				try {
					for (var _iterator3 = visibleEdges[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var d = _step3.value;
						d.updateVisualization();
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3['return']) {
							_iterator3['return']();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}
			});
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(39), __webpack_require__(75), __webpack_require__(3), __webpack_require__(6), __webpack_require__(68)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, P, color, U, _ref) {
		'use strict';
	
		var button = _ref.button;
		/* the plugin */
		var plugin = $.circuitboard.plugin['do']('tile-correlation-count-if-closed', {
			requires: ['core', 'tile-open', 'tile-skin']
		});
	
		plugin.append('Tile.prototype.construct', function () {
			var _this = this;
	
			this.newEvent('correlation-counter-click');
	
			/* create a <div> to hold the child counter */
			U.makePositioned(this.element);
			this.model.get('correlation count').then(function (correlationCount) {
				if (correlationCount > 0) {
					_this._correlationCounter = $('<div class="tile-correlation-counter">').text(correlationCount).attr('title', '' + correlationCount + ' correlations').appendTo(_this.element);
					_this.event('correlation-counter-click').plug(_this._correlationCounter.mouseClick({ threshold: _this.circuitboard.options.dragThreshold }).which(button.LEFT).skipPropagation('tile-left-click'));
				}
			});
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(36);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(71)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/example2/example2.scss", function() {
			var newContent = require("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/example2/example2.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(85)();
	exports.push([module.id, "html,body{position:absolute;width:100%;height:100%;margin:0;padding:0;}body{position:absolute;overflow:hidden;}#circuitboard{position:absolute;top:0;left:0;right:0;bottom:0;z-index:1;}div.correlation-box{margin:8px;padding:6px;border:solid 2px;position:relative;}div.correlation-box ul{padding-left:19px;margin:3px 0;}div.correlation-box>input[type=checkbox]{position:absolute;top:-5px;right:-5px;margin:0;padding:0;}.checkbox-bullet{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;width:100%;height:20px;}.checkbox-bullet span:first-child{display:block;width:17px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;text-align:center;}.checkbox-bullet span:first-child input[type=checkbox]{margin-left:0;margin-right:0;}.checkbox-bullet span:nth-child(2){display:block;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;margin-left:2px;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;}#lyph-checkboxes,#clindex-checkboxes{margin:6px;}#three-d-canvas{position:absolute;top:0;left:0;right:0;bottom:0;margin:0;padding:0;z-index:0;}.tile{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;text-align:center;overflow:hidden;border:solid 1px;}.tile>header{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;font-weight:bold;border-width:1px;}.tile.open>header{height:26px;border-style:none none solid none;line-height:26px;font-size:20.8px;white-space:nowrap;overflow:hidden;}.tile:not(.open)>header{border-style:none;}.tile:not(.active){border-style:dotted !important;}.tile>section{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;}.tile:not(.open)>section{display:none;}.tile.hidden-header>header{display:none !important;}", ""]);

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["jQuery"] = __webpack_require__(38);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v2.1.4
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2015-04-28T16:01Z
	 */
	
	(function( global, factory ) {
	
		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}
	
	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
	
	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//
	
	var arr = [];
	
	var slice = arr.slice;
	
	var concat = arr.concat;
	
	var push = arr.push;
	
	var indexOf = arr.indexOf;
	
	var class2type = {};
	
	var toString = class2type.toString;
	
	var hasOwn = class2type.hasOwnProperty;
	
	var support = {};
	
	
	
	var
		// Use the correct document accordingly with window argument (sandbox)
		document = window.document,
	
		version = "2.1.4",
	
		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},
	
		// Support: Android<4.1
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	
		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,
	
		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};
	
	jQuery.fn = jQuery.prototype = {
		// The current version of jQuery being used
		jquery: version,
	
		constructor: jQuery,
	
		// Start with an empty selector
		selector: "",
	
		// The default length of a jQuery object is 0
		length: 0,
	
		toArray: function() {
			return slice.call( this );
		},
	
		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?
	
				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :
	
				// Return all the elements in a clean array
				slice.call( this );
		},
	
		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {
	
			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );
	
			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;
	
			// Return the newly-formed element set
			return ret;
		},
	
		// Execute a callback for every element in the matched set.
		// (You can seed the arguments with an array of args, but this is
		// only used internally.)
		each: function( callback, args ) {
			return jQuery.each( this, callback, args );
		},
	
		map: function( callback ) {
			return this.pushStack( jQuery.map(this, function( elem, i ) {
				return callback.call( elem, i, elem );
			}));
		},
	
		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},
	
		first: function() {
			return this.eq( 0 );
		},
	
		last: function() {
			return this.eq( -1 );
		},
	
		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
		},
	
		end: function() {
			return this.prevObject || this.constructor(null);
		},
	
		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};
	
	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;
	
		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
	
			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}
	
		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
			target = {};
		}
	
		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}
	
		for ( ; i < length; i++ ) {
			// Only deal with non-null/undefined values
			if ( (options = arguments[ i ]) != null ) {
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];
	
					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}
	
					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray(src) ? src : [];
	
						} else {
							clone = src && jQuery.isPlainObject(src) ? src : {};
						}
	
						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );
	
					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	
	jQuery.extend({
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
	
		// Assume jQuery is ready without the ready module
		isReady: true,
	
		error: function( msg ) {
			throw new Error( msg );
		},
	
		noop: function() {},
	
		isFunction: function( obj ) {
			return jQuery.type(obj) === "function";
		},
	
		isArray: Array.isArray,
	
		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},
	
		isNumeric: function( obj ) {
			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
		},
	
		isPlainObject: function( obj ) {
			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}
	
			if ( obj.constructor &&
					!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
				return false;
			}
	
			// If the function hasn't returned already, we're confident that
			// |obj| is a plain object, created by {} or constructed with new Object
			return true;
		},
	
		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},
	
		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}
			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call(obj) ] || "object" :
				typeof obj;
		},
	
		// Evaluates a script in a global context
		globalEval: function( code ) {
			var script,
				indirect = eval;
	
			code = jQuery.trim( code );
	
			if ( code ) {
				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if ( code.indexOf("use strict") === 1 ) {
					script = document.createElement("script");
					script.text = code;
					document.head.appendChild( script ).parentNode.removeChild( script );
				} else {
				// Otherwise, avoid the DOM node creation, insertion
				// and removal by using an indirect global eval
					indirect( code );
				}
			}
		},
	
		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},
	
		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},
	
		// args is for internal usage only
		each: function( obj, callback, args ) {
			var value,
				i = 0,
				length = obj.length,
				isArray = isArraylike( obj );
	
			if ( args ) {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.apply( obj[ i ], args );
	
						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.apply( obj[ i ], args );
	
						if ( value === false ) {
							break;
						}
					}
				}
	
			// A special, fast, case for the most common use of each
			} else {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.call( obj[ i ], i, obj[ i ] );
	
						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.call( obj[ i ], i, obj[ i ] );
	
						if ( value === false ) {
							break;
						}
					}
				}
			}
	
			return obj;
		},
	
		// Support: Android<4.1
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},
	
		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];
	
			if ( arr != null ) {
				if ( isArraylike( Object(arr) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}
	
			return ret;
		},
	
		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},
	
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;
	
			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}
	
			first.length = i;
	
			return first;
		},
	
		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;
	
			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}
	
			return matches;
		},
	
		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var value,
				i = 0,
				length = elems.length,
				isArray = isArraylike( elems ),
				ret = [];
	
			// Go through the array, translating each of the items to their new values
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
	
			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
			}
	
			// Flatten any nested arrays
			return concat.apply( [], ret );
		},
	
		// A global GUID counter for objects
		guid: 1,
	
		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;
	
			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}
	
			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}
	
			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};
	
			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	
			return proxy;
		},
	
		now: Date.now,
	
		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	});
	
	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	});
	
	function isArraylike( obj ) {
	
		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = "length" in obj && obj.length,
			type = jQuery.type( obj );
	
		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}
	
		if ( obj.nodeType === 1 && length ) {
			return true;
		}
	
		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.2.0-pre
	 * http://sizzlejs.com/
	 *
	 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2014-12-16
	 */
	(function( window ) {
	
	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,
	
		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
	
		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},
	
		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,
	
		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},
	
		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	
		// Regular expressions
	
		// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
		// http://www.w3.org/TR/css3-syntax/#characters
		characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
	
		// Loosely modeled on CSS identifier characters
		// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
		// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = characterEncoding.replace( "w", "w#" ),
	
		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",
	
		pseudos = ":(" + characterEncoding + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",
	
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
	
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	
		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
	
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),
	
		matchExpr = {
			"ID": new RegExp( "^#(" + characterEncoding + ")" ),
			"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
			"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},
	
		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,
	
		rnative = /^[^{]+\{\s*\[native \w/,
	
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	
		rsibling = /[+~]/,
		rescape = /'|\\/g,
	
		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},
	
		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		};
	
	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?
	
			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :
	
			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}
	
	function Sizzle( selector, context, results, seed ) {
		var match, elem, m, nodeType,
			// QSA vars
			i, groups, old, nid, newContext, newSelector;
	
		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
	
		context = context || document;
		results = results || [];
		nodeType = context.nodeType;
	
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
	
			return results;
		}
	
		if ( !seed && documentIsHTML ) {
	
			// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
				// Speed-up: Sizzle("#ID")
				if ( (m = match[1]) ) {
					if ( nodeType === 9 ) {
						elem = context.getElementById( m );
						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document (jQuery #6963)
						if ( elem && elem.parentNode ) {
							// Handle the case where IE, Opera, and Webkit return items
							// by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}
					} else {
						// Context is not a document
						if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
							contains( context, elem ) && elem.id === m ) {
							results.push( elem );
							return results;
						}
					}
	
				// Speed-up: Sizzle("TAG")
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;
	
				// Speed-up: Sizzle(".CLASS")
				} else if ( (m = match[3]) && support.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}
	
			// QSA path
			if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
				nid = old = expando;
				newContext = context;
				newSelector = nodeType !== 1 && selector;
	
				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					groups = tokenize( selector );
	
					if ( (old = context.getAttribute("id")) ) {
						nid = old.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", nid );
					}
					nid = "[id='" + nid + "'] ";
	
					i = groups.length;
					while ( i-- ) {
						groups[i] = nid + toSelector( groups[i] );
					}
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
					newSelector = groups.join(",");
				}
	
				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute("id");
						}
					}
				}
			}
		}
	
		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}
	
	/**
	 * Create key-value caches of limited size
	 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];
	
		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}
	
	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}
	
	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");
	
		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}
	
	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = attrs.length;
	
		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}
	
	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );
	
		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}
	
		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}
	
		return a ? 1 : -1;
	}
	
	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;
	
				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}
	
	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}
	
	// Expose support vars for convenience
	support = Sizzle.support = {};
	
	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};
	
	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, parent,
			doc = node ? node.ownerDocument || node : preferredDoc;
	
		// If no document and documentElement is available, return
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}
	
		// Set our document
		document = doc;
		docElem = doc.documentElement;
		parent = doc.defaultView;
	
		// Support: IE>8
		// If iframe document is assigned to "document" variable and if iframe has been reloaded,
		// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
		// IE6-8 do not support the defaultView property so parent will be undefined
		if ( parent && parent !== parent.top ) {
			// IE11 does not have attachEvent, so all must suffer
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", unloadHandler, false );
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", unloadHandler );
			}
		}
	
		/* Support tests
		---------------------------------------------------------------------- */
		documentIsHTML = !isXML( doc );
	
		/* Attributes
		---------------------------------------------------------------------- */
	
		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});
	
		/* getElement(s)By*
		---------------------------------------------------------------------- */
	
		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( doc.createComment("") );
			return !div.getElementsByTagName("*").length;
		});
	
		// Support: IE<9
		support.getElementsByClassName = rnative.test( doc.getElementsByClassName );
	
		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
		});
	
		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m && m.parentNode ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];
	
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}
	
		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );
	
				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :
	
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );
	
				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}
	
					return tmp;
				}
				return results;
			};
	
		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};
	
		/* QSA/matchesSelector
		---------------------------------------------------------------------- */
	
		// QSA and matchesSelector support
	
		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];
	
		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];
	
		if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\f]' msallowcapture=''>" +
					"<option selected=''></option></select>";
	
				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}
	
				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}
	
				// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
				if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}
	
				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
	
				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibing-combinator selector` fails
				if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});
	
			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = doc.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );
	
				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}
	
				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}
	
		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {
	
			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );
	
				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}
	
		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
	
		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );
	
		// Element contains another
		// Purposefully does not implement inclusive descendent
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};
	
		/* Sorting
		---------------------------------------------------------------------- */
	
		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {
	
			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}
	
			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :
	
				// Otherwise we know they are disconnected
				1;
	
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
	
				// Choose the first element that is related to our preferred document
				if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}
	
				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}
	
			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];
	
			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === doc ? -1 :
					b === doc ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
	
			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}
	
			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}
	
			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}
	
			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :
	
				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};
	
		return doc;
	};
	
	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};
	
	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );
	
		if ( support.matchesSelector && documentIsHTML &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
	
			try {
				var ret = matches.call( elem, expr );
	
				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}
	
		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};
	
	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};
	
	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;
	
		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};
	
	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	
	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;
	
		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );
	
		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}
	
		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;
	
		return results;
	};
	
	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;
	
		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	
		return ret;
	};
	
	Expr = Sizzle.selectors = {
	
		// Can be adjusted by the user
		cacheLength: 50,
	
		createPseudo: markFunction,
	
		match: matchExpr,
	
		attrHandle: {},
	
		find: {},
	
		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},
	
		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );
	
				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
	
				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}
	
				return match.slice( 0, 4 );
			},
	
			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();
	
				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}
	
					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
	
				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}
	
				return match;
			},
	
			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];
	
				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}
	
				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";
	
				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
	
					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}
	
				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},
	
		filter: {
	
			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},
	
			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];
	
				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},
	
			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );
	
					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}
	
					result += "";
	
					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},
	
			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";
	
				return first === 1 && last === 0 ?
	
					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :
	
					function( elem, context, xml ) {
						var cache, outerCache, node, diff, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType;
	
						if ( parent ) {
	
							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}
	
							start = [ forward ? parent.firstChild : parent.lastChild ];
	
							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
								// Seek `elem` from a previously-cached index
								outerCache = parent[ expando ] || (parent[ expando ] = {});
								cache = outerCache[ type ] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = cache[0] === dirruns && cache[2];
								node = nodeIndex && parent.childNodes[ nodeIndex ];
	
								while ( (node = ++nodeIndex && node && node[ dir ] ||
	
									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										outerCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}
	
							// Use previously-cached element index if available
							} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
								diff = cache[1];
	
							// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
							} else {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
										// Cache the index of each encountered element
										if ( useCache ) {
											(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
										}
	
										if ( node === elem ) {
											break;
										}
									}
								}
							}
	
							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},
	
			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );
	
				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}
	
				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}
	
				return fn;
			}
		},
	
		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );
	
				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;
	
						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),
	
			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),
	
			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),
	
			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
	
							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),
	
			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},
	
			"root": function( elem ) {
				return elem === docElem;
			},
	
			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},
	
			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},
	
			"disabled": function( elem ) {
				return elem.disabled === true;
			},
	
			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},
	
			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}
	
				return elem.selected === true;
			},
	
			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},
	
			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},
	
			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},
	
			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},
	
			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},
	
			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
	
					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},
	
			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),
	
			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),
	
			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),
	
			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};
	
	Expr.pseudos["nth"] = Expr.pseudos["eq"];
	
	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}
	
	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();
	
	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];
	
		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}
	
		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;
	
		while ( soFar ) {
	
			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}
	
			matched = false;
	
			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}
	
			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}
	
			if ( !matched ) {
				break;
			}
		}
	
		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};
	
	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}
	
	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;
	
		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :
	
			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, outerCache,
					newCache = [ dirruns, doneName ];
	
				// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
							if ( (oldCache = outerCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
	
								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								outerCache[ dir ] = newCache;
	
								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}
	
	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}
	
	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}
	
	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;
	
		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}
	
		return newUnmatched;
	}
	
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,
	
				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
	
				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,
	
				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	
						// ...intermediate processing is necessary
						[] :
	
						// ...otherwise use results directly
						results :
					matcherIn;
	
			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}
	
			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );
	
				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}
	
			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}
	
					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
	
							seed[temp] = !(results[temp] = elem);
						}
					}
				}
	
			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}
	
	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,
	
			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];
	
		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
	
				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}
	
		return elementMatcher( matchers );
	}
	
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;
	
				if ( outermost ) {
					outermostContext = context !== document && context;
				}
	
				// Add elements passing elementMatchers directly to results
				// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context, xml ) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}
	
					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}
	
						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}
	
				// Apply set filters to unmatched elements
				matchedCount += i;
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}
	
					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}
	
						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}
	
					// Add matches to results
					push.apply( results, setMatched );
	
					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {
	
						Sizzle.uniqueSort( results );
					}
				}
	
				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}
	
				return unmatched;
			};
	
		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}
	
	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];
	
		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}
	
			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	
			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};
	
	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );
	
		results = results || [];
	
		// Try to minimize operations if there is no seed and only one group
		if ( match.length === 1 ) {
	
			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {
	
				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
	
				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}
	
				selector = selector.slice( tokens.shift().value.length );
			}
	
			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];
	
				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {
	
						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}
	
						break;
					}
				}
			}
		}
	
		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};
	
	// One-time assignments
	
	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
	
	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;
	
	// Initialize against the default document
	setDocument();
	
	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});
	
	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}
	
	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}
	
	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}
	
	return Sizzle;
	
	})( window );
	
	
	
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	
	
	
	var rneedsContext = jQuery.expr.match.needsContext;
	
	var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);
	
	
	
	var risSimple = /^.[^:#\[\.,]*$/;
	
	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				/* jshint -W018 */
				return !!qualifier.call( elem, i, elem ) !== not;
			});
	
		}
	
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			});
	
		}
	
		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}
	
			qualifier = jQuery.filter( qualifier, elements );
		}
	
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
		});
	}
	
	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];
	
		if ( not ) {
			expr = ":not(" + expr + ")";
		}
	
		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			}));
	};
	
	jQuery.fn.extend({
		find: function( selector ) {
			var i,
				len = this.length,
				ret = [],
				self = this;
	
			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter(function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				}) );
			}
	
			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}
	
			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow(this, selector || [], false) );
		},
		not: function( selector ) {
			return this.pushStack( winnow(this, selector || [], true) );
		},
		is: function( selector ) {
			return !!winnow(
				this,
	
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	});
	
	
	// Initialize a jQuery object
	
	
	// A central reference to the root jQuery(document)
	var rootjQuery,
	
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
	
		init = jQuery.fn.init = function( selector, context ) {
			var match, elem;
	
			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}
	
			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];
	
				} else {
					match = rquickExpr.exec( selector );
				}
	
				// Match html or make sure no context is specified for #id
				if ( match && (match[1] || !context) ) {
	
					// HANDLE: $(html) -> $(array)
					if ( match[1] ) {
						context = context instanceof jQuery ? context[0] : context;
	
						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[1],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );
	
						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );
	
								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}
	
						return this;
	
					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[2] );
	
						// Support: Blackberry 4.6
						// gEBID returns nodes no longer in the document (#6963)
						if ( elem && elem.parentNode ) {
							// Inject the element directly into the jQuery object
							this.length = 1;
							this[0] = elem;
						}
	
						this.context = document;
						this.selector = selector;
						return this;
					}
	
				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || rootjQuery ).find( selector );
	
				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}
	
			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[0] = selector;
				this.length = 1;
				return this;
	
			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return typeof rootjQuery.ready !== "undefined" ?
					rootjQuery.ready( selector ) :
					// Execute immediately if ready is not present
					selector( jQuery );
			}
	
			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}
	
			return jQuery.makeArray( selector, this );
		};
	
	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;
	
	// Initialize central reference
	rootjQuery = jQuery( document );
	
	
	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};
	
	jQuery.extend({
		dir: function( elem, dir, until ) {
			var matched = [],
				truncate = until !== undefined;
	
			while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
				if ( elem.nodeType === 1 ) {
					if ( truncate && jQuery( elem ).is( until ) ) {
						break;
					}
					matched.push( elem );
				}
			}
			return matched;
		},
	
		sibling: function( n, elem ) {
			var matched = [];
	
			for ( ; n; n = n.nextSibling ) {
				if ( n.nodeType === 1 && n !== elem ) {
					matched.push( n );
				}
			}
	
			return matched;
		}
	});
	
	jQuery.fn.extend({
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;
	
			return this.filter(function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[i] ) ) {
						return true;
					}
				}
			});
		},
	
		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;
	
			for ( ; i < l; i++ ) {
				for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
					// Always skip document fragments
					if ( cur.nodeType < 11 && (pos ?
						pos.index(cur) > -1 :
	
						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector(cur, selectors)) ) {
	
						matched.push( cur );
						break;
					}
				}
			}
	
			return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
		},
	
		// Determine the position of an element within the set
		index: function( elem ) {
	
			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}
	
			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}
	
			// Locate the position of the desired element
			return indexOf.call( this,
	
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},
	
		add: function( selector, context ) {
			return this.pushStack(
				jQuery.unique(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},
	
		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter(selector)
			);
		}
	});
	
	function sibling( cur, dir ) {
		while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
		return cur;
	}
	
	jQuery.each({
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return jQuery.dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return jQuery.dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return jQuery.dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return jQuery.sibling( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );
	
			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}
	
			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}
	
			if ( this.length > 1 ) {
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.unique( matched );
				}
	
				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}
	
			return this.pushStack( matched );
		};
	});
	var rnotwhite = (/\S+/g);
	
	
	
	// String to Object options format cache
	var optionsCache = {};
	
	// Convert String-formatted options into Object-formatted ones and store in cache
	function createOptions( options ) {
		var object = optionsCache[ options ] = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		});
		return object;
	}
	
	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {
	
		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			( optionsCache[ options ] || createOptions( options ) ) :
			jQuery.extend( {}, options );
	
		var // Last fire value (for non-forgettable lists)
			memory,
			// Flag to know if list was already fired
			fired,
			// Flag to know if list is currently firing
			firing,
			// First callback to fire (used internally by add and fireWith)
			firingStart,
			// End of the loop when firing
			firingLength,
			// Index of currently firing callback (modified by remove if needed)
			firingIndex,
			// Actual callback list
			list = [],
			// Stack of fire calls for repeatable lists
			stack = !options.once && [],
			// Fire callbacks
			fire = function( data ) {
				memory = options.memory && data;
				fired = true;
				firingIndex = firingStart || 0;
				firingStart = 0;
				firingLength = list.length;
				firing = true;
				for ( ; list && firingIndex < firingLength; firingIndex++ ) {
					if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
						memory = false; // To prevent further calls using add
						break;
					}
				}
				firing = false;
				if ( list ) {
					if ( stack ) {
						if ( stack.length ) {
							fire( stack.shift() );
						}
					} else if ( memory ) {
						list = [];
					} else {
						self.disable();
					}
				}
			},
			// Actual Callbacks object
			self = {
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
						// First, we save the current length
						var start = list.length;
						(function add( args ) {
							jQuery.each( args, function( _, arg ) {
								var type = jQuery.type( arg );
								if ( type === "function" ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && type !== "string" ) {
									// Inspect recursively
									add( arg );
								}
							});
						})( arguments );
						// Do we need to add the callbacks to the
						// current firing batch?
						if ( firing ) {
							firingLength = list.length;
						// With memory, if we're not firing then
						// we should call right away
						} else if ( memory ) {
							firingStart = start;
							fire( memory );
						}
					}
					return this;
				},
				// Remove a callback from the list
				remove: function() {
					if ( list ) {
						jQuery.each( arguments, function( _, arg ) {
							var index;
							while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
								list.splice( index, 1 );
								// Handle firing indexes
								if ( firing ) {
									if ( index <= firingLength ) {
										firingLength--;
									}
									if ( index <= firingIndex ) {
										firingIndex--;
									}
								}
							}
						});
					}
					return this;
				},
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
				},
				// Remove all callbacks from the list
				empty: function() {
					list = [];
					firingLength = 0;
					return this;
				},
				// Have the list do nothing anymore
				disable: function() {
					list = stack = memory = undefined;
					return this;
				},
				// Is it disabled?
				disabled: function() {
					return !list;
				},
				// Lock the list in its current state
				lock: function() {
					stack = undefined;
					if ( !memory ) {
						self.disable();
					}
					return this;
				},
				// Is it locked?
				locked: function() {
					return !stack;
				},
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( list && ( !fired || stack ) ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						if ( firing ) {
							stack.push( args );
						} else {
							fire( args );
						}
					}
					return this;
				},
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};
	
		return self;
	};
	
	
	jQuery.extend({
	
		Deferred: function( func ) {
			var tuples = [
					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks("memory") ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred(function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[1] ](function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.done( newDefer.resolve )
											.fail( newDefer.reject )
											.progress( newDefer.notify );
									} else {
										newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
									}
								});
							});
							fns = null;
						}).promise();
					},
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};
	
			// Keep pipe for back-compat
			promise.pipe = promise.then;
	
			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];
	
				// promise[ done | fail | progress ] = list.add
				promise[ tuple[1] ] = list.add;
	
				// Handle state
				if ( stateString ) {
					list.add(function() {
						// state = [ resolved | rejected ]
						state = stateString;
	
					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}
	
				// deferred[ resolve | reject | notify ]
				deferred[ tuple[0] ] = function() {
					deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[0] + "With" ] = list.fireWith;
			});
	
			// Make the deferred a promise
			promise.promise( deferred );
	
			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}
	
			// All done!
			return deferred;
		},
	
		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = slice.call( arguments ),
				length = resolveValues.length,
	
				// the count of uncompleted subordinates
				remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
	
				// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
	
				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},
	
				progressValues, progressContexts, resolveContexts;
	
			// Add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject )
							.progress( updateFunc( i, progressContexts, progressValues ) );
					} else {
						--remaining;
					}
				}
			}
	
			// If we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}
	
			return deferred.promise();
		}
	});
	
	
	// The deferred used on DOM ready
	var readyList;
	
	jQuery.fn.ready = function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );
	
		return this;
	};
	
	jQuery.extend({
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
	
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
	
		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},
	
		// Handle when the DOM is ready
		ready: function( wait ) {
	
			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}
	
			// Remember that the DOM is ready
			jQuery.isReady = true;
	
			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}
	
			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
	
			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
				jQuery( document ).off( "ready" );
			}
		}
	});
	
	/**
	 * The ready event handler and self cleanup method
	 */
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed, false );
		window.removeEventListener( "load", completed, false );
		jQuery.ready();
	}
	
	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {
	
			readyList = jQuery.Deferred();
	
			// Catch cases where $(document).ready() is called after the browser event has already occurred.
			// We once tried to use readyState "interactive" here, but it caused issues like the one
			// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
			if ( document.readyState === "complete" ) {
				// Handle it asynchronously to allow scripts the opportunity to delay ready
				setTimeout( jQuery.ready );
	
			} else {
	
				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed, false );
	
				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed, false );
			}
		}
		return readyList.promise( obj );
	};
	
	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();
	
	
	
	
	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;
	
		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
			}
	
		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;
	
			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}
	
			if ( bulk ) {
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;
	
				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}
	
			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
				}
			}
		}
	
		return chainable ?
			elems :
	
			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[0], key ) : emptyGet;
	};
	
	
	/**
	 * Determines whether an object can have data
	 */
	jQuery.acceptData = function( owner ) {
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};
	
	
	function Data() {
		// Support: Android<4,
		// Old WebKit does not have Object.preventExtensions/freeze method,
		// return new empty object instead with no [[set]] accessor
		Object.defineProperty( this.cache = {}, 0, {
			get: function() {
				return {};
			}
		});
	
		this.expando = jQuery.expando + Data.uid++;
	}
	
	Data.uid = 1;
	Data.accepts = jQuery.acceptData;
	
	Data.prototype = {
		key: function( owner ) {
			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return the key for a frozen object.
			if ( !Data.accepts( owner ) ) {
				return 0;
			}
	
			var descriptor = {},
				// Check if the owner object already has a cache key
				unlock = owner[ this.expando ];
	
			// If not, create one
			if ( !unlock ) {
				unlock = Data.uid++;
	
				// Secure it in a non-enumerable, non-writable property
				try {
					descriptor[ this.expando ] = { value: unlock };
					Object.defineProperties( owner, descriptor );
	
				// Support: Android<4
				// Fallback to a less secure definition
				} catch ( e ) {
					descriptor[ this.expando ] = unlock;
					jQuery.extend( owner, descriptor );
				}
			}
	
			// Ensure the cache object
			if ( !this.cache[ unlock ] ) {
				this.cache[ unlock ] = {};
			}
	
			return unlock;
		},
		set: function( owner, data, value ) {
			var prop,
				// There may be an unlock assigned to this node,
				// if there is no entry for this "owner", create one inline
				// and set the unlock as though an owner entry had always existed
				unlock = this.key( owner ),
				cache = this.cache[ unlock ];
	
			// Handle: [ owner, key, value ] args
			if ( typeof data === "string" ) {
				cache[ data ] = value;
	
			// Handle: [ owner, { properties } ] args
			} else {
				// Fresh assignments by object are shallow copied
				if ( jQuery.isEmptyObject( cache ) ) {
					jQuery.extend( this.cache[ unlock ], data );
				// Otherwise, copy the properties one-by-one to the cache object
				} else {
					for ( prop in data ) {
						cache[ prop ] = data[ prop ];
					}
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			// Either a valid cache is found, or will be created.
			// New caches will be created and the unlock returned,
			// allowing direct access to the newly created
			// empty data object. A valid owner object must be provided.
			var cache = this.cache[ this.key( owner ) ];
	
			return key === undefined ?
				cache : cache[ key ];
		},
		access: function( owner, key, value ) {
			var stored;
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					((key && typeof key === "string") && value === undefined) ) {
	
				stored = this.get( owner, key );
	
				return stored !== undefined ?
					stored : this.get( owner, jQuery.camelCase(key) );
			}
	
			// [*]When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );
	
			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i, name, camel,
				unlock = this.key( owner ),
				cache = this.cache[ unlock ];
	
			if ( key === undefined ) {
				this.cache[ unlock ] = {};
	
			} else {
				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {
					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat( key.map( jQuery.camelCase ) );
				} else {
					camel = jQuery.camelCase( key );
					// Try the string as a key before any manipulation
					if ( key in cache ) {
						name = [ key, camel ];
					} else {
						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ?
							[ name ] : ( name.match( rnotwhite ) || [] );
					}
				}
	
				i = name.length;
				while ( i-- ) {
					delete cache[ name[ i ] ];
				}
			}
		},
		hasData: function( owner ) {
			return !jQuery.isEmptyObject(
				this.cache[ owner[ this.expando ] ] || {}
			);
		},
		discard: function( owner ) {
			if ( owner[ this.expando ] ) {
				delete this.cache[ owner[ this.expando ] ];
			}
		}
	};
	var data_priv = new Data();
	
	var data_user = new Data();
	
	
	
	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
	
	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /([A-Z])/g;
	
	function dataAttr( elem, key, data ) {
		var name;
	
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
			data = elem.getAttribute( name );
	
			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :
						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch( e ) {}
	
				// Make sure we set the data so it isn't changed later
				data_user.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}
	
	jQuery.extend({
		hasData: function( elem ) {
			return data_user.hasData( elem ) || data_priv.hasData( elem );
		},
	
		data: function( elem, name, data ) {
			return data_user.access( elem, name, data );
		},
	
		removeData: function( elem, name ) {
			data_user.remove( elem, name );
		},
	
		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to data_priv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return data_priv.access( elem, name, data );
		},
	
		_removeData: function( elem, name ) {
			data_priv.remove( elem, name );
		}
	});
	
	jQuery.fn.extend({
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;
	
			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = data_user.get( elem );
	
					if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {
	
							// Support: IE11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice(5) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						data_priv.set( elem, "hasDataAttrs", true );
					}
				}
	
				return data;
			}
	
			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each(function() {
					data_user.set( this, key );
				});
			}
	
			return access( this, function( value ) {
				var data,
					camelKey = jQuery.camelCase( key );
	
				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {
					// Attempt to get data from the cache
					// with the key as-is
					data = data_user.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// Attempt to get data from the cache
					// with the key camelized
					data = data_user.get( elem, camelKey );
					if ( data !== undefined ) {
						return data;
					}
	
					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, camelKey, undefined );
					if ( data !== undefined ) {
						return data;
					}
	
					// We tried really hard, but the data doesn't exist.
					return;
				}
	
				// Set the data...
				this.each(function() {
					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = data_user.get( this, camelKey );
	
					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					data_user.set( this, camelKey, value );
	
					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if ( key.indexOf("-") !== -1 && data !== undefined ) {
						data_user.set( this, key, value );
					}
				});
			}, null, value, arguments.length > 1, null, true );
		},
	
		removeData: function( key ) {
			return this.each(function() {
				data_user.remove( this, key );
			});
		}
	});
	
	
	jQuery.extend({
		queue: function( elem, type, data ) {
			var queue;
	
			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = data_priv.get( elem, type );
	
				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = data_priv.access( elem, type, jQuery.makeArray(data) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},
	
		dequeue: function( elem, type ) {
			type = type || "fx";
	
			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};
	
			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}
	
			if ( fn ) {
	
				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}
	
				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}
	
			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},
	
		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return data_priv.get( elem, key ) || data_priv.access( elem, key, {
				empty: jQuery.Callbacks("once memory").add(function() {
					data_priv.remove( elem, [ type + "queue", key ] );
				})
			});
		}
	});
	
	jQuery.fn.extend({
		queue: function( type, data ) {
			var setter = 2;
	
			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}
	
			if ( arguments.length < setter ) {
				return jQuery.queue( this[0], type );
			}
	
			return data === undefined ?
				this :
				this.each(function() {
					var queue = jQuery.queue( this, type, data );
	
					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );
	
					if ( type === "fx" && queue[0] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				});
		},
		dequeue: function( type ) {
			return this.each(function() {
				jQuery.dequeue( this, type );
			});
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};
	
			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";
	
			while ( i-- ) {
				tmp = data_priv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	});
	var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
	
	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
	
	var isHidden = function( elem, el ) {
			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
		};
	
	var rcheckableType = (/^(?:checkbox|radio)$/i);
	
	
	
	(function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );
	
		// Support: Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );
	
		div.appendChild( input );
	
		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
	
		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	})();
	var strundefined = typeof undefined;
	
	
	
	support.focusinBubbles = "onfocusin" in window;
	
	
	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
		rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
	
	function returnTrue() {
		return true;
	}
	
	function returnFalse() {
		return false;
	}
	
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}
	
	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {
	
		global: {},
	
		add: function( elem, types, handler, data, selector ) {
	
			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = data_priv.get( elem );
	
			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}
	
			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}
	
			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}
	
			// Init the element's event structure and main handler, if this is the first
			if ( !(events = elemData.events) ) {
				events = elemData.events = {};
			}
			if ( !(eventHandle = elemData.handle) ) {
				eventHandle = elemData.handle = function( e ) {
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}
	
			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();
	
				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}
	
				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};
	
				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;
	
				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};
	
				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join(".")
				}, handleObjIn );
	
				// Init the event handler queue if we're the first
				if ( !(handlers = events[ type ]) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;
	
					// Only use addEventListener if the special events handler returns false
					if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle, false );
						}
					}
				}
	
				if ( special.add ) {
					special.add.call( elem, handleObj );
	
					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}
	
				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}
	
				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}
	
		},
	
		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {
	
			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = data_priv.hasData( elem ) && data_priv.get( elem );
	
			if ( !elemData || !(events = elemData.events) ) {
				return;
			}
	
			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();
	
				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}
	
				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );
	
				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];
	
					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );
	
						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}
	
				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
						jQuery.removeEvent( elem, type, elemData.handle );
					}
	
					delete events[ type ];
				}
			}
	
			// Remove the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				delete elemData.handle;
				data_priv.remove( elem, "events" );
			}
		},
	
		trigger: function( event, data, elem, onlyHandlers ) {
	
			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];
	
			cur = tmp = elem = elem || document;
	
			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}
	
			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}
	
			if ( type.indexOf(".") >= 0 ) {
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;
	
			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );
	
			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join(".");
			event.namespace_re = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
				null;
	
			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}
	
			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );
	
			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}
	
			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
	
				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}
	
				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === (elem.ownerDocument || document) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}
	
			// Fire handlers on the event path
			i = 0;
			while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {
	
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;
	
				// jQuery handler
				handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}
	
				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;
	
			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {
	
				if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
					jQuery.acceptData( elem ) ) {
	
					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
	
						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];
	
						if ( tmp ) {
							elem[ ontype ] = null;
						}
	
						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;
	
						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}
	
			return event.result;
		},
	
		dispatch: function( event ) {
	
			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );
	
			var i, j, ret, matched, handleObj,
				handlerQueue = [],
				args = slice.call( arguments ),
				handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};
	
			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;
			event.delegateTarget = this;
	
			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}
	
			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );
	
			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;
	
				j = 0;
				while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {
	
					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {
	
						event.handleObj = handleObj;
						event.data = handleObj.data;
	
						ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
								.apply( matched.elem, args );
	
						if ( ret !== undefined ) {
							if ( (event.result = ret) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}
	
			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}
	
			return event.result;
		},
	
		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;
	
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			// Avoid non-left-click bubbling in Firefox (#3861)
			if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {
	
				for ( ; cur !== this; cur = cur.parentNode || this ) {
	
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.disabled !== true || event.type !== "click" ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];
	
							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";
	
							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) >= 0 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push({ elem: cur, handlers: matches });
						}
					}
				}
			}
	
			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
			}
	
			return handlerQueue;
		},
	
		// Includes some event props shared by KeyEvent and MouseEvent
		props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
	
		fixHooks: {},
	
		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function( event, original ) {
	
				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}
	
				return event;
			}
		},
	
		mouseHooks: {
			props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
			filter: function( event, original ) {
				var eventDoc, doc, body,
					button = original.button;
	
				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;
	
					event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}
	
				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}
	
				return event;
			}
		},
	
		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}
	
			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];
	
			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
	
			event = new jQuery.Event( originalEvent );
	
			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}
	
			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if ( !event.target ) {
				event.target = document;
			}
	
			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}
	
			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},
	
		special: {
			load: {
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},
	
				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},
	
			beforeunload: {
				postDispatch: function( event ) {
	
					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		},
	
		simulate: function( type, elem, event, bubble ) {
			// Piggyback on a donor event to simulate a different one.
			// Fake originalEvent to avoid donor's stopPropagation, but if the
			// simulated event prevents default then we do the same on the donor.
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true,
					originalEvent: {}
				}
			);
			if ( bubble ) {
				jQuery.event.trigger( e, null, elem );
			} else {
				jQuery.event.dispatch.call( elem, e );
			}
			if ( e.isDefaultPrevented() ) {
				event.preventDefault();
			}
		}
	};
	
	jQuery.removeEvent = function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	};
	
	jQuery.Event = function( src, props ) {
		// Allow instantiation without the 'new' keyword
		if ( !(this instanceof jQuery.Event) ) {
			return new jQuery.Event( src, props );
		}
	
		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;
	
			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
					// Support: Android<4.0
					src.returnValue === false ?
				returnTrue :
				returnFalse;
	
		// Event type
		} else {
			this.type = src;
		}
	
		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}
	
		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();
	
		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};
	
	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
	
		preventDefault: function() {
			var e = this.originalEvent;
	
			this.isDefaultPrevented = returnTrue;
	
			if ( e && e.preventDefault ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;
	
			this.isPropagationStopped = returnTrue;
	
			if ( e && e.stopPropagation ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;
	
			this.isImmediatePropagationStopped = returnTrue;
	
			if ( e && e.stopImmediatePropagation ) {
				e.stopImmediatePropagation();
			}
	
			this.stopPropagation();
		}
	};
	
	// Create mouseenter/leave events using mouseover/out and event-time checks
	// Support: Chrome 15+
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,
	
			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;
	
				// For mousenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	});
	
	// Support: Firefox, Chrome, Safari
	// Create "bubbling" focus and blur events
	if ( !support.focusinBubbles ) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
	
			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
					jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
				};
	
			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = data_priv.access( doc, fix );
	
					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = data_priv.access( doc, fix ) - 1;
	
					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						data_priv.remove( doc, fix );
	
					} else {
						data_priv.access( doc, fix, attaches );
					}
				}
			};
		});
	}
	
	jQuery.fn.extend({
	
		on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
			var origFn, type;
	
			// Types can be a map of types/handlers
			if ( typeof types === "object" ) {
				// ( types-Object, selector, data )
				if ( typeof selector !== "string" ) {
					// ( types-Object, data )
					data = data || selector;
					selector = undefined;
				}
				for ( type in types ) {
					this.on( type, selector, data, types[ type ], one );
				}
				return this;
			}
	
			if ( data == null && fn == null ) {
				// ( types, fn )
				fn = selector;
				data = selector = undefined;
			} else if ( fn == null ) {
				if ( typeof selector === "string" ) {
					// ( types, selector, fn )
					fn = data;
					data = undefined;
				} else {
					// ( types, data, fn )
					fn = data;
					data = selector;
					selector = undefined;
				}
			}
			if ( fn === false ) {
				fn = returnFalse;
			} else if ( !fn ) {
				return this;
			}
	
			if ( one === 1 ) {
				origFn = fn;
				fn = function( event ) {
					// Can use an empty set, since event contains the info
					jQuery().off( event );
					return origFn.apply( this, arguments );
				};
				// Use same guid so caller can remove using origFn
				fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
			}
			return this.each( function() {
				jQuery.event.add( this, types, fn, data, selector );
			});
		},
		one: function( types, selector, data, fn ) {
			return this.on( types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each(function() {
				jQuery.event.remove( this, types, fn, selector );
			});
		},
	
		trigger: function( type, data ) {
			return this.each(function() {
				jQuery.event.trigger( type, data, this );
			});
		},
		triggerHandler: function( type, data ) {
			var elem = this[0];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	});
	
	
	var
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
		rtagName = /<([\w:]+)/,
		rhtml = /<|&#?\w+;/,
		rnoInnerhtml = /<(?:script|style|link)/i,
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptType = /^$|\/(?:java|ecma)script/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
	
		// We have to close these tags to support XHTML (#13200)
		wrapMap = {
	
			// Support: IE9
			option: [ 1, "<select multiple='multiple'>", "</select>" ],
	
			thead: [ 1, "<table>", "</table>" ],
			col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
			tr: [ 2, "<table><tbody>", "</tbody></table>" ],
			td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
	
			_default: [ 0, "", "" ]
		};
	
	// Support: IE9
	wrapMap.optgroup = wrapMap.option;
	
	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;
	
	// Support: 1.x compatibility
	// Manipulating tables requires a tbody
	function manipulationTarget( elem, content ) {
		return jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?
	
			elem.getElementsByTagName("tbody")[0] ||
				elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
			elem;
	}
	
	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );
	
		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute("type");
		}
	
		return elem;
	}
	
	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			data_priv.set(
				elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
			);
		}
	}
	
	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
	
		if ( dest.nodeType !== 1 ) {
			return;
		}
	
		// 1. Copy private data: events, handlers, etc.
		if ( data_priv.hasData( src ) ) {
			pdataOld = data_priv.access( src );
			pdataCur = data_priv.set( dest, pdataOld );
			events = pdataOld.events;
	
			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};
	
				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}
	
		// 2. Copy user data
		if ( data_user.hasData( src ) ) {
			udataOld = data_user.access( src );
			udataCur = jQuery.extend( {}, udataOld );
	
			data_user.set( dest, udataCur );
		}
	}
	
	function getAll( context, tag ) {
		var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
				context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
				[];
	
		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}
	
	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();
	
		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;
	
		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}
	
	jQuery.extend({
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );
	
			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {
	
				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );
	
				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}
	
			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );
	
					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}
	
			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}
	
			// Return the cloned set
			return clone;
		},
	
		buildFragment: function( elems, context, scripts, selection ) {
			var elem, tmp, tag, wrap, contains, j,
				fragment = context.createDocumentFragment(),
				nodes = [],
				i = 0,
				l = elems.length;
	
			for ( ; i < l; i++ ) {
				elem = elems[ i ];
	
				if ( elem || elem === 0 ) {
	
					// Add nodes directly
					if ( jQuery.type( elem ) === "object" ) {
						// Support: QtWebKit, PhantomJS
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
	
					// Convert non-html into a text node
					} else if ( !rhtml.test( elem ) ) {
						nodes.push( context.createTextNode( elem ) );
	
					// Convert html into DOM nodes
					} else {
						tmp = tmp || fragment.appendChild( context.createElement("div") );
	
						// Deserialize a standard representation
						tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
						wrap = wrapMap[ tag ] || wrapMap._default;
						tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];
	
						// Descend through wrappers to the right content
						j = wrap[ 0 ];
						while ( j-- ) {
							tmp = tmp.lastChild;
						}
	
						// Support: QtWebKit, PhantomJS
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( nodes, tmp.childNodes );
	
						// Remember the top-level container
						tmp = fragment.firstChild;
	
						// Ensure the created nodes are orphaned (#12392)
						tmp.textContent = "";
					}
				}
			}
	
			// Remove wrapper from fragment
			fragment.textContent = "";
	
			i = 0;
			while ( (elem = nodes[ i++ ]) ) {
	
				// #4087 - If origin and destination elements are the same, and this is
				// that element, do not do anything
				if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
					continue;
				}
	
				contains = jQuery.contains( elem.ownerDocument, elem );
	
				// Append to fragment
				tmp = getAll( fragment.appendChild( elem ), "script" );
	
				// Preserve script evaluation history
				if ( contains ) {
					setGlobalEval( tmp );
				}
	
				// Capture executables
				if ( scripts ) {
					j = 0;
					while ( (elem = tmp[ j++ ]) ) {
						if ( rscriptType.test( elem.type || "" ) ) {
							scripts.push( elem );
						}
					}
				}
			}
	
			return fragment;
		},
	
		cleanData: function( elems ) {
			var data, elem, type, key,
				special = jQuery.event.special,
				i = 0;
	
			for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
				if ( jQuery.acceptData( elem ) ) {
					key = elem[ data_priv.expando ];
	
					if ( key && (data = data_priv.cache[ key ]) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );
	
								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
						if ( data_priv.cache[ key ] ) {
							// Discard any remaining `private` data
							delete data_priv.cache[ key ];
						}
					}
				}
				// Discard any remaining `user` data
				delete data_user.cache[ elem[ data_user.expando ] ];
			}
		}
	});
	
	jQuery.fn.extend({
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each(function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					});
			}, null, value, arguments.length );
		},
	
		append: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			});
		},
	
		prepend: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			});
		},
	
		before: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			});
		},
	
		after: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			});
		},
	
		remove: function( selector, keepData /* Internal Use Only */ ) {
			var elem,
				elems = selector ? jQuery.filter( selector, this ) : this,
				i = 0;
	
			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( getAll( elem ) );
				}
	
				if ( elem.parentNode ) {
					if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
						setGlobalEval( getAll( elem, "script" ) );
					}
					elem.parentNode.removeChild( elem );
				}
			}
	
			return this;
		},
	
		empty: function() {
			var elem,
				i = 0;
	
			for ( ; (elem = this[i]) != null; i++ ) {
				if ( elem.nodeType === 1 ) {
	
					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );
	
					// Remove any remaining nodes
					elem.textContent = "";
				}
			}
	
			return this;
		},
	
		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	
			return this.map(function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			});
		},
	
		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;
	
				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}
	
				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
	
					value = value.replace( rxhtmlTag, "<$1></$2>" );
	
					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};
	
							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}
	
						elem = 0;
	
					// If using innerHTML throws an exception, use the fallback method
					} catch( e ) {}
				}
	
				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},
	
		replaceWith: function() {
			var arg = arguments[ 0 ];
	
			// Make the changes, replacing each context element with the new content
			this.domManip( arguments, function( elem ) {
				arg = this.parentNode;
	
				jQuery.cleanData( getAll( this ) );
	
				if ( arg ) {
					arg.replaceChild( elem, this );
				}
			});
	
			// Force removal if there was no new content (e.g., from empty arguments)
			return arg && (arg.length || arg.nodeType) ? this : this.remove();
		},
	
		detach: function( selector ) {
			return this.remove( selector, true );
		},
	
		domManip: function( args, callback ) {
	
			// Flatten any nested arrays
			args = concat.apply( [], args );
	
			var fragment, first, scripts, hasScripts, node, doc,
				i = 0,
				l = this.length,
				set = this,
				iNoClone = l - 1,
				value = args[ 0 ],
				isFunction = jQuery.isFunction( value );
	
			// We can't cloneNode fragments that contain checked, in WebKit
			if ( isFunction ||
					( l > 1 && typeof value === "string" &&
						!support.checkClone && rchecked.test( value ) ) ) {
				return this.each(function( index ) {
					var self = set.eq( index );
					if ( isFunction ) {
						args[ 0 ] = value.call( this, index, self.html() );
					}
					self.domManip( args, callback );
				});
			}
	
			if ( l ) {
				fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
				first = fragment.firstChild;
	
				if ( fragment.childNodes.length === 1 ) {
					fragment = first;
				}
	
				if ( first ) {
					scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
					hasScripts = scripts.length;
	
					// Use the original fragment for the last item instead of the first because it can end up
					// being emptied incorrectly in certain situations (#8070).
					for ( ; i < l; i++ ) {
						node = fragment;
	
						if ( i !== iNoClone ) {
							node = jQuery.clone( node, true, true );
	
							// Keep references to cloned scripts for later restoration
							if ( hasScripts ) {
								// Support: QtWebKit
								// jQuery.merge because push.apply(_, arraylike) throws
								jQuery.merge( scripts, getAll( node, "script" ) );
							}
						}
	
						callback.call( this[ i ], node, i );
					}
	
					if ( hasScripts ) {
						doc = scripts[ scripts.length - 1 ].ownerDocument;
	
						// Reenable scripts
						jQuery.map( scripts, restoreScript );
	
						// Evaluate executable scripts on first document insertion
						for ( i = 0; i < hasScripts; i++ ) {
							node = scripts[ i ];
							if ( rscriptType.test( node.type || "" ) &&
								!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {
	
								if ( node.src ) {
									// Optional AJAX dependency, but won't run scripts if not present
									if ( jQuery._evalUrl ) {
										jQuery._evalUrl( node.src );
									}
								} else {
									jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
								}
							}
						}
					}
				}
			}
	
			return this;
		}
	});
	
	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;
	
			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );
	
				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply( ret, elems.get() );
			}
	
			return this.pushStack( ret );
		};
	});
	
	
	var iframe,
		elemdisplay = {};
	
	/**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */
	// Called only from within defaultDisplay
	function actualDisplay( name, doc ) {
		var style,
			elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
	
			// getDefaultComputedStyle might be reliably used only on attached element
			display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?
	
				// Use of this method is a temporary fix (more like optimization) until something better comes along,
				// since it was removed from specification and supported only in FF
				style.display : jQuery.css( elem[ 0 ], "display" );
	
		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();
	
		return display;
	}
	
	/**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */
	function defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];
	
		if ( !display ) {
			display = actualDisplay( nodeName, doc );
	
			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {
	
				// Use the already-created iframe if possible
				iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );
	
				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[ 0 ].contentDocument;
	
				// Support: IE
				doc.write();
				doc.close();
	
				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}
	
			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}
	
		return display;
	}
	var rmargin = (/^margin/);
	
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
	
	var getStyles = function( elem ) {
			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			if ( elem.ownerDocument.defaultView.opener ) {
				return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
			}
	
			return window.getComputedStyle( elem, null );
		};
	
	
	
	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;
	
		computed = computed || getStyles( elem );
	
		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];
		}
	
		if ( computed ) {
	
			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}
	
			// Support: iOS < 6
			// A tribute to the "awesome hack by Dean Edwards"
			// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {
	
				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;
	
				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;
	
				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}
	
		return ret !== undefined ?
			// Support: IE
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}
	
	
	function addGetHookIf( conditionFn, hookFn ) {
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}
	
				// Hook needed; redefine it so that the support test is not executed again.
				return (this.get = hookFn).apply( this, arguments );
			}
		};
	}
	
	
	(function() {
		var pixelPositionVal, boxSizingReliableVal,
			docElem = document.documentElement,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );
	
		if ( !div.style ) {
			return;
		}
	
		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";
	
		container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
			"position:absolute";
		container.appendChild( div );
	
		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computePixelPositionAndBoxSizingReliable() {
			div.style.cssText =
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
				"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
				"border:1px;padding:1px;width:4px;position:absolute";
			div.innerHTML = "";
			docElem.appendChild( container );
	
			var divStyle = window.getComputedStyle( div, null );
			pixelPositionVal = divStyle.top !== "1%";
			boxSizingReliableVal = divStyle.width === "4px";
	
			docElem.removeChild( container );
		}
	
		// Support: node.js jsdom
		// Don't assume that getComputedStyle is a property of the global object
		if ( window.getComputedStyle ) {
			jQuery.extend( support, {
				pixelPosition: function() {
	
					// This test is executed only once but we still do memoizing
					// since we can use the boxSizingReliable pre-computing.
					// No need to check if the test was already performed, though.
					computePixelPositionAndBoxSizingReliable();
					return pixelPositionVal;
				},
				boxSizingReliable: function() {
					if ( boxSizingReliableVal == null ) {
						computePixelPositionAndBoxSizingReliable();
					}
					return boxSizingReliableVal;
				},
				reliableMarginRight: function() {
	
					// Support: Android 2.3
					// Check if div with explicit width and no margin-right incorrectly
					// gets computed margin-right based on width of container. (#3333)
					// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
					// This support function is only executed once so no memoizing is needed.
					var ret,
						marginDiv = div.appendChild( document.createElement( "div" ) );
	
					// Reset CSS: box-sizing; display; margin; border; padding
					marginDiv.style.cssText = div.style.cssText =
						// Support: Firefox<29, Android 2.3
						// Vendor-prefix box-sizing
						"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
						"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
					marginDiv.style.marginRight = marginDiv.style.width = "0";
					div.style.width = "1px";
					docElem.appendChild( container );
	
					ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );
	
					docElem.removeChild( container );
					div.removeChild( marginDiv );
	
					return ret;
				}
			});
		}
	})();
	
	
	// A method for quickly swapping in/out CSS properties to get correct calculations.
	jQuery.swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};
	
		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}
	
		ret = callback.apply( elem, args || [] );
	
		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	
		return ret;
	};
	
	
	var
		// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
		rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),
	
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},
	
		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
	
	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( style, name ) {
	
		// Shortcut for names that are not vendor prefixed
		if ( name in style ) {
			return name;
		}
	
		// Check for vendor prefixed names
		var capName = name[0].toUpperCase() + name.slice(1),
			origName = name,
			i = cssPrefixes.length;
	
		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in style ) {
				return name;
			}
		}
	
		return origName;
	}
	
	function setPositiveNumber( elem, value, subtract ) {
		var matches = rnumsplit.exec( value );
		return matches ?
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
			value;
	}
	
	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?
			// If we already have the right measurement, avoid augmentation
			4 :
			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,
	
			val = 0;
	
		for ( ; i < 4; i += 2 ) {
			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}
	
			if ( isBorderBox ) {
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}
	
				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
	
				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}
	
		return val;
	}
	
	function getWidthOrHeight( elem, name, extra ) {
	
		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
	
		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}
	
			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test(val) ) {
				return val;
			}
	
			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );
	
			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}
	
		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}
	
	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;
	
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
	
			values[ index ] = data_priv.get( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {
				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}
	
				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
				}
			} else {
				hidden = isHidden( elem );
	
				if ( display !== "none" || !hidden ) {
					data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
				}
			}
		}
	
		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}
	
		return elements;
	}
	
	jQuery.extend({
	
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {
	
						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},
	
		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},
	
		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},
	
		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {
	
			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}
	
			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;
	
			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );
	
			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;
	
				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && (ret = rrelNum.exec( value )) ) {
					value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
					// Fixes bug #9237
					type = "number";
				}
	
				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}
	
				// If a number, add 'px' to the (except for certain CSS properties)
				if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
					value += "px";
				}
	
				// Support: IE9-11+
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}
	
				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
					style[ name ] = value;
				}
	
			} else {
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
					return ret;
				}
	
				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},
	
		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );
	
			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );
	
			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}
	
			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}
	
			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}
	
			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
			}
			return val;
		}
	});
	
	jQuery.each([ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {
	
					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
						jQuery.swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						}) :
						getWidthOrHeight( elem, name, extra );
				}
			},
	
			set: function( elem, value, extra ) {
				var styles = extra && getStyles( elem );
				return setPositiveNumber( elem, value, extra ?
					augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					) : 0
				);
			}
		};
	});
	
	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
		function( elem, computed ) {
			if ( computed ) {
				return jQuery.swap( elem, { "display": "inline-block" },
					curCSS, [ elem, "marginRight" ] );
			}
		}
	);
	
	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},
	
					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split(" ") : [ value ];
	
				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}
	
				return expanded;
			}
		};
	
		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	});
	
	jQuery.fn.extend({
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;
	
				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;
	
					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}
	
					return map;
				}
	
				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}
	
			return this.each(function() {
				if ( isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			});
		}
	});
	
	
	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;
	
	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || "swing";
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];
	
			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];
	
			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;
	
			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}
	
			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};
	
	Tween.prototype.init.prototype = Tween.prototype;
	
	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;
	
				if ( tween.elem[ tween.prop ] != null &&
					(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
					return tween.elem[ tween.prop ];
				}
	
				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};
	
	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};
	
	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		}
	};
	
	jQuery.fx = Tween.prototype.init;
	
	// Back Compat <1.8 extension point
	jQuery.fx.step = {};
	
	
	
	
	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
		rrun = /queueHooks$/,
		animationPrefilters = [ defaultPrefilter ],
		tweeners = {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value ),
					target = tween.cur(),
					parts = rfxnum.exec( value ),
					unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
	
					// Starting value computation is required for potential unit mismatches
					start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
						rfxnum.exec( jQuery.css( tween.elem, prop ) ),
					scale = 1,
					maxIterations = 20;
	
				if ( start && start[ 3 ] !== unit ) {
					// Trust units reported by jQuery.css
					unit = unit || start[ 3 ];
	
					// Make sure we update the tween properties later on
					parts = parts || [];
	
					// Iteratively approximate from a nonzero starting point
					start = +target || 1;
	
					do {
						// If previous iteration zeroed out, double until we get *something*.
						// Use string for doubling so we don't accidentally see scale as unchanged below
						scale = scale || ".5";
	
						// Adjust and apply
						start = start / scale;
						jQuery.style( tween.elem, prop, start + unit );
	
					// Update scale, tolerating zero or NaN from tween.cur(),
					// break the loop if scale is unchanged or perfect, or if we've just had enough
					} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
				}
	
				// Update tween properties
				if ( parts ) {
					start = tween.start = +start || +target || 0;
					tween.unit = unit;
					// If a +=/-= token was provided, we're doing a relative animation
					tween.end = parts[ 1 ] ?
						start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
						+parts[ 2 ];
				}
	
				return tween;
			} ]
		};
	
	// Animations created synchronously will run synchronously
	function createFxNow() {
		setTimeout(function() {
			fxNow = undefined;
		});
		return ( fxNow = jQuery.now() );
	}
	
	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };
	
		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}
	
		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}
	
		return attrs;
	}
	
	function createTween( value, prop, animation ) {
		var tween,
			collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( (tween = collection[ index ].call( animation, prop, value )) ) {
	
				// We're done with this property
				return tween;
			}
		}
	}
	
	function defaultPrefilter( elem, props, opts ) {
		/* jshint validthis: true */
		var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHidden( elem ),
			dataShow = data_priv.get( elem, "fxshow" );
	
		// Handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;
	
			anim.always(function() {
				// Ensure the complete handler is called before this completes
				anim.always(function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				});
			});
		}
	
		// Height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
	
			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css( elem, "display" );
	
			// Test default display if display is currently "none"
			checkDisplay = display === "none" ?
				data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;
	
			if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
				style.display = "inline-block";
			}
		}
	
		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	
		// show/hide pass
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {
	
					// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
	
			// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}
	
		if ( !jQuery.isEmptyObject( orig ) ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = data_priv.access( elem, "fxshow", {} );
			}
	
			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done(function() {
					jQuery( elem ).hide();
				});
			}
			anim.done(function() {
				var prop;
	
				data_priv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			});
			for ( prop in orig ) {
				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
	
				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}
	
		// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
			style.display = display;
		}
	}
	
	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;
	
		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}
	
			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}
	
			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];
	
				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}
	
	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = animationPrefilters.length,
			deferred = jQuery.Deferred().always( function() {
				// Don't match elem in the :animated selector
				delete tick.elem;
			}),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
					// Support: Android 2.3
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;
	
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}
	
				deferred.notifyWith( elem, [ animation, percent, remaining ]);
	
				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise({
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, { specialEasing: {} }, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}
	
					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			}),
			props = animation.props;
	
		propFilter( props, animation.opts.specialEasing );
	
		for ( ; index < length ; index++ ) {
			result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				return result;
			}
		}
	
		jQuery.map( props, createTween, animation );
	
		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}
	
		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			})
		);
	
		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}
	
	jQuery.Animation = jQuery.extend( Animation, {
	
		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.split(" ");
			}
	
			var prop,
				index = 0,
				length = props.length;
	
			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				tweeners[ prop ] = tweeners[ prop ] || [];
				tweeners[ prop ].unshift( callback );
			}
		},
	
		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				animationPrefilters.unshift( callback );
			} else {
				animationPrefilters.push( callback );
			}
		}
	});
	
	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};
	
		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
	
		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}
	
		// Queueing
		opt.old = opt.complete;
	
		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
	
			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};
	
		return opt;
	};
	
	jQuery.fn.extend({
		fadeTo: function( speed, to, easing, callback ) {
	
			// Show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()
	
				// Animate to the value specified
				.end().animate({ opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
	
					// Empty animations, or finishing resolves immediately
					if ( empty || data_priv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;
	
			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};
	
			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}
	
			return this.each(function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = data_priv.get( this );
	
				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}
	
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}
	
				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			});
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each(function() {
				var index,
					data = data_priv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;
	
				// Enable finishing flag on private data
				data.finish = true;
	
				// Empty the queue first
				jQuery.queue( this, type, [] );
	
				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}
	
				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}
	
				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}
	
				// Turn off finishing flag
				delete data.finish;
			});
		}
	});
	
	jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	});
	
	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	});
	
	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;
	
		fxNow = jQuery.now();
	
		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}
	
		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};
	
	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};
	
	jQuery.fx.interval = 13;
	
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};
	
	jQuery.fx.stop = function() {
		clearInterval( timerId );
		timerId = null;
	};
	
	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	};
	
	
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";
	
		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	};
	
	
	(function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );
	
		input.type = "checkbox";
	
		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";
	
		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;
	
		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;
	
		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	})();
	
	
	var nodeHook, boolHook,
		attrHandle = jQuery.expr.attrHandle;
	
	jQuery.fn.extend({
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},
	
		removeAttr: function( name ) {
			return this.each(function() {
				jQuery.removeAttr( this, name );
			});
		}
	});
	
	jQuery.extend({
		attr: function( elem, name, value ) {
			var hooks, ret,
				nType = elem.nodeType;
	
			// don't get/set attributes on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === strundefined ) {
				return jQuery.prop( elem, name, value );
			}
	
			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
			}
	
			if ( value !== undefined ) {
	
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
	
				} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
					return ret;
	
				} else {
					elem.setAttribute( name, value + "" );
					return value;
				}
	
			} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;
	
			} else {
				ret = jQuery.find.attr( elem, name );
	
				// Non-existent attributes return null, we normalize to undefined
				return ret == null ?
					undefined :
					ret;
			}
		},
	
		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( rnotwhite );
	
			if ( attrNames && elem.nodeType === 1 ) {
				while ( (name = attrNames[i++]) ) {
					propName = jQuery.propFix[ name ] || name;
	
					// Boolean attributes get special treatment (#10870)
					if ( jQuery.expr.match.bool.test( name ) ) {
						// Set corresponding property to false
						elem[ propName ] = false;
					}
	
					elem.removeAttribute( name );
				}
			}
		},
	
		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		}
	});
	
	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;
	
		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		};
	});
	
	
	
	
	var rfocusable = /^(?:input|select|textarea|button)$/i;
	
	jQuery.fn.extend({
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},
	
		removeProp: function( name ) {
			return this.each(function() {
				delete this[ jQuery.propFix[ name ] || name ];
			});
		}
	});
	
	jQuery.extend({
		propFix: {
			"for": "htmlFor",
			"class": "className"
		},
	
		prop: function( elem, name, value ) {
			var ret, hooks, notxml,
				nType = elem.nodeType;
	
			// Don't get/set properties on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
	
			if ( notxml ) {
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}
	
			if ( value !== undefined ) {
				return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
					ret :
					( elem[ name ] = value );
	
			} else {
				return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
					ret :
					elem[ name ];
			}
		},
	
		propHooks: {
			tabIndex: {
				get: function( elem ) {
					return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
						elem.tabIndex :
						-1;
				}
			}
		}
	});
	
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			}
		};
	}
	
	jQuery.each([
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	});
	
	
	
	
	var rclass = /[\t\r\n\f]/g;
	
	jQuery.fn.extend({
		addClass: function( value ) {
			var classes, elem, cur, clazz, j, finalValue,
				proceed = typeof value === "string" && value,
				i = 0,
				len = this.length;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).addClass( value.call( this, j, this.className ) );
				});
			}
	
			if ( proceed ) {
				// The disjunction here is for better compressibility (see removeClass)
				classes = ( value || "" ).match( rnotwhite ) || [];
	
				for ( ; i < len; i++ ) {
					elem = this[ i ];
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						" "
					);
	
					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}
	
						// only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( elem.className !== finalValue ) {
							elem.className = finalValue;
						}
					}
				}
			}
	
			return this;
		},
	
		removeClass: function( value ) {
			var classes, elem, cur, clazz, j, finalValue,
				proceed = arguments.length === 0 || typeof value === "string" && value,
				i = 0,
				len = this.length;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).removeClass( value.call( this, j, this.className ) );
				});
			}
			if ( proceed ) {
				classes = ( value || "" ).match( rnotwhite ) || [];
	
				for ( ; i < len; i++ ) {
					elem = this[ i ];
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						""
					);
	
					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = value ? jQuery.trim( cur ) : "";
						if ( elem.className !== finalValue ) {
							elem.className = finalValue;
						}
					}
				}
			}
	
			return this;
		},
	
		toggleClass: function( value, stateVal ) {
			var type = typeof value;
	
			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}
	
			if ( jQuery.isFunction( value ) ) {
				return this.each(function( i ) {
					jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
				});
			}
	
			return this.each(function() {
				if ( type === "string" ) {
					// Toggle individual class names
					var className,
						i = 0,
						self = jQuery( this ),
						classNames = value.match( rnotwhite ) || [];
	
					while ( (className = classNames[ i++ ]) ) {
						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}
	
				// Toggle whole class name
				} else if ( type === strundefined || type === "boolean" ) {
					if ( this.className ) {
						// store className if set
						data_priv.set( this, "__className__", this.className );
					}
	
					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
				}
			});
		},
	
		hasClass: function( selector ) {
			var className = " " + selector + " ",
				i = 0,
				l = this.length;
			for ( ; i < l; i++ ) {
				if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
					return true;
				}
			}
	
			return false;
		}
	});
	
	
	
	
	var rreturn = /\r/g;
	
	jQuery.fn.extend({
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[0];
	
			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];
	
					if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
						return ret;
					}
	
					ret = elem.value;
	
					return typeof ret === "string" ?
						// Handle most common string cases
						ret.replace(rreturn, "") :
						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}
	
				return;
			}
	
			isFunction = jQuery.isFunction( value );
	
			return this.each(function( i ) {
				var val;
	
				if ( this.nodeType !== 1 ) {
					return;
				}
	
				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}
	
				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";
	
				} else if ( typeof val === "number" ) {
					val += "";
	
				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					});
				}
	
				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
	
				// If set returns undefined, fall back to normal setting
				if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			});
		}
	});
	
	jQuery.extend({
		valHooks: {
			option: {
				get: function( elem ) {
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
						// Support: IE10-11+
						// option.text throws exceptions (#14686, #14858)
						jQuery.trim( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;
	
					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];
	
						// IE6-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
								// Don't return options that are disabled or in a disabled optgroup
								( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
								( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
	
							// Get the specific value for the option
							value = jQuery( option ).val();
	
							// We don't need an array for one selects
							if ( one ) {
								return value;
							}
	
							// Multi-Selects return an array
							values.push( value );
						}
					}
	
					return values;
				},
	
				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;
	
					while ( i-- ) {
						option = options[ i ];
						if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
							optionSet = true;
						}
					}
	
					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	});
	
	// Radios and checkboxes getter/setter
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute("value") === null ? "on" : elem.value;
			};
		}
	});
	
	
	
	
	// Return jQuery for attributes-only inclusion
	
	
	jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {
	
		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	});
	
	jQuery.fn.extend({
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		},
	
		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},
	
		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
		}
	});
	
	
	var nonce = jQuery.now();
	
	var rquery = (/\?/);
	
	
	
	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function( data ) {
		return JSON.parse( data + "" );
	};
	
	
	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
	
		// Support: IE9
		try {
			tmp = new DOMParser();
			xml = tmp.parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}
	
		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};
	
	
	var
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
		rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
	
		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},
	
		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},
	
		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),
	
		// Document location
		ajaxLocation = window.location.href,
	
		// Segment location into parts
		ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
	
	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {
	
		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {
	
			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}
	
			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];
	
			if ( jQuery.isFunction( func ) ) {
				// For each dataType in the dataTypeExpression
				while ( (dataType = dataTypes[i++]) ) {
					// Prepend if requested
					if ( dataType[0] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						(structure[ dataType ] = structure[ dataType ] || []).unshift( func );
	
					// Otherwise append
					} else {
						(structure[ dataType ] = structure[ dataType ] || []).push( func );
					}
				}
			}
		};
	}
	
	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
	
		var inspected = {},
			seekingTransport = ( structure === transports );
	
		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			});
			return selected;
		}
	
		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}
	
	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};
	
		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}
	
		return target;
	}
	
	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {
	
		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;
	
		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}
	
		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}
	
		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}
	
		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}
	
	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();
	
		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}
	
		current = dataTypes.shift();
	
		// Convert to each sequential dataType
		while ( current ) {
	
			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}
	
			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}
	
			prev = current;
			current = dataTypes.shift();
	
			if ( current ) {
	
			// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {
	
					current = prev;
	
				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {
	
					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];
	
					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {
	
							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {
	
								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];
	
									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}
	
					// Apply converter (if not an equivalence)
					if ( conv !== true ) {
	
						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s[ "throws" ] ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
							}
						}
					}
				}
			}
		}
	
		return { state: "success", data: response };
	}
	
	jQuery.extend({
	
		// Counter for holding the number of active queries
		active: 0,
	
		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},
	
		ajaxSettings: {
			url: ajaxLocation,
			type: "GET",
			isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/
	
			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
	
			contents: {
				xml: /xml/,
				html: /html/,
				json: /json/
			},
	
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
	
			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {
	
				// Convert anything to text
				"* text": String,
	
				// Text to html (true = no transformation)
				"text html": true,
	
				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,
	
				// Parse text as xml
				"text xml": jQuery.parseXML
			},
	
			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},
	
		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?
	
				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
	
				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},
	
		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),
	
		// Main method
		ajax: function( url, options ) {
	
			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}
	
			// Force options to be an object
			options = options || {};
	
			var transport,
				// URL without anti-cache param
				cacheURL,
				// Response headers
				responseHeadersString,
				responseHeaders,
				// timeout handle
				timeoutTimer,
				// Cross-domain detection vars
				parts,
				// To know if global events are to be dispatched
				fireGlobals,
				// Loop variable
				i,
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
				// Callbacks context
				callbackContext = s.context || s,
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks("once memory"),
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
				// The jqXHR state
				state = 0,
				// Default abort message
				strAbort = "canceled",
				// Fake xhr
				jqXHR = {
					readyState: 0,
	
					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( (match = rheaders.exec( responseHeadersString )) ) {
									responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},
	
					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},
	
					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},
	
					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},
	
					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {
									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},
	
					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};
	
			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;
	
			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
				.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
	
			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;
	
			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];
	
			// A cross-domain request is in order when we have a protocol:host:port mismatch
			if ( s.crossDomain == null ) {
				parts = rurl.exec( s.url.toLowerCase() );
				s.crossDomain = !!( parts &&
					( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
						( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
							( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
				);
			}
	
			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}
	
			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
	
			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}
	
			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;
	
			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger("ajaxStart");
			}
	
			// Uppercase the type
			s.type = s.type.toUpperCase();
	
			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );
	
			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;
	
			// More options handling for requests with no content
			if ( !s.hasContent ) {
	
				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}
	
				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?
	
						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + nonce++ ) :
	
						// Otherwise add one to the end
						cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
				}
			}
	
			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}
	
			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}
	
			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
					s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);
	
			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}
	
			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already and return
				return jqXHR.abort();
			}
	
			// Aborting is no longer a cancellation
			strAbort = "abort";
	
			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}
	
			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
	
			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;
	
				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = setTimeout(function() {
						jqXHR.abort("timeout");
					}, s.timeout );
				}
	
				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {
					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );
					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}
	
			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;
	
				// Called once
				if ( state === 2 ) {
					return;
				}
	
				// State is "done" now
				state = 2;
	
				// Clear timeout if it exists
				if ( timeoutTimer ) {
					clearTimeout( timeoutTimer );
				}
	
				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;
	
				// Cache response headers
				responseHeadersString = headers || "";
	
				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;
	
				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;
	
				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}
	
				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );
	
				// If successful, handle type chaining
				if ( isSuccess ) {
	
					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}
	
					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";
	
					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";
	
					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}
	
				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";
	
				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}
	
				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;
	
				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}
	
				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
	
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}
	
			return jqXHR;
		},
	
		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},
	
		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	});
	
	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}
	
			return jQuery.ajax({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			});
		};
	});
	
	
	jQuery._evalUrl = function( url ) {
		return jQuery.ajax({
			url: url,
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	};
	
	
	jQuery.fn.extend({
		wrapAll: function( html ) {
			var wrap;
	
			if ( jQuery.isFunction( html ) ) {
				return this.each(function( i ) {
					jQuery( this ).wrapAll( html.call(this, i) );
				});
			}
	
			if ( this[ 0 ] ) {
	
				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
	
				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}
	
				wrap.map(function() {
					var elem = this;
	
					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}
	
					return elem;
				}).append( this );
			}
	
			return this;
		},
	
		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each(function( i ) {
					jQuery( this ).wrapInner( html.call(this, i) );
				});
			}
	
			return this.each(function() {
				var self = jQuery( this ),
					contents = self.contents();
	
				if ( contents.length ) {
					contents.wrapAll( html );
	
				} else {
					self.append( html );
				}
			});
		},
	
		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );
	
			return this.each(function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
			});
		},
	
		unwrap: function() {
			return this.parent().each(function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			}).end();
		}
	});
	
	
	jQuery.expr.filters.hidden = function( elem ) {
		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
	};
	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
	
	
	
	
	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;
	
	function buildParams( prefix, obj, traditional, add ) {
		var name;
	
		if ( jQuery.isArray( obj ) ) {
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
					// Treat each array item as a scalar.
					add( prefix, v );
	
				} else {
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
				}
			});
	
		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}
	
		} else {
			// Serialize scalar item.
			add( prefix, obj );
		}
	}
	
	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};
	
		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}
	
		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});
	
		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}
	
		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};
	
	jQuery.fn.extend({
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map(function() {
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			})
			.filter(function() {
				var type = this.type;
	
				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			})
			.map(function( i, elem ) {
				var val = jQuery( this ).val();
	
				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						}) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			}).get();
		}
	});
	
	
	jQuery.ajaxSettings.xhr = function() {
		try {
			return new XMLHttpRequest();
		} catch( e ) {}
	};
	
	var xhrId = 0,
		xhrCallbacks = {},
		xhrSuccessStatus = {
			// file protocol always yields status code 0, assume 200
			0: 200,
			// Support: IE9
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();
	
	// Support: IE9
	// Open requests must be manually aborted on unload (#5280)
	// See https://support.microsoft.com/kb/2856746 for more info
	if ( window.attachEvent ) {
		window.attachEvent( "onunload", function() {
			for ( var key in xhrCallbacks ) {
				xhrCallbacks[ key ]();
			}
		});
	}
	
	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;
	
	jQuery.ajaxTransport(function( options ) {
		var callback;
	
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr(),
						id = ++xhrId;
	
					xhr.open( options.type, options.url, options.async, options.username, options.password );
	
					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}
	
					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}
	
					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}
	
					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}
	
					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								delete xhrCallbacks[ id ];
								callback = xhr.onload = xhr.onerror = null;
	
								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {
									complete(
										// file: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,
										// Support: IE9
										// Accessing binary-data responseText throws an exception
										// (#11426)
										typeof xhr.responseText === "string" ? {
											text: xhr.responseText
										} : undefined,
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};
	
					// Listen to events
					xhr.onload = callback();
					xhr.onerror = callback("error");
	
					// Create the abort callback
					callback = xhrCallbacks[ id ] = callback("abort");
	
					try {
						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},
	
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	});
	
	
	
	
	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /(?:java|ecma)script/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	});
	
	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	});
	
	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery("<script>").prop({
						async: true,
						charset: s.scriptCharset,
						src: s.url
					}).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	});
	
	
	
	
	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;
	
	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	});
	
	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
	
		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
			);
	
		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
	
			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;
	
			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}
	
			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};
	
			// force json dataType
			s.dataTypes[ 0 ] = "json";
	
			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};
	
			// Clean-up function (fires after converters)
			jqXHR.always(function() {
				// Restore preexisting value
				window[ callbackName ] = overwritten;
	
				// Save back as free
				if ( s[ callbackName ] ) {
					// make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;
	
					// save the callback name for future use
					oldCallbacks.push( callbackName );
				}
	
				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}
	
				responseContainer = overwritten = undefined;
			});
	
			// Delegate to script
			return "script";
		}
	});
	
	
	
	
	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;
	
		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];
	
		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[1] ) ];
		}
	
		parsed = jQuery.buildFragment( [ data ], context, scripts );
	
		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}
	
		return jQuery.merge( [], parsed.childNodes );
	};
	
	
	// Keep a copy of the old load method
	var _load = jQuery.fn.load;
	
	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}
	
		var selector, type, response,
			self = this,
			off = url.indexOf(" ");
	
		if ( off >= 0 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}
	
		// If it's a function
		if ( jQuery.isFunction( params ) ) {
	
			// We assume that it's the callback
			callback = params;
			params = undefined;
	
		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}
	
		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax({
				url: url,
	
				// if "type" variable is undefined, then "GET" method will be used
				type: type,
				dataType: "html",
				data: params
			}).done(function( responseText ) {
	
				// Save response for use in complete callback
				response = arguments;
	
				self.html( selector ?
	
					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :
	
					// Otherwise use the full result
					responseText );
	
			}).complete( callback && function( jqXHR, status ) {
				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
			});
		}
	
		return this;
	};
	
	
	
	
	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	});
	
	
	
	
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
	
	
	
	
	var docElem = window.document.documentElement;
	
	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}
	
	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};
	
			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}
	
			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf("auto") > -1;
	
			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
	
			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}
	
			if ( jQuery.isFunction( options ) ) {
				options = options.call( elem, i, curOffset );
			}
	
			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}
	
			if ( "using" in options ) {
				options.using.call( elem, props );
	
			} else {
				curElem.css( props );
			}
		}
	};
	
	jQuery.fn.extend({
		offset: function( options ) {
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each(function( i ) {
						jQuery.offset.setOffset( this, options, i );
					});
			}
	
			var docElem, win,
				elem = this[ 0 ],
				box = { top: 0, left: 0 },
				doc = elem && elem.ownerDocument;
	
			if ( !doc ) {
				return;
			}
	
			docElem = doc.documentElement;
	
			// Make sure it's not a disconnected DOM node
			if ( !jQuery.contains( docElem, elem ) ) {
				return box;
			}
	
			// Support: BlackBerry 5, iOS 3 (original iPhone)
			// If we don't have gBCR, just use 0,0 rather than error
			if ( typeof elem.getBoundingClientRect !== strundefined ) {
				box = elem.getBoundingClientRect();
			}
			win = getWindow( doc );
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},
	
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}
	
			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };
	
			// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
	
			} else {
				// Get *real* offsetParent
				offsetParent = this.offsetParent();
	
				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}
	
				// Add offsetParent borders
				parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
			}
	
			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},
	
		offsetParent: function() {
			return this.map(function() {
				var offsetParent = this.offsetParent || docElem;
	
				while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
					offsetParent = offsetParent.offsetParent;
				}
	
				return offsetParent || docElem;
			});
		}
	});
	
	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;
	
		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );
	
				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}
	
				if ( win ) {
					win.scrollTo(
						!top ? val : window.pageXOffset,
						top ? val : window.pageYOffset
					);
	
				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length, null );
		};
	});
	
	// Support: Safari<7+, Chrome<37+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	});
	
	
	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
	
				return access( this, function( elem, type, value ) {
					var doc;
	
					if ( jQuery.isWindow( elem ) ) {
						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}
	
					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;
	
						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}
	
					return value === undefined ?
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :
	
						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		});
	});
	
	
	// The number of elements contained in the matched element set
	jQuery.fn.size = function() {
		return this.length;
	};
	
	jQuery.fn.andSelf = jQuery.fn.addBack;
	
	
	
	
	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	
	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
	
	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	
	
	
	
	var
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
	
		// Map over the $ in case of overwrite
		_$ = window.$;
	
	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}
	
		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}
	
		return jQuery;
	};
	
	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( typeof noGlobal === strundefined ) {
		window.jQuery = window.$ = jQuery;
	}
	
	
	
	
	return jQuery;
	
	}));


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {/* @preserve
	 * The MIT License (MIT)
	 * 
	 * Copyright (c) 2014 Petka Antonov
	 * 
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 * 
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 * 
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 * 
	 */
	/**
	 * bluebird build version 2.9.25
	 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, cancel, using, filter, any, each, timers
	*/
	!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var SomePromiseArray = Promise._SomePromiseArray;
	function any(promises) {
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(1);
	    ret.setUnwrap();
	    ret.init();
	    return promise;
	}
	
	Promise.any = function (promises) {
	    return any(promises);
	};
	
	Promise.prototype.any = function () {
	    return any(this);
	};
	
	};
	
	},{}],2:[function(_dereq_,module,exports){
	"use strict";
	var firstLineError;
	try {throw new Error(); } catch (e) {firstLineError = e;}
	var schedule = _dereq_("./schedule.js");
	var Queue = _dereq_("./queue.js");
	var util = _dereq_("./util.js");
	
	function Async() {
	    this._isTickUsed = false;
	    this._lateQueue = new Queue(16);
	    this._normalQueue = new Queue(16);
	    this._trampolineEnabled = true;
	    var self = this;
	    this.drainQueues = function () {
	        self._drainQueues();
	    };
	    this._schedule =
	        schedule.isStatic ? schedule(this.drainQueues) : schedule;
	}
	
	Async.prototype.disableTrampolineIfNecessary = function() {
	    if (util.hasDevTools) {
	        this._trampolineEnabled = false;
	    }
	};
	
	Async.prototype.enableTrampoline = function() {
	    if (!this._trampolineEnabled) {
	        this._trampolineEnabled = true;
	        this._schedule = function(fn) {
	            setTimeout(fn, 0);
	        };
	    }
	};
	
	Async.prototype.haveItemsQueued = function () {
	    return this._normalQueue.length() > 0;
	};
	
	Async.prototype.throwLater = function(fn, arg) {
	    if (arguments.length === 1) {
	        arg = fn;
	        fn = function () { throw arg; };
	    }
	    var domain = this._getDomain();
	    if (domain !== undefined) fn = domain.bind(fn);
	    if (typeof setTimeout !== "undefined") {
	        setTimeout(function() {
	            fn(arg);
	        }, 0);
	    } else try {
	        this._schedule(function() {
	            fn(arg);
	        });
	    } catch (e) {
	        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
	    }
	};
	
	Async.prototype._getDomain = function() {};
	
	if (false) {
	if (util.isNode) {
	    var EventsModule = _dereq_("events");
	
	    var domainGetter = function() {
	        var domain = process.domain;
	        if (domain === null) return undefined;
	        return domain;
	    };
	
	    if (EventsModule.usingDomains) {
	        Async.prototype._getDomain = domainGetter;
	    } else {
	        var descriptor =
	            Object.getOwnPropertyDescriptor(EventsModule, "usingDomains");
	
	        if (descriptor) {
	            if (!descriptor.configurable) {
	                process.on("domainsActivated", function() {
	                    Async.prototype._getDomain = domainGetter;
	                });
	            } else {
	                var usingDomains = false;
	                Object.defineProperty(EventsModule, "usingDomains", {
	                    configurable: false,
	                    enumerable: true,
	                    get: function() {
	                        return usingDomains;
	                    },
	                    set: function(value) {
	                        if (usingDomains || !value) return;
	                        usingDomains = true;
	                        Async.prototype._getDomain = domainGetter;
	                        util.toFastProperties(process);
	                        process.emit("domainsActivated");
	                    }
	                });
	            }
	        }
	    }
	}
	}
	
	function AsyncInvokeLater(fn, receiver, arg) {
	    var domain = this._getDomain();
	    if (domain !== undefined) fn = domain.bind(fn);
	    this._lateQueue.push(fn, receiver, arg);
	    this._queueTick();
	}
	
	function AsyncInvoke(fn, receiver, arg) {
	    var domain = this._getDomain();
	    if (domain !== undefined) fn = domain.bind(fn);
	    this._normalQueue.push(fn, receiver, arg);
	    this._queueTick();
	}
	
	function AsyncSettlePromises(promise) {
	    var domain = this._getDomain();
	    if (domain !== undefined) {
	        var fn = domain.bind(promise._settlePromises);
	        this._normalQueue.push(fn, promise, undefined);
	    } else {
	        this._normalQueue._pushOne(promise);
	    }
	    this._queueTick();
	}
	
	if (!util.hasDevTools) {
	    Async.prototype.invokeLater = AsyncInvokeLater;
	    Async.prototype.invoke = AsyncInvoke;
	    Async.prototype.settlePromises = AsyncSettlePromises;
	} else {
	    Async.prototype.invokeLater = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvokeLater.call(this, fn, receiver, arg);
	        } else {
	            setTimeout(function() {
	                fn.call(receiver, arg);
	            }, 100);
	        }
	    };
	
	    Async.prototype.invoke = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvoke.call(this, fn, receiver, arg);
	        } else {
	            setTimeout(function() {
	                fn.call(receiver, arg);
	            }, 0);
	        }
	    };
	
	    Async.prototype.settlePromises = function(promise) {
	        if (this._trampolineEnabled) {
	            AsyncSettlePromises.call(this, promise);
	        } else {
	            setTimeout(function() {
	                promise._settlePromises();
	            }, 0);
	        }
	    };
	}
	
	Async.prototype.invokeFirst = function (fn, receiver, arg) {
	    var domain = this._getDomain();
	    if (domain !== undefined) fn = domain.bind(fn);
	    this._normalQueue.unshift(fn, receiver, arg);
	    this._queueTick();
	};
	
	Async.prototype._drainQueue = function(queue) {
	    while (queue.length() > 0) {
	        var fn = queue.shift();
	        if (typeof fn !== "function") {
	            fn._settlePromises();
	            continue;
	        }
	        var receiver = queue.shift();
	        var arg = queue.shift();
	        fn.call(receiver, arg);
	    }
	};
	
	Async.prototype._drainQueues = function () {
	    this._drainQueue(this._normalQueue);
	    this._reset();
	    this._drainQueue(this._lateQueue);
	};
	
	Async.prototype._queueTick = function () {
	    if (!this._isTickUsed) {
	        this._isTickUsed = true;
	        this._schedule(this.drainQueues);
	    }
	};
	
	Async.prototype._reset = function () {
	    this._isTickUsed = false;
	};
	
	module.exports = new Async();
	module.exports.firstLineError = firstLineError;
	
	},{"./queue.js":28,"./schedule.js":31,"./util.js":38,"events":39}],3:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
	var rejectThis = function(_, e) {
	    this._reject(e);
	};
	
	var targetRejected = function(e, context) {
	    context.promiseRejectionQueued = true;
	    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
	};
	
	var bindingResolved = function(thisArg, context) {
	    this._setBoundTo(thisArg);
	    if (this._isPending()) {
	        this._resolveCallback(context.target);
	    }
	};
	
	var bindingRejected = function(e, context) {
	    if (!context.promiseRejectionQueued) this._reject(e);
	};
	
	Promise.prototype.bind = function (thisArg) {
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);
	    ret._propagateFrom(this, 1);
	    var target = this._target();
	    if (maybePromise instanceof Promise) {
	        var context = {
	            promiseRejectionQueued: false,
	            promise: ret,
	            target: target,
	            bindingPromise: maybePromise
	        };
	        target._then(INTERNAL, targetRejected, ret._progress, ret, context);
	        maybePromise._then(
	            bindingResolved, bindingRejected, ret._progress, ret, context);
	    } else {
	        ret._setBoundTo(thisArg);
	        ret._resolveCallback(target);
	    }
	    return ret;
	};
	
	Promise.prototype._setBoundTo = function (obj) {
	    if (obj !== undefined) {
	        this._bitField = this._bitField | 131072;
	        this._boundTo = obj;
	    } else {
	        this._bitField = this._bitField & (~131072);
	    }
	};
	
	Promise.prototype._isBound = function () {
	    return (this._bitField & 131072) === 131072;
	};
	
	Promise.bind = function (thisArg, value) {
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);
	
	    if (maybePromise instanceof Promise) {
	        maybePromise._then(function(thisArg) {
	            ret._setBoundTo(thisArg);
	            ret._resolveCallback(value);
	        }, ret._reject, ret._progress, ret, null);
	    } else {
	        ret._setBoundTo(thisArg);
	        ret._resolveCallback(value);
	    }
	    return ret;
	};
	};
	
	},{}],4:[function(_dereq_,module,exports){
	"use strict";
	var old;
	if (typeof Promise !== "undefined") old = Promise;
	function noConflict() {
	    try { if (Promise === bluebird) Promise = old; }
	    catch (e) {}
	    return bluebird;
	}
	var bluebird = _dereq_("./promise.js")();
	bluebird.noConflict = noConflict;
	module.exports = bluebird;
	
	},{"./promise.js":23}],5:[function(_dereq_,module,exports){
	"use strict";
	var cr = Object.create;
	if (cr) {
	    var callerCache = cr(null);
	    var getterCache = cr(null);
	    callerCache[" size"] = getterCache[" size"] = 0;
	}
	
	module.exports = function(Promise) {
	var util = _dereq_("./util.js");
	var canEvaluate = util.canEvaluate;
	var isIdentifier = util.isIdentifier;
	
	var getMethodCaller;
	var getGetter;
	if (false) {
	var makeMethodCaller = function (methodName) {
	    return new Function("ensureMethod", "                                    \n\
	        return function(obj) {                                               \n\
	            'use strict'                                                     \n\
	            var len = this.length;                                           \n\
	            ensureMethod(obj, 'methodName');                                 \n\
	            switch(len) {                                                    \n\
	                case 1: return obj.methodName(this[0]);                      \n\
	                case 2: return obj.methodName(this[0], this[1]);             \n\
	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
	                case 0: return obj.methodName();                             \n\
	                default:                                                     \n\
	                    return obj.methodName.apply(obj, this);                  \n\
	            }                                                                \n\
	        };                                                                   \n\
	        ".replace(/methodName/g, methodName))(ensureMethod);
	};
	
	var makeGetter = function (propertyName) {
	    return new Function("obj", "                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName", propertyName));
	};
	
	var getCompiled = function(name, compiler, cache) {
	    var ret = cache[name];
	    if (typeof ret !== "function") {
	        if (!isIdentifier(name)) {
	            return null;
	        }
	        ret = compiler(name);
	        cache[name] = ret;
	        cache[" size"]++;
	        if (cache[" size"] > 512) {
	            var keys = Object.keys(cache);
	            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
	            cache[" size"] = keys.length - 256;
	        }
	    }
	    return ret;
	};
	
	getMethodCaller = function(name) {
	    return getCompiled(name, makeMethodCaller, callerCache);
	};
	
	getGetter = function(name) {
	    return getCompiled(name, makeGetter, getterCache);
	};
	}
	
	function ensureMethod(obj, methodName) {
	    var fn;
	    if (obj != null) fn = obj[methodName];
	    if (typeof fn !== "function") {
	        var message = "Object " + util.classString(obj) + " has no method '" +
	            util.toString(methodName) + "'";
	        throw new Promise.TypeError(message);
	    }
	    return fn;
	}
	
	function caller(obj) {
	    var methodName = this.pop();
	    var fn = ensureMethod(obj, methodName);
	    return fn.apply(obj, this);
	}
	Promise.prototype.call = function (methodName) {
	    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	    if (false) {
	        if (canEvaluate) {
	            var maybeCaller = getMethodCaller(methodName);
	            if (maybeCaller !== null) {
	                return this._then(
	                    maybeCaller, undefined, undefined, args, undefined);
	            }
	        }
	    }
	    args.push(methodName);
	    return this._then(caller, undefined, undefined, args, undefined);
	};
	
	function namedGetter(obj) {
	    return obj[this];
	}
	function indexedGetter(obj) {
	    var index = +this;
	    if (index < 0) index = Math.max(0, index + obj.length);
	    return obj[index];
	}
	Promise.prototype.get = function (propertyName) {
	    var isIndex = (typeof propertyName === "number");
	    var getter;
	    if (!isIndex) {
	        if (canEvaluate) {
	            var maybeGetter = getGetter(propertyName);
	            getter = maybeGetter !== null ? maybeGetter : namedGetter;
	        } else {
	            getter = namedGetter;
	        }
	    } else {
	        getter = indexedGetter;
	    }
	    return this._then(getter, undefined, undefined, propertyName, undefined);
	};
	};
	
	},{"./util.js":38}],6:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var errors = _dereq_("./errors.js");
	var async = _dereq_("./async.js");
	var CancellationError = errors.CancellationError;
	
	Promise.prototype._cancel = function (reason) {
	    if (!this.isCancellable()) return this;
	    var parent;
	    var promiseToReject = this;
	    while ((parent = promiseToReject._cancellationParent) !== undefined &&
	        parent.isCancellable()) {
	        promiseToReject = parent;
	    }
	    this._unsetCancellable();
	    promiseToReject._target()._rejectCallback(reason, false, true);
	};
	
	Promise.prototype.cancel = function (reason) {
	    if (!this.isCancellable()) return this;
	    if (reason === undefined) reason = new CancellationError();
	    async.invokeLater(this._cancel, this, reason);
	    return this;
	};
	
	Promise.prototype.cancellable = function () {
	    if (this._cancellable()) return this;
	    async.enableTrampoline();
	    this._setCancellable();
	    this._cancellationParent = undefined;
	    return this;
	};
	
	Promise.prototype.uncancellable = function () {
	    var ret = this.then();
	    ret._unsetCancellable();
	    return ret;
	};
	
	Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
	    var ret = this._then(didFulfill, didReject, didProgress,
	                         undefined, undefined);
	
	    ret._setCancellable();
	    ret._cancellationParent = undefined;
	    return ret;
	};
	};
	
	},{"./async.js":2,"./errors.js":13}],7:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var bluebirdFramePattern =
	    /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
	var stackFramePattern = null;
	var formatStack = null;
	var indentStackFrames = false;
	var warn;
	
	function CapturedTrace(parent) {
	    this._parent = parent;
	    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
	    captureStackTrace(this, CapturedTrace);
	    if (length > 32) this.uncycle();
	}
	util.inherits(CapturedTrace, Error);
	
	CapturedTrace.prototype.uncycle = function() {
	    var length = this._length;
	    if (length < 2) return;
	    var nodes = [];
	    var stackToIndex = {};
	
	    for (var i = 0, node = this; node !== undefined; ++i) {
	        nodes.push(node);
	        node = node._parent;
	    }
	    length = this._length = i;
	    for (var i = length - 1; i >= 0; --i) {
	        var stack = nodes[i].stack;
	        if (stackToIndex[stack] === undefined) {
	            stackToIndex[stack] = i;
	        }
	    }
	    for (var i = 0; i < length; ++i) {
	        var currentStack = nodes[i].stack;
	        var index = stackToIndex[currentStack];
	        if (index !== undefined && index !== i) {
	            if (index > 0) {
	                nodes[index - 1]._parent = undefined;
	                nodes[index - 1]._length = 1;
	            }
	            nodes[i]._parent = undefined;
	            nodes[i]._length = 1;
	            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
	
	            if (index < length - 1) {
	                cycleEdgeNode._parent = nodes[index + 1];
	                cycleEdgeNode._parent.uncycle();
	                cycleEdgeNode._length =
	                    cycleEdgeNode._parent._length + 1;
	            } else {
	                cycleEdgeNode._parent = undefined;
	                cycleEdgeNode._length = 1;
	            }
	            var currentChildLength = cycleEdgeNode._length + 1;
	            for (var j = i - 2; j >= 0; --j) {
	                nodes[j]._length = currentChildLength;
	                currentChildLength++;
	            }
	            return;
	        }
	    }
	};
	
	CapturedTrace.prototype.parent = function() {
	    return this._parent;
	};
	
	CapturedTrace.prototype.hasParent = function() {
	    return this._parent !== undefined;
	};
	
	CapturedTrace.prototype.attachExtraTrace = function(error) {
	    if (error.__stackCleaned__) return;
	    this.uncycle();
	    var parsed = CapturedTrace.parseStackAndMessage(error);
	    var message = parsed.message;
	    var stacks = [parsed.stack];
	
	    var trace = this;
	    while (trace !== undefined) {
	        stacks.push(cleanStack(trace.stack.split("\n")));
	        trace = trace._parent;
	    }
	    removeCommonRoots(stacks);
	    removeDuplicateOrEmptyJumps(stacks);
	    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
	    util.notEnumerableProp(error, "__stackCleaned__", true);
	};
	
	function reconstructStack(message, stacks) {
	    for (var i = 0; i < stacks.length - 1; ++i) {
	        stacks[i].push("From previous event:");
	        stacks[i] = stacks[i].join("\n");
	    }
	    if (i < stacks.length) {
	        stacks[i] = stacks[i].join("\n");
	    }
	    return message + "\n" + stacks.join("\n");
	}
	
	function removeDuplicateOrEmptyJumps(stacks) {
	    for (var i = 0; i < stacks.length; ++i) {
	        if (stacks[i].length === 0 ||
	            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
	            stacks.splice(i, 1);
	            i--;
	        }
	    }
	}
	
	function removeCommonRoots(stacks) {
	    var current = stacks[0];
	    for (var i = 1; i < stacks.length; ++i) {
	        var prev = stacks[i];
	        var currentLastIndex = current.length - 1;
	        var currentLastLine = current[currentLastIndex];
	        var commonRootMeetPoint = -1;
	
	        for (var j = prev.length - 1; j >= 0; --j) {
	            if (prev[j] === currentLastLine) {
	                commonRootMeetPoint = j;
	                break;
	            }
	        }
	
	        for (var j = commonRootMeetPoint; j >= 0; --j) {
	            var line = prev[j];
	            if (current[currentLastIndex] === line) {
	                current.pop();
	                currentLastIndex--;
	            } else {
	                break;
	            }
	        }
	        current = prev;
	    }
	}
	
	function cleanStack(stack) {
	    var ret = [];
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        var isTraceLine = stackFramePattern.test(line) ||
	            "    (No stack trace)" === line;
	        var isInternalFrame = isTraceLine && shouldIgnore(line);
	        if (isTraceLine && !isInternalFrame) {
	            if (indentStackFrames && line.charAt(0) !== " ") {
	                line = "    " + line;
	            }
	            ret.push(line);
	        }
	    }
	    return ret;
	}
	
	function stackFramesAsArray(error) {
	    var stack = error.stack.replace(/\s+$/g, "").split("\n");
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
	            break;
	        }
	    }
	    if (i > 0) {
	        stack = stack.slice(i);
	    }
	    return stack;
	}
	
	CapturedTrace.parseStackAndMessage = function(error) {
	    var stack = error.stack;
	    var message = error.toString();
	    stack = typeof stack === "string" && stack.length > 0
	                ? stackFramesAsArray(error) : ["    (No stack trace)"];
	    return {
	        message: message,
	        stack: cleanStack(stack)
	    };
	};
	
	CapturedTrace.formatAndLogError = function(error, title) {
	    if (typeof console !== "undefined") {
	        var message;
	        if (typeof error === "object" || typeof error === "function") {
	            var stack = error.stack;
	            message = title + formatStack(stack, error);
	        } else {
	            message = title + String(error);
	        }
	        if (typeof warn === "function") {
	            warn(message);
	        } else if (typeof console.log === "function" ||
	            typeof console.log === "object") {
	            console.log(message);
	        }
	    }
	};
	
	CapturedTrace.unhandledRejection = function (reason) {
	    CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
	};
	
	CapturedTrace.isSupported = function () {
	    return typeof captureStackTrace === "function";
	};
	
	CapturedTrace.fireRejectionEvent =
	function(name, localHandler, reason, promise) {
	    var localEventFired = false;
	    try {
	        if (typeof localHandler === "function") {
	            localEventFired = true;
	            if (name === "rejectionHandled") {
	                localHandler(promise);
	            } else {
	                localHandler(reason, promise);
	            }
	        }
	    } catch (e) {
	        async.throwLater(e);
	    }
	
	    var globalEventFired = false;
	    try {
	        globalEventFired = fireGlobalEvent(name, reason, promise);
	    } catch (e) {
	        globalEventFired = true;
	        async.throwLater(e);
	    }
	
	    var domEventFired = false;
	    if (fireDomEvent) {
	        try {
	            domEventFired = fireDomEvent(name.toLowerCase(), {
	                reason: reason,
	                promise: promise
	            });
	        } catch (e) {
	            domEventFired = true;
	            async.throwLater(e);
	        }
	    }
	
	    if (!globalEventFired && !localEventFired && !domEventFired &&
	        name === "unhandledRejection") {
	        CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
	    }
	};
	
	function formatNonError(obj) {
	    var str;
	    if (typeof obj === "function") {
	        str = "[function " +
	            (obj.name || "anonymous") +
	            "]";
	    } else {
	        str = obj.toString();
	        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
	        if (ruselessToString.test(str)) {
	            try {
	                var newStr = JSON.stringify(obj);
	                str = newStr;
	            }
	            catch(e) {
	
	            }
	        }
	        if (str.length === 0) {
	            str = "(empty array)";
	        }
	    }
	    return ("(<" + snip(str) + ">, no stack trace)");
	}
	
	function snip(str) {
	    var maxChars = 41;
	    if (str.length < maxChars) {
	        return str;
	    }
	    return str.substr(0, maxChars - 3) + "...";
	}
	
	var shouldIgnore = function() { return false; };
	var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
	function parseLineInfo(line) {
	    var matches = line.match(parseLineInfoRegex);
	    if (matches) {
	        return {
	            fileName: matches[1],
	            line: parseInt(matches[2], 10)
	        };
	    }
	}
	CapturedTrace.setBounds = function(firstLineError, lastLineError) {
	    if (!CapturedTrace.isSupported()) return;
	    var firstStackLines = firstLineError.stack.split("\n");
	    var lastStackLines = lastLineError.stack.split("\n");
	    var firstIndex = -1;
	    var lastIndex = -1;
	    var firstFileName;
	    var lastFileName;
	    for (var i = 0; i < firstStackLines.length; ++i) {
	        var result = parseLineInfo(firstStackLines[i]);
	        if (result) {
	            firstFileName = result.fileName;
	            firstIndex = result.line;
	            break;
	        }
	    }
	    for (var i = 0; i < lastStackLines.length; ++i) {
	        var result = parseLineInfo(lastStackLines[i]);
	        if (result) {
	            lastFileName = result.fileName;
	            lastIndex = result.line;
	            break;
	        }
	    }
	    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
	        firstFileName !== lastFileName || firstIndex >= lastIndex) {
	        return;
	    }
	
	    shouldIgnore = function(line) {
	        if (bluebirdFramePattern.test(line)) return true;
	        var info = parseLineInfo(line);
	        if (info) {
	            if (info.fileName === firstFileName &&
	                (firstIndex <= info.line && info.line <= lastIndex)) {
	                return true;
	            }
	        }
	        return false;
	    };
	};
	
	var captureStackTrace = (function stackDetection() {
	    var v8stackFramePattern = /^\s*at\s*/;
	    var v8stackFormatter = function(stack, error) {
	        if (typeof stack === "string") return stack;
	
	        if (error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };
	
	    if (typeof Error.stackTraceLimit === "number" &&
	        typeof Error.captureStackTrace === "function") {
	        Error.stackTraceLimit = Error.stackTraceLimit + 6;
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        var captureStackTrace = Error.captureStackTrace;
	
	        shouldIgnore = function(line) {
	            return bluebirdFramePattern.test(line);
	        };
	        return function(receiver, ignoreUntil) {
	            Error.stackTraceLimit = Error.stackTraceLimit + 6;
	            captureStackTrace(receiver, ignoreUntil);
	            Error.stackTraceLimit = Error.stackTraceLimit - 6;
	        };
	    }
	    var err = new Error();
	
	    if (typeof err.stack === "string" &&
	        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
	        stackFramePattern = /@/;
	        formatStack = v8stackFormatter;
	        indentStackFrames = true;
	        return function captureStackTrace(o) {
	            o.stack = new Error().stack;
	        };
	    }
	
	    var hasStackAfterThrow;
	    try { throw new Error(); }
	    catch(e) {
	        hasStackAfterThrow = ("stack" in e);
	    }
	    if (!("stack" in err) && hasStackAfterThrow) {
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        return function captureStackTrace(o) {
	            Error.stackTraceLimit = Error.stackTraceLimit + 6;
	            try { throw new Error(); }
	            catch(e) { o.stack = e.stack; }
	            Error.stackTraceLimit = Error.stackTraceLimit - 6;
	        };
	    }
	
	    formatStack = function(stack, error) {
	        if (typeof stack === "string") return stack;
	
	        if ((typeof error === "object" ||
	            typeof error === "function") &&
	            error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };
	
	    return null;
	
	})([]);
	
	var fireDomEvent;
	var fireGlobalEvent = (function() {
	    if (util.isNode) {
	        return function(name, reason, promise) {
	            if (name === "rejectionHandled") {
	                return process.emit(name, promise);
	            } else {
	                return process.emit(name, reason, promise);
	            }
	        };
	    } else {
	        var customEventWorks = false;
	        var anyEventWorks = true;
	        try {
	            var ev = new self.CustomEvent("test");
	            customEventWorks = ev instanceof CustomEvent;
	        } catch (e) {}
	        if (!customEventWorks) {
	            try {
	                var event = document.createEvent("CustomEvent");
	                event.initCustomEvent("testingtheevent", false, true, {});
	                self.dispatchEvent(event);
	            } catch (e) {
	                anyEventWorks = false;
	            }
	        }
	        if (anyEventWorks) {
	            fireDomEvent = function(type, detail) {
	                var event;
	                if (customEventWorks) {
	                    event = new self.CustomEvent(type, {
	                        detail: detail,
	                        bubbles: false,
	                        cancelable: true
	                    });
	                } else if (self.dispatchEvent) {
	                    event = document.createEvent("CustomEvent");
	                    event.initCustomEvent(type, false, true, detail);
	                }
	
	                return event ? !self.dispatchEvent(event) : false;
	            };
	        }
	
	        var toWindowMethodNameMap = {};
	        toWindowMethodNameMap["unhandledRejection"] = ("on" +
	            "unhandledRejection").toLowerCase();
	        toWindowMethodNameMap["rejectionHandled"] = ("on" +
	            "rejectionHandled").toLowerCase();
	
	        return function(name, reason, promise) {
	            var methodName = toWindowMethodNameMap[name];
	            var method = self[methodName];
	            if (!method) return false;
	            if (name === "rejectionHandled") {
	                method.call(self, promise);
	            } else {
	                method.call(self, reason, promise);
	            }
	            return true;
	        };
	    }
	})();
	
	if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
	    warn = function (message) {
	        console.warn(message);
	    };
	    if (util.isNode && process.stderr.isTTY) {
	        warn = function(message) {
	            process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
	        };
	    } else if (!util.isNode && typeof (new Error().stack) === "string") {
	        warn = function(message) {
	            console.warn("%c" + message, "color: red");
	        };
	    }
	}
	
	return CapturedTrace;
	};
	
	},{"./async.js":2,"./util.js":38}],8:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(NEXT_FILTER) {
	var util = _dereq_("./util.js");
	var errors = _dereq_("./errors.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var keys = _dereq_("./es5.js").keys;
	var TypeError = errors.TypeError;
	
	function CatchFilter(instances, callback, promise) {
	    this._instances = instances;
	    this._callback = callback;
	    this._promise = promise;
	}
	
	function safePredicate(predicate, e) {
	    var safeObject = {};
	    var retfilter = tryCatch(predicate).call(safeObject, e);
	
	    if (retfilter === errorObj) return retfilter;
	
	    var safeKeys = keys(safeObject);
	    if (safeKeys.length) {
	        errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
	        return errorObj;
	    }
	    return retfilter;
	}
	
	CatchFilter.prototype.doFilter = function (e) {
	    var cb = this._callback;
	    var promise = this._promise;
	    var boundTo = promise._boundTo;
	    for (var i = 0, len = this._instances.length; i < len; ++i) {
	        var item = this._instances[i];
	        var itemIsErrorType = item === Error ||
	            (item != null && item.prototype instanceof Error);
	
	        if (itemIsErrorType && e instanceof item) {
	            var ret = tryCatch(cb).call(boundTo, e);
	            if (ret === errorObj) {
	                NEXT_FILTER.e = ret.e;
	                return NEXT_FILTER;
	            }
	            return ret;
	        } else if (typeof item === "function" && !itemIsErrorType) {
	            var shouldHandle = safePredicate(item, e);
	            if (shouldHandle === errorObj) {
	                e = errorObj.e;
	                break;
	            } else if (shouldHandle) {
	                var ret = tryCatch(cb).call(boundTo, e);
	                if (ret === errorObj) {
	                    NEXT_FILTER.e = ret.e;
	                    return NEXT_FILTER;
	                }
	                return ret;
	            }
	        }
	    }
	    NEXT_FILTER.e = e;
	    return NEXT_FILTER;
	};
	
	return CatchFilter;
	};
	
	},{"./errors.js":13,"./es5.js":14,"./util.js":38}],9:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, CapturedTrace, isDebugging) {
	var contextStack = [];
	function Context() {
	    this._trace = new CapturedTrace(peekContext());
	}
	Context.prototype._pushContext = function () {
	    if (!isDebugging()) return;
	    if (this._trace !== undefined) {
	        contextStack.push(this._trace);
	    }
	};
	
	Context.prototype._popContext = function () {
	    if (!isDebugging()) return;
	    if (this._trace !== undefined) {
	        contextStack.pop();
	    }
	};
	
	function createContext() {
	    if (isDebugging()) return new Context();
	}
	
	function peekContext() {
	    var lastIndex = contextStack.length - 1;
	    if (lastIndex >= 0) {
	        return contextStack[lastIndex];
	    }
	    return undefined;
	}
	
	Promise.prototype._peekContext = peekContext;
	Promise.prototype._pushContext = Context.prototype._pushContext;
	Promise.prototype._popContext = Context.prototype._popContext;
	
	return createContext;
	};
	
	},{}],10:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, CapturedTrace) {
	var async = _dereq_("./async.js");
	var Warning = _dereq_("./errors.js").Warning;
	var util = _dereq_("./util.js");
	var canAttachTrace = util.canAttachTrace;
	var unhandledRejectionHandled;
	var possiblyUnhandledRejection;
	var debugging = false || (util.isNode &&
	                    (!!process.env["BLUEBIRD_DEBUG"] ||
	                     process.env["NODE_ENV"] === "development"));
	
	if (debugging) {
	    async.disableTrampolineIfNecessary();
	}
	
	Promise.prototype._ensurePossibleRejectionHandled = function () {
	    this._setRejectionIsUnhandled();
	    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
	};
	
	Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
	    CapturedTrace.fireRejectionEvent("rejectionHandled",
	                                  unhandledRejectionHandled, undefined, this);
	};
	
	Promise.prototype._notifyUnhandledRejection = function () {
	    if (this._isRejectionUnhandled()) {
	        var reason = this._getCarriedStackTrace() || this._settledValue;
	        this._setUnhandledRejectionIsNotified();
	        CapturedTrace.fireRejectionEvent("unhandledRejection",
	                                      possiblyUnhandledRejection, reason, this);
	    }
	};
	
	Promise.prototype._setUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField | 524288;
	};
	
	Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField & (~524288);
	};
	
	Promise.prototype._isUnhandledRejectionNotified = function () {
	    return (this._bitField & 524288) > 0;
	};
	
	Promise.prototype._setRejectionIsUnhandled = function () {
	    this._bitField = this._bitField | 2097152;
	};
	
	Promise.prototype._unsetRejectionIsUnhandled = function () {
	    this._bitField = this._bitField & (~2097152);
	    if (this._isUnhandledRejectionNotified()) {
	        this._unsetUnhandledRejectionIsNotified();
	        this._notifyUnhandledRejectionIsHandled();
	    }
	};
	
	Promise.prototype._isRejectionUnhandled = function () {
	    return (this._bitField & 2097152) > 0;
	};
	
	Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
	    this._bitField = this._bitField | 1048576;
	    this._fulfillmentHandler0 = capturedTrace;
	};
	
	Promise.prototype._isCarryingStackTrace = function () {
	    return (this._bitField & 1048576) > 0;
	};
	
	Promise.prototype._getCarriedStackTrace = function () {
	    return this._isCarryingStackTrace()
	        ? this._fulfillmentHandler0
	        : undefined;
	};
	
	Promise.prototype._captureStackTrace = function () {
	    if (debugging) {
	        this._trace = new CapturedTrace(this._peekContext());
	    }
	    return this;
	};
	
	Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
	    if (debugging && canAttachTrace(error)) {
	        var trace = this._trace;
	        if (trace !== undefined) {
	            if (ignoreSelf) trace = trace._parent;
	        }
	        if (trace !== undefined) {
	            trace.attachExtraTrace(error);
	        } else if (!error.__stackCleaned__) {
	            var parsed = CapturedTrace.parseStackAndMessage(error);
	            util.notEnumerableProp(error, "stack",
	                parsed.message + "\n" + parsed.stack.join("\n"));
	            util.notEnumerableProp(error, "__stackCleaned__", true);
	        }
	    }
	};
	
	Promise.prototype._warn = function(message) {
	    var warning = new Warning(message);
	    var ctx = this._peekContext();
	    if (ctx) {
	        ctx.attachExtraTrace(warning);
	    } else {
	        var parsed = CapturedTrace.parseStackAndMessage(warning);
	        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
	    }
	    CapturedTrace.formatAndLogError(warning, "");
	};
	
	Promise.onPossiblyUnhandledRejection = function (fn) {
	    possiblyUnhandledRejection = typeof fn === "function" ? fn : undefined;
	};
	
	Promise.onUnhandledRejectionHandled = function (fn) {
	    unhandledRejectionHandled = typeof fn === "function" ? fn : undefined;
	};
	
	Promise.longStackTraces = function () {
	    if (async.haveItemsQueued() &&
	        debugging === false
	   ) {
	        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
	    }
	    debugging = CapturedTrace.isSupported();
	    if (debugging) {
	        async.disableTrampolineIfNecessary();
	    }
	};
	
	Promise.hasLongStackTraces = function () {
	    return debugging && CapturedTrace.isSupported();
	};
	
	if (!CapturedTrace.isSupported()) {
	    Promise.longStackTraces = function(){};
	    debugging = false;
	}
	
	return function() {
	    return debugging;
	};
	};
	
	},{"./async.js":2,"./errors.js":13,"./util.js":38}],11:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util.js");
	var isPrimitive = util.isPrimitive;
	var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
	
	module.exports = function(Promise) {
	var returner = function () {
	    return this;
	};
	var thrower = function () {
	    throw this;
	};
	
	var wrapper = function (value, action) {
	    if (action === 1) {
	        return function () {
	            throw value;
	        };
	    } else if (action === 2) {
	        return function () {
	            return value;
	        };
	    }
	};
	
	
	Promise.prototype["return"] =
	Promise.prototype.thenReturn = function (value) {
	    if (wrapsPrimitiveReceiver && isPrimitive(value)) {
	        return this._then(
	            wrapper(value, 2),
	            undefined,
	            undefined,
	            undefined,
	            undefined
	       );
	    }
	    return this._then(returner, undefined, undefined, value, undefined);
	};
	
	Promise.prototype["throw"] =
	Promise.prototype.thenThrow = function (reason) {
	    if (wrapsPrimitiveReceiver && isPrimitive(reason)) {
	        return this._then(
	            wrapper(reason, 1),
	            undefined,
	            undefined,
	            undefined,
	            undefined
	       );
	    }
	    return this._then(thrower, undefined, undefined, reason, undefined);
	};
	};
	
	},{"./util.js":38}],12:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseReduce = Promise.reduce;
	
	Promise.prototype.each = function (fn) {
	    return PromiseReduce(this, fn, null, INTERNAL);
	};
	
	Promise.each = function (promises, fn) {
	    return PromiseReduce(promises, fn, null, INTERNAL);
	};
	};
	
	},{}],13:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5.js");
	var Objectfreeze = es5.freeze;
	var util = _dereq_("./util.js");
	var inherits = util.inherits;
	var notEnumerableProp = util.notEnumerableProp;
	
	function subError(nameProperty, defaultMessage) {
	    function SubError(message) {
	        if (!(this instanceof SubError)) return new SubError(message);
	        notEnumerableProp(this, "message",
	            typeof message === "string" ? message : defaultMessage);
	        notEnumerableProp(this, "name", nameProperty);
	        if (Error.captureStackTrace) {
	            Error.captureStackTrace(this, this.constructor);
	        } else {
	            Error.call(this);
	        }
	    }
	    inherits(SubError, Error);
	    return SubError;
	}
	
	var _TypeError, _RangeError;
	var Warning = subError("Warning", "warning");
	var CancellationError = subError("CancellationError", "cancellation error");
	var TimeoutError = subError("TimeoutError", "timeout error");
	var AggregateError = subError("AggregateError", "aggregate error");
	try {
	    _TypeError = TypeError;
	    _RangeError = RangeError;
	} catch(e) {
	    _TypeError = subError("TypeError", "type error");
	    _RangeError = subError("RangeError", "range error");
	}
	
	var methods = ("join pop push shift unshift slice filter forEach some " +
	    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
	
	for (var i = 0; i < methods.length; ++i) {
	    if (typeof Array.prototype[methods[i]] === "function") {
	        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
	    }
	}
	
	es5.defineProperty(AggregateError.prototype, "length", {
	    value: 0,
	    configurable: false,
	    writable: true,
	    enumerable: true
	});
	AggregateError.prototype["isOperational"] = true;
	var level = 0;
	AggregateError.prototype.toString = function() {
	    var indent = Array(level * 4 + 1).join(" ");
	    var ret = "\n" + indent + "AggregateError of:" + "\n";
	    level++;
	    indent = Array(level * 4 + 1).join(" ");
	    for (var i = 0; i < this.length; ++i) {
	        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
	        var lines = str.split("\n");
	        for (var j = 0; j < lines.length; ++j) {
	            lines[j] = indent + lines[j];
	        }
	        str = lines.join("\n");
	        ret += str + "\n";
	    }
	    level--;
	    return ret;
	};
	
	function OperationalError(message) {
	    if (!(this instanceof OperationalError))
	        return new OperationalError(message);
	    notEnumerableProp(this, "name", "OperationalError");
	    notEnumerableProp(this, "message", message);
	    this.cause = message;
	    this["isOperational"] = true;
	
	    if (message instanceof Error) {
	        notEnumerableProp(this, "message", message.message);
	        notEnumerableProp(this, "stack", message.stack);
	    } else if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, this.constructor);
	    }
	
	}
	inherits(OperationalError, Error);
	
	var errorTypes = Error["__BluebirdErrorTypes__"];
	if (!errorTypes) {
	    errorTypes = Objectfreeze({
	        CancellationError: CancellationError,
	        TimeoutError: TimeoutError,
	        OperationalError: OperationalError,
	        RejectionError: OperationalError,
	        AggregateError: AggregateError
	    });
	    notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
	}
	
	module.exports = {
	    Error: Error,
	    TypeError: _TypeError,
	    RangeError: _RangeError,
	    CancellationError: errorTypes.CancellationError,
	    OperationalError: errorTypes.OperationalError,
	    TimeoutError: errorTypes.TimeoutError,
	    AggregateError: errorTypes.AggregateError,
	    Warning: Warning
	};
	
	},{"./es5.js":14,"./util.js":38}],14:[function(_dereq_,module,exports){
	var isES5 = (function(){
	    "use strict";
	    return this === undefined;
	})();
	
	if (isES5) {
	    module.exports = {
	        freeze: Object.freeze,
	        defineProperty: Object.defineProperty,
	        getDescriptor: Object.getOwnPropertyDescriptor,
	        keys: Object.keys,
	        names: Object.getOwnPropertyNames,
	        getPrototypeOf: Object.getPrototypeOf,
	        isArray: Array.isArray,
	        isES5: isES5,
	        propertyIsWritable: function(obj, prop) {
	            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	            return !!(!descriptor || descriptor.writable || descriptor.set);
	        }
	    };
	} else {
	    var has = {}.hasOwnProperty;
	    var str = {}.toString;
	    var proto = {}.constructor.prototype;
	
	    var ObjectKeys = function (o) {
	        var ret = [];
	        for (var key in o) {
	            if (has.call(o, key)) {
	                ret.push(key);
	            }
	        }
	        return ret;
	    };
	
	    var ObjectGetDescriptor = function(o, key) {
	        return {value: o[key]};
	    };
	
	    var ObjectDefineProperty = function (o, key, desc) {
	        o[key] = desc.value;
	        return o;
	    };
	
	    var ObjectFreeze = function (obj) {
	        return obj;
	    };
	
	    var ObjectGetPrototypeOf = function (obj) {
	        try {
	            return Object(obj).constructor.prototype;
	        }
	        catch (e) {
	            return proto;
	        }
	    };
	
	    var ArrayIsArray = function (obj) {
	        try {
	            return str.call(obj) === "[object Array]";
	        }
	        catch(e) {
	            return false;
	        }
	    };
	
	    module.exports = {
	        isArray: ArrayIsArray,
	        keys: ObjectKeys,
	        names: ObjectKeys,
	        defineProperty: ObjectDefineProperty,
	        getDescriptor: ObjectGetDescriptor,
	        freeze: ObjectFreeze,
	        getPrototypeOf: ObjectGetPrototypeOf,
	        isES5: isES5,
	        propertyIsWritable: function() {
	            return true;
	        }
	    };
	}
	
	},{}],15:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseMap = Promise.map;
	
	Promise.prototype.filter = function (fn, options) {
	    return PromiseMap(this, fn, options, INTERNAL);
	};
	
	Promise.filter = function (promises, fn, options) {
	    return PromiseMap(promises, fn, options, INTERNAL);
	};
	};
	
	},{}],16:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
	var util = _dereq_("./util.js");
	var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
	var isPrimitive = util.isPrimitive;
	var thrower = util.thrower;
	
	function returnThis() {
	    return this;
	}
	function throwThis() {
	    throw this;
	}
	function return$(r) {
	    return function() {
	        return r;
	    };
	}
	function throw$(r) {
	    return function() {
	        throw r;
	    };
	}
	function promisedFinally(ret, reasonOrValue, isFulfilled) {
	    var then;
	    if (wrapsPrimitiveReceiver && isPrimitive(reasonOrValue)) {
	        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
	    } else {
	        then = isFulfilled ? returnThis : throwThis;
	    }
	    return ret._then(then, thrower, undefined, reasonOrValue, undefined);
	}
	
	function finallyHandler(reasonOrValue) {
	    var promise = this.promise;
	    var handler = this.handler;
	
	    var ret = promise._isBound()
	                    ? handler.call(promise._boundTo)
	                    : handler();
	
	    if (ret !== undefined) {
	        var maybePromise = tryConvertToPromise(ret, promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            return promisedFinally(maybePromise, reasonOrValue,
	                                    promise.isFulfilled());
	        }
	    }
	
	    if (promise.isRejected()) {
	        NEXT_FILTER.e = reasonOrValue;
	        return NEXT_FILTER;
	    } else {
	        return reasonOrValue;
	    }
	}
	
	function tapHandler(value) {
	    var promise = this.promise;
	    var handler = this.handler;
	
	    var ret = promise._isBound()
	                    ? handler.call(promise._boundTo, value)
	                    : handler(value);
	
	    if (ret !== undefined) {
	        var maybePromise = tryConvertToPromise(ret, promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            return promisedFinally(maybePromise, value, true);
	        }
	    }
	    return value;
	}
	
	Promise.prototype._passThroughHandler = function (handler, isFinally) {
	    if (typeof handler !== "function") return this.then();
	
	    var promiseAndHandler = {
	        promise: this,
	        handler: handler
	    };
	
	    return this._then(
	            isFinally ? finallyHandler : tapHandler,
	            isFinally ? finallyHandler : undefined, undefined,
	            promiseAndHandler, undefined);
	};
	
	Promise.prototype.lastly =
	Promise.prototype["finally"] = function (handler) {
	    return this._passThroughHandler(handler, true);
	};
	
	Promise.prototype.tap = function (handler) {
	    return this._passThroughHandler(handler, false);
	};
	};
	
	},{"./util.js":38}],17:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          apiRejection,
	                          INTERNAL,
	                          tryConvertToPromise) {
	var errors = _dereq_("./errors.js");
	var TypeError = errors.TypeError;
	var util = _dereq_("./util.js");
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	var yieldHandlers = [];
	
	function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
	    for (var i = 0; i < yieldHandlers.length; ++i) {
	        traceParent._pushContext();
	        var result = tryCatch(yieldHandlers[i])(value);
	        traceParent._popContext();
	        if (result === errorObj) {
	            traceParent._pushContext();
	            var ret = Promise.reject(errorObj.e);
	            traceParent._popContext();
	            return ret;
	        }
	        var maybePromise = tryConvertToPromise(result, traceParent);
	        if (maybePromise instanceof Promise) return maybePromise;
	    }
	    return null;
	}
	
	function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
	    var promise = this._promise = new Promise(INTERNAL);
	    promise._captureStackTrace();
	    this._stack = stack;
	    this._generatorFunction = generatorFunction;
	    this._receiver = receiver;
	    this._generator = undefined;
	    this._yieldHandlers = typeof yieldHandler === "function"
	        ? [yieldHandler].concat(yieldHandlers)
	        : yieldHandlers;
	}
	
	PromiseSpawn.prototype.promise = function () {
	    return this._promise;
	};
	
	PromiseSpawn.prototype._run = function () {
	    this._generator = this._generatorFunction.call(this._receiver);
	    this._receiver =
	        this._generatorFunction = undefined;
	    this._next(undefined);
	};
	
	PromiseSpawn.prototype._continue = function (result) {
	    if (result === errorObj) {
	        return this._promise._rejectCallback(result.e, false, true);
	    }
	
	    var value = result.value;
	    if (result.done === true) {
	        this._promise._resolveCallback(value);
	    } else {
	        var maybePromise = tryConvertToPromise(value, this._promise);
	        if (!(maybePromise instanceof Promise)) {
	            maybePromise =
	                promiseFromYieldHandler(maybePromise,
	                                        this._yieldHandlers,
	                                        this._promise);
	            if (maybePromise === null) {
	                this._throw(
	                    new TypeError(
	                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) +
	                        "From coroutine:\u000a" +
	                        this._stack.split("\n").slice(1, -7).join("\n")
	                    )
	                );
	                return;
	            }
	        }
	        maybePromise._then(
	            this._next,
	            this._throw,
	            undefined,
	            this,
	            null
	       );
	    }
	};
	
	PromiseSpawn.prototype._throw = function (reason) {
	    this._promise._attachExtraTrace(reason);
	    this._promise._pushContext();
	    var result = tryCatch(this._generator["throw"])
	        .call(this._generator, reason);
	    this._promise._popContext();
	    this._continue(result);
	};
	
	PromiseSpawn.prototype._next = function (value) {
	    this._promise._pushContext();
	    var result = tryCatch(this._generator.next).call(this._generator, value);
	    this._promise._popContext();
	    this._continue(result);
	};
	
	Promise.coroutine = function (generatorFunction, options) {
	    if (typeof generatorFunction !== "function") {
	        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
	    }
	    var yieldHandler = Object(options).yieldHandler;
	    var PromiseSpawn$ = PromiseSpawn;
	    var stack = new Error().stack;
	    return function () {
	        var generator = generatorFunction.apply(this, arguments);
	        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
	                                      stack);
	        spawn._generator = generator;
	        spawn._next(undefined);
	        return spawn.promise();
	    };
	};
	
	Promise.coroutine.addYieldHandler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    yieldHandlers.push(fn);
	};
	
	Promise.spawn = function (generatorFunction) {
	    if (typeof generatorFunction !== "function") {
	        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
	    }
	    var spawn = new PromiseSpawn(generatorFunction, this);
	    var ret = spawn.promise();
	    spawn._run(Promise.spawn);
	    return ret;
	};
	};
	
	},{"./errors.js":13,"./util.js":38}],18:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
	var util = _dereq_("./util.js");
	var canEvaluate = util.canEvaluate;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var reject;
	
	if (false) {
	if (canEvaluate) {
	    var thenCallback = function(i) {
	        return new Function("value", "holder", "                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g, i));
	    };
	
	    var caller = function(count) {
	        var values = [];
	        for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
	        return new Function("holder", "                                      \n\
	            'use strict';                                                    \n\
	            var callback = holder.fn;                                        \n\
	            return callback(values);                                         \n\
	            ".replace(/values/g, values.join(", ")));
	    };
	    var thenCallbacks = [];
	    var callers = [undefined];
	    for (var i = 1; i <= 5; ++i) {
	        thenCallbacks.push(thenCallback(i));
	        callers.push(caller(i));
	    }
	
	    var Holder = function(total, fn) {
	        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
	        this.fn = fn;
	        this.total = total;
	        this.now = 0;
	    };
	
	    Holder.prototype.callers = callers;
	    Holder.prototype.checkFulfillment = function(promise) {
	        var now = this.now;
	        now++;
	        var total = this.total;
	        if (now >= total) {
	            var handler = this.callers[total];
	            promise._pushContext();
	            var ret = tryCatch(handler)(this);
	            promise._popContext();
	            if (ret === errorObj) {
	                promise._rejectCallback(ret.e, false, true);
	            } else {
	                promise._resolveCallback(ret);
	            }
	        } else {
	            this.now = now;
	        }
	    };
	
	    var reject = function (reason) {
	        this._reject(reason);
	    };
	}
	}
	
	Promise.join = function () {
	    var last = arguments.length - 1;
	    var fn;
	    if (last > 0 && typeof arguments[last] === "function") {
	        fn = arguments[last];
	        if (false) {
	            if (last < 6 && canEvaluate) {
	                var ret = new Promise(INTERNAL);
	                ret._captureStackTrace();
	                var holder = new Holder(last, fn);
	                var callbacks = thenCallbacks;
	                for (var i = 0; i < last; ++i) {
	                    var maybePromise = tryConvertToPromise(arguments[i], ret);
	                    if (maybePromise instanceof Promise) {
	                        maybePromise = maybePromise._target();
	                        if (maybePromise._isPending()) {
	                            maybePromise._then(callbacks[i], reject,
	                                               undefined, ret, holder);
	                        } else if (maybePromise._isFulfilled()) {
	                            callbacks[i].call(ret,
	                                              maybePromise._value(), holder);
	                        } else {
	                            ret._reject(maybePromise._reason());
	                        }
	                    } else {
	                        callbacks[i].call(ret, maybePromise, holder);
	                    }
	                }
	                return ret;
	            }
	        }
	    }
	    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
	    if (fn) args.pop();
	    var ret = new PromiseArray(args).promise();
	    return fn !== undefined ? ret.spread(fn) : ret;
	};
	
	};
	
	},{"./util.js":38}],19:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL) {
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var PENDING = {};
	var EMPTY_ARRAY = [];
	
	function MappingPromiseArray(promises, fn, limit, _filter) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    this._callback = fn;
	    this._preservedValues = _filter === INTERNAL
	        ? new Array(this.length())
	        : null;
	    this._limit = limit;
	    this._inFlight = 0;
	    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
	    async.invoke(init, this, undefined);
	}
	util.inherits(MappingPromiseArray, PromiseArray);
	function init() {this._init$(undefined, -2);}
	
	MappingPromiseArray.prototype._init = function () {};
	
	MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var limit = this._limit;
	    if (values[index] === PENDING) {
	        values[index] = value;
	        if (limit >= 1) {
	            this._inFlight--;
	            this._drainQueue();
	            if (this._isResolved()) return;
	        }
	    } else {
	        if (limit >= 1 && this._inFlight >= limit) {
	            values[index] = value;
	            this._queue.push(index);
	            return;
	        }
	        if (preservedValues !== null) preservedValues[index] = value;
	
	        var callback = this._callback;
	        var receiver = this._promise._boundTo;
	        this._promise._pushContext();
	        var ret = tryCatch(callback).call(receiver, value, index, length);
	        this._promise._popContext();
	        if (ret === errorObj) return this._reject(ret.e);
	
	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (maybePromise._isPending()) {
	                if (limit >= 1) this._inFlight++;
	                values[index] = PENDING;
	                return maybePromise._proxyPromiseArray(this, index);
	            } else if (maybePromise._isFulfilled()) {
	                ret = maybePromise._value();
	            } else {
	                return this._reject(maybePromise._reason());
	            }
	        }
	        values[index] = ret;
	    }
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= length) {
	        if (preservedValues !== null) {
	            this._filter(values, preservedValues);
	        } else {
	            this._resolve(values);
	        }
	
	    }
	};
	
	MappingPromiseArray.prototype._drainQueue = function () {
	    var queue = this._queue;
	    var limit = this._limit;
	    var values = this._values;
	    while (queue.length > 0 && this._inFlight < limit) {
	        if (this._isResolved()) return;
	        var index = queue.pop();
	        this._promiseFulfilled(values[index], index);
	    }
	};
	
	MappingPromiseArray.prototype._filter = function (booleans, values) {
	    var len = values.length;
	    var ret = new Array(len);
	    var j = 0;
	    for (var i = 0; i < len; ++i) {
	        if (booleans[i]) ret[j++] = values[i];
	    }
	    ret.length = j;
	    this._resolve(ret);
	};
	
	MappingPromiseArray.prototype.preservedValues = function () {
	    return this._preservedValues;
	};
	
	function map(promises, fn, options, _filter) {
	    var limit = typeof options === "object" && options !== null
	        ? options.concurrency
	        : 0;
	    limit = typeof limit === "number" &&
	        isFinite(limit) && limit >= 1 ? limit : 0;
	    return new MappingPromiseArray(promises, fn, limit, _filter);
	}
	
	Promise.prototype.map = function (fn, options) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	
	    return map(this, fn, options, null).promise();
	};
	
	Promise.map = function (promises, fn, options, _filter) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    return map(promises, fn, options, _filter).promise();
	};
	
	
	};
	
	},{"./async.js":2,"./util.js":38}],20:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	
	Promise.method = function (fn) {
	    if (typeof fn !== "function") {
	        throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    return function () {
	        var ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._pushContext();
	        var value = tryCatch(fn).apply(this, arguments);
	        ret._popContext();
	        ret._resolveFromSyncValue(value);
	        return ret;
	    };
	};
	
	Promise.attempt = Promise["try"] = function (fn, args, ctx) {
	    if (typeof fn !== "function") {
	        return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._pushContext();
	    var value = util.isArray(args)
	        ? tryCatch(fn).apply(ctx, args)
	        : tryCatch(fn).call(ctx, args);
	    ret._popContext();
	    ret._resolveFromSyncValue(value);
	    return ret;
	};
	
	Promise.prototype._resolveFromSyncValue = function (value) {
	    if (value === util.errorObj) {
	        this._rejectCallback(value.e, false, true);
	    } else {
	        this._resolveCallback(value, true);
	    }
	};
	};
	
	},{"./util.js":38}],21:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	
	function spreadAdapter(val, nodeback) {
	    var promise = this;
	    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
	    var ret = tryCatch(nodeback).apply(promise._boundTo, [null].concat(val));
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	
	function successAdapter(val, nodeback) {
	    var promise = this;
	    var receiver = promise._boundTo;
	    var ret = val === undefined
	        ? tryCatch(nodeback).call(receiver, null)
	        : tryCatch(nodeback).call(receiver, null, val);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	function errorAdapter(reason, nodeback) {
	    var promise = this;
	    if (!reason) {
	        var target = promise._target();
	        var newReason = target._getCarriedStackTrace();
	        newReason.cause = reason;
	        reason = newReason;
	    }
	    var ret = tryCatch(nodeback).call(promise._boundTo, reason);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	
	Promise.prototype.asCallback = 
	Promise.prototype.nodeify = function (nodeback, options) {
	    if (typeof nodeback == "function") {
	        var adapter = successAdapter;
	        if (options !== undefined && Object(options).spread) {
	            adapter = spreadAdapter;
	        }
	        this._then(
	            adapter,
	            errorAdapter,
	            undefined,
	            this,
	            nodeback
	        );
	    }
	    return this;
	};
	};
	
	},{"./async.js":2,"./util.js":38}],22:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, PromiseArray) {
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	
	Promise.prototype.progressed = function (handler) {
	    return this._then(undefined, undefined, handler, undefined, undefined);
	};
	
	Promise.prototype._progress = function (progressValue) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._target()._progressUnchecked(progressValue);
	
	};
	
	Promise.prototype._progressHandlerAt = function (index) {
	    return index === 0
	        ? this._progressHandler0
	        : this[(index << 2) + index - 5 + 2];
	};
	
	Promise.prototype._doProgressWith = function (progression) {
	    var progressValue = progression.value;
	    var handler = progression.handler;
	    var promise = progression.promise;
	    var receiver = progression.receiver;
	
	    var ret = tryCatch(handler).call(receiver, progressValue);
	    if (ret === errorObj) {
	        if (ret.e != null &&
	            ret.e.name !== "StopProgressPropagation") {
	            var trace = util.canAttachTrace(ret.e)
	                ? ret.e : new Error(util.toString(ret.e));
	            promise._attachExtraTrace(trace);
	            promise._progress(ret.e);
	        }
	    } else if (ret instanceof Promise) {
	        ret._then(promise._progress, null, null, promise, undefined);
	    } else {
	        promise._progress(ret);
	    }
	};
	
	
	Promise.prototype._progressUnchecked = function (progressValue) {
	    var len = this._length();
	    var progress = this._progress;
	    for (var i = 0; i < len; i++) {
	        var handler = this._progressHandlerAt(i);
	        var promise = this._promiseAt(i);
	        if (!(promise instanceof Promise)) {
	            var receiver = this._receiverAt(i);
	            if (typeof handler === "function") {
	                handler.call(receiver, progressValue, promise);
	            } else if (receiver instanceof PromiseArray &&
	                       !receiver._isResolved()) {
	                receiver._promiseProgressed(progressValue, promise);
	            }
	            continue;
	        }
	
	        if (typeof handler === "function") {
	            async.invoke(this._doProgressWith, this, {
	                handler: handler,
	                promise: promise,
	                receiver: this._receiverAt(i),
	                value: progressValue
	            });
	        } else {
	            async.invoke(progress, promise, progressValue);
	        }
	    }
	};
	};
	
	},{"./async.js":2,"./util.js":38}],23:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var makeSelfResolutionError = function () {
	    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
	};
	var reflect = function() {
	    return new Promise.PromiseInspection(this._target());
	};
	var apiRejection = function(msg) {
	    return Promise.reject(new TypeError(msg));
	};
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var errors = _dereq_("./errors.js");
	var TypeError = Promise.TypeError = errors.TypeError;
	Promise.RangeError = errors.RangeError;
	Promise.CancellationError = errors.CancellationError;
	Promise.TimeoutError = errors.TimeoutError;
	Promise.OperationalError = errors.OperationalError;
	Promise.RejectionError = errors.OperationalError;
	Promise.AggregateError = errors.AggregateError;
	var INTERNAL = function(){};
	var APPLY = {};
	var NEXT_FILTER = {e: null};
	var tryConvertToPromise = _dereq_("./thenables.js")(Promise, INTERNAL);
	var PromiseArray =
	    _dereq_("./promise_array.js")(Promise, INTERNAL,
	                                    tryConvertToPromise, apiRejection);
	var CapturedTrace = _dereq_("./captured_trace.js")();
	var isDebugging = _dereq_("./debuggability.js")(Promise, CapturedTrace);
	 /*jshint unused:false*/
	var createContext =
	    _dereq_("./context.js")(Promise, CapturedTrace, isDebugging);
	var CatchFilter = _dereq_("./catch_filter.js")(NEXT_FILTER);
	var PromiseResolver = _dereq_("./promise_resolver.js");
	var nodebackForPromise = PromiseResolver._nodebackForPromise;
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	function Promise(resolver) {
	    if (typeof resolver !== "function") {
	        throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
	    }
	    if (this.constructor !== Promise) {
	        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
	    }
	    this._bitField = 0;
	    this._fulfillmentHandler0 = undefined;
	    this._rejectionHandler0 = undefined;
	    this._progressHandler0 = undefined;
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    this._settledValue = undefined;
	    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
	}
	
	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};
	
	Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
	    var len = arguments.length;
	    if (len > 1) {
	        var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (typeof item === "function") {
	                catchInstances[j++] = item;
	            } else {
	                return Promise.reject(
	                    new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
	            }
	        }
	        catchInstances.length = j;
	        fn = arguments[i];
	        var catchFilter = new CatchFilter(catchInstances, fn, this);
	        return this._then(undefined, catchFilter.doFilter, undefined,
	            catchFilter, undefined);
	    }
	    return this._then(undefined, fn, undefined, undefined, undefined);
	};
	
	Promise.prototype.reflect = function () {
	    return this._then(reflect, reflect, undefined, this, undefined);
	};
	
	Promise.prototype.then = function (didFulfill, didReject, didProgress) {
	    if (isDebugging() && arguments.length > 0 &&
	        typeof didFulfill !== "function" &&
	        typeof didReject !== "function") {
	        var msg = ".then() only accepts functions but was passed: " +
	                util.classString(didFulfill);
	        if (arguments.length > 1) {
	            msg += ", " + util.classString(didReject);
	        }
	        this._warn(msg);
	    }
	    return this._then(didFulfill, didReject, didProgress,
	        undefined, undefined);
	};
	
	Promise.prototype.done = function (didFulfill, didReject, didProgress) {
	    var promise = this._then(didFulfill, didReject, didProgress,
	        undefined, undefined);
	    promise._setIsFinal();
	};
	
	Promise.prototype.spread = function (didFulfill, didReject) {
	    return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
	};
	
	Promise.prototype.isCancellable = function () {
	    return !this.isResolved() &&
	        this._cancellable();
	};
	
	Promise.prototype.toJSON = function () {
	    var ret = {
	        isFulfilled: false,
	        isRejected: false,
	        fulfillmentValue: undefined,
	        rejectionReason: undefined
	    };
	    if (this.isFulfilled()) {
	        ret.fulfillmentValue = this.value();
	        ret.isFulfilled = true;
	    } else if (this.isRejected()) {
	        ret.rejectionReason = this.reason();
	        ret.isRejected = true;
	    }
	    return ret;
	};
	
	Promise.prototype.all = function () {
	    return new PromiseArray(this).promise();
	};
	
	Promise.prototype.error = function (fn) {
	    return this.caught(util.originatesFromRejection, fn);
	};
	
	Promise.is = function (val) {
	    return val instanceof Promise;
	};
	
	Promise.fromNode = function(fn) {
	    var ret = new Promise(INTERNAL);
	    var result = tryCatch(fn)(nodebackForPromise(ret));
	    if (result === errorObj) {
	        ret._rejectCallback(result.e, true, true);
	    }
	    return ret;
	};
	
	Promise.all = function (promises) {
	    return new PromiseArray(promises).promise();
	};
	
	Promise.defer = Promise.pending = function () {
	    var promise = new Promise(INTERNAL);
	    return new PromiseResolver(promise);
	};
	
	Promise.cast = function (obj) {
	    var ret = tryConvertToPromise(obj);
	    if (!(ret instanceof Promise)) {
	        var val = ret;
	        ret = new Promise(INTERNAL);
	        ret._fulfillUnchecked(val);
	    }
	    return ret;
	};
	
	Promise.resolve = Promise.fulfilled = Promise.cast;
	
	Promise.reject = Promise.rejected = function (reason) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._rejectCallback(reason, true);
	    return ret;
	};
	
	Promise.setScheduler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    var prev = async._schedule;
	    async._schedule = fn;
	    return prev;
	};
	
	Promise.prototype._then = function (
	    didFulfill,
	    didReject,
	    didProgress,
	    receiver,
	    internalData
	) {
	    var haveInternalData = internalData !== undefined;
	    var ret = haveInternalData ? internalData : new Promise(INTERNAL);
	
	    if (!haveInternalData) {
	        ret._propagateFrom(this, 4 | 1);
	        ret._captureStackTrace();
	    }
	
	    var target = this._target();
	    if (target !== this) {
	        if (receiver === undefined) receiver = this._boundTo;
	        if (!haveInternalData) ret._setIsMigrated();
	    }
	
	    var callbackIndex =
	        target._addCallbacks(didFulfill, didReject, didProgress, ret, receiver);
	
	    if (target._isResolved() && !target._isSettlePromisesQueued()) {
	        async.invoke(
	            target._settlePromiseAtPostResolution, target, callbackIndex);
	    }
	
	    return ret;
	};
	
	Promise.prototype._settlePromiseAtPostResolution = function (index) {
	    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
	    this._settlePromiseAt(index);
	};
	
	Promise.prototype._length = function () {
	    return this._bitField & 131071;
	};
	
	Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
	    return (this._bitField & 939524096) > 0;
	};
	
	Promise.prototype._isFollowing = function () {
	    return (this._bitField & 536870912) === 536870912;
	};
	
	Promise.prototype._setLength = function (len) {
	    this._bitField = (this._bitField & -131072) |
	        (len & 131071);
	};
	
	Promise.prototype._setFulfilled = function () {
	    this._bitField = this._bitField | 268435456;
	};
	
	Promise.prototype._setRejected = function () {
	    this._bitField = this._bitField | 134217728;
	};
	
	Promise.prototype._setFollowing = function () {
	    this._bitField = this._bitField | 536870912;
	};
	
	Promise.prototype._setIsFinal = function () {
	    this._bitField = this._bitField | 33554432;
	};
	
	Promise.prototype._isFinal = function () {
	    return (this._bitField & 33554432) > 0;
	};
	
	Promise.prototype._cancellable = function () {
	    return (this._bitField & 67108864) > 0;
	};
	
	Promise.prototype._setCancellable = function () {
	    this._bitField = this._bitField | 67108864;
	};
	
	Promise.prototype._unsetCancellable = function () {
	    this._bitField = this._bitField & (~67108864);
	};
	
	Promise.prototype._setIsMigrated = function () {
	    this._bitField = this._bitField | 4194304;
	};
	
	Promise.prototype._unsetIsMigrated = function () {
	    this._bitField = this._bitField & (~4194304);
	};
	
	Promise.prototype._isMigrated = function () {
	    return (this._bitField & 4194304) > 0;
	};
	
	Promise.prototype._receiverAt = function (index) {
	    var ret = index === 0
	        ? this._receiver0
	        : this[
	            index * 5 - 5 + 4];
	    if (ret === undefined && this._isBound()) {
	        return this._boundTo;
	    }
	    return ret;
	};
	
	Promise.prototype._promiseAt = function (index) {
	    return index === 0
	        ? this._promise0
	        : this[index * 5 - 5 + 3];
	};
	
	Promise.prototype._fulfillmentHandlerAt = function (index) {
	    return index === 0
	        ? this._fulfillmentHandler0
	        : this[index * 5 - 5 + 0];
	};
	
	Promise.prototype._rejectionHandlerAt = function (index) {
	    return index === 0
	        ? this._rejectionHandler0
	        : this[index * 5 - 5 + 1];
	};
	
	Promise.prototype._migrateCallbacks = function (follower, index) {
	    var fulfill = follower._fulfillmentHandlerAt(index);
	    var reject = follower._rejectionHandlerAt(index);
	    var progress = follower._progressHandlerAt(index);
	    var promise = follower._promiseAt(index);
	    var receiver = follower._receiverAt(index);
	    if (promise instanceof Promise) promise._setIsMigrated();
	    this._addCallbacks(fulfill, reject, progress, promise, receiver);
	};
	
	Promise.prototype._addCallbacks = function (
	    fulfill,
	    reject,
	    progress,
	    promise,
	    receiver
	) {
	    var index = this._length();
	
	    if (index >= 131071 - 5) {
	        index = 0;
	        this._setLength(0);
	    }
	
	    if (index === 0) {
	        this._promise0 = promise;
	        if (receiver !== undefined) this._receiver0 = receiver;
	        if (typeof fulfill === "function" && !this._isCarryingStackTrace())
	            this._fulfillmentHandler0 = fulfill;
	        if (typeof reject === "function") this._rejectionHandler0 = reject;
	        if (typeof progress === "function") this._progressHandler0 = progress;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] = promise;
	        this[base + 4] = receiver;
	        if (typeof fulfill === "function")
	            this[base + 0] = fulfill;
	        if (typeof reject === "function")
	            this[base + 1] = reject;
	        if (typeof progress === "function")
	            this[base + 2] = progress;
	    }
	    this._setLength(index + 1);
	    return index;
	};
	
	Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
	    var index = this._length();
	
	    if (index >= 131071 - 5) {
	        index = 0;
	        this._setLength(0);
	    }
	    if (index === 0) {
	        this._promise0 = promiseSlotValue;
	        this._receiver0 = receiver;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] = promiseSlotValue;
	        this[base + 4] = receiver;
	    }
	    this._setLength(index + 1);
	};
	
	Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
	    this._setProxyHandlers(promiseArray, index);
	};
	
	Promise.prototype._resolveCallback = function(value, shouldBind) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    if (value === this)
	        return this._rejectCallback(makeSelfResolutionError(), false, true);
	    var maybePromise = tryConvertToPromise(value, this);
	    if (!(maybePromise instanceof Promise)) return this._fulfill(value);
	
	    var propagationFlags = 1 | (shouldBind ? 4 : 0);
	    this._propagateFrom(maybePromise, propagationFlags);
	    var promise = maybePromise._target();
	    if (promise._isPending()) {
	        var len = this._length();
	        for (var i = 0; i < len; ++i) {
	            promise._migrateCallbacks(this, i);
	        }
	        this._setFollowing();
	        this._setLength(0);
	        this._setFollowee(promise);
	    } else if (promise._isFulfilled()) {
	        this._fulfillUnchecked(promise._value());
	    } else {
	        this._rejectUnchecked(promise._reason(),
	            promise._getCarriedStackTrace());
	    }
	};
	
	Promise.prototype._rejectCallback =
	function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
	    if (!shouldNotMarkOriginatingFromRejection) {
	        util.markAsOriginatingFromRejection(reason);
	    }
	    var trace = util.ensureErrorObject(reason);
	    var hasStack = trace === reason;
	    this._attachExtraTrace(trace, synchronous ? hasStack : false);
	    this._reject(reason, hasStack ? undefined : trace);
	};
	
	Promise.prototype._resolveFromResolver = function (resolver) {
	    var promise = this;
	    this._captureStackTrace();
	    this._pushContext();
	    var synchronous = true;
	    var r = tryCatch(resolver)(function(value) {
	        if (promise === null) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }, function (reason) {
	        if (promise === null) return;
	        promise._rejectCallback(reason, synchronous);
	        promise = null;
	    });
	    synchronous = false;
	    this._popContext();
	
	    if (r !== undefined && r === errorObj && promise !== null) {
	        promise._rejectCallback(r.e, true, true);
	        promise = null;
	    }
	};
	
	Promise.prototype._settlePromiseFromHandler = function (
	    handler, receiver, value, promise
	) {
	    if (promise._isRejected()) return;
	    promise._pushContext();
	    var x;
	    if (receiver === APPLY && !this._isRejected()) {
	        x = tryCatch(handler).apply(this._boundTo, value);
	    } else {
	        x = tryCatch(handler).call(receiver, value);
	    }
	    promise._popContext();
	
	    if (x === errorObj || x === promise || x === NEXT_FILTER) {
	        var err = x === promise ? makeSelfResolutionError() : x.e;
	        promise._rejectCallback(err, false, true);
	    } else {
	        promise._resolveCallback(x);
	    }
	};
	
	Promise.prototype._target = function() {
	    var ret = this;
	    while (ret._isFollowing()) ret = ret._followee();
	    return ret;
	};
	
	Promise.prototype._followee = function() {
	    return this._rejectionHandler0;
	};
	
	Promise.prototype._setFollowee = function(promise) {
	    this._rejectionHandler0 = promise;
	};
	
	Promise.prototype._cleanValues = function () {
	    if (this._cancellable()) {
	        this._cancellationParent = undefined;
	    }
	};
	
	Promise.prototype._propagateFrom = function (parent, flags) {
	    if ((flags & 1) > 0 && parent._cancellable()) {
	        this._setCancellable();
	        this._cancellationParent = parent;
	    }
	    if ((flags & 4) > 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	};
	
	Promise.prototype._fulfill = function (value) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._fulfillUnchecked(value);
	};
	
	Promise.prototype._reject = function (reason, carriedStackTrace) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._rejectUnchecked(reason, carriedStackTrace);
	};
	
	Promise.prototype._settlePromiseAt = function (index) {
	    var promise = this._promiseAt(index);
	    var isPromise = promise instanceof Promise;
	
	    if (isPromise && promise._isMigrated()) {
	        promise._unsetIsMigrated();
	        return async.invoke(this._settlePromiseAt, this, index);
	    }
	    var handler = this._isFulfilled()
	        ? this._fulfillmentHandlerAt(index)
	        : this._rejectionHandlerAt(index);
	
	    var carriedStackTrace =
	        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
	    var value = this._settledValue;
	    var receiver = this._receiverAt(index);
	
	
	    this._clearCallbackDataAtIndex(index);
	
	    if (typeof handler === "function") {
	        if (!isPromise) {
	            handler.call(receiver, value, promise);
	        } else {
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (receiver instanceof PromiseArray) {
	        if (!receiver._isResolved()) {
	            if (this._isFulfilled()) {
	                receiver._promiseFulfilled(value, promise);
	            }
	            else {
	                receiver._promiseRejected(value, promise);
	            }
	        }
	    } else if (isPromise) {
	        if (this._isFulfilled()) {
	            promise._fulfill(value);
	        } else {
	            promise._reject(value, carriedStackTrace);
	        }
	    }
	
	    if (index >= 4 && (index & 31) === 4)
	        async.invokeLater(this._setLength, this, 0);
	};
	
	Promise.prototype._clearCallbackDataAtIndex = function(index) {
	    if (index === 0) {
	        if (!this._isCarryingStackTrace()) {
	            this._fulfillmentHandler0 = undefined;
	        }
	        this._rejectionHandler0 =
	        this._progressHandler0 =
	        this._receiver0 =
	        this._promise0 = undefined;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] =
	        this[base + 4] =
	        this[base + 0] =
	        this[base + 1] =
	        this[base + 2] = undefined;
	    }
	};
	
	Promise.prototype._isSettlePromisesQueued = function () {
	    return (this._bitField &
	            -1073741824) === -1073741824;
	};
	
	Promise.prototype._setSettlePromisesQueued = function () {
	    this._bitField = this._bitField | -1073741824;
	};
	
	Promise.prototype._unsetSettlePromisesQueued = function () {
	    this._bitField = this._bitField & (~-1073741824);
	};
	
	Promise.prototype._queueSettlePromises = function() {
	    async.settlePromises(this);
	    this._setSettlePromisesQueued();
	};
	
	Promise.prototype._fulfillUnchecked = function (value) {
	    if (value === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err, undefined);
	    }
	    this._setFulfilled();
	    this._settledValue = value;
	    this._cleanValues();
	
	    if (this._length() > 0) {
	        this._queueSettlePromises();
	    }
	};
	
	Promise.prototype._rejectUncheckedCheckError = function (reason) {
	    var trace = util.ensureErrorObject(reason);
	    this._rejectUnchecked(reason, trace === reason ? undefined : trace);
	};
	
	Promise.prototype._rejectUnchecked = function (reason, trace) {
	    if (reason === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err);
	    }
	    this._setRejected();
	    this._settledValue = reason;
	    this._cleanValues();
	
	    if (this._isFinal()) {
	        async.throwLater(function(e) {
	            if ("stack" in e) {
	                async.invokeFirst(
	                    CapturedTrace.unhandledRejection, undefined, e);
	            }
	            throw e;
	        }, trace === undefined ? reason : trace);
	        return;
	    }
	
	    if (trace !== undefined && trace !== reason) {
	        this._setCarriedStackTrace(trace);
	    }
	
	    if (this._length() > 0) {
	        this._queueSettlePromises();
	    } else {
	        this._ensurePossibleRejectionHandled();
	    }
	};
	
	Promise.prototype._settlePromises = function () {
	    this._unsetSettlePromisesQueued();
	    var len = this._length();
	    for (var i = 0; i < len; i++) {
	        this._settlePromiseAt(i);
	    }
	};
	
	Promise._makeSelfResolutionError = makeSelfResolutionError;
	_dereq_("./progress.js")(Promise, PromiseArray);
	_dereq_("./method.js")(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_("./bind.js")(Promise, INTERNAL, tryConvertToPromise);
	_dereq_("./finally.js")(Promise, NEXT_FILTER, tryConvertToPromise);
	_dereq_("./direct_resolve.js")(Promise);
	_dereq_("./synchronous_inspection.js")(Promise);
	_dereq_("./join.js")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
	Promise.Promise = Promise;
	_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
	_dereq_('./cancel.js')(Promise);
	_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
	_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
	_dereq_('./nodeify.js')(Promise);
	_dereq_('./call_get.js')(Promise);
	_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
	_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
	_dereq_('./settle.js')(Promise, PromiseArray);
	_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
	_dereq_('./promisify.js')(Promise, INTERNAL);
	_dereq_('./any.js')(Promise);
	_dereq_('./each.js')(Promise, INTERNAL);
	_dereq_('./timers.js')(Promise, INTERNAL);
	_dereq_('./filter.js')(Promise, INTERNAL);
	                                                         
	    util.toFastProperties(Promise);                                          
	    util.toFastProperties(Promise.prototype);                                
	    function fillTypes(value) {                                              
	        var p = new Promise(INTERNAL);                                       
	        p._fulfillmentHandler0 = value;                                      
	        p._rejectionHandler0 = value;                                        
	        p._progressHandler0 = value;                                         
	        p._promise0 = value;                                                 
	        p._receiver0 = value;                                                
	        p._settledValue = value;                                             
	    }                                                                        
	    // Complete slack tracking, opt out of field-type tracking and           
	    // stabilize map                                                         
	    fillTypes({a: 1});                                                       
	    fillTypes({b: 2});                                                       
	    fillTypes({c: 3});                                                       
	    fillTypes(1);                                                            
	    fillTypes(function(){});                                                 
	    fillTypes(undefined);                                                    
	    fillTypes(false);                                                        
	    fillTypes(new Promise(INTERNAL));                                        
	    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       
	    return Promise;                                                          
	
	};
	
	},{"./any.js":1,"./async.js":2,"./bind.js":3,"./call_get.js":5,"./cancel.js":6,"./captured_trace.js":7,"./catch_filter.js":8,"./context.js":9,"./debuggability.js":10,"./direct_resolve.js":11,"./each.js":12,"./errors.js":13,"./filter.js":15,"./finally.js":16,"./generators.js":17,"./join.js":18,"./map.js":19,"./method.js":20,"./nodeify.js":21,"./progress.js":22,"./promise_array.js":24,"./promise_resolver.js":25,"./promisify.js":26,"./props.js":27,"./race.js":29,"./reduce.js":30,"./settle.js":32,"./some.js":33,"./synchronous_inspection.js":34,"./thenables.js":35,"./timers.js":36,"./using.js":37,"./util.js":38}],24:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise,
	    apiRejection) {
	var util = _dereq_("./util.js");
	var isArray = util.isArray;
	
	function toResolutionValue(val) {
	    switch(val) {
	    case -2: return [];
	    case -3: return {};
	    }
	}
	
	function PromiseArray(values) {
	    var promise = this._promise = new Promise(INTERNAL);
	    var parent;
	    if (values instanceof Promise) {
	        parent = values;
	        promise._propagateFrom(parent, 1 | 4);
	    }
	    this._values = values;
	    this._length = 0;
	    this._totalResolved = 0;
	    this._init(undefined, -2);
	}
	PromiseArray.prototype.length = function () {
	    return this._length;
	};
	
	PromiseArray.prototype.promise = function () {
	    return this._promise;
	};
	
	PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
	    var values = tryConvertToPromise(this._values, this._promise);
	    if (values instanceof Promise) {
	        values = values._target();
	        this._values = values;
	        if (values._isFulfilled()) {
	            values = values._value();
	            if (!isArray(values)) {
	                var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
	                this.__hardReject__(err);
	                return;
	            }
	        } else if (values._isPending()) {
	            values._then(
	                init,
	                this._reject,
	                undefined,
	                this,
	                resolveValueIfEmpty
	           );
	            return;
	        } else {
	            this._reject(values._reason());
	            return;
	        }
	    } else if (!isArray(values)) {
	        this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
	        return;
	    }
	
	    if (values.length === 0) {
	        if (resolveValueIfEmpty === -5) {
	            this._resolveEmptyArray();
	        }
	        else {
	            this._resolve(toResolutionValue(resolveValueIfEmpty));
	        }
	        return;
	    }
	    var len = this.getActualLength(values.length);
	    this._length = len;
	    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
	    var promise = this._promise;
	    for (var i = 0; i < len; ++i) {
	        var isResolved = this._isResolved();
	        var maybePromise = tryConvertToPromise(values[i], promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (isResolved) {
	                maybePromise._unsetRejectionIsUnhandled();
	            } else if (maybePromise._isPending()) {
	                maybePromise._proxyPromiseArray(this, i);
	            } else if (maybePromise._isFulfilled()) {
	                this._promiseFulfilled(maybePromise._value(), i);
	            } else {
	                this._promiseRejected(maybePromise._reason(), i);
	            }
	        } else if (!isResolved) {
	            this._promiseFulfilled(maybePromise, i);
	        }
	    }
	};
	
	PromiseArray.prototype._isResolved = function () {
	    return this._values === null;
	};
	
	PromiseArray.prototype._resolve = function (value) {
	    this._values = null;
	    this._promise._fulfill(value);
	};
	
	PromiseArray.prototype.__hardReject__ =
	PromiseArray.prototype._reject = function (reason) {
	    this._values = null;
	    this._promise._rejectCallback(reason, false, true);
	};
	
	PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
	    this._promise._progress({
	        index: index,
	        value: progressValue
	    });
	};
	
	
	PromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};
	
	PromiseArray.prototype._promiseRejected = function (reason, index) {
	    this._totalResolved++;
	    this._reject(reason);
	};
	
	PromiseArray.prototype.shouldCopyValues = function () {
	    return true;
	};
	
	PromiseArray.prototype.getActualLength = function (len) {
	    return len;
	};
	
	return PromiseArray;
	};
	
	},{"./util.js":38}],25:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util.js");
	var maybeWrapAsError = util.maybeWrapAsError;
	var errors = _dereq_("./errors.js");
	var TimeoutError = errors.TimeoutError;
	var OperationalError = errors.OperationalError;
	var haveGetters = util.haveGetters;
	var es5 = _dereq_("./es5.js");
	
	function isUntypedError(obj) {
	    return obj instanceof Error &&
	        es5.getPrototypeOf(obj) === Error.prototype;
	}
	
	var rErrorKey = /^(?:name|message|stack|cause)$/;
	function wrapAsOperationalError(obj) {
	    var ret;
	    if (isUntypedError(obj)) {
	        ret = new OperationalError(obj);
	        ret.name = obj.name;
	        ret.message = obj.message;
	        ret.stack = obj.stack;
	        var keys = es5.keys(obj);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (!rErrorKey.test(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    util.markAsOriginatingFromRejection(obj);
	    return obj;
	}
	
	function nodebackForPromise(promise) {
	    return function(err, value) {
	        if (promise === null) return;
	
	        if (err) {
	            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
	            promise._attachExtraTrace(wrapped);
	            promise._reject(wrapped);
	        } else if (arguments.length > 2) {
	            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	            promise._fulfill(args);
	        } else {
	            promise._fulfill(value);
	        }
	
	        promise = null;
	    };
	}
	
	
	var PromiseResolver;
	if (!haveGetters) {
	    PromiseResolver = function (promise) {
	        this.promise = promise;
	        this.asCallback = nodebackForPromise(promise);
	        this.callback = this.asCallback;
	    };
	}
	else {
	    PromiseResolver = function (promise) {
	        this.promise = promise;
	    };
	}
	if (haveGetters) {
	    var prop = {
	        get: function() {
	            return nodebackForPromise(this.promise);
	        }
	    };
	    es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
	    es5.defineProperty(PromiseResolver.prototype, "callback", prop);
	}
	
	PromiseResolver._nodebackForPromise = nodebackForPromise;
	
	PromiseResolver.prototype.toString = function () {
	    return "[object PromiseResolver]";
	};
	
	PromiseResolver.prototype.resolve =
	PromiseResolver.prototype.fulfill = function (value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._resolveCallback(value);
	};
	
	PromiseResolver.prototype.reject = function (reason) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._rejectCallback(reason);
	};
	
	PromiseResolver.prototype.progress = function (value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._progress(value);
	};
	
	PromiseResolver.prototype.cancel = function (err) {
	    this.promise.cancel(err);
	};
	
	PromiseResolver.prototype.timeout = function () {
	    this.reject(new TimeoutError("timeout"));
	};
	
	PromiseResolver.prototype.isResolved = function () {
	    return this.promise.isResolved();
	};
	
	PromiseResolver.prototype.toJSON = function () {
	    return this.promise.toJSON();
	};
	
	module.exports = PromiseResolver;
	
	},{"./errors.js":13,"./es5.js":14,"./util.js":38}],26:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var THIS = {};
	var util = _dereq_("./util.js");
	var nodebackForPromise = _dereq_("./promise_resolver.js")
	    ._nodebackForPromise;
	var withAppended = util.withAppended;
	var maybeWrapAsError = util.maybeWrapAsError;
	var canEvaluate = util.canEvaluate;
	var TypeError = _dereq_("./errors").TypeError;
	var defaultSuffix = "Async";
	var defaultPromisified = {__isPromisified__: true};
	var noCopyPropsPattern =
	    /^(?:length|name|arguments|caller|callee|prototype|__isPromisified__)$/;
	var defaultFilter = function(name, func) {
	    return util.isIdentifier(name) &&
	        name.charAt(0) !== "_" &&
	        !util.isClass(func);
	};
	
	function propsFilter(key) {
	    return !noCopyPropsPattern.test(key);
	}
	
	function isPromisified(fn) {
	    try {
	        return fn.__isPromisified__ === true;
	    }
	    catch (e) {
	        return false;
	    }
	}
	
	function hasPromisified(obj, key, suffix) {
	    var val = util.getDataPropertyOrDefault(obj, key + suffix,
	                                            defaultPromisified);
	    return val ? isPromisified(val) : false;
	}
	function checkValid(ret, suffix, suffixRegexp) {
	    for (var i = 0; i < ret.length; i += 2) {
	        var key = ret[i];
	        if (suffixRegexp.test(key)) {
	            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
	            for (var j = 0; j < ret.length; j += 2) {
	                if (ret[j] === keyWithoutAsyncSuffix) {
	                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a"
	                        .replace("%s", suffix));
	                }
	            }
	        }
	    }
	}
	
	function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
	    var keys = util.inheritedDataKeys(obj);
	    var ret = [];
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var value = obj[key];
	        var passesDefaultFilter = filter === defaultFilter
	            ? true : defaultFilter(key, value, obj);
	        if (typeof value === "function" &&
	            !isPromisified(value) &&
	            !hasPromisified(obj, key, suffix) &&
	            filter(key, value, obj, passesDefaultFilter)) {
	            ret.push(key, value);
	        }
	    }
	    checkValid(ret, suffix, suffixRegexp);
	    return ret;
	}
	
	var escapeIdentRegex = function(str) {
	    return str.replace(/([$])/, "\\$");
	};
	
	var makeNodePromisifiedEval;
	if (false) {
	var switchCaseArgumentOrder = function(likelyArgumentCount) {
	    var ret = [likelyArgumentCount];
	    var min = Math.max(0, likelyArgumentCount - 1 - 3);
	    for(var i = likelyArgumentCount - 1; i >= min; --i) {
	        ret.push(i);
	    }
	    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
	        ret.push(i);
	    }
	    return ret;
	};
	
	var argumentSequence = function(argumentCount) {
	    return util.filledRange(argumentCount, "_arg", "");
	};
	
	var parameterDeclaration = function(parameterCount) {
	    return util.filledRange(
	        Math.max(parameterCount, 3), "_arg", "");
	};
	
	var parameterCount = function(fn) {
	    if (typeof fn.length === "number") {
	        return Math.max(Math.min(fn.length, 1023 + 1), 0);
	    }
	    return 0;
	};
	
	makeNodePromisifiedEval =
	function(callback, receiver, originalName, fn) {
	    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
	    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
	    var shouldProxyThis = typeof callback === "string" || receiver === THIS;
	
	    function generateCallForArgumentCount(count) {
	        var args = argumentSequence(count).join(", ");
	        var comma = count > 0 ? ", " : "";
	        var ret;
	        if (shouldProxyThis) {
	            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
	        } else {
	            ret = receiver === undefined
	                ? "ret = callback({{args}}, nodeback); break;\n"
	                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
	        }
	        return ret.replace("{{args}}", args).replace(", ", comma);
	    }
	
	    function generateArgumentSwitchCase() {
	        var ret = "";
	        for (var i = 0; i < argumentOrder.length; ++i) {
	            ret += "case " + argumentOrder[i] +":" +
	                generateCallForArgumentCount(argumentOrder[i]);
	        }
	
	        ret += "                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = nodeback;                                              \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]", (shouldProxyThis
	                                ? "ret = callback.apply(this, args);\n"
	                                : "ret = callback.apply(receiver, args);\n"));
	        return ret;
	    }
	
	    var getFunctionCode = typeof callback === "string"
	                                ? ("this != null ? this['"+callback+"'] : fn")
	                                : "fn";
	
	    return new Function("Promise",
	                        "fn",
	                        "receiver",
	                        "withAppended",
	                        "maybeWrapAsError",
	                        "nodebackForPromise",
	                        "tryCatch",
	                        "errorObj",
	                        "INTERNAL","'use strict';                            \n\
	        var ret = function (Parameters) {                                    \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._captureStackTrace();                                    \n\
	            var nodeback = nodebackForPromise(promise);                      \n\
	            var ret;                                                         \n\
	            var callback = tryCatch([GetFunctionCode]);                      \n\
	            switch(len) {                                                    \n\
	                [CodeForSwitchCase]                                          \n\
	            }                                                                \n\
	            if (ret === errorObj) {                                          \n\
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
	            }                                                                \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        ret.__isPromisified__ = true;                                        \n\
	        return ret;                                                          \n\
	        "
	        .replace("Parameters", parameterDeclaration(newParameterCount))
	        .replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
	        .replace("[GetFunctionCode]", getFunctionCode))(
	            Promise,
	            fn,
	            receiver,
	            withAppended,
	            maybeWrapAsError,
	            nodebackForPromise,
	            util.tryCatch,
	            util.errorObj,
	            INTERNAL
	        );
	};
	}
	
	function makeNodePromisifiedClosure(callback, receiver, _, fn) {
	    var defaultThis = (function() {return this;})();
	    var method = callback;
	    if (typeof method === "string") {
	        callback = fn;
	    }
	    function promisified() {
	        var _receiver = receiver;
	        if (receiver === THIS) _receiver = this;
	        var promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	        var cb = typeof method === "string" && this !== defaultThis
	            ? this[method] : callback;
	        var fn = nodebackForPromise(promise);
	        try {
	            cb.apply(_receiver, withAppended(arguments, fn));
	        } catch(e) {
	            promise._rejectCallback(maybeWrapAsError(e), true, true);
	        }
	        return promise;
	    }
	    promisified.__isPromisified__ = true;
	    return promisified;
	}
	
	var makeNodePromisified = canEvaluate
	    ? makeNodePromisifiedEval
	    : makeNodePromisifiedClosure;
	
	function promisifyAll(obj, suffix, filter, promisifier) {
	    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
	    var methods =
	        promisifiableMethods(obj, suffix, suffixRegexp, filter);
	
	    for (var i = 0, len = methods.length; i < len; i+= 2) {
	        var key = methods[i];
	        var fn = methods[i+1];
	        var promisifiedKey = key + suffix;
	        obj[promisifiedKey] = promisifier === makeNodePromisified
	                ? makeNodePromisified(key, THIS, key, fn, suffix)
	                : promisifier(fn, function() {
	                    return makeNodePromisified(key, THIS, key, fn, suffix);
	                });
	    }
	    util.toFastProperties(obj);
	    return obj;
	}
	
	function promisify(callback, receiver) {
	    return makeNodePromisified(callback, receiver, undefined, callback);
	}
	
	Promise.promisify = function (fn, receiver) {
	    if (typeof fn !== "function") {
	        throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    if (isPromisified(fn)) {
	        return fn;
	    }
	    var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
	    util.copyDescriptors(fn, ret, propsFilter);
	    return ret;
	};
	
	Promise.promisifyAll = function (target, options) {
	    if (typeof target !== "function" && typeof target !== "object") {
	        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
	    }
	    options = Object(options);
	    var suffix = options.suffix;
	    if (typeof suffix !== "string") suffix = defaultSuffix;
	    var filter = options.filter;
	    if (typeof filter !== "function") filter = defaultFilter;
	    var promisifier = options.promisifier;
	    if (typeof promisifier !== "function") promisifier = makeNodePromisified;
	
	    if (!util.isIdentifier(suffix)) {
	        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
	    }
	
	    var keys = util.inheritedDataKeys(target);
	    for (var i = 0; i < keys.length; ++i) {
	        var value = target[keys[i]];
	        if (keys[i] !== "constructor" &&
	            util.isClass(value)) {
	            promisifyAll(value.prototype, suffix, filter, promisifier);
	            promisifyAll(value, suffix, filter, promisifier);
	        }
	    }
	
	    return promisifyAll(target, suffix, filter, promisifier);
	};
	};
	
	
	},{"./errors":13,"./promise_resolver.js":25,"./util.js":38}],27:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util.js");
	var isObject = util.isObject;
	var es5 = _dereq_("./es5.js");
	
	function PropertiesPromiseArray(obj) {
	    var keys = es5.keys(obj);
	    var len = keys.length;
	    var values = new Array(len * 2);
	    for (var i = 0; i < len; ++i) {
	        var key = keys[i];
	        values[i] = obj[key];
	        values[i + len] = key;
	    }
	    this.constructor$(values);
	}
	util.inherits(PropertiesPromiseArray, PromiseArray);
	
	PropertiesPromiseArray.prototype._init = function () {
	    this._init$(undefined, -3) ;
	};
	
	PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        var val = {};
	        var keyOffset = this.length();
	        for (var i = 0, len = this.length(); i < len; ++i) {
	            val[this._values[i + keyOffset]] = this._values[i];
	        }
	        this._resolve(val);
	    }
	};
	
	PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
	    this._promise._progress({
	        key: this._values[index + this.length()],
	        value: value
	    });
	};
	
	PropertiesPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};
	
	PropertiesPromiseArray.prototype.getActualLength = function (len) {
	    return len >> 1;
	};
	
	function props(promises) {
	    var ret;
	    var castValue = tryConvertToPromise(promises);
	
	    if (!isObject(castValue)) {
	        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
	    } else if (castValue instanceof Promise) {
	        ret = castValue._then(
	            Promise.props, undefined, undefined, undefined, undefined);
	    } else {
	        ret = new PropertiesPromiseArray(castValue).promise();
	    }
	
	    if (castValue instanceof Promise) {
	        ret._propagateFrom(castValue, 4);
	    }
	    return ret;
	}
	
	Promise.prototype.props = function () {
	    return props(this);
	};
	
	Promise.props = function (promises) {
	    return props(promises);
	};
	};
	
	},{"./es5.js":14,"./util.js":38}],28:[function(_dereq_,module,exports){
	"use strict";
	function arrayMove(src, srcIndex, dst, dstIndex, len) {
	    for (var j = 0; j < len; ++j) {
	        dst[j + dstIndex] = src[j + srcIndex];
	        src[j + srcIndex] = void 0;
	    }
	}
	
	function Queue(capacity) {
	    this._capacity = capacity;
	    this._length = 0;
	    this._front = 0;
	}
	
	Queue.prototype._willBeOverCapacity = function (size) {
	    return this._capacity < size;
	};
	
	Queue.prototype._pushOne = function (arg) {
	    var length = this.length();
	    this._checkCapacity(length + 1);
	    var i = (this._front + length) & (this._capacity - 1);
	    this[i] = arg;
	    this._length = length + 1;
	};
	
	Queue.prototype._unshiftOne = function(value) {
	    var capacity = this._capacity;
	    this._checkCapacity(this.length() + 1);
	    var front = this._front;
	    var i = (((( front - 1 ) &
	                    ( capacity - 1) ) ^ capacity ) - capacity );
	    this[i] = value;
	    this._front = i;
	    this._length = this.length() + 1;
	};
	
	Queue.prototype.unshift = function(fn, receiver, arg) {
	    this._unshiftOne(arg);
	    this._unshiftOne(receiver);
	    this._unshiftOne(fn);
	};
	
	Queue.prototype.push = function (fn, receiver, arg) {
	    var length = this.length() + 3;
	    if (this._willBeOverCapacity(length)) {
	        this._pushOne(fn);
	        this._pushOne(receiver);
	        this._pushOne(arg);
	        return;
	    }
	    var j = this._front + length - 3;
	    this._checkCapacity(length);
	    var wrapMask = this._capacity - 1;
	    this[(j + 0) & wrapMask] = fn;
	    this[(j + 1) & wrapMask] = receiver;
	    this[(j + 2) & wrapMask] = arg;
	    this._length = length;
	};
	
	Queue.prototype.shift = function () {
	    var front = this._front,
	        ret = this[front];
	
	    this[front] = undefined;
	    this._front = (front + 1) & (this._capacity - 1);
	    this._length--;
	    return ret;
	};
	
	Queue.prototype.length = function () {
	    return this._length;
	};
	
	Queue.prototype._checkCapacity = function (size) {
	    if (this._capacity < size) {
	        this._resizeTo(this._capacity << 1);
	    }
	};
	
	Queue.prototype._resizeTo = function (capacity) {
	    var oldCapacity = this._capacity;
	    this._capacity = capacity;
	    var front = this._front;
	    var length = this._length;
	    var moveItemsCount = (front + length) & (oldCapacity - 1);
	    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
	};
	
	module.exports = Queue;
	
	},{}],29:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var isArray = _dereq_("./util.js").isArray;
	
	var raceLater = function (promise) {
	    return promise.then(function(array) {
	        return race(array, promise);
	    });
	};
	
	function race(promises, parent) {
	    var maybePromise = tryConvertToPromise(promises);
	
	    if (maybePromise instanceof Promise) {
	        return raceLater(maybePromise);
	    } else if (!isArray(promises)) {
	        return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
	    }
	
	    var ret = new Promise(INTERNAL);
	    if (parent !== undefined) {
	        ret._propagateFrom(parent, 4 | 1);
	    }
	    var fulfill = ret._fulfill;
	    var reject = ret._reject;
	    for (var i = 0, len = promises.length; i < len; ++i) {
	        var val = promises[i];
	
	        if (val === undefined && !(i in promises)) {
	            continue;
	        }
	
	        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
	    }
	    return ret;
	}
	
	Promise.race = function (promises) {
	    return race(promises, undefined);
	};
	
	Promise.prototype.race = function () {
	    return race(this, undefined);
	};
	
	};
	
	},{"./util.js":38}],30:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL) {
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	function ReductionPromiseArray(promises, fn, accum, _each) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    this._preservedValues = _each === INTERNAL ? [] : null;
	    this._zerothIsAccum = (accum === undefined);
	    this._gotAccum = false;
	    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
	    this._valuesPhase = undefined;
	    var maybePromise = tryConvertToPromise(accum, this._promise);
	    var rejected = false;
	    var isPromise = maybePromise instanceof Promise;
	    if (isPromise) {
	        maybePromise = maybePromise._target();
	        if (maybePromise._isPending()) {
	            maybePromise._proxyPromiseArray(this, -1);
	        } else if (maybePromise._isFulfilled()) {
	            accum = maybePromise._value();
	            this._gotAccum = true;
	        } else {
	            this._reject(maybePromise._reason());
	            rejected = true;
	        }
	    }
	    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
	    this._callback = fn;
	    this._accum = accum;
	    if (!rejected) async.invoke(init, this, undefined);
	}
	function init() {
	    this._init$(undefined, -5);
	}
	util.inherits(ReductionPromiseArray, PromiseArray);
	
	ReductionPromiseArray.prototype._init = function () {};
	
	ReductionPromiseArray.prototype._resolveEmptyArray = function () {
	    if (this._gotAccum || this._zerothIsAccum) {
	        this._resolve(this._preservedValues !== null
	                        ? [] : this._accum);
	    }
	};
	
	ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    values[index] = value;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var isEach = preservedValues !== null;
	    var gotAccum = this._gotAccum;
	    var valuesPhase = this._valuesPhase;
	    var valuesPhaseIndex;
	    if (!valuesPhase) {
	        valuesPhase = this._valuesPhase = new Array(length);
	        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
	            valuesPhase[valuesPhaseIndex] = 0;
	        }
	    }
	    valuesPhaseIndex = valuesPhase[index];
	
	    if (index === 0 && this._zerothIsAccum) {
	        this._accum = value;
	        this._gotAccum = gotAccum = true;
	        valuesPhase[index] = ((valuesPhaseIndex === 0)
	            ? 1 : 2);
	    } else if (index === -1) {
	        this._accum = value;
	        this._gotAccum = gotAccum = true;
	    } else {
	        if (valuesPhaseIndex === 0) {
	            valuesPhase[index] = 1;
	        } else {
	            valuesPhase[index] = 2;
	            this._accum = value;
	        }
	    }
	    if (!gotAccum) return;
	
	    var callback = this._callback;
	    var receiver = this._promise._boundTo;
	    var ret;
	
	    for (var i = this._reducingIndex; i < length; ++i) {
	        valuesPhaseIndex = valuesPhase[i];
	        if (valuesPhaseIndex === 2) {
	            this._reducingIndex = i + 1;
	            continue;
	        }
	        if (valuesPhaseIndex !== 1) return;
	        value = values[i];
	        this._promise._pushContext();
	        if (isEach) {
	            preservedValues.push(value);
	            ret = tryCatch(callback).call(receiver, value, i, length);
	        }
	        else {
	            ret = tryCatch(callback)
	                .call(receiver, this._accum, value, i, length);
	        }
	        this._promise._popContext();
	
	        if (ret === errorObj) return this._reject(ret.e);
	
	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (maybePromise._isPending()) {
	                valuesPhase[i] = 4;
	                return maybePromise._proxyPromiseArray(this, i);
	            } else if (maybePromise._isFulfilled()) {
	                ret = maybePromise._value();
	            } else {
	                return this._reject(maybePromise._reason());
	            }
	        }
	
	        this._reducingIndex = i + 1;
	        this._accum = ret;
	    }
	
	    this._resolve(isEach ? preservedValues : this._accum);
	};
	
	function reduce(promises, fn, initialValue, _each) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
	    return array.promise();
	}
	
	Promise.prototype.reduce = function (fn, initialValue) {
	    return reduce(this, fn, initialValue, null);
	};
	
	Promise.reduce = function (promises, fn, initialValue, _each) {
	    return reduce(promises, fn, initialValue, _each);
	};
	};
	
	},{"./async.js":2,"./util.js":38}],31:[function(_dereq_,module,exports){
	"use strict";
	var schedule;
	var noAsyncScheduler = function() {
	    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
	};
	if (_dereq_("./util.js").isNode) {
	    var version = process.versions.node.split(".").map(Number);
	    schedule = (version[0] === 0 && version[1] > 10) || (version[0] > 0)
	        ? global.setImmediate : process.nextTick;
	
	    if (!schedule) {
	        if (typeof setImmediate !== "undefined") {
	            schedule = setImmediate;
	        } else if (typeof setTimeout !== "undefined") {
	            schedule = setTimeout;
	        } else {
	            schedule = noAsyncScheduler;
	        }
	    }
	} else if (typeof MutationObserver !== "undefined") {
	    schedule = function(fn) {
	        var div = document.createElement("div");
	        var observer = new MutationObserver(fn);
	        observer.observe(div, {attributes: true});
	        return function() { div.classList.toggle("foo"); };
	    };
	    schedule.isStatic = true;
	} else if (typeof setImmediate !== "undefined") {
	    schedule = function (fn) {
	        setImmediate(fn);
	    };
	} else if (typeof setTimeout !== "undefined") {
	    schedule = function (fn) {
	        setTimeout(fn, 0);
	    };
	} else {
	    schedule = noAsyncScheduler;
	}
	module.exports = schedule;
	
	},{"./util.js":38}],32:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	    function(Promise, PromiseArray) {
	var PromiseInspection = Promise.PromiseInspection;
	var util = _dereq_("./util.js");
	
	function SettledPromiseArray(values) {
	    this.constructor$(values);
	}
	util.inherits(SettledPromiseArray, PromiseArray);
	
	SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
	    this._values[index] = inspection;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};
	
	SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 268435456;
	    ret._settledValue = value;
	    this._promiseResolved(index, ret);
	};
	SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 134217728;
	    ret._settledValue = reason;
	    this._promiseResolved(index, ret);
	};
	
	Promise.settle = function (promises) {
	    return new SettledPromiseArray(promises).promise();
	};
	
	Promise.prototype.settle = function () {
	    return new SettledPromiseArray(this).promise();
	};
	};
	
	},{"./util.js":38}],33:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, apiRejection) {
	var util = _dereq_("./util.js");
	var RangeError = _dereq_("./errors.js").RangeError;
	var AggregateError = _dereq_("./errors.js").AggregateError;
	var isArray = util.isArray;
	
	
	function SomePromiseArray(values) {
	    this.constructor$(values);
	    this._howMany = 0;
	    this._unwrap = false;
	    this._initialized = false;
	}
	util.inherits(SomePromiseArray, PromiseArray);
	
	SomePromiseArray.prototype._init = function () {
	    if (!this._initialized) {
	        return;
	    }
	    if (this._howMany === 0) {
	        this._resolve([]);
	        return;
	    }
	    this._init$(undefined, -5);
	    var isArrayResolved = isArray(this._values);
	    if (!this._isResolved() &&
	        isArrayResolved &&
	        this._howMany > this._canPossiblyFulfill()) {
	        this._reject(this._getRangeError(this.length()));
	    }
	};
	
	SomePromiseArray.prototype.init = function () {
	    this._initialized = true;
	    this._init();
	};
	
	SomePromiseArray.prototype.setUnwrap = function () {
	    this._unwrap = true;
	};
	
	SomePromiseArray.prototype.howMany = function () {
	    return this._howMany;
	};
	
	SomePromiseArray.prototype.setHowMany = function (count) {
	    this._howMany = count;
	};
	
	SomePromiseArray.prototype._promiseFulfilled = function (value) {
	    this._addFulfilled(value);
	    if (this._fulfilled() === this.howMany()) {
	        this._values.length = this.howMany();
	        if (this.howMany() === 1 && this._unwrap) {
	            this._resolve(this._values[0]);
	        } else {
	            this._resolve(this._values);
	        }
	    }
	
	};
	SomePromiseArray.prototype._promiseRejected = function (reason) {
	    this._addRejected(reason);
	    if (this.howMany() > this._canPossiblyFulfill()) {
	        var e = new AggregateError();
	        for (var i = this.length(); i < this._values.length; ++i) {
	            e.push(this._values[i]);
	        }
	        this._reject(e);
	    }
	};
	
	SomePromiseArray.prototype._fulfilled = function () {
	    return this._totalResolved;
	};
	
	SomePromiseArray.prototype._rejected = function () {
	    return this._values.length - this.length();
	};
	
	SomePromiseArray.prototype._addRejected = function (reason) {
	    this._values.push(reason);
	};
	
	SomePromiseArray.prototype._addFulfilled = function (value) {
	    this._values[this._totalResolved++] = value;
	};
	
	SomePromiseArray.prototype._canPossiblyFulfill = function () {
	    return this.length() - this._rejected();
	};
	
	SomePromiseArray.prototype._getRangeError = function (count) {
	    var message = "Input array must contain at least " +
	            this._howMany + " items but contains only " + count + " items";
	    return new RangeError(message);
	};
	
	SomePromiseArray.prototype._resolveEmptyArray = function () {
	    this._reject(this._getRangeError(0));
	};
	
	function some(promises, howMany) {
	    if ((howMany | 0) !== howMany || howMany < 0) {
	        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
	    }
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(howMany);
	    ret.init();
	    return promise;
	}
	
	Promise.some = function (promises, howMany) {
	    return some(promises, howMany);
	};
	
	Promise.prototype.some = function (howMany) {
	    return some(this, howMany);
	};
	
	Promise._SomePromiseArray = SomePromiseArray;
	};
	
	},{"./errors.js":13,"./util.js":38}],34:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	function PromiseInspection(promise) {
	    if (promise !== undefined) {
	        promise = promise._target();
	        this._bitField = promise._bitField;
	        this._settledValue = promise._settledValue;
	    }
	    else {
	        this._bitField = 0;
	        this._settledValue = undefined;
	    }
	}
	
	PromiseInspection.prototype.value = function () {
	    if (!this.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
	    }
	    return this._settledValue;
	};
	
	PromiseInspection.prototype.error =
	PromiseInspection.prototype.reason = function () {
	    if (!this.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
	    }
	    return this._settledValue;
	};
	
	PromiseInspection.prototype.isFulfilled =
	Promise.prototype._isFulfilled = function () {
	    return (this._bitField & 268435456) > 0;
	};
	
	PromiseInspection.prototype.isRejected =
	Promise.prototype._isRejected = function () {
	    return (this._bitField & 134217728) > 0;
	};
	
	PromiseInspection.prototype.isPending =
	Promise.prototype._isPending = function () {
	    return (this._bitField & 402653184) === 0;
	};
	
	PromiseInspection.prototype.isResolved =
	Promise.prototype._isResolved = function () {
	    return (this._bitField & 402653184) > 0;
	};
	
	Promise.prototype.isPending = function() {
	    return this._target()._isPending();
	};
	
	Promise.prototype.isRejected = function() {
	    return this._target()._isRejected();
	};
	
	Promise.prototype.isFulfilled = function() {
	    return this._target()._isFulfilled();
	};
	
	Promise.prototype.isResolved = function() {
	    return this._target()._isResolved();
	};
	
	Promise.prototype._value = function() {
	    return this._settledValue;
	};
	
	Promise.prototype._reason = function() {
	    this._unsetRejectionIsUnhandled();
	    return this._settledValue;
	};
	
	Promise.prototype.value = function() {
	    var target = this._target();
	    if (!target.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
	    }
	    return target._settledValue;
	};
	
	Promise.prototype.reason = function() {
	    var target = this._target();
	    if (!target.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
	    }
	    target._unsetRejectionIsUnhandled();
	    return target._settledValue;
	};
	
	
	Promise.PromiseInspection = PromiseInspection;
	};
	
	},{}],35:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util.js");
	var errorObj = util.errorObj;
	var isObject = util.isObject;
	
	function tryConvertToPromise(obj, context) {
	    if (isObject(obj)) {
	        if (obj instanceof Promise) {
	            return obj;
	        }
	        else if (isAnyBluebirdPromise(obj)) {
	            var ret = new Promise(INTERNAL);
	            obj._then(
	                ret._fulfillUnchecked,
	                ret._rejectUncheckedCheckError,
	                ret._progressUnchecked,
	                ret,
	                null
	            );
	            return ret;
	        }
	        var then = util.tryCatch(getThen)(obj);
	        if (then === errorObj) {
	            if (context) context._pushContext();
	            var ret = Promise.reject(then.e);
	            if (context) context._popContext();
	            return ret;
	        } else if (typeof then === "function") {
	            return doThenable(obj, then, context);
	        }
	    }
	    return obj;
	}
	
	function getThen(obj) {
	    return obj.then;
	}
	
	var hasProp = {}.hasOwnProperty;
	function isAnyBluebirdPromise(obj) {
	    return hasProp.call(obj, "_promise0");
	}
	
	function doThenable(x, then, context) {
	    var promise = new Promise(INTERNAL);
	    var ret = promise;
	    if (context) context._pushContext();
	    promise._captureStackTrace();
	    if (context) context._popContext();
	    var synchronous = true;
	    var result = util.tryCatch(then).call(x,
	                                        resolveFromThenable,
	                                        rejectFromThenable,
	                                        progressFromThenable);
	    synchronous = false;
	    if (promise && result === errorObj) {
	        promise._rejectCallback(result.e, true, true);
	        promise = null;
	    }
	
	    function resolveFromThenable(value) {
	        if (!promise) return;
	        if (x === value) {
	            promise._rejectCallback(
	                Promise._makeSelfResolutionError(), false, true);
	        } else {
	            promise._resolveCallback(value);
	        }
	        promise = null;
	    }
	
	    function rejectFromThenable(reason) {
	        if (!promise) return;
	        promise._rejectCallback(reason, synchronous, true);
	        promise = null;
	    }
	
	    function progressFromThenable(value) {
	        if (!promise) return;
	        if (typeof promise._progress === "function") {
	            promise._progress(value);
	        }
	    }
	    return ret;
	}
	
	return tryConvertToPromise;
	};
	
	},{"./util.js":38}],36:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util.js");
	var TimeoutError = Promise.TimeoutError;
	
	var afterTimeout = function (promise, message) {
	    if (!promise.isPending()) return;
	    if (typeof message !== "string") {
	        message = "operation timed out";
	    }
	    var err = new TimeoutError(message);
	    util.markAsOriginatingFromRejection(err);
	    promise._attachExtraTrace(err);
	    promise._cancel(err);
	};
	
	var afterValue = function(value) { return delay(+this).thenReturn(value); };
	var delay = Promise.delay = function (value, ms) {
	    if (ms === undefined) {
	        ms = value;
	        value = undefined;
	        var ret = new Promise(INTERNAL);
	        setTimeout(function() { ret._fulfill(); }, ms);
	        return ret;
	    }
	    ms = +ms;
	    return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
	};
	
	Promise.prototype.delay = function (ms) {
	    return delay(this, ms);
	};
	
	function successClear(value) {
	    var handle = this;
	    if (handle instanceof Number) handle = +handle;
	    clearTimeout(handle);
	    return value;
	}
	
	function failureClear(reason) {
	    var handle = this;
	    if (handle instanceof Number) handle = +handle;
	    clearTimeout(handle);
	    throw reason;
	}
	
	Promise.prototype.timeout = function (ms, message) {
	    ms = +ms;
	    var ret = this.then().cancellable();
	    ret._cancellationParent = this;
	    var handle = setTimeout(function timeoutTimeout() {
	        afterTimeout(ret, message);
	    }, ms);
	    return ret._then(successClear, failureClear, undefined, handle, undefined);
	};
	
	};
	
	},{"./util.js":38}],37:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function (Promise, apiRejection, tryConvertToPromise,
	    createContext) {
	    var TypeError = _dereq_("./errors.js").TypeError;
	    var inherits = _dereq_("./util.js").inherits;
	    var PromiseInspection = Promise.PromiseInspection;
	
	    function inspectionMapper(inspections) {
	        var len = inspections.length;
	        for (var i = 0; i < len; ++i) {
	            var inspection = inspections[i];
	            if (inspection.isRejected()) {
	                return Promise.reject(inspection.error());
	            }
	            inspections[i] = inspection._settledValue;
	        }
	        return inspections;
	    }
	
	    function thrower(e) {
	        setTimeout(function(){throw e;}, 0);
	    }
	
	    function castPreservingDisposable(thenable) {
	        var maybePromise = tryConvertToPromise(thenable);
	        if (maybePromise !== thenable &&
	            typeof thenable._isDisposable === "function" &&
	            typeof thenable._getDisposer === "function" &&
	            thenable._isDisposable()) {
	            maybePromise._setDisposable(thenable._getDisposer());
	        }
	        return maybePromise;
	    }
	    function dispose(resources, inspection) {
	        var i = 0;
	        var len = resources.length;
	        var ret = Promise.defer();
	        function iterator() {
	            if (i >= len) return ret.resolve();
	            var maybePromise = castPreservingDisposable(resources[i++]);
	            if (maybePromise instanceof Promise &&
	                maybePromise._isDisposable()) {
	                try {
	                    maybePromise = tryConvertToPromise(
	                        maybePromise._getDisposer().tryDispose(inspection),
	                        resources.promise);
	                } catch (e) {
	                    return thrower(e);
	                }
	                if (maybePromise instanceof Promise) {
	                    return maybePromise._then(iterator, thrower,
	                                              null, null, null);
	                }
	            }
	            iterator();
	        }
	        iterator();
	        return ret.promise;
	    }
	
	    function disposerSuccess(value) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = value;
	        inspection._bitField = 268435456;
	        return dispose(this, inspection).thenReturn(value);
	    }
	
	    function disposerFail(reason) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = reason;
	        inspection._bitField = 134217728;
	        return dispose(this, inspection).thenThrow(reason);
	    }
	
	    function Disposer(data, promise, context) {
	        this._data = data;
	        this._promise = promise;
	        this._context = context;
	    }
	
	    Disposer.prototype.data = function () {
	        return this._data;
	    };
	
	    Disposer.prototype.promise = function () {
	        return this._promise;
	    };
	
	    Disposer.prototype.resource = function () {
	        if (this.promise().isFulfilled()) {
	            return this.promise().value();
	        }
	        return null;
	    };
	
	    Disposer.prototype.tryDispose = function(inspection) {
	        var resource = this.resource();
	        var context = this._context;
	        if (context !== undefined) context._pushContext();
	        var ret = resource !== null
	            ? this.doDispose(resource, inspection) : null;
	        if (context !== undefined) context._popContext();
	        this._promise._unsetDisposable();
	        this._data = null;
	        return ret;
	    };
	
	    Disposer.isDisposer = function (d) {
	        return (d != null &&
	                typeof d.resource === "function" &&
	                typeof d.tryDispose === "function");
	    };
	
	    function FunctionDisposer(fn, promise, context) {
	        this.constructor$(fn, promise, context);
	    }
	    inherits(FunctionDisposer, Disposer);
	
	    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
	        var fn = this.data();
	        return fn.call(resource, resource, inspection);
	    };
	
	    function maybeUnwrapDisposer(value) {
	        if (Disposer.isDisposer(value)) {
	            this.resources[this.index]._setDisposable(value);
	            return value.promise();
	        }
	        return value;
	    }
	
	    Promise.using = function () {
	        var len = arguments.length;
	        if (len < 2) return apiRejection(
	                        "you must pass at least 2 arguments to Promise.using");
	        var fn = arguments[len - 1];
	        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	        len--;
	        var resources = new Array(len);
	        for (var i = 0; i < len; ++i) {
	            var resource = arguments[i];
	            if (Disposer.isDisposer(resource)) {
	                var disposer = resource;
	                resource = resource.promise();
	                resource._setDisposable(disposer);
	            } else {
	                var maybePromise = tryConvertToPromise(resource);
	                if (maybePromise instanceof Promise) {
	                    resource =
	                        maybePromise._then(maybeUnwrapDisposer, null, null, {
	                            resources: resources,
	                            index: i
	                    }, undefined);
	                }
	            }
	            resources[i] = resource;
	        }
	
	        var promise = Promise.settle(resources)
	            .then(inspectionMapper)
	            .then(function(vals) {
	                promise._pushContext();
	                var ret;
	                try {
	                    ret = fn.apply(undefined, vals);
	                } finally {
	                    promise._popContext();
	                }
	                return ret;
	            })
	            ._then(
	                disposerSuccess, disposerFail, undefined, resources, undefined);
	        resources.promise = promise;
	        return promise;
	    };
	
	    Promise.prototype._setDisposable = function (disposer) {
	        this._bitField = this._bitField | 262144;
	        this._disposer = disposer;
	    };
	
	    Promise.prototype._isDisposable = function () {
	        return (this._bitField & 262144) > 0;
	    };
	
	    Promise.prototype._getDisposer = function () {
	        return this._disposer;
	    };
	
	    Promise.prototype._unsetDisposable = function () {
	        this._bitField = this._bitField & (~262144);
	        this._disposer = undefined;
	    };
	
	    Promise.prototype.disposer = function (fn) {
	        if (typeof fn === "function") {
	            return new FunctionDisposer(fn, this, createContext());
	        }
	        throw new TypeError();
	    };
	
	};
	
	},{"./errors.js":13,"./util.js":38}],38:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5.js");
	var canEvaluate = typeof navigator == "undefined";
	var haveGetters = (function(){
	    try {
	        var o = {};
	        es5.defineProperty(o, "f", {
	            get: function () {
	                return 3;
	            }
	        });
	        return o.f === 3;
	    }
	    catch (e) {
	        return false;
	    }
	
	})();
	
	var errorObj = {e: {}};
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	
	var inherits = function(Child, Parent) {
	    var hasProp = {}.hasOwnProperty;
	
	    function T() {
	        this.constructor = Child;
	        this.constructor$ = Parent;
	        for (var propertyName in Parent.prototype) {
	            if (hasProp.call(Parent.prototype, propertyName) &&
	                propertyName.charAt(propertyName.length-1) !== "$"
	           ) {
	                this[propertyName + "$"] = Parent.prototype[propertyName];
	            }
	        }
	    }
	    T.prototype = Parent.prototype;
	    Child.prototype = new T();
	    return Child.prototype;
	};
	
	
	function isPrimitive(val) {
	    return val == null || val === true || val === false ||
	        typeof val === "string" || typeof val === "number";
	
	}
	
	function isObject(value) {
	    return !isPrimitive(value);
	}
	
	function maybeWrapAsError(maybeError) {
	    if (!isPrimitive(maybeError)) return maybeError;
	
	    return new Error(safeToString(maybeError));
	}
	
	function withAppended(target, appendee) {
	    var len = target.length;
	    var ret = new Array(len + 1);
	    var i;
	    for (i = 0; i < len; ++i) {
	        ret[i] = target[i];
	    }
	    ret[i] = appendee;
	    return ret;
	}
	
	function getDataPropertyOrDefault(obj, key, defaultValue) {
	    if (es5.isES5) {
	        var desc = Object.getOwnPropertyDescriptor(obj, key);
	        if (desc != null) {
	            return desc.get == null && desc.set == null
	                    ? desc.value
	                    : defaultValue;
	        }
	    } else {
	        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
	    }
	}
	
	function notEnumerableProp(obj, name, value) {
	    if (isPrimitive(obj)) return obj;
	    var descriptor = {
	        value: value,
	        configurable: true,
	        enumerable: false,
	        writable: true
	    };
	    es5.defineProperty(obj, name, descriptor);
	    return obj;
	}
	
	
	var wrapsPrimitiveReceiver = (function() {
	    return this !== "string";
	}).call("string");
	
	function thrower(r) {
	    throw r;
	}
	
	var inheritedDataKeys = (function() {
	    if (es5.isES5) {
	        var oProto = Object.prototype;
	        var getKeys = Object.getOwnPropertyNames;
	        return function(obj) {
	            var ret = [];
	            var visitedKeys = Object.create(null);
	            while (obj != null && obj !== oProto) {
	                var keys;
	                try {
	                    keys = getKeys(obj);
	                } catch (e) {
	                    return ret;
	                }
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (visitedKeys[key]) continue;
	                    visitedKeys[key] = true;
	                    var desc = Object.getOwnPropertyDescriptor(obj, key);
	                    if (desc != null && desc.get == null && desc.set == null) {
	                        ret.push(key);
	                    }
	                }
	                obj = es5.getPrototypeOf(obj);
	            }
	            return ret;
	        };
	    } else {
	        return function(obj) {
	            var ret = [];
	            /*jshint forin:false */
	            for (var key in obj) {
	                ret.push(key);
	            }
	            return ret;
	        };
	    }
	
	})();
	
	function isClass(fn) {
	    try {
	        if (typeof fn === "function") {
	            var keys = es5.names(fn.prototype);
	            if (es5.isES5) return keys.length > 1;
	            return keys.length > 0 &&
	                   !(keys.length === 1 && keys[0] === "constructor");
	        }
	        return false;
	    } catch (e) {
	        return false;
	    }
	}
	
	function toFastProperties(obj) {
	    /*jshint -W027,-W055,-W031*/
	    function f() {}
	    f.prototype = obj;
	    var l = 8;
	    while (l--) new f();
	    return obj;
	    eval(obj);
	}
	
	var rident = /^[a-z$_][a-z$_0-9]*$/i;
	function isIdentifier(str) {
	    return rident.test(str);
	}
	
	function filledRange(count, prefix, suffix) {
	    var ret = new Array(count);
	    for(var i = 0; i < count; ++i) {
	        ret[i] = prefix + i + suffix;
	    }
	    return ret;
	}
	
	function safeToString(obj) {
	    try {
	        return obj + "";
	    } catch (e) {
	        return "[no string representation]";
	    }
	}
	
	function markAsOriginatingFromRejection(e) {
	    try {
	        notEnumerableProp(e, "isOperational", true);
	    }
	    catch(ignore) {}
	}
	
	function originatesFromRejection(e) {
	    if (e == null) return false;
	    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
	        e["isOperational"] === true);
	}
	
	function canAttachTrace(obj) {
	    return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
	}
	
	var ensureErrorObject = (function() {
	    if (!("stack" in new Error())) {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            try {throw new Error(safeToString(value));}
	            catch(err) {return err;}
	        };
	    } else {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            return new Error(safeToString(value));
	        };
	    }
	})();
	
	function classString(obj) {
	    return {}.toString.call(obj);
	}
	
	function copyDescriptors(from, to, filter) {
	    var keys = es5.names(from);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        if (filter(key)) {
	            es5.defineProperty(to, key, es5.getDescriptor(from, key));
	        }
	    }
	}
	
	var ret = {
	    isClass: isClass,
	    isIdentifier: isIdentifier,
	    inheritedDataKeys: inheritedDataKeys,
	    getDataPropertyOrDefault: getDataPropertyOrDefault,
	    thrower: thrower,
	    isArray: es5.isArray,
	    haveGetters: haveGetters,
	    notEnumerableProp: notEnumerableProp,
	    isPrimitive: isPrimitive,
	    isObject: isObject,
	    canEvaluate: canEvaluate,
	    errorObj: errorObj,
	    tryCatch: tryCatch,
	    inherits: inherits,
	    withAppended: withAppended,
	    maybeWrapAsError: maybeWrapAsError,
	    wrapsPrimitiveReceiver: wrapsPrimitiveReceiver,
	    toFastProperties: toFastProperties,
	    filledRange: filledRange,
	    toString: safeToString,
	    canAttachTrace: canAttachTrace,
	    ensureErrorObject: ensureErrorObject,
	    originatesFromRejection: originatesFromRejection,
	    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
	    classString: classString,
	    copyDescriptors: copyDescriptors,
	    hasDevTools: typeof chrome !== "undefined" && chrome &&
	                 typeof chrome.loadTimes === "function",
	    isNode: typeof process !== "undefined" &&
	        classString(process).toLowerCase() === "[object process]"
	};
	try {throw new Error(); } catch (e) {ret.lastLineError = e;}
	module.exports = ret;
	
	},{"./es5.js":14}],39:[function(_dereq_,module,exports){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        len = arguments.length;
	        args = new Array(len - 1);
	        for (i = 1; i < len; i++)
	          args[i - 1] = arguments[i];
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    len = arguments.length;
	    args = new Array(len - 1);
	    for (i = 1; i < len; i++)
	      args[i - 1] = arguments[i];
	
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    var m;
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  var ret;
	  if (!emitter._events || !emitter._events[type])
	    ret = 0;
	  else if (isFunction(emitter._events[type]))
	    ret = 1;
	  else
	    ret = emitter._events[type].length;
	  return ret;
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	
	},{}]},{},[4])(4)
	});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(88), (function() { return this; }()), __webpack_require__(87).setImmediate))

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(39)], __WEBPACK_AMD_DEFINE_RESULT__ = function (P) {
		'use strict';
	
		return function defer() {
			var resolve, reject;
			var promise = new P(function () {
				resolve = arguments[0];
				reject = arguments[1];
			});
			//noinspection JSUnusedAssignment
			return {
				resolve: resolve,
				reject: reject,
				promise: promise
			};
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(39), __webpack_require__(3), __webpack_require__(82), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, P, U, ArtefactP) {
		'use strict';
	
		/*  a function to create an apinatomy component (widget)          */
		/*  as a jQuery element plugin; this is returned from the module  */
		function newWidgetType(typeName) {
			var optionDefaults = arguments[1] === undefined ? {} : arguments[1];
	
			/* the specific widget class */
			var WidgetP = ArtefactP.then(function (Artefact) {
				return Artefact.newSubclass(typeName, function (_ref) {
					var _this = this;
	
					var cssClass = _ref.cssClass;
	
					/* set the element CSS class */
					if (U.isDefined(cssClass)) {
						this.element.addClass(cssClass);
					}
	
					/* if the jquery element is removed, destroy the artefact */
					this.element.asKefirStream('remove').onValue(function () {
						_this.destroy();
					});
	
					this.element.data('artefact', this);
				}, Object.defineProperties({}, {
					model: {
						get: function () {
							return this.options.model;
						},
						configurable: true,
						enumerable: true
					},
					element: {
						get: function () {
							return this.options.element;
						},
						configurable: true,
						enumerable: true
					}
				}), U.extend({
	
					beforeConstruction: P.resolve() // guarantee all widget construction to be asynchronous
	
				}, optionDefaults));
			});
	
			/* create a lowercase name for this widget type */
			var lowercaseName = typeName[0].toLowerCase() + typeName.slice(1);
	
			/* jQuery plugin: the widget creation & retrieval function  */
			$.fn[lowercaseName] = function (options) {
				var _this2 = this;
	
				/* if the word 'instance' is passed, return the (already created) widget promise */
				if (options === 'instance') {
					return this.data('-amy-' + lowercaseName);
				}
	
				/* else, create a new widget and set a promise to it */
				this.data('-amy-' + lowercaseName, WidgetP.then(function (Widget) {
					return new Widget(U.extend(options, { element: _this2 })).constructed;
				}));
	
				/* return the jQuery element instance, by jQuery convention */
				return this;
			};
	
			/* return a promise to the widget artefact class */
			return WidgetP;
		}
	
		/* expose the widget class creator function */
		return newWidgetType;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(39), __webpack_require__(86), __webpack_require__(40)], __WEBPACK_AMD_DEFINE_RESULT__ = function (P, DeltaJs, defer) {
		'use strict';
	
		/* already cached? */
		if (window.__apinatomy_core_deltajs) {
			return window.__apinatomy_core_deltajs;
		}
	
		/* set the cache */
		var deltaJs = window.__apinatomy_core_deltajs = new DeltaJs();
		var deferred = defer();
		deltaJs.selected = deferred.promise;
		var oldSelect = deltaJs.select;
		deltaJs.select = function () {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
	
			oldSelect.apply(this, args);
			deferred.resolve(args);
		};
	
		/* return the delta model that manages all plugins (= deltas) */
		return window.__apinatomy_core_deltajs;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(44);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(71)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-core.scss", function() {
			var newContent = require("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-core.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(85)();
	exports.push([module.id, ".circuitboard{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-align:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;padding:0;}.circuitboard .tilemap{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}.circuitboard .tilemap>.tilerow{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;margin:0;padding:0;height:0;}.circuitboard .tilemap>.tilerow>.tile{width:0;margin:0;padding:0;}.circuitboard .tilemap>.tilerow>.tile:last-of-type{margin-right:0 !important;}.circuitboard .tilemap>.tilerow:last-child{margin-bottom:0 !important;}", ""]);

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, U) {
		'use strict';
	
		function deepTransform(val, fn) {
			if ($.isPlainObject(val) || $.isArray(val)) {
				$.each(val, function (key, subVal) {
					var returned = fn(subVal);
					if (U.isUndefined(returned)) {
						deepTransform(subVal, fn);
					} else {
						val[key] = returned;
					}
				});
			}
		}
	
		var REF_PATTERN = /`([\[\.].+?)`/g;
	
		return function defaults(spec, context) {
	
			deepTransform(spec, function (val) {
				if (typeof val === 'string') {
					var refs = (val.match(REF_PATTERN) || []).map(function (ref) {
						var strippedRef = ref.substring(1, ref.length - 1);
						return new Function('refs', 'return refs' + strippedRef);
					});
					var expr = val.replace(REF_PATTERN, '(refs$1)');
					var templateFn = function templateFn(formalParams) {
						var newFormalParams = formalParams.concat(['return ' + expr]);
						return U.applyConstructor(Function, newFormalParams);
					};
					templateFn.refs = refs;
					return templateFn;
				}
			});
	
			//// recursive auxiliary function; returns true if a change to obj was made
			function withDefaultsAux(defSpec, obj, refs, params) {
				var change = false;
				Object.keys(defSpec).forEach(function (key) {
	
					if (key in obj) {
						if ($.isPlainObject(defSpec[key]) && $.isPlainObject(obj[key])) {
							change = withDefaultsAux(defSpec[key], obj[key], refs, params) || change;
						}
					} else if ($.isPlainObject(defSpec[key])) {
						obj[key] = {};
						change = withDefaultsAux(defSpec[key], obj[key], refs, params) || change;
					} else if ($.isFunction(defSpec[key])) {
						if (defSpec[key].refs.every(function (ref) {
							return !U.isUndefined(ref(refs));
						})) {
							// if none of the references are undefined, assign this 'default'
							var allparams = $.extend({ refs: refs }, context, params);
							var formalParams = Object.keys(allparams);
							var actualParams = formalParams.map(function (fpar) {
								return allparams[fpar];
							});
							var finalFn = defSpec[key](formalParams);
							obj[key] = finalFn.apply(null, actualParams);
						}
					}
				});
				return change;
			}
	
			return function withDefaults(obj, params) {
				var result = U.isUndefined(obj) ? {} : $.extend(true, {}, obj);
	
				var change = true;
				while (change) {
					change = withDefaultsAux(spec, result, result, params || {});
				}
	
				return result;
			};
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
		'use strict';
	
		//
		// takes an object mapping 'selector' → 'property' → 'value' and
		// applies it as a set of CSS rules to the descendants of the current element
		//
		$.fn.extend({
			amyPutCssRules: function amyPutCssRules(rules) {
				var _this = this;
	
				$.each(rules, function (selector, css) {
					var context;
					if (selector.trim() === '&') {
						context = _this;
					} else if (selector.trim().charAt(0) === '&') {
						context = _this.find(selector.trim().substr(1).trim());
					} else {
						context = _this.find(selector);
					}
					context.css(css);
				});
			}
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/* styling */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	__webpack_require__(35);
	
	/* libraries */
	
	var _exposeJQueryJquery = __webpack_require__(37);
	
	var _exposeJQueryJquery2 = _interopRequireDefault(_exposeJQueryJquery);
	
	var _bluebird = __webpack_require__(39);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	var _utilMiscEs6Js = __webpack_require__(3);
	
	var _utilMiscEs6Js2 = _interopRequireDefault(_utilMiscEs6Js);
	
	var _utilKefirAndEggsEs6Js = __webpack_require__(4);
	
	var _utilKefirAndEggsEs6Js2 = _interopRequireDefault(_utilKefirAndEggsEs6Js);
	
	var _utilKefirSignalHandlerEs6Js = __webpack_require__(5);
	
	var _utilKefirSignalHandlerEs6Js2 = _interopRequireDefault(_utilKefirSignalHandlerEs6Js);
	
	var _utilCodesEs6Js = __webpack_require__(6);
	
	/* load the circuitboard, model loader and plugins */
	
	var _circuitboardEs6Js = __webpack_require__(7);
	
	var _circuitboardEs6Js2 = _interopRequireDefault(_circuitboardEs6Js);
	
	//import getFmaModels from './fma-model.es6.js';
	
	var _lyphModelEs6Js = __webpack_require__(8);
	
	var _utilPathModelEs6Js = __webpack_require__(9);
	
	var _utilPathModelEs6Js2 = _interopRequireDefault(_utilPathModelEs6Js);
	
	__webpack_require__(10);
	
	__webpack_require__(11);
	
	__webpack_require__(12);
	
	__webpack_require__(13);
	
	__webpack_require__(14);
	
	__webpack_require__(15);
	
	__webpack_require__(16);
	
	__webpack_require__(17);
	
	__webpack_require__(2);
	
	__webpack_require__(18);
	
	__webpack_require__(19);
	
	__webpack_require__(20);
	
	__webpack_require__(21);
	
	__webpack_require__(22);
	
	__webpack_require__(23);
	
	__webpack_require__(24);
	
	__webpack_require__(25);
	
	__webpack_require__(26);
	
	__webpack_require__(27);
	
	__webpack_require__(28);
	
	__webpack_require__(29);
	
	__webpack_require__(30);
	
	__webpack_require__(31);
	
	__webpack_require__(32);
	
	__webpack_require__(33);
	
	__webpack_require__(34);
	
	//import '../features/p-connectivity.es6.js';
	//import '../features/p-ppi.es6.js';
	//import '../features/p-three-d.es6.js';
	//import '../features/p-three-d-geometric-models.es6.js';
	//import '../features/p-three-d-geometric-models-stl.es6.js';
	//import '../features/p-three-d-geometric-models-obj.es6.js';
	//import '../features/p-three-d-geometric-models-json.es6.js';
	//import '../features/p-three-d-spinner.es6.js';
	//import '../features/p-d3-three-d.es6.js';
	//import '../features/p-three-d-manual-controls.es6.js';
	//import '../features/p-three-d-auto-controls.es6.js';
	//import '../features/p-snapshot.es6.js';
	//import '../features/p-tile-visible-snapshot.es6.js';
	//import '../features/p-tile-maximized-snapshot.es6.js';
	//import '../features/p-three-d-camera-snapshot.es6.js';
	//import '../features/p-tile-open-snapshot.es6.js';
	//import '../features/p-three-d-tubes.es6.js';
	//import '../features/p-three-d-model-snapshot.es6.js';
	//import '../features/p-tile-button-to-swap-three-d-model.es6.js';
	//import '../features/p-tile-button-to-point-camera.es6.js';
	
	/* utility functions */
	function decimalToHex(d, padding) {
		var hex = Number(d).toString(16);
		while (hex.length < padding) {
			hex = '0' + hex;
		}
		return hex;
	}
	
	/* fetch query parameters */
	var root = _utilMiscEs6Js2['default'].getQueryVariable('root') || '161';
	var port = _utilMiscEs6Js2['default'].getQueryVariable('port') || '5055';
	var fmas = _utilMiscEs6Js2['default'].getQueryVariable('fmas') ? _utilMiscEs6Js2['default'].getQueryVariable('fmas').split(',') : null;
	var original = _utilMiscEs6Js2['default'].getQueryVariable('original') || root;
	
	/* start the brain tile opened up */
	_circuitboardEs6Js2['default'].plugin['do']('start-brain-open', { 'if': true, after: ['tile-open', 'tile-hidden'] }).append('Tile.prototype.construct', function () {
		if (this.model.id === root) {
			this.open = true;
			this.visible = true;
		}
	});
	
	/* select plugins to activate them  (note that these must already be *loaded* at this point) */
	_circuitboardEs6Js2['default'].plugin.select('tile-skin', 'tile-click-to-open', 'tile-grow-when-open', 'tile-shrink-when-hidden', 'tile-grow-when-maximized', 'tile-middleclick-to-maximize', 'tile-spacing', 'tile-active', 'tile-button-to-hide', 'tile-button-to-maximize', 'tile-button-to-unhide-children', 'tile-child-count-if-closed', 'tile-glyphs',
	
	//'connectivity',
	'tile-correlation-count-if-closed'
	//'three-d-manual-controls',
	//'three-d-auto-controls',
	//'three-d-geometric-models-obj',
	//'three-d-geometric-models-json',
	//'snapshot',
	//'tile-button-to-swap-three-d-model',
	//'tile-button-to-point-camera',
	);
	
	var LYPH_TO_EXPERIMENTS = {
		// filled in from translation of SCAI to FMA, then to Lyph ID
		13: ['GSE20291'],
		305: ['E-GEOD-4757', 'E-GEOD-5281', 'GSE9770'],
		304: ['E-GEOD-4757', 'E-GEOD-5281', 'GSE9770'],
		280: ['E-GEOD-5281', 'GSE9770', 'E-GEOD-36980', 'E-GEOD-1297'],
		281: ['E-GEOD-5281', 'GSE9770', 'E-GEOD-36980', 'E-GEOD-1297'],
		255: ['E-GEOD-5281', 'GSE9770'],
		166: ['E-GEOD-5281', 'GSE9770'],
		309: ['E-GEOD-5281', 'GSE9770'],
		310: ['E-GEOD-5281', 'GSE9770'],
		230: ['E-GEOD-5281', 'GSE9770'],
		229: ['E-GEOD-5281', 'GSE9770'],
		457: ['E-GEOD-53890', 'E-GEOD-36980'],
		458: ['E-GEOD-53890', 'E-GEOD-36980'],
		459: ['E-GEOD-36980', 'E-MEXP-2280'],
		460: ['E-GEOD-36980', 'E-MEXP-2280'],
		409: ['GSE20146'],
		410: ['GSE20146'],
		461: ['E-GEOD-16759'],
		462: ['E-GEOD-16759'],
		4: ['GSE20141'],
		5: ['GSE20141']
	};
	
	var experiments = {};
	
	/* start the brain tile opened up */
	_circuitboardEs6Js2['default'].plugin['do']('show-experiment-glyphs', { 'if': true, after: ['core', 'tile-glyphs'] }).append('Tile.prototype.construct', function () {
		var _this = this;
	
		var experimentsForThisLyph = LYPH_TO_EXPERIMENTS[this.model.id];
		if (!experimentsForThisLyph) {
			return;
		}
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;
	
		try {
			var _loop = function () {
				var exp = _step.value;
	
				/* unknown experiment? */
				if (!experiments[exp]) {
					experiments[exp] = {
						color: Math.floor(Math.random() * 16777215)
					};
				}
	
				/* create a glyph for it in this lyph */
				var glyph = _this.addGlyph({ tooltipText: 'experiment ' + exp, shape: 'square' });
				glyph.visible = true;
	
				/* the color of the glyph */
				glyph.element.children().css('fill', '#' + decimalToHex(experiments[exp].color, 6)).css('stroke', '#ffffff');
	
				/* clicking the glyph */
				glyph.element.click(function () {
					console.log('clicked experiment:', exp);
	
					// TODO: go to url with this experiment ID
					// http://aetionomy.scai.fraunhofer.de/apinatomy/<E-GEOD-20168>
				});
			};
	
			for (var _iterator = experimentsForThisLyph[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				_loop();
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator['return']) {
					_iterator['return']();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}
	});
	
	(0, _exposeJQueryJquery2['default'])(document).ready(function () {
		(0, _exposeJQueryJquery2['default'])('#circuitboard').circuitboard({
			model: (0, _lyphModelEs6Js.getLyphModels)('root', { root: root, port: port }),
			fetchPaths: (0, _utilPathModelEs6Js2['default'])({ port: port }),
			tileSpacing: 4,
			tilemapMargin: 4,
			weightWhenOpen: 10,
			initialTileVisibility: false
		}).circuitboard('instance').then(function (circuitboard) {
	
			console.info('circuitboard loaded');
	
			/* propagating tile visibility and open-ness */
			circuitboard.newTiles.onValue(function (tile) {
				setTimeout(function () {
					tile.p('visible').onValue(function (visible) {
						if (visible) {
							var _parent = tile.closestAncestorByType('Tile');
							if (_parent) {
								_parent.visible = true;
								_parent.open = true;
							}
						} else {
							var _iteratorNormalCompletion2 = true;
							var _didIteratorError2 = false;
							var _iteratorError2 = undefined;
	
							try {
								for (var _iterator2 = tile.closestDescendantsByType('Tile')[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
									var child = _step2.value;
	
									child.visible = false;
								}
							} catch (err) {
								_didIteratorError2 = true;
								_iteratorError2 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion2 && _iterator2['return']) {
										_iterator2['return']();
									}
								} finally {
									if (_didIteratorError2) {
										throw _iteratorError2;
									}
								}
							}
						}
					});
				}, 200);
			});
	
			/* show tiles of lyphs that have experiments */
			_bluebird2['default'].resolve((0, _lyphModelEs6Js.getLyphModels)(Object.keys(LYPH_TO_EXPERIMENTS), { root: root, port: port })).map(function (a) {
				return a;
			})
			// get a hold of their tiles
			.each(function (_ref) {
				var id = _ref.id;
	
				circuitboard.tile(id).tap(function (tile) {
					tile.populateInnerTilemap(); // TODO: this action is too wide, and thus too expensive
				}).then(function (tile) {
					tile.visible = true;
				});
			});
	
			/* get all lyph ids belonging to the given fma ids */
			//let fmas = [50801,61992,72980]; // test fmas
			if (fmas) {
				_bluebird2['default'].resolve(_exposeJQueryJquery2['default'].ajax({
					url: 'http://open-physiology.org:' + port + '/scaimap/?fmas=' + fmas.join(',') + '&pipe=yes&root=' + original,
					dataType: 'jsonp'
				})).then(function (response) {
					return (0, _lyphModelEs6Js.provideLyphsFromServer)(response, { root: root, port: port });
				}).map(function (a) {
					return a;
				})
				// get a hold of their tiles
				.each(function (_ref2) {
					var id = _ref2.id;
	
					circuitboard.tile(id).tap(function (tile) {
						tile.populateInnerTilemap(); // TODO: this action is too wide, and thus too expensive
					}).then(function (tile) {
						tile.visible = true;
					});
				});
			}
	
			// TODO: correlations
		});
	});

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(85)();
	exports.push([module.id, ".skinned-tile{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.skinned-tile>header{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;font-weight:bold;border-width:1px;overflow:hidden;}.skinned-tile.open>header{height:26px;border-style:none none solid none;line-height:26px;font-size:19.5px !important;white-space:nowrap;}.skinned-tile:not(.open)>header{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;padding:0 5px;}.skinned-tile>section{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;}.skinned-tile.open>section{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;opacity:1;}.skinned-tile:not(.open)>section{opacity:0;}", ""]);

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(50);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(71)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-tile-skin-grow-when-open.scss", function() {
			var newContent = require("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-tile-skin-grow-when-open.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(85)();
	exports.push([module.id, ".tilemap .tile>section{opacity:0;visibility:hidden;}", ""]);

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(52);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(71)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-tile-hidden.scss", function() {
			var newContent = require("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-tile-hidden.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(85)();
	exports.push([module.id, ".circuitboard .tilemap>.tilerow>.tile:last-of-type(:not(.hidden)){margin-right:0 !important;}.circuitboard .tilemap>.tilerow:last-of-type(:not(.hidden)){margin-bottom:0 !important;}", ""]);

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(54);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(71)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-tile-maximized.scss", function() {
			var newContent = require("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-tile-maximized.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(85)();
	exports.push([module.id, ".circuitboard .tilemap>.tilerow>.tile.maximized{margin-right:0 !important;}.circuitboard .tilemap>.tilerow.maximized{margin-bottom:0 !important;}", ""]);

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(56);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(71)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-tile-buttons.scss", function() {
			var newContent = require("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-tile-buttons.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(85)();
	exports.push([module.id, ".tile>.tile-button-holder{position:absolute;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;top:2px;right:2px;margin:0;padding:0;}.tile>.tile-button-holder>.tile-button{display:block;background-size:18px;background-repeat:no-repeat;background-position:center;width:20px;height:20px;margin-left:2px;border:solid 1px transparent;}.tile>.tile-button-holder>.tile-button.white:hover{border:dotted 1px white;}.tile>.tile-button-holder>.tile-button.black:hover,.tile>.tile-button-holder>.tile-button:hover{border:dotted 1px black;}.tile:not(:hover)>.tile-button-holder{display:none;}", ""]);

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(58);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(71)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-tile-child-count-if-closed.scss", function() {
			var newContent = require("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-tile-child-count-if-closed.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(85)();
	exports.push([module.id, ".tile>.tile-child-counter{position:absolute;bottom:2px;right:2px;margin:1px;padding:0 2px;border:solid 1px;border-color:inherit;background-color:inherit;}.tile.open>.tile-child-counter{display:none;}", ""]);

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _graphJs = __webpack_require__(90);
	
	var _graphJs2 = _interopRequireDefault(_graphJs);
	
	var _graphJsDistAddGraphOO = __webpack_require__(89);
	
	var _graphJsDistAddGraphOO2 = _interopRequireDefault(_graphJsDistAddGraphOO);
	
	exports['default'] = (0, _graphJsDistAddGraphOO2['default'])(_graphJs2['default']);
	module.exports = exports['default'];

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(3), __webpack_require__(82)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, U, ArtefactP) {
		'use strict';
	
		return ArtefactP.then(function (Artefact) {
	
			/* however (often) this is loaded, create the class only once */
			if (U.isDefined(window._amy_D3Group)) {
				return window._amy_D3Group;
			}
	
			window._amy_D3Group = Artefact.newSubclass('D3Group', function D3Group() {
				var _this = this;
	
				U.extend(this, {
					vertices: {},
					edges: {}
				});
	
				this.on('destroy').take(1).onValue(function () {
					_this.vertices.forEach(function (v) {
						v.destroy();
					});
					// edges are destroyed when either of their vertices is destroyed
				});
			}, Object.defineProperties({
	
				setRegion: function setRegion(region) {
					this.region = region;
					this.circuitboard.updateGraph();
				},
	
				addVertex: function addVertex(vertex) {
					var _this2 = this;
	
					vertex.group = this;
					this.vertices[vertex.id] = vertex;
					vertex.graphId = vertex.id;
					this.circuitboard._p_d3_vertices[vertex.graphId] = vertex;
					vertex.p('visible').onValue(function () {
						_this2.circuitboard.updateGraph();
					});
					return vertex;
				},
	
				removeVertex: function removeVertex(vertex) {
					if (vertex) {
						if (typeof vertex === 'string') {
							vertex = this.vertices[vertex];
						}
						vertex.destroy();
						delete this.circuitboard._p_d3_vertices[vertex.graphId];
						delete this.vertices[vertex];
						this.circuitboard.updateGraph();
					}
				},
	
				addEdge: function addEdge(edge) {
					var _this3 = this;
	
					edge.group = this;
					this.edges[edge.id] = edge;
					edge.graphId = this.id + ':' + edge.id;
					this.circuitboard._p_d3_edges[edge.graphId] = edge;
					edge.p('visible').onValue(function () {
						_this3.circuitboard.updateGraph();
					});
					return edge;
				},
	
				removeEdge: function removeEdge(edge) {
					if (edge) {
						if (typeof edge === 'string') {
							edge = this.edges[edge];
						}
						edge.destroy();
						delete this.circuitboard._p_d3_edges[edge.graphId];
						delete this.edges[edge.id];
						this.circuitboard.updateGraph();
					}
				},
	
				removeAllEdgesAndVertices: function removeAllEdgesAndVertices() {
					var _this4 = this;
	
					Object.keys(this.edges).forEach(function (edgeId) {
						if (_this4.edges[edgeId]) {
							_this4.removeEdge(_this4.edges[edgeId]);
						}
					});
					Object.keys(this.vertices).forEach(function (vertexId) {
						if (_this4.vertices[vertexId]) {
							_this4.removeVertex(_this4.vertices[vertexId]);
						}
					});
					this.circuitboard.updateGraph();
				}
	
			}, {
				gravityFactor: {
					get: function () {
						return this.options.gravityFactor;
					},
					configurable: true,
					enumerable: true
				},
				chargeFactor: {
					get: function () {
						return this.options.chargeFactor;
					},
					configurable: true,
					enumerable: true
				},
				linkDistanceFactor: {
					get: function () {
						return this.options.linkDistanceFactor;
					},
					configurable: true,
					enumerable: true
				}
			}), {
				gravityFactor: 1,
				chargeFactor: 1,
				linkDistanceFactor: 1,
				region: Object.defineProperties({ // default to the whole canvas with a small padding
					top: 10,
					left: 10 }, {
					width: {
						get: function () {
							return this.circuitboard.size.width - 20;
						},
						configurable: true,
						enumerable: true
					},
					height: {
						get: function () {
							return this.circuitboard.size.height - 20;
						},
						configurable: true,
						enumerable: true
					}
				})
			});
	
			return window._amy_D3Group;
		}).tap(function (c) {
			$.circuitboard.D3Group = c;
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(3), __webpack_require__(82), __webpack_require__(83)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, U, ArtefactP) {
		'use strict';
	
		return ArtefactP.then(function (Artefact) {
	
			/* however (often) this is loaded, create the class only once */
			if (U.isDefined(window._amy_D3Vertex)) {
				return window._amy_D3Vertex;
			}
	
			window._amy_D3Vertex = Artefact.newSubclass('D3Vertex', function D3Vertex(_ref) {
				var _this = this;
	
				var visible = _ref.visible;
				var z = _ref.z;
	
				/* the coordinate properties */
				this.newProperty('x', { initial: Math.random() * 10000 });
				this.newProperty('y', { initial: Math.random() * 10000 });
				this.newProperty('z', { initial: z || 0 });
	
				/* the 'visible' and 'hidden' properties */
				this.newProperty('visible', { initial: visible });
				this.newProperty('hidden').plug(this.p('visible').not());
				this.p('visible').plug(this.p('hidden').not());
	
				/* enact vertex hiding on the DOM */
				this.p('hidden').merge(this.on('destroy').mapTo(true)).onValue(function (h) {
					_this.element.toggleClass('hidden', h).toggleClass('visible', !h);
				});
			}, Object.defineProperties({
	
				updateVisualization: function updateVisualization() {
					if (!this.destroyed) {
						this.element.attr('x', this.x);
						this.element.attr('y', this.y);
					}
				} }, {
				element: {
					get: function () {
						if (!this._element) {
							if (this.options.shape === 'square') {
								this._element = $('\n\t\t\t\t\t\t\t<svg x="' + this.x + '" y="' + this.y + '" class="vertex ' + this.options.cssClass + '">\n\t\t\t\t\t\t\t\t<rect class="core" x="' + -this.options.radius / 2 + '" y="' + -this.options.radius / 2 + '"\n\t\t\t\t\t\t\t\t      width="' + this.options.radius + '" height="' + this.options.radius + '"></rect>\n\t\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t');
							} else {
								this._element = $('\n\t\t\t\t\t\t\t<svg x="' + this.x + '" y="' + this.y + '" class="vertex ' + this.options.cssClass + '">\n\t\t\t\t\t\t\t\t<circle class="core" r="' + this.options.radius / 2 + '"></circle>\n\t\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t');
							}
						}
						return this._element;
					},
					configurable: true,
					enumerable: true
				},
				graphZIndex: {
					get: function () {
						return this.options.graphZIndex;
					},
					configurable: true,
					enumerable: true
				}
			}), {
				graphZIndex: 200,
				cssClass: '',
				radius: 5,
				visible: true
			});
	
			return window._amy_D3Vertex;
		}).tap(function (c) {
			$.circuitboard.D3Vertex = c;
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(63);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(71)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-tile-glyphs.scss", function() {
			var newContent = require("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-tile-glyphs.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(85)();
	exports.push([module.id, ".circuitboard>svg.d3 .glyph>.core{pointer-events:visiblePainted;fill:green;stroke:darkgreen;}", ""]);

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {
	  var d3 = {
	    version: "3.4.13"
	  };
	  if (!Date.now) Date.now = function() {
	    return +new Date();
	  };
	  var d3_arraySlice = [].slice, d3_array = function(list) {
	    return d3_arraySlice.call(list);
	  };
	  var d3_document = document, d3_documentElement = d3_document.documentElement, d3_window = window;
	  try {
	    d3_array(d3_documentElement.childNodes)[0].nodeType;
	  } catch (e) {
	    d3_array = function(list) {
	      var i = list.length, array = new Array(i);
	      while (i--) array[i] = list[i];
	      return array;
	    };
	  }
	  try {
	    d3_document.createElement("div").style.setProperty("opacity", 0, "");
	  } catch (error) {
	    var d3_element_prototype = d3_window.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = d3_window.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
	    d3_element_prototype.setAttribute = function(name, value) {
	      d3_element_setAttribute.call(this, name, value + "");
	    };
	    d3_element_prototype.setAttributeNS = function(space, local, value) {
	      d3_element_setAttributeNS.call(this, space, local, value + "");
	    };
	    d3_style_prototype.setProperty = function(name, value, priority) {
	      d3_style_setProperty.call(this, name, value + "", priority);
	    };
	  }
	  d3.ascending = d3_ascending;
	  function d3_ascending(a, b) {
	    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	  }
	  d3.descending = function(a, b) {
	    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	  };
	  d3.min = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n && !((a = array[i]) != null && a <= a)) a = undefined;
	      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
	    } else {
	      while (++i < n && !((a = f.call(array, array[i], i)) != null && a <= a)) a = undefined;
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
	    }
	    return a;
	  };
	  d3.max = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n && !((a = array[i]) != null && a <= a)) a = undefined;
	      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
	    } else {
	      while (++i < n && !((a = f.call(array, array[i], i)) != null && a <= a)) a = undefined;
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
	    }
	    return a;
	  };
	  d3.extent = function(array, f) {
	    var i = -1, n = array.length, a, b, c;
	    if (arguments.length === 1) {
	      while (++i < n && !((a = c = array[i]) != null && a <= a)) a = c = undefined;
	      while (++i < n) if ((b = array[i]) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    } else {
	      while (++i < n && !((a = c = f.call(array, array[i], i)) != null && a <= a)) a = undefined;
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    }
	    return [ a, c ];
	  };
	  function d3_number(x) {
	    return x === null ? NaN : +x;
	  }
	  function d3_numeric(x) {
	    return !isNaN(x);
	  }
	  d3.sum = function(array, f) {
	    var s = 0, n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
	    } else {
	      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
	    }
	    return s;
	  };
	  d3.mean = function(array, f) {
	    var s = 0, n = array.length, a, i = -1, j = n;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
	    }
	    return j ? s / j : undefined;
	  };
	  d3.quantile = function(values, p) {
	    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
	    return e ? v + e * (values[h] - v) : v;
	  };
	  d3.median = function(array, f) {
	    var numbers = [], n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
	    }
	    return numbers.length ? d3.quantile(numbers.sort(d3_ascending), .5) : undefined;
	  };
	  function d3_bisector(compare) {
	    return {
	      left: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
	        }
	        return lo;
	      },
	      right: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
	        }
	        return lo;
	      }
	    };
	  }
	  var d3_bisect = d3_bisector(d3_ascending);
	  d3.bisectLeft = d3_bisect.left;
	  d3.bisect = d3.bisectRight = d3_bisect.right;
	  d3.bisector = function(f) {
	    return d3_bisector(f.length === 1 ? function(d, x) {
	      return d3_ascending(f(d), x);
	    } : f);
	  };
	  d3.shuffle = function(array) {
	    var m = array.length, t, i;
	    while (m) {
	      i = Math.random() * m-- | 0;
	      t = array[m], array[m] = array[i], array[i] = t;
	    }
	    return array;
	  };
	  d3.permute = function(array, indexes) {
	    var i = indexes.length, permutes = new Array(i);
	    while (i--) permutes[i] = array[indexes[i]];
	    return permutes;
	  };
	  d3.pairs = function(array) {
	    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
	    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
	    return pairs;
	  };
	  d3.zip = function() {
	    if (!(n = arguments.length)) return [];
	    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
	      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
	        zip[j] = arguments[j][i];
	      }
	    }
	    return zips;
	  };
	  function d3_zipLength(d) {
	    return d.length;
	  }
	  d3.transpose = function(matrix) {
	    return d3.zip.apply(d3, matrix);
	  };
	  d3.keys = function(map) {
	    var keys = [];
	    for (var key in map) keys.push(key);
	    return keys;
	  };
	  d3.values = function(map) {
	    var values = [];
	    for (var key in map) values.push(map[key]);
	    return values;
	  };
	  d3.entries = function(map) {
	    var entries = [];
	    for (var key in map) entries.push({
	      key: key,
	      value: map[key]
	    });
	    return entries;
	  };
	  d3.merge = function(arrays) {
	    var n = arrays.length, m, i = -1, j = 0, merged, array;
	    while (++i < n) j += arrays[i].length;
	    merged = new Array(j);
	    while (--n >= 0) {
	      array = arrays[n];
	      m = array.length;
	      while (--m >= 0) {
	        merged[--j] = array[m];
	      }
	    }
	    return merged;
	  };
	  var abs = Math.abs;
	  d3.range = function(start, stop, step) {
	    if (arguments.length < 3) {
	      step = 1;
	      if (arguments.length < 2) {
	        stop = start;
	        start = 0;
	      }
	    }
	    if ((stop - start) / step === Infinity) throw new Error("infinite range");
	    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
	    start *= k, stop *= k, step *= k;
	    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
	    return range;
	  };
	  function d3_range_integerScale(x) {
	    var k = 1;
	    while (x * k % 1) k *= 10;
	    return k;
	  }
	  function d3_class(ctor, properties) {
	    for (var key in properties) {
	      Object.defineProperty(ctor.prototype, key, {
	        value: properties[key],
	        enumerable: false
	      });
	    }
	  }
	  d3.map = function(object) {
	    var map = new d3_Map();
	    if (object instanceof d3_Map) object.forEach(function(key, value) {
	      map.set(key, value);
	    }); else for (var key in object) map.set(key, object[key]);
	    return map;
	  };
	  function d3_Map() {
	    this._ = Object.create(null);
	  }
	  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
	  d3_class(d3_Map, {
	    has: d3_map_has,
	    get: function(key) {
	      return this._[d3_map_escape(key)];
	    },
	    set: function(key, value) {
	      return this._[d3_map_escape(key)] = value;
	    },
	    remove: d3_map_remove,
	    keys: d3_map_keys,
	    values: function() {
	      var values = [];
	      for (var key in this._) values.push(this._[key]);
	      return values;
	    },
	    entries: function() {
	      var entries = [];
	      for (var key in this._) entries.push({
	        key: d3_map_unescape(key),
	        value: this._[key]
	      });
	      return entries;
	    },
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
	    }
	  });
	  function d3_map_escape(key) {
	    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
	  }
	  function d3_map_unescape(key) {
	    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
	  }
	  function d3_map_has(key) {
	    return d3_map_escape(key) in this._;
	  }
	  function d3_map_remove(key) {
	    return (key = d3_map_escape(key)) in this._ && delete this._[key];
	  }
	  function d3_map_keys() {
	    var keys = [];
	    for (var key in this._) keys.push(d3_map_unescape(key));
	    return keys;
	  }
	  function d3_map_size() {
	    var size = 0;
	    for (var key in this._) ++size;
	    return size;
	  }
	  function d3_map_empty() {
	    for (var key in this._) return false;
	    return true;
	  }
	  d3.nest = function() {
	    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
	    function map(mapType, array, depth) {
	      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
	      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
	      while (++i < n) {
	        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
	          values.push(object);
	        } else {
	          valuesByKey.set(keyValue, [ object ]);
	        }
	      }
	      if (mapType) {
	        object = mapType();
	        setter = function(keyValue, values) {
	          object.set(keyValue, map(mapType, values, depth));
	        };
	      } else {
	        object = {};
	        setter = function(keyValue, values) {
	          object[keyValue] = map(mapType, values, depth);
	        };
	      }
	      valuesByKey.forEach(setter);
	      return object;
	    }
	    function entries(map, depth) {
	      if (depth >= keys.length) return map;
	      var array = [], sortKey = sortKeys[depth++];
	      map.forEach(function(key, keyMap) {
	        array.push({
	          key: key,
	          values: entries(keyMap, depth)
	        });
	      });
	      return sortKey ? array.sort(function(a, b) {
	        return sortKey(a.key, b.key);
	      }) : array;
	    }
	    nest.map = function(array, mapType) {
	      return map(mapType, array, 0);
	    };
	    nest.entries = function(array) {
	      return entries(map(d3.map, array, 0), 0);
	    };
	    nest.key = function(d) {
	      keys.push(d);
	      return nest;
	    };
	    nest.sortKeys = function(order) {
	      sortKeys[keys.length - 1] = order;
	      return nest;
	    };
	    nest.sortValues = function(order) {
	      sortValues = order;
	      return nest;
	    };
	    nest.rollup = function(f) {
	      rollup = f;
	      return nest;
	    };
	    return nest;
	  };
	  d3.set = function(array) {
	    var set = new d3_Set();
	    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
	    return set;
	  };
	  function d3_Set() {
	    this._ = Object.create(null);
	  }
	  d3_class(d3_Set, {
	    has: d3_map_has,
	    add: function(key) {
	      this._[d3_map_escape(key += "")] = true;
	      return key;
	    },
	    remove: d3_map_remove,
	    values: d3_map_keys,
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key));
	    }
	  });
	  d3.behavior = {};
	  d3.rebind = function(target, source) {
	    var i = 1, n = arguments.length, method;
	    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
	    return target;
	  };
	  function d3_rebind(target, source, method) {
	    return function() {
	      var value = method.apply(source, arguments);
	      return value === source ? target : value;
	    };
	  }
	  function d3_vendorSymbol(object, name) {
	    if (name in object) return name;
	    name = name.charAt(0).toUpperCase() + name.slice(1);
	    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
	      var prefixName = d3_vendorPrefixes[i] + name;
	      if (prefixName in object) return prefixName;
	    }
	  }
	  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
	  function d3_noop() {}
	  d3.dispatch = function() {
	    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    return dispatch;
	  };
	  function d3_dispatch() {}
	  d3_dispatch.prototype.on = function(type, listener) {
	    var i = type.indexOf("."), name = "";
	    if (i >= 0) {
	      name = type.slice(i + 1);
	      type = type.slice(0, i);
	    }
	    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
	    if (arguments.length === 2) {
	      if (listener == null) for (type in this) {
	        if (this.hasOwnProperty(type)) this[type].on(name, null);
	      }
	      return this;
	    }
	  };
	  function d3_dispatch_event(dispatch) {
	    var listeners = [], listenerByName = new d3_Map();
	    function event() {
	      var z = listeners, i = -1, n = z.length, l;
	      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
	      return dispatch;
	    }
	    event.on = function(name, listener) {
	      var l = listenerByName.get(name), i;
	      if (arguments.length < 2) return l && l.on;
	      if (l) {
	        l.on = null;
	        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
	        listenerByName.remove(name);
	      }
	      if (listener) listeners.push(listenerByName.set(name, {
	        on: listener
	      }));
	      return dispatch;
	    };
	    return event;
	  }
	  d3.event = null;
	  function d3_eventPreventDefault() {
	    d3.event.preventDefault();
	  }
	  function d3_eventSource() {
	    var e = d3.event, s;
	    while (s = e.sourceEvent) e = s;
	    return e;
	  }
	  function d3_eventDispatch(target) {
	    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    dispatch.of = function(thiz, argumentz) {
	      return function(e1) {
	        try {
	          var e0 = e1.sourceEvent = d3.event;
	          e1.target = target;
	          d3.event = e1;
	          dispatch[e1.type].apply(thiz, argumentz);
	        } finally {
	          d3.event = e0;
	        }
	      };
	    };
	    return dispatch;
	  }
	  d3.requote = function(s) {
	    return s.replace(d3_requote_re, "\\$&");
	  };
	  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
	  var d3_subclass = {}.__proto__ ? function(object, prototype) {
	    object.__proto__ = prototype;
	  } : function(object, prototype) {
	    for (var property in prototype) object[property] = prototype[property];
	  };
	  function d3_selection(groups) {
	    d3_subclass(groups, d3_selectionPrototype);
	    return groups;
	  }
	  var d3_select = function(s, n) {
	    return n.querySelector(s);
	  }, d3_selectAll = function(s, n) {
	    return n.querySelectorAll(s);
	  }, d3_selectMatcher = d3_documentElement.matches || d3_documentElement[d3_vendorSymbol(d3_documentElement, "matchesSelector")], d3_selectMatches = function(n, s) {
	    return d3_selectMatcher.call(n, s);
	  };
	  if (typeof Sizzle === "function") {
	    d3_select = function(s, n) {
	      return Sizzle(s, n)[0] || null;
	    };
	    d3_selectAll = Sizzle;
	    d3_selectMatches = Sizzle.matchesSelector;
	  }
	  d3.selection = function() {
	    return d3_selectionRoot;
	  };
	  var d3_selectionPrototype = d3.selection.prototype = [];
	  d3_selectionPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, group, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
	          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selector(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_select(selector, this);
	    };
	  }
	  d3_selectionPrototype.selectAll = function(selector) {
	    var subgroups = [], subgroup, node;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
	          subgroup.parentNode = node;
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selectorAll(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_selectAll(selector, this);
	    };
	  }
	  var d3_nsPrefix = {
	    svg: "http://www.w3.org/2000/svg",
	    xhtml: "http://www.w3.org/1999/xhtml",
	    xlink: "http://www.w3.org/1999/xlink",
	    xml: "http://www.w3.org/XML/1998/namespace",
	    xmlns: "http://www.w3.org/2000/xmlns/"
	  };
	  d3.ns = {
	    prefix: d3_nsPrefix,
	    qualify: function(name) {
	      var i = name.indexOf(":"), prefix = name;
	      if (i >= 0) {
	        prefix = name.slice(0, i);
	        name = name.slice(i + 1);
	      }
	      return d3_nsPrefix.hasOwnProperty(prefix) ? {
	        space: d3_nsPrefix[prefix],
	        local: name
	      } : name;
	    }
	  };
	  d3_selectionPrototype.attr = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node();
	        name = d3.ns.qualify(name);
	        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
	      }
	      for (value in name) this.each(d3_selection_attr(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_attr(name, value));
	  };
	  function d3_selection_attr(name, value) {
	    name = d3.ns.qualify(name);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrConstant() {
	      this.setAttribute(name, value);
	    }
	    function attrConstantNS() {
	      this.setAttributeNS(name.space, name.local, value);
	    }
	    function attrFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
	    }
	    function attrFunctionNS() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
	    }
	    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
	  }
	  function d3_collapse(s) {
	    return s.trim().replace(/\s+/g, " ");
	  }
	  d3_selectionPrototype.classed = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
	        if (value = node.classList) {
	          while (++i < n) if (!value.contains(name[i])) return false;
	        } else {
	          value = node.getAttribute("class");
	          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
	        }
	        return true;
	      }
	      for (value in name) this.each(d3_selection_classed(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_classed(name, value));
	  };
	  function d3_selection_classedRe(name) {
	    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
	  }
	  function d3_selection_classes(name) {
	    return (name + "").trim().split(/^|\s+/);
	  }
	  function d3_selection_classed(name, value) {
	    name = d3_selection_classes(name).map(d3_selection_classedName);
	    var n = name.length;
	    function classedConstant() {
	      var i = -1;
	      while (++i < n) name[i](this, value);
	    }
	    function classedFunction() {
	      var i = -1, x = value.apply(this, arguments);
	      while (++i < n) name[i](this, x);
	    }
	    return typeof value === "function" ? classedFunction : classedConstant;
	  }
	  function d3_selection_classedName(name) {
	    var re = d3_selection_classedRe(name);
	    return function(node, value) {
	      if (c = node.classList) return value ? c.add(name) : c.remove(name);
	      var c = node.getAttribute("class") || "";
	      if (value) {
	        re.lastIndex = 0;
	        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
	      } else {
	        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
	      }
	    };
	  }
	  d3_selectionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
	        return this;
	      }
	      if (n < 2) return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name);
	      priority = "";
	    }
	    return this.each(d3_selection_style(name, value, priority));
	  };
	  function d3_selection_style(name, value, priority) {
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleConstant() {
	      this.style.setProperty(name, value, priority);
	    }
	    function styleFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
	    }
	    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
	  }
	  d3_selectionPrototype.property = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") return this.node()[name];
	      for (value in name) this.each(d3_selection_property(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_property(name, value));
	  };
	  function d3_selection_property(name, value) {
	    function propertyNull() {
	      delete this[name];
	    }
	    function propertyConstant() {
	      this[name] = value;
	    }
	    function propertyFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) delete this[name]; else this[name] = x;
	    }
	    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
	  }
	  d3_selectionPrototype.text = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.textContent = v == null ? "" : v;
	    } : value == null ? function() {
	      this.textContent = "";
	    } : function() {
	      this.textContent = value;
	    }) : this.node().textContent;
	  };
	  d3_selectionPrototype.html = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.innerHTML = v == null ? "" : v;
	    } : value == null ? function() {
	      this.innerHTML = "";
	    } : function() {
	      this.innerHTML = value;
	    }) : this.node().innerHTML;
	  };
	  d3_selectionPrototype.append = function(name) {
	    name = d3_selection_creator(name);
	    return this.select(function() {
	      return this.appendChild(name.apply(this, arguments));
	    });
	  };
	  function d3_selection_creator(name) {
	    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? function() {
	      return this.ownerDocument.createElementNS(name.space, name.local);
	    } : function() {
	      return this.ownerDocument.createElementNS(this.namespaceURI, name);
	    };
	  }
	  d3_selectionPrototype.insert = function(name, before) {
	    name = d3_selection_creator(name);
	    before = d3_selection_selector(before);
	    return this.select(function() {
	      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
	    });
	  };
	  d3_selectionPrototype.remove = function() {
	    return this.each(function() {
	      var parent = this.parentNode;
	      if (parent) parent.removeChild(this);
	    });
	  };
	  d3_selectionPrototype.data = function(value, key) {
	    var i = -1, n = this.length, group, node;
	    if (!arguments.length) {
	      value = new Array(n = (group = this[0]).length);
	      while (++i < n) {
	        if (node = group[i]) {
	          value[i] = node.__data__;
	        }
	      }
	      return value;
	    }
	    function bind(group, groupData) {
	      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
	      if (key) {
	        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
	        for (i = -1; ++i < n; ) {
	          if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {
	            exitNodes[i] = node;
	          } else {
	            nodeByKeyValue.set(keyValue, node);
	          }
	          keyValues[i] = keyValue;
	        }
	        for (i = -1; ++i < m; ) {
	          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          } else if (node !== true) {
	            updateNodes[i] = node;
	            node.__data__ = nodeData;
	          }
	          nodeByKeyValue.set(keyValue, true);
	        }
	        for (i = -1; ++i < n; ) {
	          if (nodeByKeyValue.get(keyValues[i]) !== true) {
	            exitNodes[i] = group[i];
	          }
	        }
	      } else {
	        for (i = -1; ++i < n0; ) {
	          node = group[i];
	          nodeData = groupData[i];
	          if (node) {
	            node.__data__ = nodeData;
	            updateNodes[i] = node;
	          } else {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          }
	        }
	        for (;i < m; ++i) {
	          enterNodes[i] = d3_selection_dataNode(groupData[i]);
	        }
	        for (;i < n; ++i) {
	          exitNodes[i] = group[i];
	        }
	      }
	      enterNodes.update = updateNodes;
	      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
	      enter.push(enterNodes);
	      update.push(updateNodes);
	      exit.push(exitNodes);
	    }
	    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
	    if (typeof value === "function") {
	      while (++i < n) {
	        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
	      }
	    } else {
	      while (++i < n) {
	        bind(group = this[i], value);
	      }
	    }
	    update.enter = function() {
	      return enter;
	    };
	    update.exit = function() {
	      return exit;
	    };
	    return update;
	  };
	  function d3_selection_dataNode(data) {
	    return {
	      __data__: data
	    };
	  }
	  d3_selectionPrototype.datum = function(value) {
	    return arguments.length ? this.property("__data__", value) : this.property("__data__");
	  };
	  d3_selectionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_filter(selector) {
	    return function() {
	      return d3_selectMatches(this, selector);
	    };
	  }
	  d3_selectionPrototype.order = function() {
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
	        if (node = group[i]) {
	          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
	          next = node;
	        }
	      }
	    }
	    return this;
	  };
	  d3_selectionPrototype.sort = function(comparator) {
	    comparator = d3_selection_sortComparator.apply(this, arguments);
	    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
	    return this.order();
	  };
	  function d3_selection_sortComparator(comparator) {
	    if (!arguments.length) comparator = d3_ascending;
	    return function(a, b) {
	      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
	    };
	  }
	  d3_selectionPrototype.each = function(callback) {
	    return d3_selection_each(this, function(node, i, j) {
	      callback.call(node, node.__data__, i, j);
	    });
	  };
	  function d3_selection_each(groups, callback) {
	    for (var j = 0, m = groups.length; j < m; j++) {
	      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
	        if (node = group[i]) callback(node, i, j);
	      }
	    }
	    return groups;
	  }
	  d3_selectionPrototype.call = function(callback) {
	    var args = d3_array(arguments);
	    callback.apply(args[0] = this, args);
	    return this;
	  };
	  d3_selectionPrototype.empty = function() {
	    return !this.node();
	  };
	  d3_selectionPrototype.node = function() {
	    for (var j = 0, m = this.length; j < m; j++) {
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        var node = group[i];
	        if (node) return node;
	      }
	    }
	    return null;
	  };
	  d3_selectionPrototype.size = function() {
	    var n = 0;
	    d3_selection_each(this, function() {
	      ++n;
	    });
	    return n;
	  };
	  function d3_selection_enter(selection) {
	    d3_subclass(selection, d3_selection_enterPrototype);
	    return selection;
	  }
	  var d3_selection_enterPrototype = [];
	  d3.selection.enter = d3_selection_enter;
	  d3.selection.enter.prototype = d3_selection_enterPrototype;
	  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
	  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
	  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
	  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
	  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
	  d3_selection_enterPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, upgroup, group, node;
	    for (var j = -1, m = this.length; ++j < m; ) {
	      upgroup = (group = this[j]).update;
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = group.parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
	          subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  d3_selection_enterPrototype.insert = function(name, before) {
	    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
	    return d3_selectionPrototype.insert.call(this, name, before);
	  };
	  function d3_selection_enterInsertBefore(enter) {
	    var i0, j0;
	    return function(d, i, j) {
	      var group = enter[j].update, n = group.length, node;
	      if (j != j0) j0 = j, i0 = 0;
	      if (i >= i0) i0 = i + 1;
	      while (!(node = group[i0]) && ++i0 < n) ;
	      return node;
	    };
	  }
	  d3_selectionPrototype.transition = function() {
	    var id = d3_transitionInheritId || ++d3_transitionId, subgroups = [], subgroup, node, transition = d3_transitionInherit || {
	      time: Date.now(),
	      ease: d3_ease_cubicInOut,
	      delay: 0,
	      duration: 250
	    };
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) d3_transitionNode(node, i, id, transition);
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, id);
	  };
	  d3_selectionPrototype.interrupt = function() {
	    return this.each(d3_selection_interrupt);
	  };
	  function d3_selection_interrupt() {
	    var lock = this.__transition__;
	    if (lock) ++lock.active;
	  }
	  d3.select = function(node) {
	    var group = [ typeof node === "string" ? d3_select(node, d3_document) : node ];
	    group.parentNode = d3_documentElement;
	    return d3_selection([ group ]);
	  };
	  d3.selectAll = function(nodes) {
	    var group = d3_array(typeof nodes === "string" ? d3_selectAll(nodes, d3_document) : nodes);
	    group.parentNode = d3_documentElement;
	    return d3_selection([ group ]);
	  };
	  var d3_selectionRoot = d3.select(d3_documentElement);
	  d3_selectionPrototype.on = function(type, listener, capture) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof type !== "string") {
	        if (n < 2) listener = false;
	        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
	        return this;
	      }
	      if (n < 2) return (n = this.node()["__on" + type]) && n._;
	      capture = false;
	    }
	    return this.each(d3_selection_on(type, listener, capture));
	  };
	  function d3_selection_on(type, listener, capture) {
	    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
	    if (i > 0) type = type.slice(0, i);
	    var filter = d3_selection_onFilters.get(type);
	    if (filter) type = filter, wrap = d3_selection_onFilter;
	    function onRemove() {
	      var l = this[name];
	      if (l) {
	        this.removeEventListener(type, l, l.$);
	        delete this[name];
	      }
	    }
	    function onAdd() {
	      var l = wrap(listener, d3_array(arguments));
	      onRemove.call(this);
	      this.addEventListener(type, this[name] = l, l.$ = capture);
	      l._ = listener;
	    }
	    function removeAll() {
	      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
	      for (var name in this) {
	        if (match = name.match(re)) {
	          var l = this[name];
	          this.removeEventListener(match[1], l, l.$);
	          delete this[name];
	        }
	      }
	    }
	    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
	  }
	  var d3_selection_onFilters = d3.map({
	    mouseenter: "mouseover",
	    mouseleave: "mouseout"
	  });
	  d3_selection_onFilters.forEach(function(k) {
	    if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
	  });
	  function d3_selection_onListener(listener, argumentz) {
	    return function(e) {
	      var o = d3.event;
	      d3.event = e;
	      argumentz[0] = this.__data__;
	      try {
	        listener.apply(this, argumentz);
	      } finally {
	        d3.event = o;
	      }
	    };
	  }
	  function d3_selection_onFilter(listener, argumentz) {
	    var l = d3_selection_onListener(listener, argumentz);
	    return function(e) {
	      var target = this, related = e.relatedTarget;
	      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
	        l.call(target, e);
	      }
	    };
	  }
	  var d3_event_dragSelect = "onselectstart" in d3_document ? null : d3_vendorSymbol(d3_documentElement.style, "userSelect"), d3_event_dragId = 0;
	  function d3_event_dragSuppress() {
	    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
	    if (d3_event_dragSelect) {
	      var style = d3_documentElement.style, select = style[d3_event_dragSelect];
	      style[d3_event_dragSelect] = "none";
	    }
	    return function(suppressClick) {
	      w.on(name, null);
	      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
	      if (suppressClick) {
	        function off() {
	          w.on(click, null);
	        }
	        w.on(click, function() {
	          d3_eventPreventDefault();
	          off();
	        }, true);
	        setTimeout(off, 0);
	      }
	    };
	  }
	  d3.mouse = function(container) {
	    return d3_mousePoint(container, d3_eventSource());
	  };
	  var d3_mouse_bug44083 = /WebKit/.test(d3_window.navigator.userAgent) ? -1 : 0;
	  function d3_mousePoint(container, e) {
	    if (e.changedTouches) e = e.changedTouches[0];
	    var svg = container.ownerSVGElement || container;
	    if (svg.createSVGPoint) {
	      var point = svg.createSVGPoint();
	      if (d3_mouse_bug44083 < 0 && (d3_window.scrollX || d3_window.scrollY)) {
	        svg = d3.select("body").append("svg").style({
	          position: "absolute",
	          top: 0,
	          left: 0,
	          margin: 0,
	          padding: 0,
	          border: "none"
	        }, "important");
	        var ctm = svg[0][0].getScreenCTM();
	        d3_mouse_bug44083 = !(ctm.f || ctm.e);
	        svg.remove();
	      }
	      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
	      point.y = e.clientY;
	      point = point.matrixTransform(container.getScreenCTM().inverse());
	      return [ point.x, point.y ];
	    }
	    var rect = container.getBoundingClientRect();
	    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
	  }
	  d3.touch = function(container, touches, identifier) {
	    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
	    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
	      if ((touch = touches[i]).identifier === identifier) {
	        return d3_mousePoint(container, touch);
	      }
	    }
	  };
	  d3.behavior.drag = function() {
	    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_behavior_dragMouseSubject, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_behavior_dragTouchSubject, "touchmove", "touchend");
	    function drag() {
	      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
	    }
	    function dragstart(id, position, subject, move, end) {
	      return function() {
	        var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject()).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(), position0 = position(parent, dragId);
	        if (origin) {
	          dragOffset = origin.apply(that, arguments);
	          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
	        } else {
	          dragOffset = [ 0, 0 ];
	        }
	        dispatch({
	          type: "dragstart"
	        });
	        function moved() {
	          var position1 = position(parent, dragId), dx, dy;
	          if (!position1) return;
	          dx = position1[0] - position0[0];
	          dy = position1[1] - position0[1];
	          dragged |= dx | dy;
	          position0 = position1;
	          dispatch({
	            type: "drag",
	            x: position1[0] + dragOffset[0],
	            y: position1[1] + dragOffset[1],
	            dx: dx,
	            dy: dy
	          });
	        }
	        function ended() {
	          if (!position(parent, dragId)) return;
	          dragSubject.on(move + dragName, null).on(end + dragName, null);
	          dragRestore(dragged && d3.event.target === target);
	          dispatch({
	            type: "dragend"
	          });
	        }
	      };
	    }
	    drag.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return drag;
	    };
	    return d3.rebind(drag, event, "on");
	  };
	  function d3_behavior_dragTouchId() {
	    return d3.event.changedTouches[0].identifier;
	  }
	  function d3_behavior_dragTouchSubject() {
	    return d3.event.target;
	  }
	  function d3_behavior_dragMouseSubject() {
	    return d3_window;
	  }
	  d3.touches = function(container, touches) {
	    if (arguments.length < 2) touches = d3_eventSource().touches;
	    return touches ? d3_array(touches).map(function(touch) {
	      var point = d3_mousePoint(container, touch);
	      point.identifier = touch.identifier;
	      return point;
	    }) : [];
	  };
	  var π = Math.PI, τ = 2 * π, halfπ = π / 2, ε = 1e-6, ε2 = ε * ε, d3_radians = π / 180, d3_degrees = 180 / π;
	  function d3_sgn(x) {
	    return x > 0 ? 1 : x < 0 ? -1 : 0;
	  }
	  function d3_cross2d(a, b, c) {
	    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
	  }
	  function d3_acos(x) {
	    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
	  }
	  function d3_asin(x) {
	    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
	  }
	  function d3_sinh(x) {
	    return ((x = Math.exp(x)) - 1 / x) / 2;
	  }
	  function d3_cosh(x) {
	    return ((x = Math.exp(x)) + 1 / x) / 2;
	  }
	  function d3_tanh(x) {
	    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
	  }
	  function d3_haversin(x) {
	    return (x = Math.sin(x / 2)) * x;
	  }
	  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
	  d3.interpolateZoom = function(p0, p1) {
	    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2];
	    var dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = (dr || Math.log(w1 / w0)) / ρ;
	    function interpolate(t) {
	      var s = t * S;
	      if (dr) {
	        var coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
	        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
	      }
	      return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * s) ];
	    }
	    interpolate.duration = S * 1e3;
	    return interpolate;
	  };
	  d3.behavior.zoom = function() {
	    var view = {
	      x: 0,
	      y: 0,
	      k: 1
	    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
	    function zoom(g) {
	      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
	    }
	    zoom.event = function(g) {
	      g.each(function() {
	        var dispatch = event.of(this, arguments), view1 = view;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.zoom", function() {
	            view = this.__chart__ || {
	              x: 0,
	              y: 0,
	              k: 1
	            };
	            zoomstarted(dispatch);
	          }).tween("zoom:zoom", function() {
	            var dx = size[0], dy = size[1], cx = dx / 2, cy = dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
	            return function(t) {
	              var l = i(t), k = dx / l[2];
	              this.__chart__ = view = {
	                x: cx - l[0] * k,
	                y: cy - l[1] * k,
	                k: k
	              };
	              zoomed(dispatch);
	            };
	          }).each("end.zoom", function() {
	            zoomended(dispatch);
	          });
	        } else {
	          this.__chart__ = view;
	          zoomstarted(dispatch);
	          zoomed(dispatch);
	          zoomended(dispatch);
	        }
	      });
	    };
	    zoom.translate = function(_) {
	      if (!arguments.length) return [ view.x, view.y ];
	      view = {
	        x: +_[0],
	        y: +_[1],
	        k: view.k
	      };
	      rescale();
	      return zoom;
	    };
	    zoom.scale = function(_) {
	      if (!arguments.length) return view.k;
	      view = {
	        x: view.x,
	        y: view.y,
	        k: +_
	      };
	      rescale();
	      return zoom;
	    };
	    zoom.scaleExtent = function(_) {
	      if (!arguments.length) return scaleExtent;
	      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.center = function(_) {
	      if (!arguments.length) return center;
	      center = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.size = function(_) {
	      if (!arguments.length) return size;
	      size = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.x = function(z) {
	      if (!arguments.length) return x1;
	      x1 = z;
	      x0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    zoom.y = function(z) {
	      if (!arguments.length) return y1;
	      y1 = z;
	      y0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    function location(p) {
	      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
	    }
	    function point(l) {
	      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
	    }
	    function scaleTo(s) {
	      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
	    }
	    function translateTo(p, l) {
	      l = point(l);
	      view.x += p[0] - l[0];
	      view.y += p[1] - l[1];
	    }
	    function rescale() {
	      if (x1) x1.domain(x0.range().map(function(x) {
	        return (x - view.x) / view.k;
	      }).map(x0.invert));
	      if (y1) y1.domain(y0.range().map(function(y) {
	        return (y - view.y) / view.k;
	      }).map(y0.invert));
	    }
	    function zoomstarted(dispatch) {
	      dispatch({
	        type: "zoomstart"
	      });
	    }
	    function zoomed(dispatch) {
	      rescale();
	      dispatch({
	        type: "zoom",
	        scale: view.k,
	        translate: [ view.x, view.y ]
	      });
	    }
	    function zoomended(dispatch) {
	      dispatch({
	        type: "zoomend"
	      });
	    }
	    function mousedowned() {
	      var that = this, target = d3.event.target, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress();
	      d3_selection_interrupt.call(that);
	      zoomstarted(dispatch);
	      function moved() {
	        dragged = 1;
	        translateTo(d3.mouse(that), location0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        subject.on(mousemove, null).on(mouseup, null);
	        dragRestore(dragged && d3.event.target === target);
	        zoomended(dispatch);
	      }
	    }
	    function touchstarted() {
	      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress();
	      d3_selection_interrupt.call(that);
	      started();
	      zoomstarted(dispatch);
	      subject.on(mousedown, null).on(touchstart, started);
	      function relocate() {
	        var touches = d3.touches(that);
	        scale0 = view.k;
	        touches.forEach(function(t) {
	          if (t.identifier in locations0) locations0[t.identifier] = location(t);
	        });
	        return touches;
	      }
	      function started() {
	        var target = d3.event.target;
	        d3.select(target).on(touchmove, moved).on(touchend, ended);
	        targets.push(target);
	        var changed = d3.event.changedTouches;
	        for (var i = 0, n = changed.length; i < n; ++i) {
	          locations0[changed[i].identifier] = null;
	        }
	        var touches = relocate(), now = Date.now();
	        if (touches.length === 1) {
	          if (now - touchtime < 500) {
	            var p = touches[0], l = locations0[p.identifier];
	            scaleTo(view.k * 2);
	            translateTo(p, l);
	            d3_eventPreventDefault();
	            zoomed(dispatch);
	          }
	          touchtime = now;
	        } else if (touches.length > 1) {
	          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
	          distance0 = dx * dx + dy * dy;
	        }
	      }
	      function moved() {
	        var touches = d3.touches(that), p0, l0, p1, l1;
	        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
	          p1 = touches[i];
	          if (l1 = locations0[p1.identifier]) {
	            if (l0) break;
	            p0 = p1, l0 = l1;
	          }
	        }
	        if (l1) {
	          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
	          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
	          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
	          scaleTo(scale1 * scale0);
	        }
	        touchtime = null;
	        translateTo(p0, l0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        if (d3.event.touches.length) {
	          var changed = d3.event.changedTouches;
	          for (var i = 0, n = changed.length; i < n; ++i) {
	            delete locations0[changed[i].identifier];
	          }
	          for (var identifier in locations0) {
	            return void relocate();
	          }
	        }
	        d3.selectAll(targets).on(zoomName, null);
	        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
	        dragRestore();
	        zoomended(dispatch);
	      }
	    }
	    function mousewheeled() {
	      var dispatch = event.of(this, arguments);
	      if (mousewheelTimer) clearTimeout(mousewheelTimer); else translate0 = location(center0 = center || d3.mouse(this)), 
	      d3_selection_interrupt.call(this), zoomstarted(dispatch);
	      mousewheelTimer = setTimeout(function() {
	        mousewheelTimer = null;
	        zoomended(dispatch);
	      }, 50);
	      d3_eventPreventDefault();
	      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
	      translateTo(center0, translate0);
	      zoomed(dispatch);
	    }
	    function dblclicked() {
	      var dispatch = event.of(this, arguments), p = d3.mouse(this), l = location(p), k = Math.log(view.k) / Math.LN2;
	      zoomstarted(dispatch);
	      scaleTo(Math.pow(2, d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1));
	      translateTo(p, l);
	      zoomed(dispatch);
	      zoomended(dispatch);
	    }
	    return d3.rebind(zoom, event, "on");
	  };
	  var d3_behavior_zoomInfinity = [ 0, Infinity ];
	  var d3_behavior_zoomDelta, d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	    return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
	  }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	    return d3.event.wheelDelta;
	  }, "mousewheel") : (d3_behavior_zoomDelta = function() {
	    return -d3.event.detail;
	  }, "MozMousePixelScroll");
	  d3.color = d3_color;
	  function d3_color() {}
	  d3_color.prototype.toString = function() {
	    return this.rgb() + "";
	  };
	  d3.hsl = d3_hsl;
	  function d3_hsl(h, s, l) {
	    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
	  }
	  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
	  d3_hslPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, this.l / k);
	  };
	  d3_hslPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, k * this.l);
	  };
	  d3_hslPrototype.rgb = function() {
	    return d3_hsl_rgb(this.h, this.s, this.l);
	  };
	  function d3_hsl_rgb(h, s, l) {
	    var m1, m2;
	    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
	    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
	    l = l < 0 ? 0 : l > 1 ? 1 : l;
	    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
	    m1 = 2 * l - m2;
	    function v(h) {
	      if (h > 360) h -= 360; else if (h < 0) h += 360;
	      if (h < 60) return m1 + (m2 - m1) * h / 60;
	      if (h < 180) return m2;
	      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
	      return m1;
	    }
	    function vv(h) {
	      return Math.round(v(h) * 255);
	    }
	    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
	  }
	  d3.hcl = d3_hcl;
	  function d3_hcl(h, c, l) {
	    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
	  }
	  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
	  d3_hclPrototype.brighter = function(k) {
	    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.darker = function(k) {
	    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.rgb = function() {
	    return d3_hcl_lab(this.h, this.c, this.l).rgb();
	  };
	  function d3_hcl_lab(h, c, l) {
	    if (isNaN(h)) h = 0;
	    if (isNaN(c)) c = 0;
	    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
	  }
	  d3.lab = d3_lab;
	  function d3_lab(l, a, b) {
	    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
	  }
	  var d3_lab_K = 18;
	  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
	  var d3_labPrototype = d3_lab.prototype = new d3_color();
	  d3_labPrototype.brighter = function(k) {
	    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.darker = function(k) {
	    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.rgb = function() {
	    return d3_lab_rgb(this.l, this.a, this.b);
	  };
	  function d3_lab_rgb(l, a, b) {
	    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
	    x = d3_lab_xyz(x) * d3_lab_X;
	    y = d3_lab_xyz(y) * d3_lab_Y;
	    z = d3_lab_xyz(z) * d3_lab_Z;
	    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
	  }
	  function d3_lab_hcl(l, a, b) {
	    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
	  }
	  function d3_lab_xyz(x) {
	    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
	  }
	  function d3_xyz_lab(x) {
	    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
	  }
	  function d3_xyz_rgb(r) {
	    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
	  }
	  d3.rgb = d3_rgb;
	  function d3_rgb(r, g, b) {
	    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
	  }
	  function d3_rgbNumber(value) {
	    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
	  }
	  function d3_rgbString(value) {
	    return d3_rgbNumber(value) + "";
	  }
	  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
	  d3_rgbPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    var r = this.r, g = this.g, b = this.b, i = 30;
	    if (!r && !g && !b) return new d3_rgb(i, i, i);
	    if (r && r < i) r = i;
	    if (g && g < i) g = i;
	    if (b && b < i) b = i;
	    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
	  };
	  d3_rgbPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_rgb(k * this.r, k * this.g, k * this.b);
	  };
	  d3_rgbPrototype.hsl = function() {
	    return d3_rgb_hsl(this.r, this.g, this.b);
	  };
	  d3_rgbPrototype.toString = function() {
	    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
	  };
	  function d3_rgb_hex(v) {
	    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
	  }
	  function d3_rgb_parse(format, rgb, hsl) {
	    var r = 0, g = 0, b = 0, m1, m2, color;
	    m1 = /([a-z]+)\((.*)\)/i.exec(format);
	    if (m1) {
	      m2 = m1[2].split(",");
	      switch (m1[1]) {
	       case "hsl":
	        {
	          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
	        }
	
	       case "rgb":
	        {
	          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
	        }
	      }
	    }
	    if (color = d3_rgb_names.get(format)) return rgb(color.r, color.g, color.b);
	    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
	      if (format.length === 4) {
	        r = (color & 3840) >> 4;
	        r = r >> 4 | r;
	        g = color & 240;
	        g = g >> 4 | g;
	        b = color & 15;
	        b = b << 4 | b;
	      } else if (format.length === 7) {
	        r = (color & 16711680) >> 16;
	        g = (color & 65280) >> 8;
	        b = color & 255;
	      }
	    }
	    return rgb(r, g, b);
	  }
	  function d3_rgb_hsl(r, g, b) {
	    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
	    if (d) {
	      s = l < .5 ? d / (max + min) : d / (2 - max - min);
	      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
	      h *= 60;
	    } else {
	      h = NaN;
	      s = l > 0 && l < 1 ? 0 : h;
	    }
	    return new d3_hsl(h, s, l);
	  }
	  function d3_rgb_lab(r, g, b) {
	    r = d3_rgb_xyz(r);
	    g = d3_rgb_xyz(g);
	    b = d3_rgb_xyz(b);
	    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
	    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
	  }
	  function d3_rgb_xyz(r) {
	    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
	  }
	  function d3_rgb_parseNumber(c) {
	    var f = parseFloat(c);
	    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
	  }
	  var d3_rgb_names = d3.map({
	    aliceblue: 15792383,
	    antiquewhite: 16444375,
	    aqua: 65535,
	    aquamarine: 8388564,
	    azure: 15794175,
	    beige: 16119260,
	    bisque: 16770244,
	    black: 0,
	    blanchedalmond: 16772045,
	    blue: 255,
	    blueviolet: 9055202,
	    brown: 10824234,
	    burlywood: 14596231,
	    cadetblue: 6266528,
	    chartreuse: 8388352,
	    chocolate: 13789470,
	    coral: 16744272,
	    cornflowerblue: 6591981,
	    cornsilk: 16775388,
	    crimson: 14423100,
	    cyan: 65535,
	    darkblue: 139,
	    darkcyan: 35723,
	    darkgoldenrod: 12092939,
	    darkgray: 11119017,
	    darkgreen: 25600,
	    darkgrey: 11119017,
	    darkkhaki: 12433259,
	    darkmagenta: 9109643,
	    darkolivegreen: 5597999,
	    darkorange: 16747520,
	    darkorchid: 10040012,
	    darkred: 9109504,
	    darksalmon: 15308410,
	    darkseagreen: 9419919,
	    darkslateblue: 4734347,
	    darkslategray: 3100495,
	    darkslategrey: 3100495,
	    darkturquoise: 52945,
	    darkviolet: 9699539,
	    deeppink: 16716947,
	    deepskyblue: 49151,
	    dimgray: 6908265,
	    dimgrey: 6908265,
	    dodgerblue: 2003199,
	    firebrick: 11674146,
	    floralwhite: 16775920,
	    forestgreen: 2263842,
	    fuchsia: 16711935,
	    gainsboro: 14474460,
	    ghostwhite: 16316671,
	    gold: 16766720,
	    goldenrod: 14329120,
	    gray: 8421504,
	    green: 32768,
	    greenyellow: 11403055,
	    grey: 8421504,
	    honeydew: 15794160,
	    hotpink: 16738740,
	    indianred: 13458524,
	    indigo: 4915330,
	    ivory: 16777200,
	    khaki: 15787660,
	    lavender: 15132410,
	    lavenderblush: 16773365,
	    lawngreen: 8190976,
	    lemonchiffon: 16775885,
	    lightblue: 11393254,
	    lightcoral: 15761536,
	    lightcyan: 14745599,
	    lightgoldenrodyellow: 16448210,
	    lightgray: 13882323,
	    lightgreen: 9498256,
	    lightgrey: 13882323,
	    lightpink: 16758465,
	    lightsalmon: 16752762,
	    lightseagreen: 2142890,
	    lightskyblue: 8900346,
	    lightslategray: 7833753,
	    lightslategrey: 7833753,
	    lightsteelblue: 11584734,
	    lightyellow: 16777184,
	    lime: 65280,
	    limegreen: 3329330,
	    linen: 16445670,
	    magenta: 16711935,
	    maroon: 8388608,
	    mediumaquamarine: 6737322,
	    mediumblue: 205,
	    mediumorchid: 12211667,
	    mediumpurple: 9662683,
	    mediumseagreen: 3978097,
	    mediumslateblue: 8087790,
	    mediumspringgreen: 64154,
	    mediumturquoise: 4772300,
	    mediumvioletred: 13047173,
	    midnightblue: 1644912,
	    mintcream: 16121850,
	    mistyrose: 16770273,
	    moccasin: 16770229,
	    navajowhite: 16768685,
	    navy: 128,
	    oldlace: 16643558,
	    olive: 8421376,
	    olivedrab: 7048739,
	    orange: 16753920,
	    orangered: 16729344,
	    orchid: 14315734,
	    palegoldenrod: 15657130,
	    palegreen: 10025880,
	    paleturquoise: 11529966,
	    palevioletred: 14381203,
	    papayawhip: 16773077,
	    peachpuff: 16767673,
	    peru: 13468991,
	    pink: 16761035,
	    plum: 14524637,
	    powderblue: 11591910,
	    purple: 8388736,
	    red: 16711680,
	    rosybrown: 12357519,
	    royalblue: 4286945,
	    saddlebrown: 9127187,
	    salmon: 16416882,
	    sandybrown: 16032864,
	    seagreen: 3050327,
	    seashell: 16774638,
	    sienna: 10506797,
	    silver: 12632256,
	    skyblue: 8900331,
	    slateblue: 6970061,
	    slategray: 7372944,
	    slategrey: 7372944,
	    snow: 16775930,
	    springgreen: 65407,
	    steelblue: 4620980,
	    tan: 13808780,
	    teal: 32896,
	    thistle: 14204888,
	    tomato: 16737095,
	    turquoise: 4251856,
	    violet: 15631086,
	    wheat: 16113331,
	    white: 16777215,
	    whitesmoke: 16119285,
	    yellow: 16776960,
	    yellowgreen: 10145074
	  });
	  d3_rgb_names.forEach(function(key, value) {
	    d3_rgb_names.set(key, d3_rgbNumber(value));
	  });
	  function d3_functor(v) {
	    return typeof v === "function" ? v : function() {
	      return v;
	    };
	  }
	  d3.functor = d3_functor;
	  function d3_identity(d) {
	    return d;
	  }
	  d3.xhr = d3_xhrType(d3_identity);
	  function d3_xhrType(response) {
	    return function(url, mimeType, callback) {
	      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
	      mimeType = null;
	      return d3_xhr(url, mimeType, response, callback);
	    };
	  }
	  function d3_xhr(url, mimeType, response, callback) {
	    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
	    if (d3_window.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
	    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
	      request.readyState > 3 && respond();
	    };
	    function respond() {
	      var status = request.status, result;
	      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
	        try {
	          result = response.call(xhr, request);
	        } catch (e) {
	          dispatch.error.call(xhr, e);
	          return;
	        }
	        dispatch.load.call(xhr, result);
	      } else {
	        dispatch.error.call(xhr, request);
	      }
	    }
	    request.onprogress = function(event) {
	      var o = d3.event;
	      d3.event = event;
	      try {
	        dispatch.progress.call(xhr, request);
	      } finally {
	        d3.event = o;
	      }
	    };
	    xhr.header = function(name, value) {
	      name = (name + "").toLowerCase();
	      if (arguments.length < 2) return headers[name];
	      if (value == null) delete headers[name]; else headers[name] = value + "";
	      return xhr;
	    };
	    xhr.mimeType = function(value) {
	      if (!arguments.length) return mimeType;
	      mimeType = value == null ? null : value + "";
	      return xhr;
	    };
	    xhr.responseType = function(value) {
	      if (!arguments.length) return responseType;
	      responseType = value;
	      return xhr;
	    };
	    xhr.response = function(value) {
	      response = value;
	      return xhr;
	    };
	    [ "get", "post" ].forEach(function(method) {
	      xhr[method] = function() {
	        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
	      };
	    });
	    xhr.send = function(method, data, callback) {
	      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
	      request.open(method, url, true);
	      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
	      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
	      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
	      if (responseType != null) request.responseType = responseType;
	      if (callback != null) xhr.on("error", callback).on("load", function(request) {
	        callback(null, request);
	      });
	      dispatch.beforesend.call(xhr, request);
	      request.send(data == null ? null : data);
	      return xhr;
	    };
	    xhr.abort = function() {
	      request.abort();
	      return xhr;
	    };
	    d3.rebind(xhr, dispatch, "on");
	    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
	  }
	  function d3_xhr_fixCallback(callback) {
	    return callback.length === 1 ? function(error, request) {
	      callback(error == null ? request : null);
	    } : callback;
	  }
	  function d3_xhrHasResponse(request) {
	    var type = request.responseType;
	    return type && type !== "text" ? request.response : request.responseText;
	  }
	  d3.dsv = function(delimiter, mimeType) {
	    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
	    function dsv(url, row, callback) {
	      if (arguments.length < 3) callback = row, row = null;
	      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
	      xhr.row = function(_) {
	        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
	      };
	      return xhr;
	    }
	    function response(request) {
	      return dsv.parse(request.responseText);
	    }
	    function typedResponse(f) {
	      return function(request) {
	        return dsv.parse(request.responseText, f);
	      };
	    }
	    dsv.parse = function(text, f) {
	      var o;
	      return dsv.parseRows(text, function(row, i) {
	        if (o) return o(row, i - 1);
	        var a = new Function("d", "return {" + row.map(function(name, i) {
	          return JSON.stringify(name) + ": d[" + i + "]";
	        }).join(",") + "}");
	        o = f ? function(row, i) {
	          return f(a(row), i);
	        } : a;
	      });
	    };
	    dsv.parseRows = function(text, f) {
	      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
	      function token() {
	        if (I >= N) return EOF;
	        if (eol) return eol = false, EOL;
	        var j = I;
	        if (text.charCodeAt(j) === 34) {
	          var i = j;
	          while (i++ < N) {
	            if (text.charCodeAt(i) === 34) {
	              if (text.charCodeAt(i + 1) !== 34) break;
	              ++i;
	            }
	          }
	          I = i + 2;
	          var c = text.charCodeAt(i + 1);
	          if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(i + 2) === 10) ++I;
	          } else if (c === 10) {
	            eol = true;
	          }
	          return text.slice(j + 1, i).replace(/""/g, '"');
	        }
	        while (I < N) {
	          var c = text.charCodeAt(I++), k = 1;
	          if (c === 10) eol = true; else if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(I) === 10) ++I, ++k;
	          } else if (c !== delimiterCode) continue;
	          return text.slice(j, I - k);
	        }
	        return text.slice(j);
	      }
	      while ((t = token()) !== EOF) {
	        var a = [];
	        while (t !== EOL && t !== EOF) {
	          a.push(t);
	          t = token();
	        }
	        if (f && (a = f(a, n++)) == null) continue;
	        rows.push(a);
	      }
	      return rows;
	    };
	    dsv.format = function(rows) {
	      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
	      var fieldSet = new d3_Set(), fields = [];
	      rows.forEach(function(row) {
	        for (var field in row) {
	          if (!fieldSet.has(field)) {
	            fields.push(fieldSet.add(field));
	          }
	        }
	      });
	      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
	        return fields.map(function(field) {
	          return formatValue(row[field]);
	        }).join(delimiter);
	      })).join("\n");
	    };
	    dsv.formatRows = function(rows) {
	      return rows.map(formatRow).join("\n");
	    };
	    function formatRow(row) {
	      return row.map(formatValue).join(delimiter);
	    }
	    function formatValue(text) {
	      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
	    }
	    return dsv;
	  };
	  d3.csv = d3.dsv(",", "text/csv");
	  d3.tsv = d3.dsv("	", "text/tab-separated-values");
	  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = d3_window[d3_vendorSymbol(d3_window, "requestAnimationFrame")] || function(callback) {
	    setTimeout(callback, 17);
	  };
	  d3.timer = function(callback, delay, then) {
	    var n = arguments.length;
	    if (n < 2) delay = 0;
	    if (n < 3) then = Date.now();
	    var time = then + delay, timer = {
	      c: callback,
	      t: time,
	      f: false,
	      n: null
	    };
	    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
	    d3_timer_queueTail = timer;
	    if (!d3_timer_interval) {
	      d3_timer_timeout = clearTimeout(d3_timer_timeout);
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	  };
	  function d3_timer_step() {
	    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
	    if (delay > 24) {
	      if (isFinite(delay)) {
	        clearTimeout(d3_timer_timeout);
	        d3_timer_timeout = setTimeout(d3_timer_step, delay);
	      }
	      d3_timer_interval = 0;
	    } else {
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	  }
	  d3.timer.flush = function() {
	    d3_timer_mark();
	    d3_timer_sweep();
	  };
	  function d3_timer_mark() {
	    var now = Date.now();
	    d3_timer_active = d3_timer_queueHead;
	    while (d3_timer_active) {
	      if (now >= d3_timer_active.t) d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
	      d3_timer_active = d3_timer_active.n;
	    }
	    return now;
	  }
	  function d3_timer_sweep() {
	    var t0, t1 = d3_timer_queueHead, time = Infinity;
	    while (t1) {
	      if (t1.f) {
	        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
	      } else {
	        if (t1.t < time) time = t1.t;
	        t1 = (t0 = t1).n;
	      }
	    }
	    d3_timer_queueTail = t0;
	    return time;
	  }
	  function d3_format_precision(x, p) {
	    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
	  }
	  d3.round = function(x, n) {
	    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
	  };
	  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
	  d3.formatPrefix = function(value, precision) {
	    var i = 0;
	    if (value) {
	      if (value < 0) value *= -1;
	      if (precision) value = d3.round(value, d3_format_precision(value, precision));
	      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
	      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
	    }
	    return d3_formatPrefixes[8 + i / 3];
	  };
	  function d3_formatPrefix(d, i) {
	    var k = Math.pow(10, abs(8 - i) * 3);
	    return {
	      scale: i > 8 ? function(d) {
	        return d / k;
	      } : function(d) {
	        return d * k;
	      },
	      symbol: d
	    };
	  }
	  function d3_locale_numberFormat(locale) {
	    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
	      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
	      while (i > 0 && g > 0) {
	        if (length + g + 1 > width) g = Math.max(1, width - length);
	        t.push(value.substring(i -= g, i + g));
	        if ((length += g + 1) > width) break;
	        g = locale_grouping[j = (j + 1) % locale_grouping.length];
	      }
	      return t.reverse().join(locale_thousands);
	    } : d3_identity;
	    return function(specifier) {
	      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
	      if (precision) precision = +precision.substring(1);
	      if (zfill || fill === "0" && align === "=") {
	        zfill = fill = "0";
	        align = "=";
	      }
	      switch (type) {
	       case "n":
	        comma = true;
	        type = "g";
	        break;
	
	       case "%":
	        scale = 100;
	        suffix = "%";
	        type = "f";
	        break;
	
	       case "p":
	        scale = 100;
	        suffix = "%";
	        type = "r";
	        break;
	
	       case "b":
	       case "o":
	       case "x":
	       case "X":
	        if (symbol === "#") prefix = "0" + type.toLowerCase();
	
	       case "c":
	        exponent = false;
	
	       case "d":
	        integer = true;
	        precision = 0;
	        break;
	
	       case "s":
	        scale = -1;
	        type = "r";
	        break;
	      }
	      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
	      if (type == "r" && !precision) type = "g";
	      if (precision != null) {
	        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
	      }
	      type = d3_format_types.get(type) || d3_format_typeDefault;
	      var zcomma = zfill && comma;
	      return function(value) {
	        var fullSuffix = suffix;
	        if (integer && value % 1) return "";
	        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
	        if (scale < 0) {
	          var unit = d3.formatPrefix(value, precision);
	          value = unit.scale(value);
	          fullSuffix = unit.symbol + suffix;
	        } else {
	          value *= scale;
	        }
	        value = type(value, precision);
	        var i = value.lastIndexOf("."), before, after;
	        if (i < 0) {
	          var j = exponent ? value.lastIndexOf("e") : -1;
	          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
	        } else {
	          before = value.substring(0, i);
	          after = locale_decimal + value.substring(i + 1);
	        }
	        if (!zfill && comma) before = formatGroup(before, Infinity);
	        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
	        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
	        negative += prefix;
	        value = before + after;
	        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
	      };
	    };
	  }
	  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
	  var d3_format_types = d3.map({
	    b: function(x) {
	      return x.toString(2);
	    },
	    c: function(x) {
	      return String.fromCharCode(x);
	    },
	    o: function(x) {
	      return x.toString(8);
	    },
	    x: function(x) {
	      return x.toString(16);
	    },
	    X: function(x) {
	      return x.toString(16).toUpperCase();
	    },
	    g: function(x, p) {
	      return x.toPrecision(p);
	    },
	    e: function(x, p) {
	      return x.toExponential(p);
	    },
	    f: function(x, p) {
	      return x.toFixed(p);
	    },
	    r: function(x, p) {
	      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
	    }
	  });
	  function d3_format_typeDefault(x) {
	    return x + "";
	  }
	  var d3_time = d3.time = {}, d3_date = Date;
	  function d3_date_utc() {
	    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
	  }
	  d3_date_utc.prototype = {
	    getDate: function() {
	      return this._.getUTCDate();
	    },
	    getDay: function() {
	      return this._.getUTCDay();
	    },
	    getFullYear: function() {
	      return this._.getUTCFullYear();
	    },
	    getHours: function() {
	      return this._.getUTCHours();
	    },
	    getMilliseconds: function() {
	      return this._.getUTCMilliseconds();
	    },
	    getMinutes: function() {
	      return this._.getUTCMinutes();
	    },
	    getMonth: function() {
	      return this._.getUTCMonth();
	    },
	    getSeconds: function() {
	      return this._.getUTCSeconds();
	    },
	    getTime: function() {
	      return this._.getTime();
	    },
	    getTimezoneOffset: function() {
	      return 0;
	    },
	    valueOf: function() {
	      return this._.valueOf();
	    },
	    setDate: function() {
	      d3_time_prototype.setUTCDate.apply(this._, arguments);
	    },
	    setDay: function() {
	      d3_time_prototype.setUTCDay.apply(this._, arguments);
	    },
	    setFullYear: function() {
	      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
	    },
	    setHours: function() {
	      d3_time_prototype.setUTCHours.apply(this._, arguments);
	    },
	    setMilliseconds: function() {
	      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
	    },
	    setMinutes: function() {
	      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
	    },
	    setMonth: function() {
	      d3_time_prototype.setUTCMonth.apply(this._, arguments);
	    },
	    setSeconds: function() {
	      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
	    },
	    setTime: function() {
	      d3_time_prototype.setTime.apply(this._, arguments);
	    }
	  };
	  var d3_time_prototype = Date.prototype;
	  function d3_time_interval(local, step, number) {
	    function round(date) {
	      var d0 = local(date), d1 = offset(d0, 1);
	      return date - d0 < d1 - date ? d0 : d1;
	    }
	    function ceil(date) {
	      step(date = local(new d3_date(date - 1)), 1);
	      return date;
	    }
	    function offset(date, k) {
	      step(date = new d3_date(+date), k);
	      return date;
	    }
	    function range(t0, t1, dt) {
	      var time = ceil(t0), times = [];
	      if (dt > 1) {
	        while (time < t1) {
	          if (!(number(time) % dt)) times.push(new Date(+time));
	          step(time, 1);
	        }
	      } else {
	        while (time < t1) times.push(new Date(+time)), step(time, 1);
	      }
	      return times;
	    }
	    function range_utc(t0, t1, dt) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = t0;
	        return range(utc, t1, dt);
	      } finally {
	        d3_date = Date;
	      }
	    }
	    local.floor = local;
	    local.round = round;
	    local.ceil = ceil;
	    local.offset = offset;
	    local.range = range;
	    var utc = local.utc = d3_time_interval_utc(local);
	    utc.floor = utc;
	    utc.round = d3_time_interval_utc(round);
	    utc.ceil = d3_time_interval_utc(ceil);
	    utc.offset = d3_time_interval_utc(offset);
	    utc.range = range_utc;
	    return local;
	  }
	  function d3_time_interval_utc(method) {
	    return function(date, k) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = date;
	        return method(utc, k)._;
	      } finally {
	        d3_date = Date;
	      }
	    };
	  }
	  d3_time.year = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setMonth(0, 1);
	    return date;
	  }, function(date, offset) {
	    date.setFullYear(date.getFullYear() + offset);
	  }, function(date) {
	    return date.getFullYear();
	  });
	  d3_time.years = d3_time.year.range;
	  d3_time.years.utc = d3_time.year.utc.range;
	  d3_time.day = d3_time_interval(function(date) {
	    var day = new d3_date(2e3, 0);
	    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
	    return day;
	  }, function(date, offset) {
	    date.setDate(date.getDate() + offset);
	  }, function(date) {
	    return date.getDate() - 1;
	  });
	  d3_time.days = d3_time.day.range;
	  d3_time.days.utc = d3_time.day.utc.range;
	  d3_time.dayOfYear = function(date) {
	    var year = d3_time.year(date);
	    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
	  };
	  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
	    i = 7 - i;
	    var interval = d3_time[day] = d3_time_interval(function(date) {
	      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
	      return date;
	    }, function(date, offset) {
	      date.setDate(date.getDate() + Math.floor(offset) * 7);
	    }, function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
	    });
	    d3_time[day + "s"] = interval.range;
	    d3_time[day + "s"].utc = interval.utc.range;
	    d3_time[day + "OfYear"] = function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
	    };
	  });
	  d3_time.week = d3_time.sunday;
	  d3_time.weeks = d3_time.sunday.range;
	  d3_time.weeks.utc = d3_time.sunday.utc.range;
	  d3_time.weekOfYear = d3_time.sundayOfYear;
	  function d3_locale_timeFormat(locale) {
	    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
	    function d3_time_format(template) {
	      var n = template.length;
	      function format(date) {
	        var string = [], i = -1, j = 0, c, p, f;
	        while (++i < n) {
	          if (template.charCodeAt(i) === 37) {
	            string.push(template.slice(j, i));
	            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
	            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
	            string.push(c);
	            j = i + 1;
	          }
	        }
	        string.push(template.slice(j, i));
	        return string.join("");
	      }
	      format.parse = function(string) {
	        var d = {
	          y: 1900,
	          m: 0,
	          d: 1,
	          H: 0,
	          M: 0,
	          S: 0,
	          L: 0,
	          Z: null
	        }, i = d3_time_parse(d, template, string, 0);
	        if (i != string.length) return null;
	        if ("p" in d) d.H = d.H % 12 + d.p * 12;
	        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
	        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("w" in d && ("W" in d || "U" in d)) {
	          date.setFullYear(d.y, 0, 1);
	          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
	        } else date.setFullYear(d.y, d.m, d.d);
	        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
	        return localZ ? date._ : date;
	      };
	      format.toString = function() {
	        return template;
	      };
	      return format;
	    }
	    function d3_time_parse(date, template, string, j) {
	      var c, p, t, i = 0, n = template.length, m = string.length;
	      while (i < n) {
	        if (j >= m) return -1;
	        c = template.charCodeAt(i++);
	        if (c === 37) {
	          t = template.charAt(i++);
	          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
	          if (!p || (j = p(date, string, j)) < 0) return -1;
	        } else if (c != string.charCodeAt(j++)) {
	          return -1;
	        }
	      }
	      return j;
	    }
	    d3_time_format.utc = function(template) {
	      var local = d3_time_format(template);
	      function format(date) {
	        try {
	          d3_date = d3_date_utc;
	          var utc = new d3_date();
	          utc._ = date;
	          return local(utc);
	        } finally {
	          d3_date = Date;
	        }
	      }
	      format.parse = function(string) {
	        try {
	          d3_date = d3_date_utc;
	          var date = local.parse(string);
	          return date && date._;
	        } finally {
	          d3_date = Date;
	        }
	      };
	      format.toString = local.toString;
	      return format;
	    };
	    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
	    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
	    locale_periods.forEach(function(p, i) {
	      d3_time_periodLookup.set(p.toLowerCase(), i);
	    });
	    var d3_time_formats = {
	      a: function(d) {
	        return locale_shortDays[d.getDay()];
	      },
	      A: function(d) {
	        return locale_days[d.getDay()];
	      },
	      b: function(d) {
	        return locale_shortMonths[d.getMonth()];
	      },
	      B: function(d) {
	        return locale_months[d.getMonth()];
	      },
	      c: d3_time_format(locale_dateTime),
	      d: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      e: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      H: function(d, p) {
	        return d3_time_formatPad(d.getHours(), p, 2);
	      },
	      I: function(d, p) {
	        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
	      },
	      j: function(d, p) {
	        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
	      },
	      L: function(d, p) {
	        return d3_time_formatPad(d.getMilliseconds(), p, 3);
	      },
	      m: function(d, p) {
	        return d3_time_formatPad(d.getMonth() + 1, p, 2);
	      },
	      M: function(d, p) {
	        return d3_time_formatPad(d.getMinutes(), p, 2);
	      },
	      p: function(d) {
	        return locale_periods[+(d.getHours() >= 12)];
	      },
	      S: function(d, p) {
	        return d3_time_formatPad(d.getSeconds(), p, 2);
	      },
	      U: function(d, p) {
	        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
	      },
	      w: function(d) {
	        return d.getDay();
	      },
	      W: function(d, p) {
	        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
	      },
	      x: d3_time_format(locale_date),
	      X: d3_time_format(locale_time),
	      y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
	      },
	      Y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
	      },
	      Z: d3_time_zone,
	      "%": function() {
	        return "%";
	      }
	    };
	    var d3_time_parsers = {
	      a: d3_time_parseWeekdayAbbrev,
	      A: d3_time_parseWeekday,
	      b: d3_time_parseMonthAbbrev,
	      B: d3_time_parseMonth,
	      c: d3_time_parseLocaleFull,
	      d: d3_time_parseDay,
	      e: d3_time_parseDay,
	      H: d3_time_parseHour24,
	      I: d3_time_parseHour24,
	      j: d3_time_parseDayOfYear,
	      L: d3_time_parseMilliseconds,
	      m: d3_time_parseMonthNumber,
	      M: d3_time_parseMinutes,
	      p: d3_time_parseAmPm,
	      S: d3_time_parseSeconds,
	      U: d3_time_parseWeekNumberSunday,
	      w: d3_time_parseWeekdayNumber,
	      W: d3_time_parseWeekNumberMonday,
	      x: d3_time_parseLocaleDate,
	      X: d3_time_parseLocaleTime,
	      y: d3_time_parseYear,
	      Y: d3_time_parseFullYear,
	      Z: d3_time_parseZone,
	      "%": d3_time_parseLiteralPercent
	    };
	    function d3_time_parseWeekdayAbbrev(date, string, i) {
	      d3_time_dayAbbrevRe.lastIndex = 0;
	      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseWeekday(date, string, i) {
	      d3_time_dayRe.lastIndex = 0;
	      var n = d3_time_dayRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonthAbbrev(date, string, i) {
	      d3_time_monthAbbrevRe.lastIndex = 0;
	      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonth(date, string, i) {
	      d3_time_monthRe.lastIndex = 0;
	      var n = d3_time_monthRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseLocaleFull(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
	    }
	    function d3_time_parseLocaleDate(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
	    }
	    function d3_time_parseLocaleTime(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
	    }
	    function d3_time_parseAmPm(date, string, i) {
	      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
	      return n == null ? -1 : (date.p = n, i);
	    }
	    return d3_time_format;
	  }
	  var d3_time_formatPads = {
	    "-": "",
	    _: " ",
	    "0": "0"
	  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
	  function d3_time_formatPad(value, fill, width) {
	    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
	    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
	  }
	  function d3_time_formatRe(names) {
	    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
	  }
	  function d3_time_formatLookup(names) {
	    var map = new d3_Map(), i = -1, n = names.length;
	    while (++i < n) map.set(names[i].toLowerCase(), i);
	    return map;
	  }
	  function d3_time_parseWeekdayNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
	    return n ? (date.w = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberSunday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.U = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberMonday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.W = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseFullYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
	    return n ? (date.y = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
	  }
	  function d3_time_parseZone(date, string, i) {
	    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
	    i + 5) : -1;
	  }
	  function d3_time_expandYear(d) {
	    return d + (d > 68 ? 1900 : 2e3);
	  }
	  function d3_time_parseMonthNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
	  }
	  function d3_time_parseDay(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.d = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseDayOfYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.j = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseHour24(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.H = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMinutes(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.M = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseSeconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.S = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMilliseconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.L = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_zone(d) {
	    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
	    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
	  }
	  function d3_time_parseLiteralPercent(date, string, i) {
	    d3_time_percentRe.lastIndex = 0;
	    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
	    return n ? i + n[0].length : -1;
	  }
	  function d3_time_formatMulti(formats) {
	    var n = formats.length, i = -1;
	    while (++i < n) formats[i][0] = this(formats[i][0]);
	    return function(date) {
	      var i = 0, f = formats[i];
	      while (!f[1](date)) f = formats[++i];
	      return f[0](date);
	    };
	  }
	  d3.locale = function(locale) {
	    return {
	      numberFormat: d3_locale_numberFormat(locale),
	      timeFormat: d3_locale_timeFormat(locale)
	    };
	  };
	  var d3_locale_enUS = d3.locale({
	    decimal: ".",
	    thousands: ",",
	    grouping: [ 3 ],
	    currency: [ "$", "" ],
	    dateTime: "%a %b %e %X %Y",
	    date: "%m/%d/%Y",
	    time: "%H:%M:%S",
	    periods: [ "AM", "PM" ],
	    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
	    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
	    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
	    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
	  });
	  d3.format = d3_locale_enUS.numberFormat;
	  d3.geo = {};
	  function d3_adder() {}
	  d3_adder.prototype = {
	    s: 0,
	    t: 0,
	    add: function(y) {
	      d3_adderSum(y, this.t, d3_adderTemp);
	      d3_adderSum(d3_adderTemp.s, this.s, this);
	      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
	    },
	    reset: function() {
	      this.s = this.t = 0;
	    },
	    valueOf: function() {
	      return this.s;
	    }
	  };
	  var d3_adderTemp = new d3_adder();
	  function d3_adderSum(a, b, o) {
	    var x = o.s = a + b, bv = x - a, av = x - bv;
	    o.t = a - av + (b - bv);
	  }
	  d3.geo.stream = function(object, listener) {
	    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
	      d3_geo_streamObjectType[object.type](object, listener);
	    } else {
	      d3_geo_streamGeometry(object, listener);
	    }
	  };
	  function d3_geo_streamGeometry(geometry, listener) {
	    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
	      d3_geo_streamGeometryType[geometry.type](geometry, listener);
	    }
	  }
	  var d3_geo_streamObjectType = {
	    Feature: function(feature, listener) {
	      d3_geo_streamGeometry(feature.geometry, listener);
	    },
	    FeatureCollection: function(object, listener) {
	      var features = object.features, i = -1, n = features.length;
	      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
	    }
	  };
	  var d3_geo_streamGeometryType = {
	    Sphere: function(object, listener) {
	      listener.sphere();
	    },
	    Point: function(object, listener) {
	      object = object.coordinates;
	      listener.point(object[0], object[1], object[2]);
	    },
	    MultiPoint: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
	    },
	    LineString: function(object, listener) {
	      d3_geo_streamLine(object.coordinates, listener, 0);
	    },
	    MultiLineString: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
	    },
	    Polygon: function(object, listener) {
	      d3_geo_streamPolygon(object.coordinates, listener);
	    },
	    MultiPolygon: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
	    },
	    GeometryCollection: function(object, listener) {
	      var geometries = object.geometries, i = -1, n = geometries.length;
	      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
	    }
	  };
	  function d3_geo_streamLine(coordinates, listener, closed) {
	    var i = -1, n = coordinates.length - closed, coordinate;
	    listener.lineStart();
	    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
	    listener.lineEnd();
	  }
	  function d3_geo_streamPolygon(coordinates, listener) {
	    var i = -1, n = coordinates.length;
	    listener.polygonStart();
	    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
	    listener.polygonEnd();
	  }
	  d3.geo.area = function(object) {
	    d3_geo_areaSum = 0;
	    d3.geo.stream(object, d3_geo_area);
	    return d3_geo_areaSum;
	  };
	  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
	  var d3_geo_area = {
	    sphere: function() {
	      d3_geo_areaSum += 4 * π;
	    },
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_areaRingSum.reset();
	      d3_geo_area.lineStart = d3_geo_areaRingStart;
	    },
	    polygonEnd: function() {
	      var area = 2 * d3_geo_areaRingSum;
	      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
	      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
	    }
	  };
	  function d3_geo_areaRingStart() {
	    var λ00, φ00, λ0, cosφ0, sinφ0;
	    d3_geo_area.point = function(λ, φ) {
	      d3_geo_area.point = nextPoint;
	      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
	      sinφ0 = Math.sin(φ);
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      φ = φ * d3_radians / 2 + π / 4;
	      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
	      d3_geo_areaRingSum.add(Math.atan2(v, u));
	      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
	    }
	    d3_geo_area.lineEnd = function() {
	      nextPoint(λ00, φ00);
	    };
	  }
	  function d3_geo_cartesian(spherical) {
	    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
	    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
	  }
	  function d3_geo_cartesianDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	  }
	  function d3_geo_cartesianCross(a, b) {
	    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
	  }
	  function d3_geo_cartesianAdd(a, b) {
	    a[0] += b[0];
	    a[1] += b[1];
	    a[2] += b[2];
	  }
	  function d3_geo_cartesianScale(vector, k) {
	    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
	  }
	  function d3_geo_cartesianNormalize(d) {
	    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
	    d[0] /= l;
	    d[1] /= l;
	    d[2] /= l;
	  }
	  function d3_geo_spherical(cartesian) {
	    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
	  }
	  function d3_geo_sphericalEqual(a, b) {
	    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
	  }
	  d3.geo.bounds = function() {
	    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
	    var bound = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        bound.point = ringPoint;
	        bound.lineStart = ringStart;
	        bound.lineEnd = ringEnd;
	        dλSum = 0;
	        d3_geo_area.polygonStart();
	      },
	      polygonEnd: function() {
	        d3_geo_area.polygonEnd();
	        bound.point = point;
	        bound.lineStart = lineStart;
	        bound.lineEnd = lineEnd;
	        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
	        range[0] = λ0, range[1] = λ1;
	      }
	    };
	    function point(λ, φ) {
	      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
	      if (φ < φ0) φ0 = φ;
	      if (φ > φ1) φ1 = φ;
	    }
	    function linePoint(λ, φ) {
	      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
	      if (p0) {
	        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
	        d3_geo_cartesianNormalize(inflection);
	        inflection = d3_geo_spherical(inflection);
	        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
	        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
	          var φi = inflection[1] * d3_degrees;
	          if (φi > φ1) φ1 = φi;
	        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
	          var φi = -inflection[1] * d3_degrees;
	          if (φi < φ0) φ0 = φi;
	        } else {
	          if (φ < φ0) φ0 = φ;
	          if (φ > φ1) φ1 = φ;
	        }
	        if (antimeridian) {
	          if (λ < λ_) {
	            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
	          } else {
	            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
	          }
	        } else {
	          if (λ1 >= λ0) {
	            if (λ < λ0) λ0 = λ;
	            if (λ > λ1) λ1 = λ;
	          } else {
	            if (λ > λ_) {
	              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
	            } else {
	              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
	            }
	          }
	        }
	      } else {
	        point(λ, φ);
	      }
	      p0 = p, λ_ = λ;
	    }
	    function lineStart() {
	      bound.point = linePoint;
	    }
	    function lineEnd() {
	      range[0] = λ0, range[1] = λ1;
	      bound.point = point;
	      p0 = null;
	    }
	    function ringPoint(λ, φ) {
	      if (p0) {
	        var dλ = λ - λ_;
	        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
	      } else λ__ = λ, φ__ = φ;
	      d3_geo_area.point(λ, φ);
	      linePoint(λ, φ);
	    }
	    function ringStart() {
	      d3_geo_area.lineStart();
	    }
	    function ringEnd() {
	      ringPoint(λ__, φ__);
	      d3_geo_area.lineEnd();
	      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
	      range[0] = λ0, range[1] = λ1;
	      p0 = null;
	    }
	    function angle(λ0, λ1) {
	      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
	    }
	    function compareRanges(a, b) {
	      return a[0] - b[0];
	    }
	    function withinRange(x, range) {
	      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
	    }
	    return function(feature) {
	      φ1 = λ1 = -(λ0 = φ0 = Infinity);
	      ranges = [];
	      d3.geo.stream(feature, bound);
	      var n = ranges.length;
	      if (n) {
	        ranges.sort(compareRanges);
	        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
	          b = ranges[i];
	          if (withinRange(b[0], a) || withinRange(b[1], a)) {
	            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
	            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
	          } else {
	            merged.push(a = b);
	          }
	        }
	        var best = -Infinity, dλ;
	        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
	          b = merged[i];
	          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
	        }
	      }
	      ranges = range = null;
	      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
	    };
	  }();
	  d3.geo.centroid = function(object) {
	    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	    d3.geo.stream(object, d3_geo_centroid);
	    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
	    if (m < ε2) {
	      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
	      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
	      m = x * x + y * y + z * z;
	      if (m < ε2) return [ NaN, NaN ];
	    }
	    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
	  };
	  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
	  var d3_geo_centroid = {
	    sphere: d3_noop,
	    point: d3_geo_centroidPoint,
	    lineStart: d3_geo_centroidLineStart,
	    lineEnd: d3_geo_centroidLineEnd,
	    polygonStart: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
	    }
	  };
	  function d3_geo_centroidPoint(λ, φ) {
	    λ *= d3_radians;
	    var cosφ = Math.cos(φ *= d3_radians);
	    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
	  }
	  function d3_geo_centroidPointXYZ(x, y, z) {
	    ++d3_geo_centroidW0;
	    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
	    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
	    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
	  }
	  function d3_geo_centroidLineStart() {
	    var x0, y0, z0;
	    d3_geo_centroid.point = function(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians);
	      x0 = cosφ * Math.cos(λ);
	      y0 = cosφ * Math.sin(λ);
	      z0 = Math.sin(φ);
	      d3_geo_centroid.point = nextPoint;
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_geo_centroidLineEnd() {
	    d3_geo_centroid.point = d3_geo_centroidPoint;
	  }
	  function d3_geo_centroidRingStart() {
	    var λ00, φ00, x0, y0, z0;
	    d3_geo_centroid.point = function(λ, φ) {
	      λ00 = λ, φ00 = φ;
	      d3_geo_centroid.point = nextPoint;
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians);
	      x0 = cosφ * Math.cos(λ);
	      y0 = cosφ * Math.sin(λ);
	      z0 = Math.sin(φ);
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    d3_geo_centroid.lineEnd = function() {
	      nextPoint(λ00, φ00);
	      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
	      d3_geo_centroid.point = d3_geo_centroidPoint;
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
	      d3_geo_centroidX2 += v * cx;
	      d3_geo_centroidY2 += v * cy;
	      d3_geo_centroidZ2 += v * cz;
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_true() {
	    return true;
	  }
	  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
	    var subject = [], clip = [];
	    segments.forEach(function(segment) {
	      if ((n = segment.length - 1) <= 0) return;
	      var n, p0 = segment[0], p1 = segment[n];
	      if (d3_geo_sphericalEqual(p0, p1)) {
	        listener.lineStart();
	        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
	        listener.lineEnd();
	        return;
	      }
	      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
	      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	    });
	    clip.sort(compare);
	    d3_geo_clipPolygonLinkCircular(subject);
	    d3_geo_clipPolygonLinkCircular(clip);
	    if (!subject.length) return;
	    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
	      clip[i].e = entry = !entry;
	    }
	    var start = subject[0], points, point;
	    while (1) {
	      var current = start, isSubject = true;
	      while (current.v) if ((current = current.n) === start) return;
	      points = current.z;
	      listener.lineStart();
	      do {
	        current.v = current.o.v = true;
	        if (current.e) {
	          if (isSubject) {
	            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.n.x, 1, listener);
	          }
	          current = current.n;
	        } else {
	          if (isSubject) {
	            points = current.p.z;
	            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.p.x, -1, listener);
	          }
	          current = current.p;
	        }
	        current = current.o;
	        points = current.z;
	        isSubject = !isSubject;
	      } while (!current.v);
	      listener.lineEnd();
	    }
	  }
	  function d3_geo_clipPolygonLinkCircular(array) {
	    if (!(n = array.length)) return;
	    var n, i = 0, a = array[0], b;
	    while (++i < n) {
	      a.n = b = array[i];
	      b.p = a;
	      a = b;
	    }
	    a.n = b = array[0];
	    b.p = a;
	  }
	  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
	    this.x = point;
	    this.z = points;
	    this.o = other;
	    this.e = entry;
	    this.v = false;
	    this.n = this.p = null;
	  }
	  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
	    return function(rotate, listener) {
	      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          clip.point = pointRing;
	          clip.lineStart = ringStart;
	          clip.lineEnd = ringEnd;
	          segments = [];
	          polygon = [];
	        },
	        polygonEnd: function() {
	          clip.point = point;
	          clip.lineStart = lineStart;
	          clip.lineEnd = lineEnd;
	          segments = d3.merge(segments);
	          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
	          if (segments.length) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
	          } else if (clipStartInside) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            interpolate(null, null, 1, listener);
	            listener.lineEnd();
	          }
	          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
	          segments = polygon = null;
	        },
	        sphere: function() {
	          listener.polygonStart();
	          listener.lineStart();
	          interpolate(null, null, 1, listener);
	          listener.lineEnd();
	          listener.polygonEnd();
	        }
	      };
	      function point(λ, φ) {
	        var point = rotate(λ, φ);
	        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
	      }
	      function pointLine(λ, φ) {
	        var point = rotate(λ, φ);
	        line.point(point[0], point[1]);
	      }
	      function lineStart() {
	        clip.point = pointLine;
	        line.lineStart();
	      }
	      function lineEnd() {
	        clip.point = point;
	        line.lineEnd();
	      }
	      var segments;
	      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
	      function pointRing(λ, φ) {
	        ring.push([ λ, φ ]);
	        var point = rotate(λ, φ);
	        ringListener.point(point[0], point[1]);
	      }
	      function ringStart() {
	        ringListener.lineStart();
	        ring = [];
	      }
	      function ringEnd() {
	        pointRing(ring[0][0], ring[0][1]);
	        ringListener.lineEnd();
	        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
	        ring.pop();
	        polygon.push(ring);
	        ring = null;
	        if (!n) return;
	        if (clean & 1) {
	          segment = ringSegments[0];
	          var n = segment.length - 1, i = -1, point;
	          if (n > 0) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            while (++i < n) listener.point((point = segment[i])[0], point[1]);
	            listener.lineEnd();
	          }
	          return;
	        }
	        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
	        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
	      }
	      return clip;
	    };
	  }
	  function d3_geo_clipSegmentLength1(segment) {
	    return segment.length > 1;
	  }
	  function d3_geo_clipBufferListener() {
	    var lines = [], line;
	    return {
	      lineStart: function() {
	        lines.push(line = []);
	      },
	      point: function(λ, φ) {
	        line.push([ λ, φ ]);
	      },
	      lineEnd: d3_noop,
	      buffer: function() {
	        var buffer = lines;
	        lines = [];
	        line = null;
	        return buffer;
	      },
	      rejoin: function() {
	        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
	      }
	    };
	  }
	  function d3_geo_clipSort(a, b) {
	    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
	  }
	  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
	  function d3_geo_clipAntimeridianLine(listener) {
	    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
	    return {
	      lineStart: function() {
	        listener.lineStart();
	        clean = 1;
	      },
	      point: function(λ1, φ1) {
	        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
	        if (abs(dλ - π) < ε) {
	          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
	          listener.point(sλ0, φ0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(sλ1, φ0);
	          listener.point(λ1, φ0);
	          clean = 0;
	        } else if (sλ0 !== sλ1 && dλ >= π) {
	          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
	          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
	          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
	          listener.point(sλ0, φ0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(sλ1, φ0);
	          clean = 0;
	        }
	        listener.point(λ0 = λ1, φ0 = φ1);
	        sλ0 = sλ1;
	      },
	      lineEnd: function() {
	        listener.lineEnd();
	        λ0 = φ0 = NaN;
	      },
	      clean: function() {
	        return 2 - clean;
	      }
	    };
	  }
	  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
	    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
	    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
	  }
	  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
	    var φ;
	    if (from == null) {
	      φ = direction * halfπ;
	      listener.point(-π, φ);
	      listener.point(0, φ);
	      listener.point(π, φ);
	      listener.point(π, 0);
	      listener.point(π, -φ);
	      listener.point(0, -φ);
	      listener.point(-π, -φ);
	      listener.point(-π, 0);
	      listener.point(-π, φ);
	    } else if (abs(from[0] - to[0]) > ε) {
	      var s = from[0] < to[0] ? π : -π;
	      φ = direction * s / 2;
	      listener.point(-s, φ);
	      listener.point(0, φ);
	      listener.point(s, φ);
	    } else {
	      listener.point(to[0], to[1]);
	    }
	  }
	  function d3_geo_pointInPolygon(point, polygon) {
	    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
	    d3_geo_areaRingSum.reset();
	    for (var i = 0, n = polygon.length; i < n; ++i) {
	      var ring = polygon[i], m = ring.length;
	      if (!m) continue;
	      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
	      while (true) {
	        if (j === m) j = 0;
	        point = ring[j];
	        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
	        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
	        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
	        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
	          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
	          d3_geo_cartesianNormalize(arc);
	          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
	          d3_geo_cartesianNormalize(intersection);
	          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
	          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
	            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
	          }
	        }
	        if (!j++) break;
	        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
	      }
	    }
	    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
	  }
	  function d3_geo_clipCircle(radius) {
	    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
	    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
	    function visible(λ, φ) {
	      return Math.cos(λ) * Math.cos(φ) > cr;
	    }
	    function clipLine(listener) {
	      var point0, c0, v0, v00, clean;
	      return {
	        lineStart: function() {
	          v00 = v0 = false;
	          clean = 1;
	        },
	        point: function(λ, φ) {
	          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
	          if (!point0 && (v00 = v0 = v)) listener.lineStart();
	          if (v !== v0) {
	            point2 = intersect(point0, point1);
	            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
	              point1[0] += ε;
	              point1[1] += ε;
	              v = visible(point1[0], point1[1]);
	            }
	          }
	          if (v !== v0) {
	            clean = 0;
	            if (v) {
	              listener.lineStart();
	              point2 = intersect(point1, point0);
	              listener.point(point2[0], point2[1]);
	            } else {
	              point2 = intersect(point0, point1);
	              listener.point(point2[0], point2[1]);
	              listener.lineEnd();
	            }
	            point0 = point2;
	          } else if (notHemisphere && point0 && smallRadius ^ v) {
	            var t;
	            if (!(c & c0) && (t = intersect(point1, point0, true))) {
	              clean = 0;
	              if (smallRadius) {
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	              } else {
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	              }
	            }
	          }
	          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
	            listener.point(point1[0], point1[1]);
	          }
	          point0 = point1, v0 = v, c0 = c;
	        },
	        lineEnd: function() {
	          if (v0) listener.lineEnd();
	          point0 = null;
	        },
	        clean: function() {
	          return clean | (v00 && v0) << 1;
	        }
	      };
	    }
	    function intersect(a, b, two) {
	      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
	      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
	      if (!determinant) return !two && a;
	      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
	      d3_geo_cartesianAdd(A, B);
	      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
	      if (t2 < 0) return;
	      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
	      d3_geo_cartesianAdd(q, A);
	      q = d3_geo_spherical(q);
	      if (!two) return q;
	      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
	      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
	      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
	      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
	      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
	        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
	        d3_geo_cartesianAdd(q1, A);
	        return [ q, d3_geo_spherical(q1) ];
	      }
	    }
	    function code(λ, φ) {
	      var r = smallRadius ? radius : π - radius, code = 0;
	      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
	      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
	      return code;
	    }
	  }
	  function d3_geom_clipLine(x0, y0, x1, y1) {
	    return function(line) {
	      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
	      r = x0 - ax;
	      if (!dx && r > 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dx > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = x1 - ax;
	      if (!dx && r < 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dx > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      r = y0 - ay;
	      if (!dy && r > 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dy > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = y1 - ay;
	      if (!dy && r < 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dy > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      if (t0 > 0) line.a = {
	        x: ax + t0 * dx,
	        y: ay + t0 * dy
	      };
	      if (t1 < 1) line.b = {
	        x: ax + t1 * dx,
	        y: ay + t1 * dy
	      };
	      return line;
	    };
	  }
	  var d3_geo_clipExtentMAX = 1e9;
	  d3.geo.clipExtent = function() {
	    var x0, y0, x1, y1, stream, clip, clipExtent = {
	      stream: function(output) {
	        if (stream) stream.valid = false;
	        stream = clip(output);
	        stream.valid = true;
	        return stream;
	      },
	      extent: function(_) {
	        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
	        if (stream) stream.valid = false, stream = null;
	        return clipExtent;
	      }
	    };
	    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
	  };
	  function d3_geo_clipExtent(x0, y0, x1, y1) {
	    return function(listener) {
	      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          listener = bufferListener;
	          segments = [];
	          polygon = [];
	          clean = true;
	        },
	        polygonEnd: function() {
	          listener = listener_;
	          segments = d3.merge(segments);
	          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
	          if (inside || visible) {
	            listener.polygonStart();
	            if (inside) {
	              listener.lineStart();
	              interpolate(null, null, 1, listener);
	              listener.lineEnd();
	            }
	            if (visible) {
	              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
	            }
	            listener.polygonEnd();
	          }
	          segments = polygon = ring = null;
	        }
	      };
	      function insidePolygon(p) {
	        var wn = 0, n = polygon.length, y = p[1];
	        for (var i = 0; i < n; ++i) {
	          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
	            b = v[j];
	            if (a[1] <= y) {
	              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
	            } else {
	              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
	            }
	            a = b;
	          }
	        }
	        return wn !== 0;
	      }
	      function interpolate(from, to, direction, listener) {
	        var a = 0, a1 = 0;
	        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
	          do {
	            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
	          } while ((a = (a + direction + 4) % 4) !== a1);
	        } else {
	          listener.point(to[0], to[1]);
	        }
	      }
	      function pointVisible(x, y) {
	        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
	      }
	      function point(x, y) {
	        if (pointVisible(x, y)) listener.point(x, y);
	      }
	      var x__, y__, v__, x_, y_, v_, first, clean;
	      function lineStart() {
	        clip.point = linePoint;
	        if (polygon) polygon.push(ring = []);
	        first = true;
	        v_ = false;
	        x_ = y_ = NaN;
	      }
	      function lineEnd() {
	        if (segments) {
	          linePoint(x__, y__);
	          if (v__ && v_) bufferListener.rejoin();
	          segments.push(bufferListener.buffer());
	        }
	        clip.point = point;
	        if (v_) listener.lineEnd();
	      }
	      function linePoint(x, y) {
	        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
	        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
	        var v = pointVisible(x, y);
	        if (polygon) ring.push([ x, y ]);
	        if (first) {
	          x__ = x, y__ = y, v__ = v;
	          first = false;
	          if (v) {
	            listener.lineStart();
	            listener.point(x, y);
	          }
	        } else {
	          if (v && v_) listener.point(x, y); else {
	            var l = {
	              a: {
	                x: x_,
	                y: y_
	              },
	              b: {
	                x: x,
	                y: y
	              }
	            };
	            if (clipLine(l)) {
	              if (!v_) {
	                listener.lineStart();
	                listener.point(l.a.x, l.a.y);
	              }
	              listener.point(l.b.x, l.b.y);
	              if (!v) listener.lineEnd();
	              clean = false;
	            } else if (v) {
	              listener.lineStart();
	              listener.point(x, y);
	              clean = false;
	            }
	          }
	        }
	        x_ = x, y_ = y, v_ = v;
	      }
	      return clip;
	    };
	    function corner(p, direction) {
	      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
	    }
	    function compare(a, b) {
	      return comparePoints(a.x, b.x);
	    }
	    function comparePoints(a, b) {
	      var ca = corner(a, 1), cb = corner(b, 1);
	      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
	    }
	  }
	  function d3_geo_compose(a, b) {
	    function compose(x, y) {
	      return x = a(x, y), b(x[0], x[1]);
	    }
	    if (a.invert && b.invert) compose.invert = function(x, y) {
	      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
	    };
	    return compose;
	  }
	  function d3_geo_conic(projectAt) {
	    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
	    p.parallels = function(_) {
	      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
	      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
	    };
	    return p;
	  }
	  function d3_geo_conicEqualArea(φ0, φ1) {
	    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
	    function forward(λ, φ) {
	      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
	      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = ρ0 - y;
	      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEqualArea = function() {
	    return d3_geo_conic(d3_geo_conicEqualArea);
	  }).raw = d3_geo_conicEqualArea;
	  d3.geo.albers = function() {
	    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
	  };
	  d3.geo.albersUsa = function() {
	    var lower48 = d3.geo.albers();
	    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
	    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
	    var point, pointStream = {
	      point: function(x, y) {
	        point = [ x, y ];
	      }
	    }, lower48Point, alaskaPoint, hawaiiPoint;
	    function albersUsa(coordinates) {
	      var x = coordinates[0], y = coordinates[1];
	      point = null;
	      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
	      return point;
	    }
	    albersUsa.invert = function(coordinates) {
	      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
	      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
	    };
	    albersUsa.stream = function(stream) {
	      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
	      return {
	        point: function(x, y) {
	          lower48Stream.point(x, y);
	          alaskaStream.point(x, y);
	          hawaiiStream.point(x, y);
	        },
	        sphere: function() {
	          lower48Stream.sphere();
	          alaskaStream.sphere();
	          hawaiiStream.sphere();
	        },
	        lineStart: function() {
	          lower48Stream.lineStart();
	          alaskaStream.lineStart();
	          hawaiiStream.lineStart();
	        },
	        lineEnd: function() {
	          lower48Stream.lineEnd();
	          alaskaStream.lineEnd();
	          hawaiiStream.lineEnd();
	        },
	        polygonStart: function() {
	          lower48Stream.polygonStart();
	          alaskaStream.polygonStart();
	          hawaiiStream.polygonStart();
	        },
	        polygonEnd: function() {
	          lower48Stream.polygonEnd();
	          alaskaStream.polygonEnd();
	          hawaiiStream.polygonEnd();
	        }
	      };
	    };
	    albersUsa.precision = function(_) {
	      if (!arguments.length) return lower48.precision();
	      lower48.precision(_);
	      alaska.precision(_);
	      hawaii.precision(_);
	      return albersUsa;
	    };
	    albersUsa.scale = function(_) {
	      if (!arguments.length) return lower48.scale();
	      lower48.scale(_);
	      alaska.scale(_ * .35);
	      hawaii.scale(_);
	      return albersUsa.translate(lower48.translate());
	    };
	    albersUsa.translate = function(_) {
	      if (!arguments.length) return lower48.translate();
	      var k = lower48.scale(), x = +_[0], y = +_[1];
	      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
	      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
	      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
	      return albersUsa;
	    };
	    return albersUsa.scale(1070);
	  };
	  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_pathAreaPolygon = 0;
	      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
	      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
	    }
	  };
	  function d3_geo_pathAreaRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathArea.point = function(x, y) {
	      d3_geo_pathArea.point = nextPoint;
	      x00 = x0 = x, y00 = y0 = y;
	    };
	    function nextPoint(x, y) {
	      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
	      x0 = x, y0 = y;
	    }
	    d3_geo_pathArea.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
	  var d3_geo_pathBounds = {
	    point: d3_geo_pathBoundsPoint,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_pathBoundsPoint(x, y) {
	    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
	    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
	    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
	    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
	  }
	  function d3_geo_pathBuffer() {
	    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointCircle = d3_geo_pathBufferCircle(_);
	        return stream;
	      },
	      result: function() {
	        if (buffer.length) {
	          var result = buffer.join("");
	          buffer = [];
	          return result;
	        }
	      }
	    };
	    function point(x, y) {
	      buffer.push("M", x, ",", y, pointCircle);
	    }
	    function pointLineStart(x, y) {
	      buffer.push("M", x, ",", y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      buffer.push("L", x, ",", y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      buffer.push("Z");
	    }
	    return stream;
	  }
	  function d3_geo_pathBufferCircle(radius) {
	    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
	  }
	  var d3_geo_pathCentroid = {
	    point: d3_geo_pathCentroidPoint,
	    lineStart: d3_geo_pathCentroidLineStart,
	    lineEnd: d3_geo_pathCentroidLineEnd,
	    polygonStart: function() {
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
	      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
	    }
	  };
	  function d3_geo_pathCentroidPoint(x, y) {
	    d3_geo_centroidX0 += x;
	    d3_geo_centroidY0 += y;
	    ++d3_geo_centroidZ0;
	  }
	  function d3_geo_pathCentroidLineStart() {
	    var x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	  }
	  function d3_geo_pathCentroidLineEnd() {
	    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	  }
	  function d3_geo_pathCentroidRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      z = y0 * x - x0 * y;
	      d3_geo_centroidX2 += z * (x0 + x);
	      d3_geo_centroidY2 += z * (y0 + y);
	      d3_geo_centroidZ2 += z * 3;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	    d3_geo_pathCentroid.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  function d3_geo_pathContext(context) {
	    var pointRadius = 4.5;
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointRadius = _;
	        return stream;
	      },
	      result: d3_noop
	    };
	    function point(x, y) {
	      context.moveTo(x, y);
	      context.arc(x, y, pointRadius, 0, τ);
	    }
	    function pointLineStart(x, y) {
	      context.moveTo(x, y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      context.lineTo(x, y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      context.closePath();
	    }
	    return stream;
	  }
	  function d3_geo_resample(project) {
	    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
	    function resample(stream) {
	      return (maxDepth ? resampleRecursive : resampleNone)(stream);
	    }
	    function resampleNone(stream) {
	      return d3_geo_transformPoint(stream, function(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      });
	    }
	    function resampleRecursive(stream) {
	      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
	      var resample = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          stream.polygonStart();
	          resample.lineStart = ringStart;
	        },
	        polygonEnd: function() {
	          stream.polygonEnd();
	          resample.lineStart = lineStart;
	        }
	      };
	      function point(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      }
	      function lineStart() {
	        x0 = NaN;
	        resample.point = linePoint;
	        stream.lineStart();
	      }
	      function linePoint(λ, φ) {
	        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
	        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
	        stream.point(x0, y0);
	      }
	      function lineEnd() {
	        resample.point = point;
	        stream.lineEnd();
	      }
	      function ringStart() {
	        lineStart();
	        resample.point = ringPoint;
	        resample.lineEnd = ringEnd;
	      }
	      function ringPoint(λ, φ) {
	        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
	        resample.point = linePoint;
	      }
	      function ringEnd() {
	        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
	        resample.lineEnd = lineEnd;
	        lineEnd();
	      }
	      return resample;
	    }
	    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
	      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
	      if (d2 > 4 * δ2 && depth--) {
	        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
	        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
	          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
	          stream.point(x2, y2);
	          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
	        }
	      }
	    }
	    resample.precision = function(_) {
	      if (!arguments.length) return Math.sqrt(δ2);
	      maxDepth = (δ2 = _ * _) > 0 && 16;
	      return resample;
	    };
	    return resample;
	  }
	  d3.geo.path = function() {
	    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
	    function path(object) {
	      if (object) {
	        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
	        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
	        d3.geo.stream(object, cacheStream);
	      }
	      return contextStream.result();
	    }
	    path.area = function(object) {
	      d3_geo_pathAreaSum = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathArea));
	      return d3_geo_pathAreaSum;
	    };
	    path.centroid = function(object) {
	      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
	      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
	    };
	    path.bounds = function(object) {
	      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
	      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
	      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
	    };
	    path.projection = function(_) {
	      if (!arguments.length) return projection;
	      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
	      return reset();
	    };
	    path.context = function(_) {
	      if (!arguments.length) return context;
	      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
	      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
	      return reset();
	    };
	    path.pointRadius = function(_) {
	      if (!arguments.length) return pointRadius;
	      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
	      return path;
	    };
	    function reset() {
	      cacheStream = null;
	      return path;
	    }
	    return path.projection(d3.geo.albersUsa()).context(null);
	  };
	  function d3_geo_pathProjectStream(project) {
	    var resample = d3_geo_resample(function(x, y) {
	      return project([ x * d3_degrees, y * d3_degrees ]);
	    });
	    return function(stream) {
	      return d3_geo_projectionRadians(resample(stream));
	    };
	  }
	  d3.geo.transform = function(methods) {
	    return {
	      stream: function(stream) {
	        var transform = new d3_geo_transform(stream);
	        for (var k in methods) transform[k] = methods[k];
	        return transform;
	      }
	    };
	  };
	  function d3_geo_transform(stream) {
	    this.stream = stream;
	  }
	  d3_geo_transform.prototype = {
	    point: function(x, y) {
	      this.stream.point(x, y);
	    },
	    sphere: function() {
	      this.stream.sphere();
	    },
	    lineStart: function() {
	      this.stream.lineStart();
	    },
	    lineEnd: function() {
	      this.stream.lineEnd();
	    },
	    polygonStart: function() {
	      this.stream.polygonStart();
	    },
	    polygonEnd: function() {
	      this.stream.polygonEnd();
	    }
	  };
	  function d3_geo_transformPoint(stream, point) {
	    return {
	      point: point,
	      sphere: function() {
	        stream.sphere();
	      },
	      lineStart: function() {
	        stream.lineStart();
	      },
	      lineEnd: function() {
	        stream.lineEnd();
	      },
	      polygonStart: function() {
	        stream.polygonStart();
	      },
	      polygonEnd: function() {
	        stream.polygonEnd();
	      }
	    };
	  }
	  d3.geo.projection = d3_geo_projection;
	  d3.geo.projectionMutator = d3_geo_projectionMutator;
	  function d3_geo_projection(project) {
	    return d3_geo_projectionMutator(function() {
	      return project;
	    })();
	  }
	  function d3_geo_projectionMutator(projectAt) {
	    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
	      x = project(x, y);
	      return [ x[0] * k + δx, δy - x[1] * k ];
	    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
	    function projection(point) {
	      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
	      return [ point[0] * k + δx, δy - point[1] * k ];
	    }
	    function invert(point) {
	      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
	      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
	    }
	    projection.stream = function(output) {
	      if (stream) stream.valid = false;
	      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
	      stream.valid = true;
	      return stream;
	    };
	    projection.clipAngle = function(_) {
	      if (!arguments.length) return clipAngle;
	      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
	      return invalidate();
	    };
	    projection.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent;
	      clipExtent = _;
	      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
	      return invalidate();
	    };
	    projection.scale = function(_) {
	      if (!arguments.length) return k;
	      k = +_;
	      return reset();
	    };
	    projection.translate = function(_) {
	      if (!arguments.length) return [ x, y ];
	      x = +_[0];
	      y = +_[1];
	      return reset();
	    };
	    projection.center = function(_) {
	      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
	      λ = _[0] % 360 * d3_radians;
	      φ = _[1] % 360 * d3_radians;
	      return reset();
	    };
	    projection.rotate = function(_) {
	      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
	      δλ = _[0] % 360 * d3_radians;
	      δφ = _[1] % 360 * d3_radians;
	      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
	      return reset();
	    };
	    d3.rebind(projection, projectResample, "precision");
	    function reset() {
	      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
	      var center = project(λ, φ);
	      δx = x - center[0] * k;
	      δy = y + center[1] * k;
	      return invalidate();
	    }
	    function invalidate() {
	      if (stream) stream.valid = false, stream = null;
	      return projection;
	    }
	    return function() {
	      project = projectAt.apply(this, arguments);
	      projection.invert = project.invert && invert;
	      return reset();
	    };
	  }
	  function d3_geo_projectionRadians(stream) {
	    return d3_geo_transformPoint(stream, function(x, y) {
	      stream.point(x * d3_radians, y * d3_radians);
	    });
	  }
	  function d3_geo_equirectangular(λ, φ) {
	    return [ λ, φ ];
	  }
	  (d3.geo.equirectangular = function() {
	    return d3_geo_projection(d3_geo_equirectangular);
	  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
	  d3.geo.rotation = function(rotate) {
	    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
	    function forward(coordinates) {
	      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    }
	    forward.invert = function(coordinates) {
	      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    };
	    return forward;
	  };
	  function d3_geo_identityRotation(λ, φ) {
	    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
	  }
	  d3_geo_identityRotation.invert = d3_geo_equirectangular;
	  function d3_geo_rotation(δλ, δφ, δγ) {
	    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
	  }
	  function d3_geo_forwardRotationλ(δλ) {
	    return function(λ, φ) {
	      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
	    };
	  }
	  function d3_geo_rotationλ(δλ) {
	    var rotation = d3_geo_forwardRotationλ(δλ);
	    rotation.invert = d3_geo_forwardRotationλ(-δλ);
	    return rotation;
	  }
	  function d3_geo_rotationφγ(δφ, δγ) {
	    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
	    function rotation(λ, φ) {
	      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
	      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
	    }
	    rotation.invert = function(λ, φ) {
	      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
	      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
	    };
	    return rotation;
	  }
	  d3.geo.circle = function() {
	    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
	    function circle() {
	      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
	      interpolate(null, null, 1, {
	        point: function(x, y) {
	          ring.push(x = rotate(x, y));
	          x[0] *= d3_degrees, x[1] *= d3_degrees;
	        }
	      });
	      return {
	        type: "Polygon",
	        coordinates: [ ring ]
	      };
	    }
	    circle.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return circle;
	    };
	    circle.angle = function(x) {
	      if (!arguments.length) return angle;
	      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
	      return circle;
	    };
	    circle.precision = function(_) {
	      if (!arguments.length) return precision;
	      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
	      return circle;
	    };
	    return circle.angle(90);
	  };
	  function d3_geo_circleInterpolate(radius, precision) {
	    var cr = Math.cos(radius), sr = Math.sin(radius);
	    return function(from, to, direction, listener) {
	      var step = direction * precision;
	      if (from != null) {
	        from = d3_geo_circleAngle(cr, from);
	        to = d3_geo_circleAngle(cr, to);
	        if (direction > 0 ? from < to : from > to) from += direction * τ;
	      } else {
	        from = radius + direction * τ;
	        to = radius - .5 * step;
	      }
	      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
	        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
	      }
	    };
	  }
	  function d3_geo_circleAngle(cr, point) {
	    var a = d3_geo_cartesian(point);
	    a[0] -= cr;
	    d3_geo_cartesianNormalize(a);
	    var angle = d3_acos(-a[1]);
	    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
	  }
	  d3.geo.distance = function(a, b) {
	    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
	    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
	  };
	  d3.geo.graticule = function() {
	    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
	    function graticule() {
	      return {
	        type: "MultiLineString",
	        coordinates: lines()
	      };
	    }
	    function lines() {
	      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
	        return abs(x % DX) > ε;
	      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
	        return abs(y % DY) > ε;
	      }).map(y));
	    }
	    graticule.lines = function() {
	      return lines().map(function(coordinates) {
	        return {
	          type: "LineString",
	          coordinates: coordinates
	        };
	      });
	    };
	    graticule.outline = function() {
	      return {
	        type: "Polygon",
	        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
	      };
	    };
	    graticule.extent = function(_) {
	      if (!arguments.length) return graticule.minorExtent();
	      return graticule.majorExtent(_).minorExtent(_);
	    };
	    graticule.majorExtent = function(_) {
	      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
	      X0 = +_[0][0], X1 = +_[1][0];
	      Y0 = +_[0][1], Y1 = +_[1][1];
	      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
	      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.minorExtent = function(_) {
	      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	      x0 = +_[0][0], x1 = +_[1][0];
	      y0 = +_[0][1], y1 = +_[1][1];
	      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
	      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.step = function(_) {
	      if (!arguments.length) return graticule.minorStep();
	      return graticule.majorStep(_).minorStep(_);
	    };
	    graticule.majorStep = function(_) {
	      if (!arguments.length) return [ DX, DY ];
	      DX = +_[0], DY = +_[1];
	      return graticule;
	    };
	    graticule.minorStep = function(_) {
	      if (!arguments.length) return [ dx, dy ];
	      dx = +_[0], dy = +_[1];
	      return graticule;
	    };
	    graticule.precision = function(_) {
	      if (!arguments.length) return precision;
	      precision = +_;
	      x = d3_geo_graticuleX(y0, y1, 90);
	      y = d3_geo_graticuleY(x0, x1, precision);
	      X = d3_geo_graticuleX(Y0, Y1, 90);
	      Y = d3_geo_graticuleY(X0, X1, precision);
	      return graticule;
	    };
	    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
	  };
	  function d3_geo_graticuleX(y0, y1, dy) {
	    var y = d3.range(y0, y1 - ε, dy).concat(y1);
	    return function(x) {
	      return y.map(function(y) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_geo_graticuleY(x0, x1, dx) {
	    var x = d3.range(x0, x1 - ε, dx).concat(x1);
	    return function(y) {
	      return x.map(function(x) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_source(d) {
	    return d.source;
	  }
	  function d3_target(d) {
	    return d.target;
	  }
	  d3.geo.greatArc = function() {
	    var source = d3_source, source_, target = d3_target, target_;
	    function greatArc() {
	      return {
	        type: "LineString",
	        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
	      };
	    }
	    greatArc.distance = function() {
	      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
	    };
	    greatArc.source = function(_) {
	      if (!arguments.length) return source;
	      source = _, source_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.target = function(_) {
	      if (!arguments.length) return target;
	      target = _, target_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.precision = function() {
	      return arguments.length ? greatArc : 0;
	    };
	    return greatArc;
	  };
	  d3.geo.interpolate = function(source, target) {
	    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
	  };
	  function d3_geo_interpolate(x0, y0, x1, y1) {
	    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
	    var interpolate = d ? function(t) {
	      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
	      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
	    } : function() {
	      return [ x0 * d3_degrees, y0 * d3_degrees ];
	    };
	    interpolate.distance = d;
	    return interpolate;
	  }
	  d3.geo.length = function(object) {
	    d3_geo_lengthSum = 0;
	    d3.geo.stream(object, d3_geo_length);
	    return d3_geo_lengthSum;
	  };
	  var d3_geo_lengthSum;
	  var d3_geo_length = {
	    sphere: d3_noop,
	    point: d3_noop,
	    lineStart: d3_geo_lengthLineStart,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_lengthLineStart() {
	    var λ0, sinφ0, cosφ0;
	    d3_geo_length.point = function(λ, φ) {
	      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
	      d3_geo_length.point = nextPoint;
	    };
	    d3_geo_length.lineEnd = function() {
	      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
	    };
	    function nextPoint(λ, φ) {
	      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
	      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
	      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
	    }
	  }
	  function d3_geo_azimuthal(scale, angle) {
	    function azimuthal(λ, φ) {
	      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
	      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
	    }
	    azimuthal.invert = function(x, y) {
	      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
	      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
	    };
	    return azimuthal;
	  }
	  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
	    return Math.sqrt(2 / (1 + cosλcosφ));
	  }, function(ρ) {
	    return 2 * Math.asin(ρ / 2);
	  });
	  (d3.geo.azimuthalEqualArea = function() {
	    return d3_geo_projection(d3_geo_azimuthalEqualArea);
	  }).raw = d3_geo_azimuthalEqualArea;
	  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
	    var c = Math.acos(cosλcosφ);
	    return c && c / Math.sin(c);
	  }, d3_identity);
	  (d3.geo.azimuthalEquidistant = function() {
	    return d3_geo_projection(d3_geo_azimuthalEquidistant);
	  }).raw = d3_geo_azimuthalEquidistant;
	  function d3_geo_conicConformal(φ0, φ1) {
	    var cosφ0 = Math.cos(φ0), t = function(φ) {
	      return Math.tan(π / 4 + φ / 2);
	    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
	    if (!n) return d3_geo_mercator;
	    function forward(λ, φ) {
	      if (F > 0) {
	        if (φ < -halfπ + ε) φ = -halfπ + ε;
	      } else {
	        if (φ > halfπ - ε) φ = halfπ - ε;
	      }
	      var ρ = F / Math.pow(t(φ), n);
	      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
	      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
	    };
	    return forward;
	  }
	  (d3.geo.conicConformal = function() {
	    return d3_geo_conic(d3_geo_conicConformal);
	  }).raw = d3_geo_conicConformal;
	  function d3_geo_conicEquidistant(φ0, φ1) {
	    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
	    if (abs(n) < ε) return d3_geo_equirectangular;
	    function forward(λ, φ) {
	      var ρ = G - φ;
	      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = G - y;
	      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEquidistant = function() {
	    return d3_geo_conic(d3_geo_conicEquidistant);
	  }).raw = d3_geo_conicEquidistant;
	  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
	    return 1 / cosλcosφ;
	  }, Math.atan);
	  (d3.geo.gnomonic = function() {
	    return d3_geo_projection(d3_geo_gnomonic);
	  }).raw = d3_geo_gnomonic;
	  function d3_geo_mercator(λ, φ) {
	    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
	  }
	  d3_geo_mercator.invert = function(x, y) {
	    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
	  };
	  function d3_geo_mercatorProjection(project) {
	    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
	    m.scale = function() {
	      var v = scale.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.translate = function() {
	      var v = translate.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.clipExtent = function(_) {
	      var v = clipExtent.apply(m, arguments);
	      if (v === m) {
	        if (clipAuto = _ == null) {
	          var k = π * scale(), t = translate();
	          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
	        }
	      } else if (clipAuto) {
	        v = null;
	      }
	      return v;
	    };
	    return m.clipExtent(null);
	  }
	  (d3.geo.mercator = function() {
	    return d3_geo_mercatorProjection(d3_geo_mercator);
	  }).raw = d3_geo_mercator;
	  var d3_geo_orthographic = d3_geo_azimuthal(function() {
	    return 1;
	  }, Math.asin);
	  (d3.geo.orthographic = function() {
	    return d3_geo_projection(d3_geo_orthographic);
	  }).raw = d3_geo_orthographic;
	  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
	    return 1 / (1 + cosλcosφ);
	  }, function(ρ) {
	    return 2 * Math.atan(ρ);
	  });
	  (d3.geo.stereographic = function() {
	    return d3_geo_projection(d3_geo_stereographic);
	  }).raw = d3_geo_stereographic;
	  function d3_geo_transverseMercator(λ, φ) {
	    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
	  }
	  d3_geo_transverseMercator.invert = function(x, y) {
	    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
	  };
	  (d3.geo.transverseMercator = function() {
	    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
	    projection.center = function(_) {
	      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
	    };
	    projection.rotate = function(_) {
	      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
	      [ _[0], _[1], _[2] - 90 ]);
	    };
	    return rotate([ 0, 0, 90 ]);
	  }).raw = d3_geo_transverseMercator;
	  d3.geom = {};
	  function d3_geom_pointX(d) {
	    return d[0];
	  }
	  function d3_geom_pointY(d) {
	    return d[1];
	  }
	  d3.geom.hull = function(vertices) {
	    var x = d3_geom_pointX, y = d3_geom_pointY;
	    if (arguments.length) return hull(vertices);
	    function hull(data) {
	      if (data.length < 3) return [];
	      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
	      for (i = 0; i < n; i++) {
	        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
	      }
	      points.sort(d3_geom_hullOrder);
	      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
	      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
	      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
	      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
	      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
	      return polygon;
	    }
	    hull.x = function(_) {
	      return arguments.length ? (x = _, hull) : x;
	    };
	    hull.y = function(_) {
	      return arguments.length ? (y = _, hull) : y;
	    };
	    return hull;
	  };
	  function d3_geom_hullUpper(points) {
	    var n = points.length, hull = [ 0, 1 ], hs = 2;
	    for (var i = 2; i < n; i++) {
	      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
	      hull[hs++] = i;
	    }
	    return hull.slice(0, hs);
	  }
	  function d3_geom_hullOrder(a, b) {
	    return a[0] - b[0] || a[1] - b[1];
	  }
	  d3.geom.polygon = function(coordinates) {
	    d3_subclass(coordinates, d3_geom_polygonPrototype);
	    return coordinates;
	  };
	  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
	  d3_geom_polygonPrototype.area = function() {
	    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      area += a[1] * b[0] - a[0] * b[1];
	    }
	    return area * .5;
	  };
	  d3_geom_polygonPrototype.centroid = function(k) {
	    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
	    if (!arguments.length) k = -1 / (6 * this.area());
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      c = a[0] * b[1] - b[0] * a[1];
	      x += (a[0] + b[0]) * c;
	      y += (a[1] + b[1]) * c;
	    }
	    return [ x * k, y * k ];
	  };
	  d3_geom_polygonPrototype.clip = function(subject) {
	    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
	    while (++i < n) {
	      input = subject.slice();
	      subject.length = 0;
	      b = this[i];
	      c = input[(m = input.length - closed) - 1];
	      j = -1;
	      while (++j < m) {
	        d = input[j];
	        if (d3_geom_polygonInside(d, a, b)) {
	          if (!d3_geom_polygonInside(c, a, b)) {
	            subject.push(d3_geom_polygonIntersect(c, d, a, b));
	          }
	          subject.push(d);
	        } else if (d3_geom_polygonInside(c, a, b)) {
	          subject.push(d3_geom_polygonIntersect(c, d, a, b));
	        }
	        c = d;
	      }
	      if (closed) subject.push(subject[0]);
	      a = b;
	    }
	    return subject;
	  };
	  function d3_geom_polygonInside(p, a, b) {
	    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
	  }
	  function d3_geom_polygonIntersect(c, d, a, b) {
	    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
	    return [ x1 + ua * x21, y1 + ua * y21 ];
	  }
	  function d3_geom_polygonClosed(coordinates) {
	    var a = coordinates[0], b = coordinates[coordinates.length - 1];
	    return !(a[0] - b[0] || a[1] - b[1]);
	  }
	  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
	  function d3_geom_voronoiBeach() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.edge = this.site = this.circle = null;
	  }
	  function d3_geom_voronoiCreateBeach(site) {
	    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
	    beach.site = site;
	    return beach;
	  }
	  function d3_geom_voronoiDetachBeach(beach) {
	    d3_geom_voronoiDetachCircle(beach);
	    d3_geom_voronoiBeaches.remove(beach);
	    d3_geom_voronoiBeachPool.push(beach);
	    d3_geom_voronoiRedBlackNode(beach);
	  }
	  function d3_geom_voronoiRemoveBeach(beach) {
	    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
	      x: x,
	      y: y
	    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
	    d3_geom_voronoiDetachBeach(beach);
	    var lArc = previous;
	    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
	      previous = lArc.P;
	      disappearing.unshift(lArc);
	      d3_geom_voronoiDetachBeach(lArc);
	      lArc = previous;
	    }
	    disappearing.unshift(lArc);
	    d3_geom_voronoiDetachCircle(lArc);
	    var rArc = next;
	    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
	      next = rArc.N;
	      disappearing.push(rArc);
	      d3_geom_voronoiDetachBeach(rArc);
	      rArc = next;
	    }
	    disappearing.push(rArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var nArcs = disappearing.length, iArc;
	    for (iArc = 1; iArc < nArcs; ++iArc) {
	      rArc = disappearing[iArc];
	      lArc = disappearing[iArc - 1];
	      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
	    }
	    lArc = disappearing[0];
	    rArc = disappearing[nArcs - 1];
	    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiAddBeach(site) {
	    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
	    while (node) {
	      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
	      if (dxl > ε) node = node.L; else {
	        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
	        if (dxr > ε) {
	          if (!node.R) {
	            lArc = node;
	            break;
	          }
	          node = node.R;
	        } else {
	          if (dxl > -ε) {
	            lArc = node.P;
	            rArc = node;
	          } else if (dxr > -ε) {
	            lArc = node;
	            rArc = node.N;
	          } else {
	            lArc = rArc = node;
	          }
	          break;
	        }
	      }
	    }
	    var newArc = d3_geom_voronoiCreateBeach(site);
	    d3_geom_voronoiBeaches.insert(lArc, newArc);
	    if (!lArc && !rArc) return;
	    if (lArc === rArc) {
	      d3_geom_voronoiDetachCircle(lArc);
	      rArc = d3_geom_voronoiCreateBeach(lArc.site);
	      d3_geom_voronoiBeaches.insert(newArc, rArc);
	      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      d3_geom_voronoiAttachCircle(lArc);
	      d3_geom_voronoiAttachCircle(rArc);
	      return;
	    }
	    if (!rArc) {
	      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      return;
	    }
	    d3_geom_voronoiDetachCircle(lArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
	      x: (cy * hb - by * hc) / d + ax,
	      y: (bx * hc - cx * hb) / d + ay
	    };
	    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
	    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
	    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
	    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
	    if (!pby2) return rfocx;
	    var lArc = arc.P;
	    if (!lArc) return -Infinity;
	    site = lArc.site;
	    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
	    if (!plby2) return lfocx;
	    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
	    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
	    return (rfocx + lfocx) / 2;
	  }
	  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
	    var rArc = arc.N;
	    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
	    var site = arc.site;
	    return site.y === directrix ? site.x : Infinity;
	  }
	  function d3_geom_voronoiCell(site) {
	    this.site = site;
	    this.edges = [];
	  }
	  d3_geom_voronoiCell.prototype.prepare = function() {
	    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
	    while (iHalfEdge--) {
	      edge = halfEdges[iHalfEdge].edge;
	      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
	    }
	    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
	    return halfEdges.length;
	  };
	  function d3_geom_voronoiCloseCells(extent) {
	    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
	    while (iCell--) {
	      cell = cells[iCell];
	      if (!cell || !cell.prepare()) continue;
	      halfEdges = cell.edges;
	      nHalfEdges = halfEdges.length;
	      iHalfEdge = 0;
	      while (iHalfEdge < nHalfEdges) {
	        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
	        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
	        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
	          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
	            x: x0,
	            y: abs(x2 - x0) < ε ? y2 : y1
	          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
	            x: abs(y2 - y1) < ε ? x2 : x1,
	            y: y1
	          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
	            x: x1,
	            y: abs(x2 - x1) < ε ? y2 : y0
	          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
	            x: abs(y2 - y0) < ε ? x2 : x0,
	            y: y0
	          } : null), cell.site, null));
	          ++nHalfEdges;
	        }
	      }
	    }
	  }
	  function d3_geom_voronoiHalfEdgeOrder(a, b) {
	    return b.angle - a.angle;
	  }
	  function d3_geom_voronoiCircle() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.x = this.y = this.arc = this.site = this.cy = null;
	  }
	  function d3_geom_voronoiAttachCircle(arc) {
	    var lArc = arc.P, rArc = arc.N;
	    if (!lArc || !rArc) return;
	    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
	    if (lSite === rSite) return;
	    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
	    var d = 2 * (ax * cy - ay * cx);
	    if (d >= -ε2) return;
	    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
	    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
	    circle.arc = arc;
	    circle.site = cSite;
	    circle.x = x + bx;
	    circle.y = cy + Math.sqrt(x * x + y * y);
	    circle.cy = cy;
	    arc.circle = circle;
	    var before = null, node = d3_geom_voronoiCircles._;
	    while (node) {
	      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
	        if (node.L) node = node.L; else {
	          before = node.P;
	          break;
	        }
	      } else {
	        if (node.R) node = node.R; else {
	          before = node;
	          break;
	        }
	      }
	    }
	    d3_geom_voronoiCircles.insert(before, circle);
	    if (!before) d3_geom_voronoiFirstCircle = circle;
	  }
	  function d3_geom_voronoiDetachCircle(arc) {
	    var circle = arc.circle;
	    if (circle) {
	      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
	      d3_geom_voronoiCircles.remove(circle);
	      d3_geom_voronoiCirclePool.push(circle);
	      d3_geom_voronoiRedBlackNode(circle);
	      arc.circle = null;
	    }
	  }
	  function d3_geom_voronoiClipEdges(extent) {
	    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
	    while (i--) {
	      e = edges[i];
	      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
	        e.a = e.b = null;
	        edges.splice(i, 1);
	      }
	    }
	  }
	  function d3_geom_voronoiConnectEdge(edge, extent) {
	    var vb = edge.b;
	    if (vb) return true;
	    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
	    if (ry === ly) {
	      if (fx < x0 || fx >= x1) return;
	      if (lx > rx) {
	        if (!va) va = {
	          x: fx,
	          y: y0
	        }; else if (va.y >= y1) return;
	        vb = {
	          x: fx,
	          y: y1
	        };
	      } else {
	        if (!va) va = {
	          x: fx,
	          y: y1
	        }; else if (va.y < y0) return;
	        vb = {
	          x: fx,
	          y: y0
	        };
	      }
	    } else {
	      fm = (lx - rx) / (ry - ly);
	      fb = fy - fm * fx;
	      if (fm < -1 || fm > 1) {
	        if (lx > rx) {
	          if (!va) va = {
	            x: (y0 - fb) / fm,
	            y: y0
	          }; else if (va.y >= y1) return;
	          vb = {
	            x: (y1 - fb) / fm,
	            y: y1
	          };
	        } else {
	          if (!va) va = {
	            x: (y1 - fb) / fm,
	            y: y1
	          }; else if (va.y < y0) return;
	          vb = {
	            x: (y0 - fb) / fm,
	            y: y0
	          };
	        }
	      } else {
	        if (ly < ry) {
	          if (!va) va = {
	            x: x0,
	            y: fm * x0 + fb
	          }; else if (va.x >= x1) return;
	          vb = {
	            x: x1,
	            y: fm * x1 + fb
	          };
	        } else {
	          if (!va) va = {
	            x: x1,
	            y: fm * x1 + fb
	          }; else if (va.x < x0) return;
	          vb = {
	            x: x0,
	            y: fm * x0 + fb
	          };
	        }
	      }
	    }
	    edge.a = va;
	    edge.b = vb;
	    return true;
	  }
	  function d3_geom_voronoiEdge(lSite, rSite) {
	    this.l = lSite;
	    this.r = rSite;
	    this.a = this.b = null;
	  }
	  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, rSite);
	    d3_geom_voronoiEdges.push(edge);
	    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
	    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
	    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
	    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
	    return edge;
	  }
	  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, null);
	    edge.a = va;
	    edge.b = vb;
	    d3_geom_voronoiEdges.push(edge);
	    return edge;
	  }
	  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
	    if (!edge.a && !edge.b) {
	      edge.a = vertex;
	      edge.l = lSite;
	      edge.r = rSite;
	    } else if (edge.l === rSite) {
	      edge.b = vertex;
	    } else {
	      edge.a = vertex;
	    }
	  }
	  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
	    var va = edge.a, vb = edge.b;
	    this.edge = edge;
	    this.site = lSite;
	    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
	  }
	  d3_geom_voronoiHalfEdge.prototype = {
	    start: function() {
	      return this.edge.l === this.site ? this.edge.a : this.edge.b;
	    },
	    end: function() {
	      return this.edge.l === this.site ? this.edge.b : this.edge.a;
	    }
	  };
	  function d3_geom_voronoiRedBlackTree() {
	    this._ = null;
	  }
	  function d3_geom_voronoiRedBlackNode(node) {
	    node.U = node.C = node.L = node.R = node.P = node.N = null;
	  }
	  d3_geom_voronoiRedBlackTree.prototype = {
	    insert: function(after, node) {
	      var parent, grandpa, uncle;
	      if (after) {
	        node.P = after;
	        node.N = after.N;
	        if (after.N) after.N.P = node;
	        after.N = node;
	        if (after.R) {
	          after = after.R;
	          while (after.L) after = after.L;
	          after.L = node;
	        } else {
	          after.R = node;
	        }
	        parent = after;
	      } else if (this._) {
	        after = d3_geom_voronoiRedBlackFirst(this._);
	        node.P = null;
	        node.N = after;
	        after.P = after.L = node;
	        parent = after;
	      } else {
	        node.P = node.N = null;
	        this._ = node;
	        parent = null;
	      }
	      node.L = node.R = null;
	      node.U = parent;
	      node.C = true;
	      after = node;
	      while (parent && parent.C) {
	        grandpa = parent.U;
	        if (parent === grandpa.L) {
	          uncle = grandpa.R;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.R) {
	              d3_geom_voronoiRedBlackRotateLeft(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
	          }
	        } else {
	          uncle = grandpa.L;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.L) {
	              d3_geom_voronoiRedBlackRotateRight(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
	          }
	        }
	        parent = after.U;
	      }
	      this._.C = false;
	    },
	    remove: function(node) {
	      if (node.N) node.N.P = node.P;
	      if (node.P) node.P.N = node.N;
	      node.N = node.P = null;
	      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
	      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
	      if (parent) {
	        if (parent.L === node) parent.L = next; else parent.R = next;
	      } else {
	        this._ = next;
	      }
	      if (left && right) {
	        red = next.C;
	        next.C = node.C;
	        next.L = left;
	        left.U = next;
	        if (next !== right) {
	          parent = next.U;
	          next.U = node.U;
	          node = next.R;
	          parent.L = node;
	          next.R = right;
	          right.U = next;
	        } else {
	          next.U = parent;
	          parent = next;
	          node = next.R;
	        }
	      } else {
	        red = node.C;
	        node = next;
	      }
	      if (node) node.U = parent;
	      if (red) return;
	      if (node && node.C) {
	        node.C = false;
	        return;
	      }
	      do {
	        if (node === this._) break;
	        if (node === parent.L) {
	          sibling = parent.R;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            sibling = parent.R;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.R || !sibling.R.C) {
	              sibling.L.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateRight(this, sibling);
	              sibling = parent.R;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.R.C = false;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            node = this._;
	            break;
	          }
	        } else {
	          sibling = parent.L;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            sibling = parent.L;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.L || !sibling.L.C) {
	              sibling.R.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
	              sibling = parent.L;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.L.C = false;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            node = this._;
	            break;
	          }
	        }
	        sibling.C = true;
	        node = parent;
	        parent = parent.U;
	      } while (!node.C);
	      if (node) node.C = false;
	    }
	  };
	  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
	    var p = node, q = node.R, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.R = q.L;
	    if (p.R) p.R.U = p;
	    q.L = p;
	  }
	  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
	    var p = node, q = node.L, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.L = q.R;
	    if (p.L) p.L.U = p;
	    q.R = p;
	  }
	  function d3_geom_voronoiRedBlackFirst(node) {
	    while (node.L) node = node.L;
	    return node;
	  }
	  function d3_geom_voronoi(sites, bbox) {
	    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
	    d3_geom_voronoiEdges = [];
	    d3_geom_voronoiCells = new Array(sites.length);
	    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
	    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
	    while (true) {
	      circle = d3_geom_voronoiFirstCircle;
	      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
	        if (site.x !== x0 || site.y !== y0) {
	          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
	          d3_geom_voronoiAddBeach(site);
	          x0 = site.x, y0 = site.y;
	        }
	        site = sites.pop();
	      } else if (circle) {
	        d3_geom_voronoiRemoveBeach(circle.arc);
	      } else {
	        break;
	      }
	    }
	    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
	    var diagram = {
	      cells: d3_geom_voronoiCells,
	      edges: d3_geom_voronoiEdges
	    };
	    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
	    return diagram;
	  }
	  function d3_geom_voronoiVertexOrder(a, b) {
	    return b.y - a.y || b.x - a.x;
	  }
	  d3.geom.voronoi = function(points) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
	    if (points) return voronoi(points);
	    function voronoi(data) {
	      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
	      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
	        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
	          var s = e.start();
	          return [ s.x, s.y ];
	        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
	        polygon.point = data[i];
	      });
	      return polygons;
	    }
	    function sites(data) {
	      return data.map(function(d, i) {
	        return {
	          x: Math.round(fx(d, i) / ε) * ε,
	          y: Math.round(fy(d, i) / ε) * ε,
	          i: i
	        };
	      });
	    }
	    voronoi.links = function(data) {
	      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
	        return edge.l && edge.r;
	      }).map(function(edge) {
	        return {
	          source: data[edge.l.i],
	          target: data[edge.r.i]
	        };
	      });
	    };
	    voronoi.triangles = function(data) {
	      var triangles = [];
	      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
	        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
	        while (++j < m) {
	          e0 = e1;
	          s0 = s1;
	          e1 = edges[j].edge;
	          s1 = e1.l === site ? e1.r : e1.l;
	          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
	            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
	          }
	        }
	      });
	      return triangles;
	    };
	    voronoi.x = function(_) {
	      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
	    };
	    voronoi.y = function(_) {
	      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
	    };
	    voronoi.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
	      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
	      return voronoi;
	    };
	    voronoi.size = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
	      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
	    };
	    return voronoi;
	  };
	  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
	  function d3_geom_voronoiTriangleArea(a, b, c) {
	    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
	  }
	  d3.geom.delaunay = function(vertices) {
	    return d3.geom.voronoi().triangles(vertices);
	  };
	  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
	    if (compat = arguments.length) {
	      x = d3_geom_quadtreeCompatX;
	      y = d3_geom_quadtreeCompatY;
	      if (compat === 3) {
	        y2 = y1;
	        x2 = x1;
	        y1 = x1 = 0;
	      }
	      return quadtree(points);
	    }
	    function quadtree(data) {
	      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
	      if (x1 != null) {
	        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
	      } else {
	        x2_ = y2_ = -(x1_ = y1_ = Infinity);
	        xs = [], ys = [];
	        n = data.length;
	        if (compat) for (i = 0; i < n; ++i) {
	          d = data[i];
	          if (d.x < x1_) x1_ = d.x;
	          if (d.y < y1_) y1_ = d.y;
	          if (d.x > x2_) x2_ = d.x;
	          if (d.y > y2_) y2_ = d.y;
	          xs.push(d.x);
	          ys.push(d.y);
	        } else for (i = 0; i < n; ++i) {
	          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
	          if (x_ < x1_) x1_ = x_;
	          if (y_ < y1_) y1_ = y_;
	          if (x_ > x2_) x2_ = x_;
	          if (y_ > y2_) y2_ = y_;
	          xs.push(x_);
	          ys.push(y_);
	        }
	      }
	      var dx = x2_ - x1_, dy = y2_ - y1_;
	      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
	      function insert(n, d, x, y, x1, y1, x2, y2) {
	        if (isNaN(x) || isNaN(y)) return;
	        if (n.leaf) {
	          var nx = n.x, ny = n.y;
	          if (nx != null) {
	            if (abs(nx - x) + abs(ny - y) < .01) {
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            } else {
	              var nPoint = n.point;
	              n.x = n.y = n.point = null;
	              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            }
	          } else {
	            n.x = x, n.y = y, n.point = d;
	          }
	        } else {
	          insertChild(n, d, x, y, x1, y1, x2, y2);
	        }
	      }
	      function insertChild(n, d, x, y, x1, y1, x2, y2) {
	        var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, right = x >= sx, bottom = y >= sy, i = (bottom << 1) + right;
	        n.leaf = false;
	        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
	        if (right) x1 = sx; else x2 = sx;
	        if (bottom) y1 = sy; else y2 = sy;
	        insert(n, d, x, y, x1, y1, x2, y2);
	      }
	      var root = d3_geom_quadtreeNode();
	      root.add = function(d) {
	        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
	      };
	      root.visit = function(f) {
	        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
	      };
	      i = -1;
	      if (x1 == null) {
	        while (++i < n) {
	          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
	        }
	        --i;
	      } else data.forEach(root.add);
	      xs = ys = data = d = null;
	      return root;
	    }
	    quadtree.x = function(_) {
	      return arguments.length ? (x = _, quadtree) : x;
	    };
	    quadtree.y = function(_) {
	      return arguments.length ? (y = _, quadtree) : y;
	    };
	    quadtree.extent = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
	      y2 = +_[1][1];
	      return quadtree;
	    };
	    quadtree.size = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
	      return quadtree;
	    };
	    return quadtree;
	  };
	  function d3_geom_quadtreeCompatX(d) {
	    return d.x;
	  }
	  function d3_geom_quadtreeCompatY(d) {
	    return d.y;
	  }
	  function d3_geom_quadtreeNode() {
	    return {
	      leaf: true,
	      nodes: [],
	      point: null,
	      x: null,
	      y: null
	    };
	  }
	  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
	    if (!f(node, x1, y1, x2, y2)) {
	      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
	      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
	      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
	      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
	      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
	    }
	  }
	  d3.interpolateRgb = d3_interpolateRgb;
	  function d3_interpolateRgb(a, b) {
	    a = d3.rgb(a);
	    b = d3.rgb(b);
	    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
	    return function(t) {
	      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
	    };
	  }
	  d3.interpolateObject = d3_interpolateObject;
	  function d3_interpolateObject(a, b) {
	    var i = {}, c = {}, k;
	    for (k in a) {
	      if (k in b) {
	        i[k] = d3_interpolate(a[k], b[k]);
	      } else {
	        c[k] = a[k];
	      }
	    }
	    for (k in b) {
	      if (!(k in a)) {
	        c[k] = b[k];
	      }
	    }
	    return function(t) {
	      for (k in i) c[k] = i[k](t);
	      return c;
	    };
	  }
	  d3.interpolateNumber = d3_interpolateNumber;
	  function d3_interpolateNumber(a, b) {
	    a = +a, b = +b;
	    return function(t) {
	      return a * (1 - t) + b * t;
	    };
	  }
	  d3.interpolateString = d3_interpolateString;
	  function d3_interpolateString(a, b) {
	    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
	    a = a + "", b = b + "";
	    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
	      if ((bs = bm.index) > bi) {
	        bs = b.slice(bi, bs);
	        if (s[i]) s[i] += bs; else s[++i] = bs;
	      }
	      if ((am = am[0]) === (bm = bm[0])) {
	        if (s[i]) s[i] += bm; else s[++i] = bm;
	      } else {
	        s[++i] = null;
	        q.push({
	          i: i,
	          x: d3_interpolateNumber(am, bm)
	        });
	      }
	      bi = d3_interpolate_numberB.lastIndex;
	    }
	    if (bi < b.length) {
	      bs = b.slice(bi);
	      if (s[i]) s[i] += bs; else s[++i] = bs;
	    }
	    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
	      return b(t) + "";
	    }) : function() {
	      return b;
	    } : (b = q.length, function(t) {
	      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    });
	  }
	  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
	  d3.interpolate = d3_interpolate;
	  function d3_interpolate(a, b) {
	    var i = d3.interpolators.length, f;
	    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
	    return f;
	  }
	  d3.interpolators = [ function(a, b) {
	    var t = typeof b;
	    return (t === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
	  } ];
	  d3.interpolateArray = d3_interpolateArray;
	  function d3_interpolateArray(a, b) {
	    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
	    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
	    for (;i < na; ++i) c[i] = a[i];
	    for (;i < nb; ++i) c[i] = b[i];
	    return function(t) {
	      for (i = 0; i < n0; ++i) c[i] = x[i](t);
	      return c;
	    };
	  }
	  var d3_ease_default = function() {
	    return d3_identity;
	  };
	  var d3_ease = d3.map({
	    linear: d3_ease_default,
	    poly: d3_ease_poly,
	    quad: function() {
	      return d3_ease_quad;
	    },
	    cubic: function() {
	      return d3_ease_cubic;
	    },
	    sin: function() {
	      return d3_ease_sin;
	    },
	    exp: function() {
	      return d3_ease_exp;
	    },
	    circle: function() {
	      return d3_ease_circle;
	    },
	    elastic: d3_ease_elastic,
	    back: d3_ease_back,
	    bounce: function() {
	      return d3_ease_bounce;
	    }
	  });
	  var d3_ease_mode = d3.map({
	    "in": d3_identity,
	    out: d3_ease_reverse,
	    "in-out": d3_ease_reflect,
	    "out-in": function(f) {
	      return d3_ease_reflect(d3_ease_reverse(f));
	    }
	  });
	  d3.ease = function(name) {
	    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
	    t = d3_ease.get(t) || d3_ease_default;
	    m = d3_ease_mode.get(m) || d3_identity;
	    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
	  };
	  function d3_ease_clamp(f) {
	    return function(t) {
	      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
	    };
	  }
	  function d3_ease_reverse(f) {
	    return function(t) {
	      return 1 - f(1 - t);
	    };
	  }
	  function d3_ease_reflect(f) {
	    return function(t) {
	      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
	    };
	  }
	  function d3_ease_quad(t) {
	    return t * t;
	  }
	  function d3_ease_cubic(t) {
	    return t * t * t;
	  }
	  function d3_ease_cubicInOut(t) {
	    if (t <= 0) return 0;
	    if (t >= 1) return 1;
	    var t2 = t * t, t3 = t2 * t;
	    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
	  }
	  function d3_ease_poly(e) {
	    return function(t) {
	      return Math.pow(t, e);
	    };
	  }
	  function d3_ease_sin(t) {
	    return 1 - Math.cos(t * halfπ);
	  }
	  function d3_ease_exp(t) {
	    return Math.pow(2, 10 * (t - 1));
	  }
	  function d3_ease_circle(t) {
	    return 1 - Math.sqrt(1 - t * t);
	  }
	  function d3_ease_elastic(a, p) {
	    var s;
	    if (arguments.length < 2) p = .45;
	    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
	    return function(t) {
	      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
	    };
	  }
	  function d3_ease_back(s) {
	    if (!s) s = 1.70158;
	    return function(t) {
	      return t * t * ((s + 1) * t - s);
	    };
	  }
	  function d3_ease_bounce(t) {
	    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
	  }
	  d3.interpolateHcl = d3_interpolateHcl;
	  function d3_interpolateHcl(a, b) {
	    a = d3.hcl(a);
	    b = d3.hcl(b);
	    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
	    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateHsl = d3_interpolateHsl;
	  function d3_interpolateHsl(a, b) {
	    a = d3.hsl(a);
	    b = d3.hsl(b);
	    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
	    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateLab = d3_interpolateLab;
	  function d3_interpolateLab(a, b) {
	    a = d3.lab(a);
	    b = d3.lab(b);
	    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
	    return function(t) {
	      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
	    };
	  }
	  d3.interpolateRound = d3_interpolateRound;
	  function d3_interpolateRound(a, b) {
	    b -= a;
	    return function(t) {
	      return Math.round(a + b * t);
	    };
	  }
	  d3.transform = function(string) {
	    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
	    return (d3.transform = function(string) {
	      if (string != null) {
	        g.setAttribute("transform", string);
	        var t = g.transform.baseVal.consolidate();
	      }
	      return new d3_transform(t ? t.matrix : d3_transformIdentity);
	    })(string);
	  };
	  function d3_transform(m) {
	    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
	    if (r0[0] * r1[1] < r1[0] * r0[1]) {
	      r0[0] *= -1;
	      r0[1] *= -1;
	      kx *= -1;
	      kz *= -1;
	    }
	    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
	    this.translate = [ m.e, m.f ];
	    this.scale = [ kx, ky ];
	    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
	  }
	  d3_transform.prototype.toString = function() {
	    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
	  };
	  function d3_transformDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1];
	  }
	  function d3_transformNormalize(a) {
	    var k = Math.sqrt(d3_transformDot(a, a));
	    if (k) {
	      a[0] /= k;
	      a[1] /= k;
	    }
	    return k;
	  }
	  function d3_transformCombine(a, b, k) {
	    a[0] += k * b[0];
	    a[1] += k * b[1];
	    return a;
	  }
	  var d3_transformIdentity = {
	    a: 1,
	    b: 0,
	    c: 0,
	    d: 1,
	    e: 0,
	    f: 0
	  };
	  d3.interpolateTransform = d3_interpolateTransform;
	  function d3_interpolateTransform(a, b) {
	    var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
	    if (ta[0] != tb[0] || ta[1] != tb[1]) {
	      s.push("translate(", null, ",", null, ")");
	      q.push({
	        i: 1,
	        x: d3_interpolateNumber(ta[0], tb[0])
	      }, {
	        i: 3,
	        x: d3_interpolateNumber(ta[1], tb[1])
	      });
	    } else if (tb[0] || tb[1]) {
	      s.push("translate(" + tb + ")");
	    } else {
	      s.push("");
	    }
	    if (ra != rb) {
	      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
	      q.push({
	        i: s.push(s.pop() + "rotate(", null, ")") - 2,
	        x: d3_interpolateNumber(ra, rb)
	      });
	    } else if (rb) {
	      s.push(s.pop() + "rotate(" + rb + ")");
	    }
	    if (wa != wb) {
	      q.push({
	        i: s.push(s.pop() + "skewX(", null, ")") - 2,
	        x: d3_interpolateNumber(wa, wb)
	      });
	    } else if (wb) {
	      s.push(s.pop() + "skewX(" + wb + ")");
	    }
	    if (ka[0] != kb[0] || ka[1] != kb[1]) {
	      n = s.push(s.pop() + "scale(", null, ",", null, ")");
	      q.push({
	        i: n - 4,
	        x: d3_interpolateNumber(ka[0], kb[0])
	      }, {
	        i: n - 2,
	        x: d3_interpolateNumber(ka[1], kb[1])
	      });
	    } else if (kb[0] != 1 || kb[1] != 1) {
	      s.push(s.pop() + "scale(" + kb + ")");
	    }
	    n = q.length;
	    return function(t) {
	      var i = -1, o;
	      while (++i < n) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    };
	  }
	  function d3_uninterpolateNumber(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return (x - a) / b;
	    };
	  }
	  function d3_uninterpolateClamp(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return Math.max(0, Math.min(1, (x - a) / b));
	    };
	  }
	  d3.layout = {};
	  d3.layout.bundle = function() {
	    return function(links) {
	      var paths = [], i = -1, n = links.length;
	      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
	      return paths;
	    };
	  };
	  function d3_layout_bundlePath(link) {
	    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
	    while (start !== lca) {
	      start = start.parent;
	      points.push(start);
	    }
	    var k = points.length;
	    while (end !== lca) {
	      points.splice(k, 0, end);
	      end = end.parent;
	    }
	    return points;
	  }
	  function d3_layout_bundleAncestors(node) {
	    var ancestors = [], parent = node.parent;
	    while (parent != null) {
	      ancestors.push(node);
	      node = parent;
	      parent = parent.parent;
	    }
	    ancestors.push(node);
	    return ancestors;
	  }
	  function d3_layout_bundleLeastCommonAncestor(a, b) {
	    if (a === b) return a;
	    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
	    while (aNode === bNode) {
	      sharedNode = aNode;
	      aNode = aNodes.pop();
	      bNode = bNodes.pop();
	    }
	    return sharedNode;
	  }
	  d3.layout.chord = function() {
	    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
	    function relayout() {
	      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
	      chords = [];
	      groups = [];
	      k = 0, i = -1;
	      while (++i < n) {
	        x = 0, j = -1;
	        while (++j < n) {
	          x += matrix[i][j];
	        }
	        groupSums.push(x);
	        subgroupIndex.push(d3.range(n));
	        k += x;
	      }
	      if (sortGroups) {
	        groupIndex.sort(function(a, b) {
	          return sortGroups(groupSums[a], groupSums[b]);
	        });
	      }
	      if (sortSubgroups) {
	        subgroupIndex.forEach(function(d, i) {
	          d.sort(function(a, b) {
	            return sortSubgroups(matrix[i][a], matrix[i][b]);
	          });
	        });
	      }
	      k = (τ - padding * n) / k;
	      x = 0, i = -1;
	      while (++i < n) {
	        x0 = x, j = -1;
	        while (++j < n) {
	          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
	          subgroups[di + "-" + dj] = {
	            index: di,
	            subindex: dj,
	            startAngle: a0,
	            endAngle: a1,
	            value: v
	          };
	        }
	        groups[di] = {
	          index: di,
	          startAngle: x0,
	          endAngle: x,
	          value: (x - x0) / k
	        };
	        x += padding;
	      }
	      i = -1;
	      while (++i < n) {
	        j = i - 1;
	        while (++j < n) {
	          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
	          if (source.value || target.value) {
	            chords.push(source.value < target.value ? {
	              source: target,
	              target: source
	            } : {
	              source: source,
	              target: target
	            });
	          }
	        }
	      }
	      if (sortChords) resort();
	    }
	    function resort() {
	      chords.sort(function(a, b) {
	        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
	      });
	    }
	    chord.matrix = function(x) {
	      if (!arguments.length) return matrix;
	      n = (matrix = x) && matrix.length;
	      chords = groups = null;
	      return chord;
	    };
	    chord.padding = function(x) {
	      if (!arguments.length) return padding;
	      padding = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortGroups = function(x) {
	      if (!arguments.length) return sortGroups;
	      sortGroups = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortSubgroups = function(x) {
	      if (!arguments.length) return sortSubgroups;
	      sortSubgroups = x;
	      chords = null;
	      return chord;
	    };
	    chord.sortChords = function(x) {
	      if (!arguments.length) return sortChords;
	      sortChords = x;
	      if (chords) resort();
	      return chord;
	    };
	    chord.chords = function() {
	      if (!chords) relayout();
	      return chords;
	    };
	    chord.groups = function() {
	      if (!groups) relayout();
	      return groups;
	    };
	    return chord;
	  };
	  d3.layout.force = function() {
	    var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
	    function repulse(node) {
	      return function(quad, x1, _, x2) {
	        if (quad.point !== node) {
	          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
	          if (dw * dw / theta2 < dn) {
	            if (dn < chargeDistance2) {
	              var k = quad.charge / dn;
	              node.px -= dx * k;
	              node.py -= dy * k;
	            }
	            return true;
	          }
	          if (quad.point && dn && dn < chargeDistance2) {
	            var k = quad.pointCharge / dn;
	            node.px -= dx * k;
	            node.py -= dy * k;
	          }
	        }
	        return !quad.charge;
	      };
	    }
	    force.tick = function() {
	      if ((alpha *= .99) < .005) {
	        event.end({
	          type: "end",
	          alpha: alpha = 0
	        });
	        return true;
	      }
	      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        s = o.source;
	        t = o.target;
	        x = t.x - s.x;
	        y = t.y - s.y;
	        if (l = x * x + y * y) {
	          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
	          x *= l;
	          y *= l;
	          t.x -= x * (k = s.weight / (t.weight + s.weight));
	          t.y -= y * k;
	          s.x += x * (k = 1 - k);
	          s.y += y * k;
	        }
	      }
	      if (k = alpha * gravity) {
	        x = size[0] / 2;
	        y = size[1] / 2;
	        i = -1;
	        if (k) while (++i < n) {
	          o = nodes[i];
	          o.x += (x - o.x) * k;
	          o.y += (y - o.y) * k;
	        }
	      }
	      if (charge) {
	        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
	        i = -1;
	        while (++i < n) {
	          if (!(o = nodes[i]).fixed) {
	            q.visit(repulse(o));
	          }
	        }
	      }
	      i = -1;
	      while (++i < n) {
	        o = nodes[i];
	        if (o.fixed) {
	          o.x = o.px;
	          o.y = o.py;
	        } else {
	          o.x -= (o.px - (o.px = o.x)) * friction;
	          o.y -= (o.py - (o.py = o.y)) * friction;
	        }
	      }
	      event.tick({
	        type: "tick",
	        alpha: alpha
	      });
	    };
	    force.nodes = function(x) {
	      if (!arguments.length) return nodes;
	      nodes = x;
	      return force;
	    };
	    force.links = function(x) {
	      if (!arguments.length) return links;
	      links = x;
	      return force;
	    };
	    force.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return force;
	    };
	    force.linkDistance = function(x) {
	      if (!arguments.length) return linkDistance;
	      linkDistance = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.distance = force.linkDistance;
	    force.linkStrength = function(x) {
	      if (!arguments.length) return linkStrength;
	      linkStrength = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.friction = function(x) {
	      if (!arguments.length) return friction;
	      friction = +x;
	      return force;
	    };
	    force.charge = function(x) {
	      if (!arguments.length) return charge;
	      charge = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.chargeDistance = function(x) {
	      if (!arguments.length) return Math.sqrt(chargeDistance2);
	      chargeDistance2 = x * x;
	      return force;
	    };
	    force.gravity = function(x) {
	      if (!arguments.length) return gravity;
	      gravity = +x;
	      return force;
	    };
	    force.theta = function(x) {
	      if (!arguments.length) return Math.sqrt(theta2);
	      theta2 = x * x;
	      return force;
	    };
	    force.alpha = function(x) {
	      if (!arguments.length) return alpha;
	      x = +x;
	      if (alpha) {
	        if (x > 0) alpha = x; else alpha = 0;
	      } else if (x > 0) {
	        event.start({
	          type: "start",
	          alpha: alpha = x
	        });
	        d3.timer(force.tick);
	      }
	      return force;
	    };
	    force.start = function() {
	      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
	      for (i = 0; i < n; ++i) {
	        (o = nodes[i]).index = i;
	        o.weight = 0;
	      }
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        if (typeof o.source == "number") o.source = nodes[o.source];
	        if (typeof o.target == "number") o.target = nodes[o.target];
	        ++o.source.weight;
	        ++o.target.weight;
	      }
	      for (i = 0; i < n; ++i) {
	        o = nodes[i];
	        if (isNaN(o.x)) o.x = position("x", w);
	        if (isNaN(o.y)) o.y = position("y", h);
	        if (isNaN(o.px)) o.px = o.x;
	        if (isNaN(o.py)) o.py = o.y;
	      }
	      distances = [];
	      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
	      strengths = [];
	      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
	      charges = [];
	      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
	      function position(dimension, size) {
	        if (!neighbors) {
	          neighbors = new Array(n);
	          for (j = 0; j < n; ++j) {
	            neighbors[j] = [];
	          }
	          for (j = 0; j < m; ++j) {
	            var o = links[j];
	            neighbors[o.source.index].push(o.target);
	            neighbors[o.target.index].push(o.source);
	          }
	        }
	        var candidates = neighbors[i], j = -1, m = candidates.length, x;
	        while (++j < m) if (!isNaN(x = candidates[j][dimension])) return x;
	        return Math.random() * size;
	      }
	      return force.resume();
	    };
	    force.resume = function() {
	      return force.alpha(.1);
	    };
	    force.stop = function() {
	      return force.alpha(0);
	    };
	    force.drag = function() {
	      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
	      if (!arguments.length) return drag;
	      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
	    };
	    function dragmove(d) {
	      d.px = d3.event.x, d.py = d3.event.y;
	      force.resume();
	    }
	    return d3.rebind(force, event, "on");
	  };
	  function d3_layout_forceDragstart(d) {
	    d.fixed |= 2;
	  }
	  function d3_layout_forceDragend(d) {
	    d.fixed &= ~6;
	  }
	  function d3_layout_forceMouseover(d) {
	    d.fixed |= 4;
	    d.px = d.x, d.py = d.y;
	  }
	  function d3_layout_forceMouseout(d) {
	    d.fixed &= ~4;
	  }
	  function d3_layout_forceAccumulate(quad, alpha, charges) {
	    var cx = 0, cy = 0;
	    quad.charge = 0;
	    if (!quad.leaf) {
	      var nodes = quad.nodes, n = nodes.length, i = -1, c;
	      while (++i < n) {
	        c = nodes[i];
	        if (c == null) continue;
	        d3_layout_forceAccumulate(c, alpha, charges);
	        quad.charge += c.charge;
	        cx += c.charge * c.cx;
	        cy += c.charge * c.cy;
	      }
	    }
	    if (quad.point) {
	      if (!quad.leaf) {
	        quad.point.x += Math.random() - .5;
	        quad.point.y += Math.random() - .5;
	      }
	      var k = alpha * charges[quad.point.index];
	      quad.charge += quad.pointCharge = k;
	      cx += k * quad.point.x;
	      cy += k * quad.point.y;
	    }
	    quad.cx = cx / quad.charge;
	    quad.cy = cy / quad.charge;
	  }
	  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
	  d3.layout.hierarchy = function() {
	    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
	    function hierarchy(root) {
	      var stack = [ root ], nodes = [], node;
	      root.depth = 0;
	      while ((node = stack.pop()) != null) {
	        nodes.push(node);
	        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
	          var n, childs, child;
	          while (--n >= 0) {
	            stack.push(child = childs[n]);
	            child.parent = node;
	            child.depth = node.depth + 1;
	          }
	          if (value) node.value = 0;
	          node.children = childs;
	        } else {
	          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          delete node.children;
	        }
	      }
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var childs, parent;
	        if (sort && (childs = node.children)) childs.sort(sort);
	        if (value && (parent = node.parent)) parent.value += node.value;
	      });
	      return nodes;
	    }
	    hierarchy.sort = function(x) {
	      if (!arguments.length) return sort;
	      sort = x;
	      return hierarchy;
	    };
	    hierarchy.children = function(x) {
	      if (!arguments.length) return children;
	      children = x;
	      return hierarchy;
	    };
	    hierarchy.value = function(x) {
	      if (!arguments.length) return value;
	      value = x;
	      return hierarchy;
	    };
	    hierarchy.revalue = function(root) {
	      if (value) {
	        d3_layout_hierarchyVisitBefore(root, function(node) {
	          if (node.children) node.value = 0;
	        });
	        d3_layout_hierarchyVisitAfter(root, function(node) {
	          var parent;
	          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          if (parent = node.parent) parent.value += node.value;
	        });
	      }
	      return root;
	    };
	    return hierarchy;
	  };
	  function d3_layout_hierarchyRebind(object, hierarchy) {
	    d3.rebind(object, hierarchy, "sort", "children", "value");
	    object.nodes = object;
	    object.links = d3_layout_hierarchyLinks;
	    return object;
	  }
	  function d3_layout_hierarchyVisitBefore(node, callback) {
	    var nodes = [ node ];
	    while ((node = nodes.pop()) != null) {
	      callback(node);
	      if ((children = node.children) && (n = children.length)) {
	        var n, children;
	        while (--n >= 0) nodes.push(children[n]);
	      }
	    }
	  }
	  function d3_layout_hierarchyVisitAfter(node, callback) {
	    var nodes = [ node ], nodes2 = [];
	    while ((node = nodes.pop()) != null) {
	      nodes2.push(node);
	      if ((children = node.children) && (n = children.length)) {
	        var i = -1, n, children;
	        while (++i < n) nodes.push(children[i]);
	      }
	    }
	    while ((node = nodes2.pop()) != null) {
	      callback(node);
	    }
	  }
	  function d3_layout_hierarchyChildren(d) {
	    return d.children;
	  }
	  function d3_layout_hierarchyValue(d) {
	    return d.value;
	  }
	  function d3_layout_hierarchySort(a, b) {
	    return b.value - a.value;
	  }
	  function d3_layout_hierarchyLinks(nodes) {
	    return d3.merge(nodes.map(function(parent) {
	      return (parent.children || []).map(function(child) {
	        return {
	          source: parent,
	          target: child
	        };
	      });
	    }));
	  }
	  d3.layout.partition = function() {
	    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
	    function position(node, x, dx, dy) {
	      var children = node.children;
	      node.x = x;
	      node.y = node.depth * dy;
	      node.dx = dx;
	      node.dy = dy;
	      if (children && (n = children.length)) {
	        var i = -1, n, c, d;
	        dx = node.value ? dx / node.value : 0;
	        while (++i < n) {
	          position(c = children[i], x, d = c.value * dx, dy);
	          x += d;
	        }
	      }
	    }
	    function depth(node) {
	      var children = node.children, d = 0;
	      if (children && (n = children.length)) {
	        var i = -1, n;
	        while (++i < n) d = Math.max(d, depth(children[i]));
	      }
	      return 1 + d;
	    }
	    function partition(d, i) {
	      var nodes = hierarchy.call(this, d, i);
	      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
	      return nodes;
	    }
	    partition.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return partition;
	    };
	    return d3_layout_hierarchyRebind(partition, hierarchy);
	  };
	  d3.layout.pie = function() {
	    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ;
	    function pie(data) {
	      var values = data.map(function(d, i) {
	        return +value.call(pie, d, i);
	      });
	      var a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle);
	      var k = ((typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a) / d3.sum(values);
	      var index = d3.range(data.length);
	      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
	        return values[j] - values[i];
	      } : function(i, j) {
	        return sort(data[i], data[j]);
	      });
	      var arcs = [];
	      index.forEach(function(i) {
	        var d;
	        arcs[i] = {
	          data: data[i],
	          value: d = values[i],
	          startAngle: a,
	          endAngle: a += d * k
	        };
	      });
	      return arcs;
	    }
	    pie.value = function(x) {
	      if (!arguments.length) return value;
	      value = x;
	      return pie;
	    };
	    pie.sort = function(x) {
	      if (!arguments.length) return sort;
	      sort = x;
	      return pie;
	    };
	    pie.startAngle = function(x) {
	      if (!arguments.length) return startAngle;
	      startAngle = x;
	      return pie;
	    };
	    pie.endAngle = function(x) {
	      if (!arguments.length) return endAngle;
	      endAngle = x;
	      return pie;
	    };
	    return pie;
	  };
	  var d3_layout_pieSortByValue = {};
	  d3.layout.stack = function() {
	    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
	    function stack(data, index) {
	      if (!(n = data.length)) return data;
	      var series = data.map(function(d, i) {
	        return values.call(stack, d, i);
	      });
	      var points = series.map(function(d) {
	        return d.map(function(v, i) {
	          return [ x.call(stack, v, i), y.call(stack, v, i) ];
	        });
	      });
	      var orders = order.call(stack, points, index);
	      series = d3.permute(series, orders);
	      points = d3.permute(points, orders);
	      var offsets = offset.call(stack, points, index);
	      var m = series[0].length, n, i, j, o;
	      for (j = 0; j < m; ++j) {
	        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
	        for (i = 1; i < n; ++i) {
	          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
	        }
	      }
	      return data;
	    }
	    stack.values = function(x) {
	      if (!arguments.length) return values;
	      values = x;
	      return stack;
	    };
	    stack.order = function(x) {
	      if (!arguments.length) return order;
	      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
	      return stack;
	    };
	    stack.offset = function(x) {
	      if (!arguments.length) return offset;
	      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
	      return stack;
	    };
	    stack.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      return stack;
	    };
	    stack.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      return stack;
	    };
	    stack.out = function(z) {
	      if (!arguments.length) return out;
	      out = z;
	      return stack;
	    };
	    return stack;
	  };
	  function d3_layout_stackX(d) {
	    return d.x;
	  }
	  function d3_layout_stackY(d) {
	    return d.y;
	  }
	  function d3_layout_stackOut(d, y0, y) {
	    d.y0 = y0;
	    d.y = y;
	  }
	  var d3_layout_stackOrders = d3.map({
	    "inside-out": function(data) {
	      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
	        return max[a] - max[b];
	      }), top = 0, bottom = 0, tops = [], bottoms = [];
	      for (i = 0; i < n; ++i) {
	        j = index[i];
	        if (top < bottom) {
	          top += sums[j];
	          tops.push(j);
	        } else {
	          bottom += sums[j];
	          bottoms.push(j);
	        }
	      }
	      return bottoms.reverse().concat(tops);
	    },
	    reverse: function(data) {
	      return d3.range(data.length).reverse();
	    },
	    "default": d3_layout_stackOrderDefault
	  });
	  var d3_layout_stackOffsets = d3.map({
	    silhouette: function(data) {
	      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o > max) max = o;
	        sums.push(o);
	      }
	      for (j = 0; j < m; ++j) {
	        y0[j] = (max - sums[j]) / 2;
	      }
	      return y0;
	    },
	    wiggle: function(data) {
	      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
	      y0[0] = o = o0 = 0;
	      for (j = 1; j < m; ++j) {
	        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
	        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
	          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
	            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
	          }
	          s2 += s3 * data[i][j][1];
	        }
	        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
	        if (o < o0) o0 = o;
	      }
	      for (j = 0; j < m; ++j) y0[j] -= o0;
	      return y0;
	    },
	    expand: function(data) {
	      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
	      }
	      for (j = 0; j < m; ++j) y0[j] = 0;
	      return y0;
	    },
	    zero: d3_layout_stackOffsetZero
	  });
	  function d3_layout_stackOrderDefault(data) {
	    return d3.range(data.length);
	  }
	  function d3_layout_stackOffsetZero(data) {
	    var j = -1, m = data[0].length, y0 = [];
	    while (++j < m) y0[j] = 0;
	    return y0;
	  }
	  function d3_layout_stackMaxIndex(array) {
	    var i = 1, j = 0, v = array[0][1], k, n = array.length;
	    for (;i < n; ++i) {
	      if ((k = array[i][1]) > v) {
	        j = i;
	        v = k;
	      }
	    }
	    return j;
	  }
	  function d3_layout_stackReduceSum(d) {
	    return d.reduce(d3_layout_stackSum, 0);
	  }
	  function d3_layout_stackSum(p, d) {
	    return p + d[1];
	  }
	  d3.layout.histogram = function() {
	    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
	    function histogram(data, i) {
	      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
	      while (++i < m) {
	        bin = bins[i] = [];
	        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
	        bin.y = 0;
	      }
	      if (m > 0) {
	        i = -1;
	        while (++i < n) {
	          x = values[i];
	          if (x >= range[0] && x <= range[1]) {
	            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
	            bin.y += k;
	            bin.push(data[i]);
	          }
	        }
	      }
	      return bins;
	    }
	    histogram.value = function(x) {
	      if (!arguments.length) return valuer;
	      valuer = x;
	      return histogram;
	    };
	    histogram.range = function(x) {
	      if (!arguments.length) return ranger;
	      ranger = d3_functor(x);
	      return histogram;
	    };
	    histogram.bins = function(x) {
	      if (!arguments.length) return binner;
	      binner = typeof x === "number" ? function(range) {
	        return d3_layout_histogramBinFixed(range, x);
	      } : d3_functor(x);
	      return histogram;
	    };
	    histogram.frequency = function(x) {
	      if (!arguments.length) return frequency;
	      frequency = !!x;
	      return histogram;
	    };
	    return histogram;
	  };
	  function d3_layout_histogramBinSturges(range, values) {
	    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
	  }
	  function d3_layout_histogramBinFixed(range, n) {
	    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
	    while (++x <= n) f[x] = m * x + b;
	    return f;
	  }
	  function d3_layout_histogramRange(values) {
	    return [ d3.min(values), d3.max(values) ];
	  }
	  d3.layout.pack = function() {
	    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
	    function pack(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
	        return radius;
	      };
	      root.x = root.y = 0;
	      d3_layout_hierarchyVisitAfter(root, function(d) {
	        d.r = +r(d.value);
	      });
	      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	      if (padding) {
	        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r += dr;
	        });
	        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r -= dr;
	        });
	      }
	      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
	      return nodes;
	    }
	    pack.size = function(_) {
	      if (!arguments.length) return size;
	      size = _;
	      return pack;
	    };
	    pack.radius = function(_) {
	      if (!arguments.length) return radius;
	      radius = _ == null || typeof _ === "function" ? _ : +_;
	      return pack;
	    };
	    pack.padding = function(_) {
	      if (!arguments.length) return padding;
	      padding = +_;
	      return pack;
	    };
	    return d3_layout_hierarchyRebind(pack, hierarchy);
	  };
	  function d3_layout_packSort(a, b) {
	    return a.value - b.value;
	  }
	  function d3_layout_packInsert(a, b) {
	    var c = a._pack_next;
	    a._pack_next = b;
	    b._pack_prev = a;
	    b._pack_next = c;
	    c._pack_prev = b;
	  }
	  function d3_layout_packSplice(a, b) {
	    a._pack_next = b;
	    b._pack_prev = a;
	  }
	  function d3_layout_packIntersects(a, b) {
	    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
	    return .999 * dr * dr > dx * dx + dy * dy;
	  }
	  function d3_layout_packSiblings(node) {
	    if (!(nodes = node.children) || !(n = nodes.length)) return;
	    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
	    function bound(node) {
	      xMin = Math.min(node.x - node.r, xMin);
	      xMax = Math.max(node.x + node.r, xMax);
	      yMin = Math.min(node.y - node.r, yMin);
	      yMax = Math.max(node.y + node.r, yMax);
	    }
	    nodes.forEach(d3_layout_packLink);
	    a = nodes[0];
	    a.x = -a.r;
	    a.y = 0;
	    bound(a);
	    if (n > 1) {
	      b = nodes[1];
	      b.x = b.r;
	      b.y = 0;
	      bound(b);
	      if (n > 2) {
	        c = nodes[2];
	        d3_layout_packPlace(a, b, c);
	        bound(c);
	        d3_layout_packInsert(a, c);
	        a._pack_prev = c;
	        d3_layout_packInsert(c, b);
	        b = a._pack_next;
	        for (i = 3; i < n; i++) {
	          d3_layout_packPlace(a, b, c = nodes[i]);
	          var isect = 0, s1 = 1, s2 = 1;
	          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
	            if (d3_layout_packIntersects(j, c)) {
	              isect = 1;
	              break;
	            }
	          }
	          if (isect == 1) {
	            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
	              if (d3_layout_packIntersects(k, c)) {
	                break;
	              }
	            }
	          }
	          if (isect) {
	            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
	            i--;
	          } else {
	            d3_layout_packInsert(a, c);
	            b = c;
	            bound(c);
	          }
	        }
	      }
	    }
	    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
	    for (i = 0; i < n; i++) {
	      c = nodes[i];
	      c.x -= cx;
	      c.y -= cy;
	      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
	    }
	    node.r = cr;
	    nodes.forEach(d3_layout_packUnlink);
	  }
	  function d3_layout_packLink(node) {
	    node._pack_next = node._pack_prev = node;
	  }
	  function d3_layout_packUnlink(node) {
	    delete node._pack_next;
	    delete node._pack_prev;
	  }
	  function d3_layout_packTransform(node, x, y, k) {
	    var children = node.children;
	    node.x = x += k * node.x;
	    node.y = y += k * node.y;
	    node.r *= k;
	    if (children) {
	      var i = -1, n = children.length;
	      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
	    }
	  }
	  function d3_layout_packPlace(a, b, c) {
	    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
	    if (db && (dx || dy)) {
	      var da = b.r + c.r, dc = dx * dx + dy * dy;
	      da *= da;
	      db *= db;
	      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
	      c.x = a.x + x * dx + y * dy;
	      c.y = a.y + x * dy - y * dx;
	    } else {
	      c.x = a.x + db;
	      c.y = a.y;
	    }
	  }
	  d3.layout.tree = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
	    function tree(d, i) {
	      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
	      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
	      d3_layout_hierarchyVisitBefore(root1, secondWalk);
	      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
	        var left = root0, right = root0, bottom = root0;
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          if (node.x < left.x) left = node;
	          if (node.x > right.x) right = node;
	          if (node.depth > bottom.depth) bottom = node;
	        });
	        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          node.x = (node.x + tx) * kx;
	          node.y = node.depth * ky;
	        });
	      }
	      return nodes;
	    }
	    function wrapTree(root0) {
	      var root1 = {
	        A: null,
	        children: [ root0 ]
	      }, queue = [ root1 ], node1;
	      while ((node1 = queue.pop()) != null) {
	        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
	          queue.push((children[i] = child = {
	            _: children[i],
	            parent: node1,
	            children: (child = children[i].children) && child.slice() || [],
	            A: null,
	            a: null,
	            z: 0,
	            m: 0,
	            c: 0,
	            s: 0,
	            t: null,
	            i: i
	          }).a = child);
	        }
	      }
	      return root1.children[0];
	    }
	    function firstWalk(v) {
	      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
	      if (children.length) {
	        d3_layout_treeShift(v);
	        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
	        if (w) {
	          v.z = w.z + separation(v._, w._);
	          v.m = v.z - midpoint;
	        } else {
	          v.z = midpoint;
	        }
	      } else if (w) {
	        v.z = w.z + separation(v._, w._);
	      }
	      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
	    }
	    function secondWalk(v) {
	      v._.x = v.z + v.parent.m;
	      v.m += v.parent.m;
	    }
	    function apportion(v, w, ancestor) {
	      if (w) {
	        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
	        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
	          vom = d3_layout_treeLeft(vom);
	          vop = d3_layout_treeRight(vop);
	          vop.a = v;
	          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
	          if (shift > 0) {
	            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
	            sip += shift;
	            sop += shift;
	          }
	          sim += vim.m;
	          sip += vip.m;
	          som += vom.m;
	          sop += vop.m;
	        }
	        if (vim && !d3_layout_treeRight(vop)) {
	          vop.t = vim;
	          vop.m += sim - sop;
	        }
	        if (vip && !d3_layout_treeLeft(vom)) {
	          vom.t = vip;
	          vom.m += sip - som;
	          ancestor = v;
	        }
	      }
	      return ancestor;
	    }
	    function sizeNode(node) {
	      node.x *= size[0];
	      node.y = node.depth * size[1];
	    }
	    tree.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return tree;
	    };
	    tree.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null ? sizeNode : null;
	      return tree;
	    };
	    tree.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) == null ? null : sizeNode;
	      return tree;
	    };
	    return d3_layout_hierarchyRebind(tree, hierarchy);
	  };
	  function d3_layout_treeSeparation(a, b) {
	    return a.parent == b.parent ? 1 : 2;
	  }
	  function d3_layout_treeLeft(v) {
	    var children = v.children;
	    return children.length ? children[0] : v.t;
	  }
	  function d3_layout_treeRight(v) {
	    var children = v.children, n;
	    return (n = children.length) ? children[n - 1] : v.t;
	  }
	  function d3_layout_treeMove(wm, wp, shift) {
	    var change = shift / (wp.i - wm.i);
	    wp.c -= change;
	    wp.s += shift;
	    wm.c += change;
	    wp.z += shift;
	    wp.m += shift;
	  }
	  function d3_layout_treeShift(v) {
	    var shift = 0, change = 0, children = v.children, i = children.length, w;
	    while (--i >= 0) {
	      w = children[i];
	      w.z += shift;
	      w.m += shift;
	      shift += w.s + (change += w.c);
	    }
	  }
	  function d3_layout_treeAncestor(vim, v, ancestor) {
	    return vim.a.parent === v.parent ? vim.a : ancestor;
	  }
	  d3.layout.cluster = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
	    function cluster(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var children = node.children;
	        if (children && children.length) {
	          node.x = d3_layout_clusterX(children);
	          node.y = d3_layout_clusterY(children);
	        } else {
	          node.x = previousNode ? x += separation(node, previousNode) : 0;
	          node.y = 0;
	          previousNode = node;
	        }
	      });
	      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
	      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
	        node.x = (node.x - root.x) * size[0];
	        node.y = (root.y - node.y) * size[1];
	      } : function(node) {
	        node.x = (node.x - x0) / (x1 - x0) * size[0];
	        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
	      });
	      return nodes;
	    }
	    cluster.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return cluster;
	    };
	    cluster.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null;
	      return cluster;
	    };
	    cluster.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) != null;
	      return cluster;
	    };
	    return d3_layout_hierarchyRebind(cluster, hierarchy);
	  };
	  function d3_layout_clusterY(children) {
	    return 1 + d3.max(children, function(child) {
	      return child.y;
	    });
	  }
	  function d3_layout_clusterX(children) {
	    return children.reduce(function(x, child) {
	      return x + child.x;
	    }, 0) / children.length;
	  }
	  function d3_layout_clusterLeft(node) {
	    var children = node.children;
	    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
	  }
	  function d3_layout_clusterRight(node) {
	    var children = node.children, n;
	    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
	  }
	  d3.layout.treemap = function() {
	    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
	    function scale(children, k) {
	      var i = -1, n = children.length, child, area;
	      while (++i < n) {
	        area = (child = children[i]).value * (k < 0 ? 0 : k);
	        child.area = isNaN(area) || area <= 0 ? 0 : area;
	      }
	    }
	    function squarify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while ((n = remaining.length) > 0) {
	          row.push(child = remaining[n - 1]);
	          row.area += child.area;
	          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
	            remaining.pop();
	            best = score;
	          } else {
	            row.area -= row.pop().area;
	            position(row, u, rect, false);
	            u = Math.min(rect.dx, rect.dy);
	            row.length = row.area = 0;
	            best = Infinity;
	          }
	        }
	        if (row.length) {
	          position(row, u, rect, true);
	          row.length = row.area = 0;
	        }
	        children.forEach(squarify);
	      }
	    }
	    function stickify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), remaining = children.slice(), child, row = [];
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while (child = remaining.pop()) {
	          row.push(child);
	          row.area += child.area;
	          if (child.z != null) {
	            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
	            row.length = row.area = 0;
	          }
	        }
	        children.forEach(stickify);
	      }
	    }
	    function worst(row, u) {
	      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
	      while (++i < n) {
	        if (!(r = row[i].area)) continue;
	        if (r < rmin) rmin = r;
	        if (r > rmax) rmax = r;
	      }
	      s *= s;
	      u *= u;
	      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
	    }
	    function position(row, u, rect, flush) {
	      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
	      if (u == rect.dx) {
	        if (flush || v > rect.dy) v = rect.dy;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dy = v;
	          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
	        }
	        o.z = true;
	        o.dx += rect.x + rect.dx - x;
	        rect.y += v;
	        rect.dy -= v;
	      } else {
	        if (flush || v > rect.dx) v = rect.dx;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dx = v;
	          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
	        }
	        o.z = false;
	        o.dy += rect.y + rect.dy - y;
	        rect.x += v;
	        rect.dx -= v;
	      }
	    }
	    function treemap(d) {
	      var nodes = stickies || hierarchy(d), root = nodes[0];
	      root.x = 0;
	      root.y = 0;
	      root.dx = size[0];
	      root.dy = size[1];
	      if (stickies) hierarchy.revalue(root);
	      scale([ root ], root.dx * root.dy / root.value);
	      (stickies ? stickify : squarify)(root);
	      if (sticky) stickies = nodes;
	      return nodes;
	    }
	    treemap.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return treemap;
	    };
	    treemap.padding = function(x) {
	      if (!arguments.length) return padding;
	      function padFunction(node) {
	        var p = x.call(treemap, node, node.depth);
	        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
	      }
	      function padConstant(node) {
	        return d3_layout_treemapPad(node, x);
	      }
	      var type;
	      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
	      padConstant) : padConstant;
	      return treemap;
	    };
	    treemap.round = function(x) {
	      if (!arguments.length) return round != Number;
	      round = x ? Math.round : Number;
	      return treemap;
	    };
	    treemap.sticky = function(x) {
	      if (!arguments.length) return sticky;
	      sticky = x;
	      stickies = null;
	      return treemap;
	    };
	    treemap.ratio = function(x) {
	      if (!arguments.length) return ratio;
	      ratio = x;
	      return treemap;
	    };
	    treemap.mode = function(x) {
	      if (!arguments.length) return mode;
	      mode = x + "";
	      return treemap;
	    };
	    return d3_layout_hierarchyRebind(treemap, hierarchy);
	  };
	  function d3_layout_treemapPadNull(node) {
	    return {
	      x: node.x,
	      y: node.y,
	      dx: node.dx,
	      dy: node.dy
	    };
	  }
	  function d3_layout_treemapPad(node, padding) {
	    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
	    if (dx < 0) {
	      x += dx / 2;
	      dx = 0;
	    }
	    if (dy < 0) {
	      y += dy / 2;
	      dy = 0;
	    }
	    return {
	      x: x,
	      y: y,
	      dx: dx,
	      dy: dy
	    };
	  }
	  d3.random = {
	    normal: function(µ, σ) {
	      var n = arguments.length;
	      if (n < 2) σ = 1;
	      if (n < 1) µ = 0;
	      return function() {
	        var x, y, r;
	        do {
	          x = Math.random() * 2 - 1;
	          y = Math.random() * 2 - 1;
	          r = x * x + y * y;
	        } while (!r || r > 1);
	        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
	      };
	    },
	    logNormal: function() {
	      var random = d3.random.normal.apply(d3, arguments);
	      return function() {
	        return Math.exp(random());
	      };
	    },
	    bates: function(m) {
	      var random = d3.random.irwinHall(m);
	      return function() {
	        return random() / m;
	      };
	    },
	    irwinHall: function(m) {
	      return function() {
	        for (var s = 0, j = 0; j < m; j++) s += Math.random();
	        return s;
	      };
	    }
	  };
	  d3.scale = {};
	  function d3_scaleExtent(domain) {
	    var start = domain[0], stop = domain[domain.length - 1];
	    return start < stop ? [ start, stop ] : [ stop, start ];
	  }
	  function d3_scaleRange(scale) {
	    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
	  }
	  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
	    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
	    return function(x) {
	      return i(u(x));
	    };
	  }
	  function d3_scale_nice(domain, nice) {
	    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
	    if (x1 < x0) {
	      dx = i0, i0 = i1, i1 = dx;
	      dx = x0, x0 = x1, x1 = dx;
	    }
	    domain[i0] = nice.floor(x0);
	    domain[i1] = nice.ceil(x1);
	    return domain;
	  }
	  function d3_scale_niceStep(step) {
	    return step ? {
	      floor: function(x) {
	        return Math.floor(x / step) * step;
	      },
	      ceil: function(x) {
	        return Math.ceil(x / step) * step;
	      }
	    } : d3_scale_niceIdentity;
	  }
	  var d3_scale_niceIdentity = {
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
	    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
	    if (domain[k] < domain[0]) {
	      domain = domain.slice().reverse();
	      range = range.slice().reverse();
	    }
	    while (++j <= k) {
	      u.push(uninterpolate(domain[j - 1], domain[j]));
	      i.push(interpolate(range[j - 1], range[j]));
	    }
	    return function(x) {
	      var j = d3.bisect(domain, x, 1, k) - 1;
	      return i[j](u[j](x));
	    };
	  }
	  d3.scale.linear = function() {
	    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
	  };
	  function d3_scale_linear(domain, range, interpolate, clamp) {
	    var output, input;
	    function rescale() {
	      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
	      output = linear(domain, range, uninterpolate, interpolate);
	      input = linear(range, domain, uninterpolate, d3_interpolate);
	      return scale;
	    }
	    function scale(x) {
	      return output(x);
	    }
	    scale.invert = function(y) {
	      return input(y);
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(Number);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.rangeRound = function(x) {
	      return scale.range(x).interpolate(d3_interpolateRound);
	    };
	    scale.clamp = function(x) {
	      if (!arguments.length) return clamp;
	      clamp = x;
	      return rescale();
	    };
	    scale.interpolate = function(x) {
	      if (!arguments.length) return interpolate;
	      interpolate = x;
	      return rescale();
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      d3_scale_linearNice(domain, m);
	      return rescale();
	    };
	    scale.copy = function() {
	      return d3_scale_linear(domain, range, interpolate, clamp);
	    };
	    return rescale();
	  }
	  function d3_scale_linearRebind(scale, linear) {
	    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
	  }
	  function d3_scale_linearNice(domain, m) {
	    return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
	  }
	  function d3_scale_linearTickRange(domain, m) {
	    if (m == null) m = 10;
	    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
	    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
	    extent[0] = Math.ceil(extent[0] / step) * step;
	    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
	    extent[2] = step;
	    return extent;
	  }
	  function d3_scale_linearTicks(domain, m) {
	    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
	  }
	  function d3_scale_linearTickFormat(domain, m, format) {
	    var range = d3_scale_linearTickRange(domain, m);
	    if (format) {
	      var match = d3_format_re.exec(format);
	      match.shift();
	      if (match[8] === "s") {
	        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
	        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
	        match[8] = "f";
	        format = d3.format(match.join(""));
	        return function(d) {
	          return format(prefix.scale(d)) + prefix.symbol;
	        };
	      }
	      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
	      format = match.join("");
	    } else {
	      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
	    }
	    return d3.format(format);
	  }
	  var d3_scale_linearFormatSignificant = {
	    s: 1,
	    g: 1,
	    p: 1,
	    r: 1,
	    e: 1
	  };
	  function d3_scale_linearPrecision(value) {
	    return -Math.floor(Math.log(value) / Math.LN10 + .01);
	  }
	  function d3_scale_linearFormatPrecision(type, range) {
	    var p = d3_scale_linearPrecision(range[2]);
	    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
	  }
	  d3.scale.log = function() {
	    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
	  };
	  function d3_scale_log(linear, base, positive, domain) {
	    function log(x) {
	      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
	    }
	    function pow(x) {
	      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
	    }
	    function scale(x) {
	      return linear(log(x));
	    }
	    scale.invert = function(x) {
	      return pow(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      positive = x[0] >= 0;
	      linear.domain((domain = x.map(Number)).map(log));
	      return scale;
	    };
	    scale.base = function(_) {
	      if (!arguments.length) return base;
	      base = +_;
	      linear.domain(domain.map(log));
	      return scale;
	    };
	    scale.nice = function() {
	      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
	      linear.domain(niced);
	      domain = niced.map(pow);
	      return scale;
	    };
	    scale.ticks = function() {
	      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
	      if (isFinite(j - i)) {
	        if (positive) {
	          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
	          ticks.push(pow(i));
	        } else {
	          ticks.push(pow(i));
	          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
	        }
	        for (i = 0; ticks[i] < u; i++) {}
	        for (j = ticks.length; ticks[j - 1] > v; j--) {}
	        ticks = ticks.slice(i, j);
	      }
	      return ticks;
	    };
	    scale.tickFormat = function(n, format) {
	      if (!arguments.length) return d3_scale_logFormat;
	      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
	      var k = Math.max(.1, n / scale.ticks().length), f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, 
	      Math.floor), e;
	      return function(d) {
	        return d / pow(f(log(d) + e)) <= k ? format(d) : "";
	      };
	    };
	    scale.copy = function() {
	      return d3_scale_log(linear.copy(), base, positive, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
	    floor: function(x) {
	      return -Math.ceil(-x);
	    },
	    ceil: function(x) {
	      return -Math.floor(-x);
	    }
	  };
	  d3.scale.pow = function() {
	    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
	  };
	  function d3_scale_pow(linear, exponent, domain) {
	    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
	    function scale(x) {
	      return linear(powp(x));
	    }
	    scale.invert = function(x) {
	      return powb(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      linear.domain((domain = x.map(Number)).map(powp));
	      return scale;
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      return scale.domain(d3_scale_linearNice(domain, m));
	    };
	    scale.exponent = function(x) {
	      if (!arguments.length) return exponent;
	      powp = d3_scale_powPow(exponent = x);
	      powb = d3_scale_powPow(1 / exponent);
	      linear.domain(domain.map(powp));
	      return scale;
	    };
	    scale.copy = function() {
	      return d3_scale_pow(linear.copy(), exponent, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_scale_powPow(e) {
	    return function(x) {
	      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
	    };
	  }
	  d3.scale.sqrt = function() {
	    return d3.scale.pow().exponent(.5);
	  };
	  d3.scale.ordinal = function() {
	    return d3_scale_ordinal([], {
	      t: "range",
	      a: [ [] ]
	    });
	  };
	  function d3_scale_ordinal(domain, ranger) {
	    var index, range, rangeBand;
	    function scale(x) {
	      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
	    }
	    function steps(start, step) {
	      return d3.range(domain.length).map(function(i) {
	        return start + step * i;
	      });
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = [];
	      index = new d3_Map();
	      var i = -1, n = x.length, xi;
	      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
	      return scale[ranger.t].apply(scale, ranger.a);
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      rangeBand = 0;
	      ranger = {
	        t: "range",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangePoints = function(x, padding) {
	      if (arguments.length < 2) padding = 0;
	      var start = x[0], stop = x[1], step = (stop - start) / (Math.max(1, domain.length - 1) + padding);
	      range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);
	      rangeBand = 0;
	      ranger = {
	        t: "rangePoints",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
	      range = steps(start + step * outerPadding, step);
	      if (reverse) range.reverse();
	      rangeBand = step * (1 - padding);
	      ranger = {
	        t: "rangeBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeRoundBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding)), error = stop - start - (domain.length - padding) * step;
	      range = steps(start + Math.round(error / 2), step);
	      if (reverse) range.reverse();
	      rangeBand = Math.round(step * (1 - padding));
	      ranger = {
	        t: "rangeRoundBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBand = function() {
	      return rangeBand;
	    };
	    scale.rangeExtent = function() {
	      return d3_scaleExtent(ranger.a[0]);
	    };
	    scale.copy = function() {
	      return d3_scale_ordinal(domain, ranger);
	    };
	    return scale.domain(domain);
	  }
	  d3.scale.category10 = function() {
	    return d3.scale.ordinal().range(d3_category10);
	  };
	  d3.scale.category20 = function() {
	    return d3.scale.ordinal().range(d3_category20);
	  };
	  d3.scale.category20b = function() {
	    return d3.scale.ordinal().range(d3_category20b);
	  };
	  d3.scale.category20c = function() {
	    return d3.scale.ordinal().range(d3_category20c);
	  };
	  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
	  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
	  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
	  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
	  d3.scale.quantile = function() {
	    return d3_scale_quantile([], []);
	  };
	  function d3_scale_quantile(domain, range) {
	    var thresholds;
	    function rescale() {
	      var k = 0, q = range.length;
	      thresholds = [];
	      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
	      return scale;
	    }
	    function scale(x) {
	      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.quantiles = function() {
	      return thresholds;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantile(domain, range);
	    };
	    return rescale();
	  }
	  d3.scale.quantize = function() {
	    return d3_scale_quantize(0, 1, [ 0, 1 ]);
	  };
	  function d3_scale_quantize(x0, x1, range) {
	    var kx, i;
	    function scale(x) {
	      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
	    }
	    function rescale() {
	      kx = range.length / (x1 - x0);
	      i = range.length - 1;
	      return scale;
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return [ x0, x1 ];
	      x0 = +x[0];
	      x1 = +x[x.length - 1];
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      y = y < 0 ? NaN : y / kx + x0;
	      return [ y, y + 1 / kx ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantize(x0, x1, range);
	    };
	    return rescale();
	  }
	  d3.scale.threshold = function() {
	    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
	  };
	  function d3_scale_threshold(domain, range) {
	    function scale(x) {
	      if (x <= x) return range[d3.bisect(domain, x)];
	    }
	    scale.domain = function(_) {
	      if (!arguments.length) return domain;
	      domain = _;
	      return scale;
	    };
	    scale.range = function(_) {
	      if (!arguments.length) return range;
	      range = _;
	      return scale;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return [ domain[y - 1], domain[y] ];
	    };
	    scale.copy = function() {
	      return d3_scale_threshold(domain, range);
	    };
	    return scale;
	  }
	  d3.scale.identity = function() {
	    return d3_scale_identity([ 0, 1 ]);
	  };
	  function d3_scale_identity(domain) {
	    function identity(x) {
	      return +x;
	    }
	    identity.invert = identity;
	    identity.domain = identity.range = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(identity);
	      return identity;
	    };
	    identity.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    identity.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    identity.copy = function() {
	      return d3_scale_identity(domain);
	    };
	    return identity;
	  }
	  d3.svg = {};
	  d3.svg.arc = function() {
	    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
	    function arc() {
	      var r0 = innerRadius.apply(this, arguments), r1 = outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset, a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset, da = (a1 < a0 && (da = a0, 
	      a0 = a1, a1 = da), a1 - a0), df = da < π ? "0" : "1", c0 = Math.cos(a0), s0 = Math.sin(a0), c1 = Math.cos(a1), s1 = Math.sin(a1);
	      return da >= d3_svg_arcMax ? r0 ? "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + r0 + "Z" : "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : r0 ? "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z" : "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0" + "Z";
	    }
	    arc.innerRadius = function(v) {
	      if (!arguments.length) return innerRadius;
	      innerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.outerRadius = function(v) {
	      if (!arguments.length) return outerRadius;
	      outerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return arc;
	    };
	    arc.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return arc;
	    };
	    arc.centroid = function() {
	      var r = (innerRadius.apply(this, arguments) + outerRadius.apply(this, arguments)) / 2, a = (startAngle.apply(this, arguments) + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
	      return [ Math.cos(a) * r, Math.sin(a) * r ];
	    };
	    return arc;
	  };
	  var d3_svg_arcOffset = -halfπ, d3_svg_arcMax = τ - ε;
	  function d3_svg_arcInnerRadius(d) {
	    return d.innerRadius;
	  }
	  function d3_svg_arcOuterRadius(d) {
	    return d.outerRadius;
	  }
	  function d3_svg_arcStartAngle(d) {
	    return d.startAngle;
	  }
	  function d3_svg_arcEndAngle(d) {
	    return d.endAngle;
	  }
	  function d3_svg_line(projection) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
	    function line(data) {
	      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
	      function segment() {
	        segments.push("M", interpolate(projection(points), tension));
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
	        } else if (points.length) {
	          segment();
	          points = [];
	        }
	      }
	      if (points.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    line.x = function(_) {
	      if (!arguments.length) return x;
	      x = _;
	      return line;
	    };
	    line.y = function(_) {
	      if (!arguments.length) return y;
	      y = _;
	      return line;
	    };
	    line.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return line;
	    };
	    line.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      return line;
	    };
	    line.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return line;
	    };
	    return line;
	  }
	  d3.svg.line = function() {
	    return d3_svg_line(d3_identity);
	  };
	  var d3_svg_lineInterpolators = d3.map({
	    linear: d3_svg_lineLinear,
	    "linear-closed": d3_svg_lineLinearClosed,
	    step: d3_svg_lineStep,
	    "step-before": d3_svg_lineStepBefore,
	    "step-after": d3_svg_lineStepAfter,
	    basis: d3_svg_lineBasis,
	    "basis-open": d3_svg_lineBasisOpen,
	    "basis-closed": d3_svg_lineBasisClosed,
	    bundle: d3_svg_lineBundle,
	    cardinal: d3_svg_lineCardinal,
	    "cardinal-open": d3_svg_lineCardinalOpen,
	    "cardinal-closed": d3_svg_lineCardinalClosed,
	    monotone: d3_svg_lineMonotone
	  });
	  d3_svg_lineInterpolators.forEach(function(key, value) {
	    value.key = key;
	    value.closed = /-closed$/.test(key);
	  });
	  function d3_svg_lineLinear(points) {
	    return points.join("L");
	  }
	  function d3_svg_lineLinearClosed(points) {
	    return d3_svg_lineLinear(points) + "Z";
	  }
	  function d3_svg_lineStep(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
	    if (n > 1) path.push("H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepBefore(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepAfter(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
	    return path.join("");
	  }
	  function d3_svg_lineCardinalOpen(points, tension) {
	    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1), d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineCardinalClosed(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
	    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
	  }
	  function d3_svg_lineCardinal(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineHermite(points, tangents) {
	    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
	      return d3_svg_lineLinear(points);
	    }
	    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
	    if (quad) {
	      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
	      p0 = points[1];
	      pi = 2;
	    }
	    if (tangents.length > 1) {
	      t = tangents[1];
	      p = points[pi];
	      pi++;
	      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      for (var i = 2; i < tangents.length; i++, pi++) {
	        p = points[pi];
	        t = tangents[i];
	        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      }
	    }
	    if (quad) {
	      var lp = points[pi];
	      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
	    }
	    return path;
	  }
	  function d3_svg_lineCardinalTangents(points, tension) {
	    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
	    while (++i < n) {
	      p0 = p1;
	      p1 = p2;
	      p2 = points[i];
	      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineBasis(points) {
	    if (points.length < 3) return d3_svg_lineLinear(points);
	    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    points.push(points[n - 1]);
	    while (++i <= n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    points.pop();
	    path.push("L", pi);
	    return path.join("");
	  }
	  function d3_svg_lineBasisOpen(points) {
	    if (points.length < 4) return d3_svg_lineLinear(points);
	    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
	    while (++i < 3) {
	      pi = points[i];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
	    --i;
	    while (++i < n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBasisClosed(points) {
	    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
	    while (++i < 4) {
	      pi = points[i % n];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    --i;
	    while (++i < m) {
	      pi = points[i % n];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBundle(points, tension) {
	    var n = points.length - 1;
	    if (n) {
	      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
	      while (++i <= n) {
	        p = points[i];
	        t = i / n;
	        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
	        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
	      }
	    }
	    return d3_svg_lineBasis(points);
	  }
	  function d3_svg_lineDot4(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
	  }
	  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
	  function d3_svg_lineBasisBezier(path, x, y) {
	    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
	  }
	  function d3_svg_lineSlope(p0, p1) {
	    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
	  }
	  function d3_svg_lineFiniteDifferences(points) {
	    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
	    while (++i < j) {
	      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
	    }
	    m[i] = d;
	    return m;
	  }
	  function d3_svg_lineMonotoneTangents(points) {
	    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
	    while (++i < j) {
	      d = d3_svg_lineSlope(points[i], points[i + 1]);
	      if (abs(d) < ε) {
	        m[i] = m[i + 1] = 0;
	      } else {
	        a = m[i] / d;
	        b = m[i + 1] / d;
	        s = a * a + b * b;
	        if (s > 9) {
	          s = d * 3 / Math.sqrt(s);
	          m[i] = s * a;
	          m[i + 1] = s * b;
	        }
	      }
	    }
	    i = -1;
	    while (++i <= j) {
	      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
	      tangents.push([ s || 0, m[i] * s || 0 ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineMonotone(points) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
	  }
	  d3.svg.line.radial = function() {
	    var line = d3_svg_line(d3_svg_lineRadial);
	    line.radius = line.x, delete line.x;
	    line.angle = line.y, delete line.y;
	    return line;
	  };
	  function d3_svg_lineRadial(points) {
	    var point, i = -1, n = points.length, r, a;
	    while (++i < n) {
	      point = points[i];
	      r = point[0];
	      a = point[1] + d3_svg_arcOffset;
	      point[0] = r * Math.cos(a);
	      point[1] = r * Math.sin(a);
	    }
	    return points;
	  }
	  function d3_svg_area(projection) {
	    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
	    function area(data) {
	      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
	        return x;
	      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
	        return y;
	      } : d3_functor(y1), x, y;
	      function segment() {
	        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
	          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
	        } else if (points0.length) {
	          segment();
	          points0 = [];
	          points1 = [];
	        }
	      }
	      if (points0.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    area.x = function(_) {
	      if (!arguments.length) return x1;
	      x0 = x1 = _;
	      return area;
	    };
	    area.x0 = function(_) {
	      if (!arguments.length) return x0;
	      x0 = _;
	      return area;
	    };
	    area.x1 = function(_) {
	      if (!arguments.length) return x1;
	      x1 = _;
	      return area;
	    };
	    area.y = function(_) {
	      if (!arguments.length) return y1;
	      y0 = y1 = _;
	      return area;
	    };
	    area.y0 = function(_) {
	      if (!arguments.length) return y0;
	      y0 = _;
	      return area;
	    };
	    area.y1 = function(_) {
	      if (!arguments.length) return y1;
	      y1 = _;
	      return area;
	    };
	    area.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return area;
	    };
	    area.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      interpolateReverse = interpolate.reverse || interpolate;
	      L = interpolate.closed ? "M" : "L";
	      return area;
	    };
	    area.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return area;
	    };
	    return area;
	  }
	  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
	  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
	  d3.svg.area = function() {
	    return d3_svg_area(d3_identity);
	  };
	  d3.svg.area.radial = function() {
	    var area = d3_svg_area(d3_svg_lineRadial);
	    area.radius = area.x, delete area.x;
	    area.innerRadius = area.x0, delete area.x0;
	    area.outerRadius = area.x1, delete area.x1;
	    area.angle = area.y, delete area.y;
	    area.startAngle = area.y0, delete area.y0;
	    area.endAngle = area.y1, delete area.y1;
	    return area;
	  };
	  d3.svg.chord = function() {
	    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
	    function chord(d, i) {
	      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
	      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
	    }
	    function subgroup(self, f, d, i) {
	      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset, a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;
	      return {
	        r: r,
	        a0: a0,
	        a1: a1,
	        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
	        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
	      };
	    }
	    function equals(a, b) {
	      return a.a0 == b.a0 && a.a1 == b.a1;
	    }
	    function arc(r, p, a) {
	      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
	    }
	    function curve(r0, p0, r1, p1) {
	      return "Q 0,0 " + p1;
	    }
	    chord.radius = function(v) {
	      if (!arguments.length) return radius;
	      radius = d3_functor(v);
	      return chord;
	    };
	    chord.source = function(v) {
	      if (!arguments.length) return source;
	      source = d3_functor(v);
	      return chord;
	    };
	    chord.target = function(v) {
	      if (!arguments.length) return target;
	      target = d3_functor(v);
	      return chord;
	    };
	    chord.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return chord;
	    };
	    chord.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return chord;
	    };
	    return chord;
	  };
	  function d3_svg_chordRadius(d) {
	    return d.radius;
	  }
	  d3.svg.diagonal = function() {
	    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
	    function diagonal(d, i) {
	      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
	        x: p0.x,
	        y: m
	      }, {
	        x: p3.x,
	        y: m
	      }, p3 ];
	      p = p.map(projection);
	      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
	    }
	    diagonal.source = function(x) {
	      if (!arguments.length) return source;
	      source = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.target = function(x) {
	      if (!arguments.length) return target;
	      target = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.projection = function(x) {
	      if (!arguments.length) return projection;
	      projection = x;
	      return diagonal;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalProjection(d) {
	    return [ d.x, d.y ];
	  }
	  d3.svg.diagonal.radial = function() {
	    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
	    diagonal.projection = function(x) {
	      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalRadialProjection(projection) {
	    return function() {
	      var d = projection.apply(this, arguments), r = d[0], a = d[1] + d3_svg_arcOffset;
	      return [ r * Math.cos(a), r * Math.sin(a) ];
	    };
	  }
	  d3.svg.symbol = function() {
	    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
	    function symbol(d, i) {
	      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
	    }
	    symbol.type = function(x) {
	      if (!arguments.length) return type;
	      type = d3_functor(x);
	      return symbol;
	    };
	    symbol.size = function(x) {
	      if (!arguments.length) return size;
	      size = d3_functor(x);
	      return symbol;
	    };
	    return symbol;
	  };
	  function d3_svg_symbolSize() {
	    return 64;
	  }
	  function d3_svg_symbolType() {
	    return "circle";
	  }
	  function d3_svg_symbolCircle(size) {
	    var r = Math.sqrt(size / π);
	    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
	  }
	  var d3_svg_symbols = d3.map({
	    circle: d3_svg_symbolCircle,
	    cross: function(size) {
	      var r = Math.sqrt(size / 5) / 2;
	      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
	    },
	    diamond: function(size) {
	      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
	      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
	    },
	    square: function(size) {
	      var r = Math.sqrt(size) / 2;
	      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
	    },
	    "triangle-down": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
	    },
	    "triangle-up": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
	    }
	  });
	  d3.svg.symbolTypes = d3_svg_symbols.keys();
	  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
	  function d3_transition(groups, id) {
	    d3_subclass(groups, d3_transitionPrototype);
	    groups.id = id;
	    return groups;
	  }
	  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
	  d3_transitionPrototype.call = d3_selectionPrototype.call;
	  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
	  d3_transitionPrototype.node = d3_selectionPrototype.node;
	  d3_transitionPrototype.size = d3_selectionPrototype.size;
	  d3.transition = function(selection) {
	    return arguments.length ? d3_transitionInheritId ? selection.transition() : selection : d3_selectionRoot.transition();
	  };
	  d3.transition.prototype = d3_transitionPrototype;
	  d3_transitionPrototype.select = function(selector) {
	    var id = this.id, subgroups = [], subgroup, subnode, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
	          if ("__data__" in node) subnode.__data__ = node.__data__;
	          d3_transitionNode(subnode, i, id, node.__transition__[id]);
	          subgroup.push(subnode);
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_transition(subgroups, id);
	  };
	  d3_transitionPrototype.selectAll = function(selector) {
	    var id = this.id, subgroups = [], subgroup, subnodes, node, subnode, transition;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          transition = node.__transition__[id];
	          subnodes = selector.call(node, node.__data__, i, j);
	          subgroups.push(subgroup = []);
	          for (var k = -1, o = subnodes.length; ++k < o; ) {
	            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, id, transition);
	            subgroup.push(subnode);
	          }
	        }
	      }
	    }
	    return d3_transition(subgroups, id);
	  };
	  d3_transitionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_transition(subgroups, this.id);
	  };
	  d3_transitionPrototype.tween = function(name, tween) {
	    var id = this.id;
	    if (arguments.length < 2) return this.node().__transition__[id].tween.get(name);
	    return d3_selection_each(this, tween == null ? function(node) {
	      node.__transition__[id].tween.remove(name);
	    } : function(node) {
	      node.__transition__[id].tween.set(name, tween);
	    });
	  };
	  function d3_transition_tween(groups, name, value, tween) {
	    var id = groups.id;
	    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
	      node.__transition__[id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
	    } : (value = tween(value), function(node) {
	      node.__transition__[id].tween.set(name, value);
	    }));
	  }
	  d3_transitionPrototype.attr = function(nameNS, value) {
	    if (arguments.length < 2) {
	      for (value in nameNS) this.attr(value, nameNS[value]);
	      return this;
	    }
	    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrTween(b) {
	      return b == null ? attrNull : (b += "", function() {
	        var a = this.getAttribute(name), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttribute(name, i(t));
	        });
	      });
	    }
	    function attrTweenNS(b) {
	      return b == null ? attrNullNS : (b += "", function() {
	        var a = this.getAttributeNS(name.space, name.local), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttributeNS(name.space, name.local, i(t));
	        });
	      });
	    }
	    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.attrTween = function(nameNS, tween) {
	    var name = d3.ns.qualify(nameNS);
	    function attrTween(d, i) {
	      var f = tween.call(this, d, i, this.getAttribute(name));
	      return f && function(t) {
	        this.setAttribute(name, f(t));
	      };
	    }
	    function attrTweenNS(d, i) {
	      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
	      return f && function(t) {
	        this.setAttributeNS(name.space, name.local, f(t));
	      };
	    }
	    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.style(priority, name[priority], value);
	        return this;
	      }
	      priority = "";
	    }
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleString(b) {
	      return b == null ? styleNull : (b += "", function() {
	        var a = d3_window.getComputedStyle(this, null).getPropertyValue(name), i;
	        return a !== b && (i = d3_interpolate(a, b), function(t) {
	          this.style.setProperty(name, i(t), priority);
	        });
	      });
	    }
	    return d3_transition_tween(this, "style." + name, value, styleString);
	  };
	  d3_transitionPrototype.styleTween = function(name, tween, priority) {
	    if (arguments.length < 3) priority = "";
	    function styleTween(d, i) {
	      var f = tween.call(this, d, i, d3_window.getComputedStyle(this, null).getPropertyValue(name));
	      return f && function(t) {
	        this.style.setProperty(name, f(t), priority);
	      };
	    }
	    return this.tween("style." + name, styleTween);
	  };
	  d3_transitionPrototype.text = function(value) {
	    return d3_transition_tween(this, "text", value, d3_transition_text);
	  };
	  function d3_transition_text(b) {
	    if (b == null) b = "";
	    return function() {
	      this.textContent = b;
	    };
	  }
	  d3_transitionPrototype.remove = function() {
	    return this.each("end.transition", function() {
	      var p;
	      if (this.__transition__.count < 2 && (p = this.parentNode)) p.removeChild(this);
	    });
	  };
	  d3_transitionPrototype.ease = function(value) {
	    var id = this.id;
	    if (arguments.length < 1) return this.node().__transition__[id].ease;
	    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
	    return d3_selection_each(this, function(node) {
	      node.__transition__[id].ease = value;
	    });
	  };
	  d3_transitionPrototype.delay = function(value) {
	    var id = this.id;
	    if (arguments.length < 1) return this.node().__transition__[id].delay;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node.__transition__[id].delay = +value.call(node, node.__data__, i, j);
	    } : (value = +value, function(node) {
	      node.__transition__[id].delay = value;
	    }));
	  };
	  d3_transitionPrototype.duration = function(value) {
	    var id = this.id;
	    if (arguments.length < 1) return this.node().__transition__[id].duration;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node.__transition__[id].duration = Math.max(1, value.call(node, node.__data__, i, j));
	    } : (value = Math.max(1, value), function(node) {
	      node.__transition__[id].duration = value;
	    }));
	  };
	  d3_transitionPrototype.each = function(type, listener) {
	    var id = this.id;
	    if (arguments.length < 2) {
	      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
	      d3_transitionInheritId = id;
	      d3_selection_each(this, function(node, i, j) {
	        d3_transitionInherit = node.__transition__[id];
	        type.call(node, node.__data__, i, j);
	      });
	      d3_transitionInherit = inherit;
	      d3_transitionInheritId = inheritId;
	    } else {
	      d3_selection_each(this, function(node) {
	        var transition = node.__transition__[id];
	        (transition.event || (transition.event = d3.dispatch("start", "end"))).on(type, listener);
	      });
	    }
	    return this;
	  };
	  d3_transitionPrototype.transition = function() {
	    var id0 = this.id, id1 = ++d3_transitionId, subgroups = [], subgroup, group, node, transition;
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if (node = group[i]) {
	          transition = Object.create(node.__transition__[id0]);
	          transition.delay += transition.duration;
	          d3_transitionNode(node, i, id1, transition);
	        }
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, id1);
	  };
	  function d3_transitionNode(node, i, id, inherit) {
	    var lock = node.__transition__ || (node.__transition__ = {
	      active: 0,
	      count: 0
	    }), transition = lock[id];
	    if (!transition) {
	      var time = inherit.time;
	      transition = lock[id] = {
	        tween: new d3_Map(),
	        time: time,
	        ease: inherit.ease,
	        delay: inherit.delay,
	        duration: inherit.duration
	      };
	      ++lock.count;
	      d3.timer(function(elapsed) {
	        var d = node.__data__, ease = transition.ease, delay = transition.delay, duration = transition.duration, timer = d3_timer_active, tweened = [];
	        timer.t = delay + time;
	        if (delay <= elapsed) return start(elapsed - delay);
	        timer.c = start;
	        function start(elapsed) {
	          if (lock.active > id) return stop();
	          lock.active = id;
	          transition.event && transition.event.start.call(node, d, i);
	          transition.tween.forEach(function(key, value) {
	            if (value = value.call(node, d, i)) {
	              tweened.push(value);
	            }
	          });
	          d3.timer(function() {
	            timer.c = tick(elapsed || 1) ? d3_true : tick;
	            return 1;
	          }, 0, time);
	        }
	        function tick(elapsed) {
	          if (lock.active !== id) return stop();
	          var t = elapsed / duration, e = ease(t), n = tweened.length;
	          while (n > 0) {
	            tweened[--n].call(node, e);
	          }
	          if (t >= 1) {
	            transition.event && transition.event.end.call(node, d, i);
	            return stop();
	          }
	        }
	        function stop() {
	          if (--lock.count) delete lock[id]; else delete node.__transition__;
	          return 1;
	        }
	      }, 0, time);
	    }
	  }
	  d3.svg.axis = function() {
	    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
	    function axis(g) {
	      g.each(function() {
	        var g = d3.select(this);
	        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
	        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
	        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
	        d3.transition(path));
	        tickEnter.append("line");
	        tickEnter.append("text");
	        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
	        if (orient === "bottom" || orient === "top") {
	          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
	          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
	          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
	        } else {
	          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
	          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
	          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
	        }
	        lineEnter.attr(y2, sign * innerTickSize);
	        textEnter.attr(y1, sign * tickSpacing);
	        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
	        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
	        if (scale1.rangeBand) {
	          var x = scale1, dx = x.rangeBand() / 2;
	          scale0 = scale1 = function(d) {
	            return x(d) + dx;
	          };
	        } else if (scale0.rangeBand) {
	          scale0 = scale1;
	        } else {
	          tickExit.call(tickTransform, scale1, scale0);
	        }
	        tickEnter.call(tickTransform, scale0, scale1);
	        tickUpdate.call(tickTransform, scale1, scale1);
	      });
	    }
	    axis.scale = function(x) {
	      if (!arguments.length) return scale;
	      scale = x;
	      return axis;
	    };
	    axis.orient = function(x) {
	      if (!arguments.length) return orient;
	      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
	      return axis;
	    };
	    axis.ticks = function() {
	      if (!arguments.length) return tickArguments_;
	      tickArguments_ = arguments;
	      return axis;
	    };
	    axis.tickValues = function(x) {
	      if (!arguments.length) return tickValues;
	      tickValues = x;
	      return axis;
	    };
	    axis.tickFormat = function(x) {
	      if (!arguments.length) return tickFormat_;
	      tickFormat_ = x;
	      return axis;
	    };
	    axis.tickSize = function(x) {
	      var n = arguments.length;
	      if (!n) return innerTickSize;
	      innerTickSize = +x;
	      outerTickSize = +arguments[n - 1];
	      return axis;
	    };
	    axis.innerTickSize = function(x) {
	      if (!arguments.length) return innerTickSize;
	      innerTickSize = +x;
	      return axis;
	    };
	    axis.outerTickSize = function(x) {
	      if (!arguments.length) return outerTickSize;
	      outerTickSize = +x;
	      return axis;
	    };
	    axis.tickPadding = function(x) {
	      if (!arguments.length) return tickPadding;
	      tickPadding = +x;
	      return axis;
	    };
	    axis.tickSubdivide = function() {
	      return arguments.length && axis;
	    };
	    return axis;
	  };
	  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
	    top: 1,
	    right: 1,
	    bottom: 1,
	    left: 1
	  };
	  function d3_svg_axisX(selection, x0, x1) {
	    selection.attr("transform", function(d) {
	      var v0 = x0(d);
	      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
	    });
	  }
	  function d3_svg_axisY(selection, y0, y1) {
	    selection.attr("transform", function(d) {
	      var v0 = y0(d);
	      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
	    });
	  }
	  d3.svg.brush = function() {
	    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
	    function brush(g) {
	      g.each(function() {
	        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
	        var background = g.selectAll(".background").data([ 0 ]);
	        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
	        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
	        var resize = g.selectAll(".resize").data(resizes, d3_identity);
	        resize.exit().remove();
	        resize.enter().append("g").attr("class", function(d) {
	          return "resize " + d;
	        }).style("cursor", function(d) {
	          return d3_svg_brushCursor[d];
	        }).append("rect").attr("x", function(d) {
	          return /[ew]$/.test(d) ? -3 : null;
	        }).attr("y", function(d) {
	          return /^[ns]/.test(d) ? -3 : null;
	        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
	        resize.style("display", brush.empty() ? "none" : null);
	        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
	        if (x) {
	          range = d3_scaleRange(x);
	          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
	          redrawX(gUpdate);
	        }
	        if (y) {
	          range = d3_scaleRange(y);
	          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
	          redrawY(gUpdate);
	        }
	        redraw(gUpdate);
	      });
	    }
	    brush.event = function(g) {
	      g.each(function() {
	        var event_ = event.of(this, arguments), extent1 = {
	          x: xExtent,
	          y: yExtent,
	          i: xExtentDomain,
	          j: yExtentDomain
	        }, extent0 = this.__chart__ || extent1;
	        this.__chart__ = extent1;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.brush", function() {
	            xExtentDomain = extent0.i;
	            yExtentDomain = extent0.j;
	            xExtent = extent0.x;
	            yExtent = extent0.y;
	            event_({
	              type: "brushstart"
	            });
	          }).tween("brush:brush", function() {
	            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
	            xExtentDomain = yExtentDomain = null;
	            return function(t) {
	              xExtent = extent1.x = xi(t);
	              yExtent = extent1.y = yi(t);
	              event_({
	                type: "brush",
	                mode: "resize"
	              });
	            };
	          }).each("end.brush", function() {
	            xExtentDomain = extent1.i;
	            yExtentDomain = extent1.j;
	            event_({
	              type: "brush",
	              mode: "resize"
	            });
	            event_({
	              type: "brushend"
	            });
	          });
	        } else {
	          event_({
	            type: "brushstart"
	          });
	          event_({
	            type: "brush",
	            mode: "resize"
	          });
	          event_({
	            type: "brushend"
	          });
	        }
	      });
	    };
	    function redraw(g) {
	      g.selectAll(".resize").attr("transform", function(d) {
	        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
	      });
	    }
	    function redrawX(g) {
	      g.select(".extent").attr("x", xExtent[0]);
	      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
	    }
	    function redrawY(g) {
	      g.select(".extent").attr("y", yExtent[0]);
	      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
	    }
	    function brushstart() {
	      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(), center, origin = d3.mouse(target), offset;
	      var w = d3.select(d3_window).on("keydown.brush", keydown).on("keyup.brush", keyup);
	      if (d3.event.changedTouches) {
	        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
	      } else {
	        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
	      }
	      g.interrupt().selectAll("*").interrupt();
	      if (dragging) {
	        origin[0] = xExtent[0] - origin[0];
	        origin[1] = yExtent[0] - origin[1];
	      } else if (resizing) {
	        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
	        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
	        origin[0] = xExtent[ex];
	        origin[1] = yExtent[ey];
	      } else if (d3.event.altKey) center = origin.slice();
	      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
	      d3.select("body").style("cursor", eventTarget.style("cursor"));
	      event_({
	        type: "brushstart"
	      });
	      brushmove();
	      function keydown() {
	        if (d3.event.keyCode == 32) {
	          if (!dragging) {
	            center = null;
	            origin[0] -= xExtent[1];
	            origin[1] -= yExtent[1];
	            dragging = 2;
	          }
	          d3_eventPreventDefault();
	        }
	      }
	      function keyup() {
	        if (d3.event.keyCode == 32 && dragging == 2) {
	          origin[0] += xExtent[1];
	          origin[1] += yExtent[1];
	          dragging = 0;
	          d3_eventPreventDefault();
	        }
	      }
	      function brushmove() {
	        var point = d3.mouse(target), moved = false;
	        if (offset) {
	          point[0] += offset[0];
	          point[1] += offset[1];
	        }
	        if (!dragging) {
	          if (d3.event.altKey) {
	            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
	            origin[0] = xExtent[+(point[0] < center[0])];
	            origin[1] = yExtent[+(point[1] < center[1])];
	          } else center = null;
	        }
	        if (resizingX && move1(point, x, 0)) {
	          redrawX(g);
	          moved = true;
	        }
	        if (resizingY && move1(point, y, 1)) {
	          redrawY(g);
	          moved = true;
	        }
	        if (moved) {
	          redraw(g);
	          event_({
	            type: "brush",
	            mode: dragging ? "move" : "resize"
	          });
	        }
	      }
	      function move1(point, scale, i) {
	        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
	        if (dragging) {
	          r0 -= position;
	          r1 -= size + position;
	        }
	        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
	        if (dragging) {
	          max = (min += position) + size;
	        } else {
	          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
	          if (position < min) {
	            max = min;
	            min = position;
	          } else {
	            max = position;
	          }
	        }
	        if (extent[0] != min || extent[1] != max) {
	          if (i) yExtentDomain = null; else xExtentDomain = null;
	          extent[0] = min;
	          extent[1] = max;
	          return true;
	        }
	      }
	      function brushend() {
	        brushmove();
	        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
	        d3.select("body").style("cursor", null);
	        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
	        dragRestore();
	        event_({
	          type: "brushend"
	        });
	      }
	    }
	    brush.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.clamp = function(z) {
	      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
	      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
	      return brush;
	    };
	    brush.extent = function(z) {
	      var x0, x1, y0, y1, t;
	      if (!arguments.length) {
	        if (x) {
	          if (xExtentDomain) {
	            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
	          } else {
	            x0 = xExtent[0], x1 = xExtent[1];
	            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
	            if (x1 < x0) t = x0, x0 = x1, x1 = t;
	          }
	        }
	        if (y) {
	          if (yExtentDomain) {
	            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
	          } else {
	            y0 = yExtent[0], y1 = yExtent[1];
	            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
	            if (y1 < y0) t = y0, y0 = y1, y1 = t;
	          }
	        }
	        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
	      }
	      if (x) {
	        x0 = z[0], x1 = z[1];
	        if (y) x0 = x0[0], x1 = x1[0];
	        xExtentDomain = [ x0, x1 ];
	        if (x.invert) x0 = x(x0), x1 = x(x1);
	        if (x1 < x0) t = x0, x0 = x1, x1 = t;
	        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
	      }
	      if (y) {
	        y0 = z[0], y1 = z[1];
	        if (x) y0 = y0[1], y1 = y1[1];
	        yExtentDomain = [ y0, y1 ];
	        if (y.invert) y0 = y(y0), y1 = y(y1);
	        if (y1 < y0) t = y0, y0 = y1, y1 = t;
	        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
	      }
	      return brush;
	    };
	    brush.clear = function() {
	      if (!brush.empty()) {
	        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
	        xExtentDomain = yExtentDomain = null;
	      }
	      return brush;
	    };
	    brush.empty = function() {
	      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
	    };
	    return d3.rebind(brush, event, "on");
	  };
	  var d3_svg_brushCursor = {
	    n: "ns-resize",
	    e: "ew-resize",
	    s: "ns-resize",
	    w: "ew-resize",
	    nw: "nwse-resize",
	    ne: "nesw-resize",
	    se: "nwse-resize",
	    sw: "nesw-resize"
	  };
	  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
	  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
	  var d3_time_formatUtc = d3_time_format.utc;
	  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
	  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
	  function d3_time_formatIsoNative(date) {
	    return date.toISOString();
	  }
	  d3_time_formatIsoNative.parse = function(string) {
	    var date = new Date(string);
	    return isNaN(date) ? null : date;
	  };
	  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
	  d3_time.second = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 1e3) * 1e3);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
	  }, function(date) {
	    return date.getSeconds();
	  });
	  d3_time.seconds = d3_time.second.range;
	  d3_time.seconds.utc = d3_time.second.utc.range;
	  d3_time.minute = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 6e4) * 6e4);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
	  }, function(date) {
	    return date.getMinutes();
	  });
	  d3_time.minutes = d3_time.minute.range;
	  d3_time.minutes.utc = d3_time.minute.utc.range;
	  d3_time.hour = d3_time_interval(function(date) {
	    var timezone = date.getTimezoneOffset() / 60;
	    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
	  }, function(date) {
	    return date.getHours();
	  });
	  d3_time.hours = d3_time.hour.range;
	  d3_time.hours.utc = d3_time.hour.utc.range;
	  d3_time.month = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setDate(1);
	    return date;
	  }, function(date, offset) {
	    date.setMonth(date.getMonth() + offset);
	  }, function(date) {
	    return date.getMonth();
	  });
	  d3_time.months = d3_time.month.range;
	  d3_time.months.utc = d3_time.month.utc.range;
	  function d3_time_scale(linear, methods, format) {
	    function scale(x) {
	      return linear(x);
	    }
	    scale.invert = function(x) {
	      return d3_time_scaleDate(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
	      linear.domain(x);
	      return scale;
	    };
	    function tickMethod(extent, count) {
	      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
	      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
	        return d / 31536e6;
	      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
	    }
	    scale.nice = function(interval, skip) {
	      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
	      if (method) interval = method[0], skip = method[1];
	      function skipped(date) {
	        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
	      }
	      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
	        floor: function(date) {
	          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
	          return date;
	        },
	        ceil: function(date) {
	          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
	          return date;
	        }
	      } : interval));
	    };
	    scale.ticks = function(interval, skip) {
	      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
	        range: interval
	      }, skip ];
	      if (method) interval = method[0], skip = method[1];
	      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
	    };
	    scale.tickFormat = function() {
	      return format;
	    };
	    scale.copy = function() {
	      return d3_time_scale(linear.copy(), methods, format);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_time_scaleDate(t) {
	    return new Date(t);
	  }
	  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
	  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
	  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
	    return d.getMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getHours();
	  } ], [ "%a %d", function(d) {
	    return d.getDay() && d.getDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getMonth();
	  } ], [ "%Y", d3_true ] ]);
	  var d3_time_scaleMilliseconds = {
	    range: function(start, stop, step) {
	      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
	    },
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  d3_time_scaleLocalMethods.year = d3_time.year;
	  d3_time.scale = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
	  };
	  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
	    return [ m[0].utc, m[1] ];
	  });
	  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
	    return d.getUTCMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getUTCSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getUTCMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getUTCHours();
	  } ], [ "%a %d", function(d) {
	    return d.getUTCDay() && d.getUTCDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getUTCDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getUTCMonth();
	  } ], [ "%Y", d3_true ] ]);
	  d3_time_scaleUtcMethods.year = d3_time.year.utc;
	  d3_time.scale.utc = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
	  };
	  d3.text = d3_xhrType(function(request) {
	    return request.responseText;
	  });
	  d3.json = function(url, callback) {
	    return d3_xhr(url, "application/json", d3_json, callback);
	  };
	  function d3_json(request) {
	    return JSON.parse(request.responseText);
	  }
	  d3.html = function(url, callback) {
	    return d3_xhr(url, "text/html", d3_html, callback);
	  };
	  function d3_html(request) {
	    var range = d3_document.createRange();
	    range.selectNode(d3_document.body);
	    return range.createContextualFragment(request.responseText);
	  }
	  d3.xml = d3_xhrType(function(request) {
	    return request.responseXML;
	  });
	  if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else if (typeof module === "object" && module.exports) module.exports = d3;
	  this.d3 = d3;
	}();

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
		'use strict';
	
		$.fn.extend({
			addSvgClass: function addSvgClass(cls) {
				var classes = new Set(this.attr('class').split(/\s+/));
				classes.add(cls);
				this.attr('class', [].concat(_toConsumableArray(classes)).join(' '));
			},
			removeSvgClass: function removeSvgClass(cls) {
				var classes = new Set(this.attr('class').split(/\s+/));
				classes['delete'](cls);
				this.attr('class', [].concat(_toConsumableArray(classes)).join(' '));
			}
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(67);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(71)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-d3.scss", function() {
			var newContent = require("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-d3.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(85)();
	exports.push([module.id, ".circuitboard>svg.d3{display:block;position:absolute;left:0;top:0;height:100%;width:100%;padding:0;margin:0;pointer-events:none;}.circuitboard>svg.d3 svg.vertex{overflow:visible;cursor:pointer;}.circuitboard>svg.d3.dragging-vertex{pointer-events:all;cursor:-webkit-grabbing;cursor:grabbing;}", ""]);

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(69);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(71)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-tile-correlation-count-if-closed.scss", function() {
			var newContent = require("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/features/p-tile-correlation-count-if-closed.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(85)();
	exports.push([module.id, ".tile>.tile-correlation-counter{position:absolute;bottom:2px;left:2px;margin:1px;padding:0 2px;font-style:italic;border:solid 1px;border-color:inherit;background-color:inherit;}.tile.open>.tile-correlation-counter{display:none;}", ""]);

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! VelocityJS.org (1.2.2). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */
	
	/*************************
	   Velocity jQuery Shim
	*************************/
	
	/*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */
	
	/* This file contains the jQuery functions that Velocity relies on, thereby removing Velocity's dependency on a full copy of jQuery, and allowing it to work in any environment. */
	/* These shimmed functions are only used if jQuery isn't present. If both this shim and jQuery are loaded, Velocity defaults to jQuery proper. */
	/* Browser support: Using this shim instead of jQuery proper removes support for IE8. */
	
	;(function (window) {
	    /***************
	         Setup
	    ***************/
	
	    /* If jQuery is already loaded, there's no point in loading this shim. */
	    if (window.jQuery) {
	        return;
	    }
	
	    /* jQuery base. */
	    var $ = function (selector, context) {
	        return new $.fn.init(selector, context);
	    };
	
	    /********************
	       Private Methods
	    ********************/
	
	    /* jQuery */
	    $.isWindow = function (obj) {
	        /* jshint eqeqeq: false */
	        return obj != null && obj == obj.window;
	    };
	
	    /* jQuery */
	    $.type = function (obj) {
	        if (obj == null) {
	            return obj + "";
	        }
	
	        return typeof obj === "object" || typeof obj === "function" ?
	            class2type[toString.call(obj)] || "object" :
	            typeof obj;
	    };
	
	    /* jQuery */
	    $.isArray = Array.isArray || function (obj) {
	        return $.type(obj) === "array";
	    };
	
	    /* jQuery */
	    function isArraylike (obj) {
	        var length = obj.length,
	            type = $.type(obj);
	
	        if (type === "function" || $.isWindow(obj)) {
	            return false;
	        }
	
	        if (obj.nodeType === 1 && length) {
	            return true;
	        }
	
	        return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
	    }
	
	    /***************
	       $ Methods
	    ***************/
	
	    /* jQuery: Support removed for IE<9. */
	    $.isPlainObject = function (obj) {
	        var key;
	
	        if (!obj || $.type(obj) !== "object" || obj.nodeType || $.isWindow(obj)) {
	            return false;
	        }
	
	        try {
	            if (obj.constructor &&
	                !hasOwn.call(obj, "constructor") &&
	                !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
	                return false;
	            }
	        } catch (e) {
	            return false;
	        }
	
	        for (key in obj) {}
	
	        return key === undefined || hasOwn.call(obj, key);
	    };
	
	    /* jQuery */
	    $.each = function(obj, callback, args) {
	        var value,
	            i = 0,
	            length = obj.length,
	            isArray = isArraylike(obj);
	
	        if (args) {
	            if (isArray) {
	                for (; i < length; i++) {
	                    value = callback.apply(obj[i], args);
	
	                    if (value === false) {
	                        break;
	                    }
	                }
	            } else {
	                for (i in obj) {
	                    value = callback.apply(obj[i], args);
	
	                    if (value === false) {
	                        break;
	                    }
	                }
	            }
	
	        } else {
	            if (isArray) {
	                for (; i < length; i++) {
	                    value = callback.call(obj[i], i, obj[i]);
	
	                    if (value === false) {
	                        break;
	                    }
	                }
	            } else {
	                for (i in obj) {
	                    value = callback.call(obj[i], i, obj[i]);
	
	                    if (value === false) {
	                        break;
	                    }
	                }
	            }
	        }
	
	        return obj;
	    };
	
	    /* Custom */
	    $.data = function (node, key, value) {
	        /* $.getData() */
	        if (value === undefined) {
	            var id = node[$.expando],
	                store = id && cache[id];
	
	            if (key === undefined) {
	                return store;
	            } else if (store) {
	                if (key in store) {
	                    return store[key];
	                }
	            }
	        /* $.setData() */
	        } else if (key !== undefined) {
	            var id = node[$.expando] || (node[$.expando] = ++$.uuid);
	
	            cache[id] = cache[id] || {};
	            cache[id][key] = value;
	
	            return value;
	        }
	    };
	
	    /* Custom */
	    $.removeData = function (node, keys) {
	        var id = node[$.expando],
	            store = id && cache[id];
	
	        if (store) {
	            $.each(keys, function(_, key) {
	                delete store[key];
	            });
	        }
	    };
	
	    /* jQuery */
	    $.extend = function () {
	        var src, copyIsArray, copy, name, options, clone,
	            target = arguments[0] || {},
	            i = 1,
	            length = arguments.length,
	            deep = false;
	
	        if (typeof target === "boolean") {
	            deep = target;
	
	            target = arguments[i] || {};
	            i++;
	        }
	
	        if (typeof target !== "object" && $.type(target) !== "function") {
	            target = {};
	        }
	
	        if (i === length) {
	            target = this;
	            i--;
	        }
	
	        for (; i < length; i++) {
	            if ((options = arguments[i]) != null) {
	                for (name in options) {
	                    src = target[name];
	                    copy = options[name];
	
	                    if (target === copy) {
	                        continue;
	                    }
	
	                    if (deep && copy && ($.isPlainObject(copy) || (copyIsArray = $.isArray(copy)))) {
	                        if (copyIsArray) {
	                            copyIsArray = false;
	                            clone = src && $.isArray(src) ? src : [];
	
	                        } else {
	                            clone = src && $.isPlainObject(src) ? src : {};
	                        }
	
	                        target[name] = $.extend(deep, clone, copy);
	
	                    } else if (copy !== undefined) {
	                        target[name] = copy;
	                    }
	                }
	            }
	        }
	
	        return target;
	    };
	
	    /* jQuery 1.4.3 */
	    $.queue = function (elem, type, data) {
	        function $makeArray (arr, results) {
	            var ret = results || [];
	
	            if (arr != null) {
	                if (isArraylike(Object(arr))) {
	                    /* $.merge */
	                    (function(first, second) {
	                        var len = +second.length,
	                            j = 0,
	                            i = first.length;
	
	                        while (j < len) {
	                            first[i++] = second[j++];
	                        }
	
	                        if (len !== len) {
	                            while (second[j] !== undefined) {
	                                first[i++] = second[j++];
	                            }
	                        }
	
	                        first.length = i;
	
	                        return first;
	                    })(ret, typeof arr === "string" ? [arr] : arr);
	                } else {
	                    [].push.call(ret, arr);
	                }
	            }
	
	            return ret;
	        }
	
	        if (!elem) {
	            return;
	        }
	
	        type = (type || "fx") + "queue";
	
	        var q = $.data(elem, type);
	
	        if (!data) {
	            return q || [];
	        }
	
	        if (!q || $.isArray(data)) {
	            q = $.data(elem, type, $makeArray(data));
	        } else {
	            q.push(data);
	        }
	
	        return q;
	    };
	
	    /* jQuery 1.4.3 */
	    $.dequeue = function (elems, type) {
	        /* Custom: Embed element iteration. */
	        $.each(elems.nodeType ? [ elems ] : elems, function(i, elem) {
	            type = type || "fx";
	
	            var queue = $.queue(elem, type),
	                fn = queue.shift();
	
	            if (fn === "inprogress") {
	                fn = queue.shift();
	            }
	
	            if (fn) {
	                if (type === "fx") {
	                    queue.unshift("inprogress");
	                }
	
	                fn.call(elem, function() {
	                    $.dequeue(elem, type);
	                });
	            }
	        });
	    };
	
	    /******************
	       $.fn Methods
	    ******************/
	
	    /* jQuery */
	    $.fn = $.prototype = {
	        init: function (selector) {
	            /* Just return the element wrapped inside an array; don't proceed with the actual jQuery node wrapping process. */
	            if (selector.nodeType) {
	                this[0] = selector;
	
	                return this;
	            } else {
	                throw new Error("Not a DOM node.");
	            }
	        },
	
	        offset: function () {
	            /* jQuery altered code: Dropped disconnected DOM node checking. */
	            var box = this[0].getBoundingClientRect ? this[0].getBoundingClientRect() : { top: 0, left: 0 };
	
	            return {
	                top: box.top + (window.pageYOffset || document.scrollTop  || 0)  - (document.clientTop  || 0),
	                left: box.left + (window.pageXOffset || document.scrollLeft  || 0) - (document.clientLeft || 0)
	            };
	        },
	
	        position: function () {
	            /* jQuery */
	            function offsetParent() {
	                var offsetParent = this.offsetParent || document;
	
	                while (offsetParent && (!offsetParent.nodeType.toLowerCase === "html" && offsetParent.style.position === "static")) {
	                    offsetParent = offsetParent.offsetParent;
	                }
	
	                return offsetParent || document;
	            }
	
	            /* Zepto */
	            var elem = this[0],
	                offsetParent = offsetParent.apply(elem),
	                offset = this.offset(),
	                parentOffset = /^(?:body|html)$/i.test(offsetParent.nodeName) ? { top: 0, left: 0 } : $(offsetParent).offset()
	
	            offset.top -= parseFloat(elem.style.marginTop) || 0;
	            offset.left -= parseFloat(elem.style.marginLeft) || 0;
	
	            if (offsetParent.style) {
	                parentOffset.top += parseFloat(offsetParent.style.borderTopWidth) || 0
	                parentOffset.left += parseFloat(offsetParent.style.borderLeftWidth) || 0
	            }
	
	            return {
	                top: offset.top - parentOffset.top,
	                left: offset.left - parentOffset.left
	            };
	        }
	    };
	
	    /**********************
	       Private Variables
	    **********************/
	
	    /* For $.data() */
	    var cache = {};
	    $.expando = "velocity" + (new Date().getTime());
	    $.uuid = 0;
	
	    /* For $.queue() */
	    var class2type = {},
	        hasOwn = class2type.hasOwnProperty,
	        toString = class2type.toString;
	
	    var types = "Boolean Number String Function Array Date RegExp Object Error".split(" ");
	    for (var i = 0; i < types.length; i++) {
	        class2type["[object " + types[i] + "]"] = types[i].toLowerCase();
	    }
	
	    /* Makes $(node) possible, without having to call init. */
	    $.fn.init.prototype = $.fn;
	
	    /* Globalize Velocity onto the window, and assign its Utilities property. */
	    window.Velocity = { Utilities: $ };
	})(window);
	
	/******************
	    Velocity.js
	******************/
	
	;(function (factory) {
	    /* CommonJS module. */
	    if (typeof module === "object" && typeof module.exports === "object") {
	        module.exports = factory();
	    /* AMD module. */
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    /* Browser globals. */
	    } else {
	        factory();
	    }
	}(function() {
	return function (global, window, document, undefined) {
	
	    /***************
	        Summary
	    ***************/
	
	    /*
	    - CSS: CSS stack that works independently from the rest of Velocity.
	    - animate(): Core animation method that iterates over the targeted elements and queues the incoming call onto each element individually.
	      - Pre-Queueing: Prepare the element for animation by instantiating its data cache and processing the call's options.
	      - Queueing: The logic that runs once the call has reached its point of execution in the element's $.queue() stack.
	                  Most logic is placed here to avoid risking it becoming stale (if the element's properties have changed).
	      - Pushing: Consolidation of the tween data followed by its push onto the global in-progress calls container.
	    - tick(): The single requestAnimationFrame loop responsible for tweening all in-progress calls.
	    - completeCall(): Handles the cleanup process for each Velocity call.
	    */
	
	    /*********************
	       Helper Functions
	    *********************/
	
	    /* IE detection. Gist: https://gist.github.com/julianshapiro/9098609 */
	    var IE = (function() {
	        if (document.documentMode) {
	            return document.documentMode;
	        } else {
	            for (var i = 7; i > 4; i--) {
	                var div = document.createElement("div");
	
	                div.innerHTML = "<!--[if IE " + i + "]><span></span><![endif]-->";
	
	                if (div.getElementsByTagName("span").length) {
	                    div = null;
	
	                    return i;
	                }
	            }
	        }
	
	        return undefined;
	    })();
	
	    /* rAF shim. Gist: https://gist.github.com/julianshapiro/9497513 */
	    var rAFShim = (function() {
	        var timeLast = 0;
	
	        return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
	            var timeCurrent = (new Date()).getTime(),
	                timeDelta;
	
	            /* Dynamically set delay on a per-tick basis to match 60fps. */
	            /* Technique by Erik Moller. MIT license: https://gist.github.com/paulirish/1579671 */
	            timeDelta = Math.max(0, 16 - (timeCurrent - timeLast));
	            timeLast = timeCurrent + timeDelta;
	
	            return setTimeout(function() { callback(timeCurrent + timeDelta); }, timeDelta);
	        };
	    })();
	
	    /* Array compacting. Copyright Lo-Dash. MIT License: https://github.com/lodash/lodash/blob/master/LICENSE.txt */
	    function compactSparseArray (array) {
	        var index = -1,
	            length = array ? array.length : 0,
	            result = [];
	
	        while (++index < length) {
	            var value = array[index];
	
	            if (value) {
	                result.push(value);
	            }
	        }
	
	        return result;
	    }
	
	    function sanitizeElements (elements) {
	        /* Unwrap jQuery/Zepto objects. */
	        if (Type.isWrapped(elements)) {
	            elements = [].slice.call(elements);
	        /* Wrap a single element in an array so that $.each() can iterate with the element instead of its node's children. */
	        } else if (Type.isNode(elements)) {
	            elements = [ elements ];
	        }
	
	        return elements;
	    }
	
	    var Type = {
	        isString: function (variable) {
	            return (typeof variable === "string");
	        },
	        isArray: Array.isArray || function (variable) {
	            return Object.prototype.toString.call(variable) === "[object Array]";
	        },
	        isFunction: function (variable) {
	            return Object.prototype.toString.call(variable) === "[object Function]";
	        },
	        isNode: function (variable) {
	            return variable && variable.nodeType;
	        },
	        /* Copyright Martin Bohm. MIT License: https://gist.github.com/Tomalak/818a78a226a0738eaade */
	        isNodeList: function (variable) {
	            return typeof variable === "object" &&
	                /^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(variable)) &&
	                variable.length !== undefined &&
	                (variable.length === 0 || (typeof variable[0] === "object" && variable[0].nodeType > 0));
	        },
	        /* Determine if variable is a wrapped jQuery or Zepto element. */
	        isWrapped: function (variable) {
	            return variable && (variable.jquery || (window.Zepto && window.Zepto.zepto.isZ(variable)));
	        },
	        isSVG: function (variable) {
	            return window.SVGElement && (variable instanceof window.SVGElement);
	        },
	        isEmptyObject: function (variable) {
	            for (var name in variable) {
	                return false;
	            }
	
	            return true;
	        }
	    };
	
	    /*****************
	       Dependencies
	    *****************/
	
	    var $,
	        isJQuery = false;
	
	    if (global.fn && global.fn.jquery) {
	        $ = global;
	        isJQuery = true;
	    } else {
	        $ = window.Velocity.Utilities;
	    }
	
	    if (IE <= 8 && !isJQuery) {
	        throw new Error("Velocity: IE8 and below require jQuery to be loaded before Velocity.");
	    } else if (IE <= 7) {
	        /* Revert to jQuery's $.animate(), and lose Velocity's extra features. */
	        jQuery.fn.velocity = jQuery.fn.animate;
	
	        /* Now that $.fn.velocity is aliased, abort this Velocity declaration. */
	        return;
	    }
	
	    /*****************
	        Constants
	    *****************/
	
	    var DURATION_DEFAULT = 400,
	        EASING_DEFAULT = "swing";
	
	    /*************
	        State
	    *************/
	
	    var Velocity = {
	        /* Container for page-wide Velocity state data. */
	        State: {
	            /* Detect mobile devices to determine if mobileHA should be turned on. */
	            isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
	            /* The mobileHA option's behavior changes on older Android devices (Gingerbread, versions 2.3.3-2.3.7). */
	            isAndroid: /Android/i.test(navigator.userAgent),
	            isGingerbread: /Android 2\.3\.[3-7]/i.test(navigator.userAgent),
	            isChrome: window.chrome,
	            isFirefox: /Firefox/i.test(navigator.userAgent),
	            /* Create a cached element for re-use when checking for CSS property prefixes. */
	            prefixElement: document.createElement("div"),
	            /* Cache every prefix match to avoid repeating lookups. */
	            prefixMatches: {},
	            /* Cache the anchor used for animating window scrolling. */
	            scrollAnchor: null,
	            /* Cache the browser-specific property names associated with the scroll anchor. */
	            scrollPropertyLeft: null,
	            scrollPropertyTop: null,
	            /* Keep track of whether our RAF tick is running. */
	            isTicking: false,
	            /* Container for every in-progress call to Velocity. */
	            calls: []
	        },
	        /* Velocity's custom CSS stack. Made global for unit testing. */
	        CSS: { /* Defined below. */ },
	        /* A shim of the jQuery utility functions used by Velocity -- provided by Velocity's optional jQuery shim. */
	        Utilities: $,
	        /* Container for the user's custom animation redirects that are referenced by name in place of the properties map argument. */
	        Redirects: { /* Manually registered by the user. */ },
	        Easings: { /* Defined below. */ },
	        /* Attempt to use ES6 Promises by default. Users can override this with a third-party promises library. */
	        Promise: window.Promise,
	        /* Velocity option defaults, which can be overriden by the user. */
	        defaults: {
	            queue: "",
	            duration: DURATION_DEFAULT,
	            easing: EASING_DEFAULT,
	            begin: undefined,
	            complete: undefined,
	            progress: undefined,
	            display: undefined,
	            visibility: undefined,
	            loop: false,
	            delay: false,
	            mobileHA: true,
	            /* Advanced: Set to false to prevent property values from being cached between consecutive Velocity-initiated chain calls. */
	            _cacheValues: true
	        },
	        /* A design goal of Velocity is to cache data wherever possible in order to avoid DOM requerying. Accordingly, each element has a data cache. */
	        init: function (element) {
	            $.data(element, "velocity", {
	                /* Store whether this is an SVG element, since its properties are retrieved and updated differently than standard HTML elements. */
	                isSVG: Type.isSVG(element),
	                /* Keep track of whether the element is currently being animated by Velocity.
	                   This is used to ensure that property values are not transferred between non-consecutive (stale) calls. */
	                isAnimating: false,
	                /* A reference to the element's live computedStyle object. Learn more here: https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle */
	                computedStyle: null,
	                /* Tween data is cached for each animation on the element so that data can be passed across calls --
	                   in particular, end values are used as subsequent start values in consecutive Velocity calls. */
	                tweensContainer: null,
	                /* The full root property values of each CSS hook being animated on this element are cached so that:
	                   1) Concurrently-animating hooks sharing the same root can have their root values' merged into one while tweening.
	                   2) Post-hook-injection root values can be transferred over to consecutively chained Velocity calls as starting root values. */
	                rootPropertyValueCache: {},
	                /* A cache for transform updates, which must be manually flushed via CSS.flushTransformCache(). */
	                transformCache: {}
	            });
	        },
	        /* A parallel to jQuery's $.css(), used for getting/setting Velocity's hooked CSS properties. */
	        hook: null, /* Defined below. */
	        /* Velocity-wide animation time remapping for testing purposes. */
	        mock: false,
	        version: { major: 1, minor: 2, patch: 2 },
	        /* Set to 1 or 2 (most verbose) to output debug info to console. */
	        debug: false
	    };
	
	    /* Retrieve the appropriate scroll anchor and property name for the browser: https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY */
	    if (window.pageYOffset !== undefined) {
	        Velocity.State.scrollAnchor = window;
	        Velocity.State.scrollPropertyLeft = "pageXOffset";
	        Velocity.State.scrollPropertyTop = "pageYOffset";
	    } else {
	        Velocity.State.scrollAnchor = document.documentElement || document.body.parentNode || document.body;
	        Velocity.State.scrollPropertyLeft = "scrollLeft";
	        Velocity.State.scrollPropertyTop = "scrollTop";
	    }
	
	    /* Shorthand alias for jQuery's $.data() utility. */
	    function Data (element) {
	        /* Hardcode a reference to the plugin name. */
	        var response = $.data(element, "velocity");
	
	        /* jQuery <=1.4.2 returns null instead of undefined when no match is found. We normalize this behavior. */
	        return response === null ? undefined : response;
	    };
	
	    /**************
	        Easing
	    **************/
	
	    /* Step easing generator. */
	    function generateStep (steps) {
	        return function (p) {
	            return Math.round(p * steps) * (1 / steps);
	        };
	    }
	
	    /* Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */
	    function generateBezier (mX1, mY1, mX2, mY2) {
	        var NEWTON_ITERATIONS = 4,
	            NEWTON_MIN_SLOPE = 0.001,
	            SUBDIVISION_PRECISION = 0.0000001,
	            SUBDIVISION_MAX_ITERATIONS = 10,
	            kSplineTableSize = 11,
	            kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),
	            float32ArraySupported = "Float32Array" in window;
	
	        /* Must contain four arguments. */
	        if (arguments.length !== 4) {
	            return false;
	        }
	
	        /* Arguments must be numbers. */
	        for (var i = 0; i < 4; ++i) {
	            if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
	                return false;
	            }
	        }
	
	        /* X values must be in the [0, 1] range. */
	        mX1 = Math.min(mX1, 1);
	        mX2 = Math.min(mX2, 1);
	        mX1 = Math.max(mX1, 0);
	        mX2 = Math.max(mX2, 0);
	
	        var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
	
	        function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
	        function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
	        function C (aA1)      { return 3.0 * aA1; }
	
	        function calcBezier (aT, aA1, aA2) {
	            return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
	        }
	
	        function getSlope (aT, aA1, aA2) {
	            return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
	        }
	
	        function newtonRaphsonIterate (aX, aGuessT) {
	            for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
	                var currentSlope = getSlope(aGuessT, mX1, mX2);
	
	                if (currentSlope === 0.0) return aGuessT;
	
	                var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
	                aGuessT -= currentX / currentSlope;
	            }
	
	            return aGuessT;
	        }
	
	        function calcSampleValues () {
	            for (var i = 0; i < kSplineTableSize; ++i) {
	                mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
	            }
	        }
	
	        function binarySubdivide (aX, aA, aB) {
	            var currentX, currentT, i = 0;
	
	            do {
	                currentT = aA + (aB - aA) / 2.0;
	                currentX = calcBezier(currentT, mX1, mX2) - aX;
	                if (currentX > 0.0) {
	                  aB = currentT;
	                } else {
	                  aA = currentT;
	                }
	            } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
	
	            return currentT;
	        }
	
	        function getTForX (aX) {
	            var intervalStart = 0.0,
	                currentSample = 1,
	                lastSample = kSplineTableSize - 1;
	
	            for (; currentSample != lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
	                intervalStart += kSampleStepSize;
	            }
	
	            --currentSample;
	
	            var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]),
	                guessForT = intervalStart + dist * kSampleStepSize,
	                initialSlope = getSlope(guessForT, mX1, mX2);
	
	            if (initialSlope >= NEWTON_MIN_SLOPE) {
	                return newtonRaphsonIterate(aX, guessForT);
	            } else if (initialSlope == 0.0) {
	                return guessForT;
	            } else {
	                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
	            }
	        }
	
	        var _precomputed = false;
	
	        function precompute() {
	            _precomputed = true;
	            if (mX1 != mY1 || mX2 != mY2) calcSampleValues();
	        }
	
	        var f = function (aX) {
	            if (!_precomputed) precompute();
	            if (mX1 === mY1 && mX2 === mY2) return aX;
	            if (aX === 0) return 0;
	            if (aX === 1) return 1;
	
	            return calcBezier(getTForX(aX), mY1, mY2);
	        };
	
	        f.getControlPoints = function() { return [{ x: mX1, y: mY1 }, { x: mX2, y: mY2 }]; };
	
	        var str = "generateBezier(" + [mX1, mY1, mX2, mY2] + ")";
	        f.toString = function () { return str; };
	
	        return f;
	    }
	
	    /* Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
	    /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
	       then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
	    var generateSpringRK4 = (function () {
	        function springAccelerationForState (state) {
	            return (-state.tension * state.x) - (state.friction * state.v);
	        }
	
	        function springEvaluateStateWithDerivative (initialState, dt, derivative) {
	            var state = {
	                x: initialState.x + derivative.dx * dt,
	                v: initialState.v + derivative.dv * dt,
	                tension: initialState.tension,
	                friction: initialState.friction
	            };
	
	            return { dx: state.v, dv: springAccelerationForState(state) };
	        }
	
	        function springIntegrateState (state, dt) {
	            var a = {
	                    dx: state.v,
	                    dv: springAccelerationForState(state)
	                },
	                b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
	                c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
	                d = springEvaluateStateWithDerivative(state, dt, c),
	                dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
	                dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);
	
	            state.x = state.x + dxdt * dt;
	            state.v = state.v + dvdt * dt;
	
	            return state;
	        }
	
	        return function springRK4Factory (tension, friction, duration) {
	
	            var initState = {
	                    x: -1,
	                    v: 0,
	                    tension: null,
	                    friction: null
	                },
	                path = [0],
	                time_lapsed = 0,
	                tolerance = 1 / 10000,
	                DT = 16 / 1000,
	                have_duration, dt, last_state;
	
	            tension = parseFloat(tension) || 500;
	            friction = parseFloat(friction) || 20;
	            duration = duration || null;
	
	            initState.tension = tension;
	            initState.friction = friction;
	
	            have_duration = duration !== null;
	
	            /* Calculate the actual time it takes for this animation to complete with the provided conditions. */
	            if (have_duration) {
	                /* Run the simulation without a duration. */
	                time_lapsed = springRK4Factory(tension, friction);
	                /* Compute the adjusted time delta. */
	                dt = time_lapsed / duration * DT;
	            } else {
	                dt = DT;
	            }
	
	            while (true) {
	                /* Next/step function .*/
	                last_state = springIntegrateState(last_state || initState, dt);
	                /* Store the position. */
	                path.push(1 + last_state.x);
	                time_lapsed += 16;
	                /* If the change threshold is reached, break. */
	                if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
	                    break;
	                }
	            }
	
	            /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
	               computed path and returns a snapshot of the position according to a given percentComplete. */
	            return !have_duration ? time_lapsed : function(percentComplete) { return path[ (percentComplete * (path.length - 1)) | 0 ]; };
	        };
	    }());
	
	    /* jQuery easings. */
	    Velocity.Easings = {
	        linear: function(p) { return p; },
	        swing: function(p) { return 0.5 - Math.cos( p * Math.PI ) / 2 },
	        /* Bonus "spring" easing, which is a less exaggerated version of easeInOutElastic. */
	        spring: function(p) { return 1 - (Math.cos(p * 4.5 * Math.PI) * Math.exp(-p * 6)); }
	    };
	
	    /* CSS3 and Robert Penner easings. */
	    $.each(
	        [
	            [ "ease", [ 0.25, 0.1, 0.25, 1.0 ] ],
	            [ "ease-in", [ 0.42, 0.0, 1.00, 1.0 ] ],
	            [ "ease-out", [ 0.00, 0.0, 0.58, 1.0 ] ],
	            [ "ease-in-out", [ 0.42, 0.0, 0.58, 1.0 ] ],
	            [ "easeInSine", [ 0.47, 0, 0.745, 0.715 ] ],
	            [ "easeOutSine", [ 0.39, 0.575, 0.565, 1 ] ],
	            [ "easeInOutSine", [ 0.445, 0.05, 0.55, 0.95 ] ],
	            [ "easeInQuad", [ 0.55, 0.085, 0.68, 0.53 ] ],
	            [ "easeOutQuad", [ 0.25, 0.46, 0.45, 0.94 ] ],
	            [ "easeInOutQuad", [ 0.455, 0.03, 0.515, 0.955 ] ],
	            [ "easeInCubic", [ 0.55, 0.055, 0.675, 0.19 ] ],
	            [ "easeOutCubic", [ 0.215, 0.61, 0.355, 1 ] ],
	            [ "easeInOutCubic", [ 0.645, 0.045, 0.355, 1 ] ],
	            [ "easeInQuart", [ 0.895, 0.03, 0.685, 0.22 ] ],
	            [ "easeOutQuart", [ 0.165, 0.84, 0.44, 1 ] ],
	            [ "easeInOutQuart", [ 0.77, 0, 0.175, 1 ] ],
	            [ "easeInQuint", [ 0.755, 0.05, 0.855, 0.06 ] ],
	            [ "easeOutQuint", [ 0.23, 1, 0.32, 1 ] ],
	            [ "easeInOutQuint", [ 0.86, 0, 0.07, 1 ] ],
	            [ "easeInExpo", [ 0.95, 0.05, 0.795, 0.035 ] ],
	            [ "easeOutExpo", [ 0.19, 1, 0.22, 1 ] ],
	            [ "easeInOutExpo", [ 1, 0, 0, 1 ] ],
	            [ "easeInCirc", [ 0.6, 0.04, 0.98, 0.335 ] ],
	            [ "easeOutCirc", [ 0.075, 0.82, 0.165, 1 ] ],
	            [ "easeInOutCirc", [ 0.785, 0.135, 0.15, 0.86 ] ]
	        ], function(i, easingArray) {
	            Velocity.Easings[easingArray[0]] = generateBezier.apply(null, easingArray[1]);
	        });
	
	    /* Determine the appropriate easing type given an easing input. */
	    function getEasing(value, duration) {
	        var easing = value;
	
	        /* The easing option can either be a string that references a pre-registered easing,
	           or it can be a two-/four-item array of integers to be converted into a bezier/spring function. */
	        if (Type.isString(value)) {
	            /* Ensure that the easing has been assigned to jQuery's Velocity.Easings object. */
	            if (!Velocity.Easings[value]) {
	                easing = false;
	            }
	        } else if (Type.isArray(value) && value.length === 1) {
	            easing = generateStep.apply(null, value);
	        } else if (Type.isArray(value) && value.length === 2) {
	            /* springRK4 must be passed the animation's duration. */
	            /* Note: If the springRK4 array contains non-numbers, generateSpringRK4() returns an easing
	               function generated with default tension and friction values. */
	            easing = generateSpringRK4.apply(null, value.concat([ duration ]));
	        } else if (Type.isArray(value) && value.length === 4) {
	            /* Note: If the bezier array contains non-numbers, generateBezier() returns false. */
	            easing = generateBezier.apply(null, value);
	        } else {
	            easing = false;
	        }
	
	        /* Revert to the Velocity-wide default easing type, or fall back to "swing" (which is also jQuery's default)
	           if the Velocity-wide default has been incorrectly modified. */
	        if (easing === false) {
	            if (Velocity.Easings[Velocity.defaults.easing]) {
	                easing = Velocity.defaults.easing;
	            } else {
	                easing = EASING_DEFAULT;
	            }
	        }
	
	        return easing;
	    }
	
	    /*****************
	        CSS Stack
	    *****************/
	
	    /* The CSS object is a highly condensed and performant CSS stack that fully replaces jQuery's.
	       It handles the validation, getting, and setting of both standard CSS properties and CSS property hooks. */
	    /* Note: A "CSS" shorthand is aliased so that our code is easier to read. */
	    var CSS = Velocity.CSS = {
	
	        /*************
	            RegEx
	        *************/
	
	        RegEx: {
	            isHex: /^#([A-f\d]{3}){1,2}$/i,
	            /* Unwrap a property value's surrounding text, e.g. "rgba(4, 3, 2, 1)" ==> "4, 3, 2, 1" and "rect(4px 3px 2px 1px)" ==> "4px 3px 2px 1px". */
	            valueUnwrap: /^[A-z]+\((.*)\)$/i,
	            wrappedValueAlreadyExtracted: /[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,
	            /* Split a multi-value property into an array of subvalues, e.g. "rgba(4, 3, 2, 1) 4px 3px 2px 1px" ==> [ "rgba(4, 3, 2, 1)", "4px", "3px", "2px", "1px" ]. */
	            valueSplit: /([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/ig
	        },
	
	        /************
	            Lists
	        ************/
	
	        Lists: {
	            colors: [ "fill", "stroke", "stopColor", "color", "backgroundColor", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "outlineColor" ],
	            transformsBase: [ "translateX", "translateY", "scale", "scaleX", "scaleY", "skewX", "skewY", "rotateZ" ],
	            transforms3D: [ "transformPerspective", "translateZ", "scaleZ", "rotateX", "rotateY" ]
	        },
	
	        /************
	            Hooks
	        ************/
	
	        /* Hooks allow a subproperty (e.g. "boxShadowBlur") of a compound-value CSS property
	           (e.g. "boxShadow: X Y Blur Spread Color") to be animated as if it were a discrete property. */
	        /* Note: Beyond enabling fine-grained property animation, hooking is necessary since Velocity only
	           tweens properties with single numeric values; unlike CSS transitions, Velocity does not interpolate compound-values. */
	        Hooks: {
	            /********************
	                Registration
	            ********************/
	
	            /* Templates are a concise way of indicating which subproperties must be individually registered for each compound-value CSS property. */
	            /* Each template consists of the compound-value's base name, its constituent subproperty names, and those subproperties' default values. */
	            templates: {
	                "textShadow": [ "Color X Y Blur", "black 0px 0px 0px" ],
	                "boxShadow": [ "Color X Y Blur Spread", "black 0px 0px 0px 0px" ],
	                "clip": [ "Top Right Bottom Left", "0px 0px 0px 0px" ],
	                "backgroundPosition": [ "X Y", "0% 0%" ],
	                "transformOrigin": [ "X Y Z", "50% 50% 0px" ],
	                "perspectiveOrigin": [ "X Y", "50% 50%" ]
	            },
	
	            /* A "registered" hook is one that has been converted from its template form into a live,
	               tweenable property. It contains data to associate it with its root property. */
	            registered: {
	                /* Note: A registered hook looks like this ==> textShadowBlur: [ "textShadow", 3 ],
	                   which consists of the subproperty's name, the associated root property's name,
	                   and the subproperty's position in the root's value. */
	            },
	            /* Convert the templates into individual hooks then append them to the registered object above. */
	            register: function () {
	                /* Color hooks registration: Colors are defaulted to white -- as opposed to black -- since colors that are
	                   currently set to "transparent" default to their respective template below when color-animated,
	                   and white is typically a closer match to transparent than black is. An exception is made for text ("color"),
	                   which is almost always set closer to black than white. */
	                for (var i = 0; i < CSS.Lists.colors.length; i++) {
	                    var rgbComponents = (CSS.Lists.colors[i] === "color") ? "0 0 0 1" : "255 255 255 1";
	                    CSS.Hooks.templates[CSS.Lists.colors[i]] = [ "Red Green Blue Alpha", rgbComponents ];
	                }
	
	                var rootProperty,
	                    hookTemplate,
	                    hookNames;
	
	                /* In IE, color values inside compound-value properties are positioned at the end the value instead of at the beginning.
	                   Thus, we re-arrange the templates accordingly. */
	                if (IE) {
	                    for (rootProperty in CSS.Hooks.templates) {
	                        hookTemplate = CSS.Hooks.templates[rootProperty];
	                        hookNames = hookTemplate[0].split(" ");
	
	                        var defaultValues = hookTemplate[1].match(CSS.RegEx.valueSplit);
	
	                        if (hookNames[0] === "Color") {
	                            /* Reposition both the hook's name and its default value to the end of their respective strings. */
	                            hookNames.push(hookNames.shift());
	                            defaultValues.push(defaultValues.shift());
	
	                            /* Replace the existing template for the hook's root property. */
	                            CSS.Hooks.templates[rootProperty] = [ hookNames.join(" "), defaultValues.join(" ") ];
	                        }
	                    }
	                }
	
	                /* Hook registration. */
	                for (rootProperty in CSS.Hooks.templates) {
	                    hookTemplate = CSS.Hooks.templates[rootProperty];
	                    hookNames = hookTemplate[0].split(" ");
	
	                    for (var i in hookNames) {
	                        var fullHookName = rootProperty + hookNames[i],
	                            hookPosition = i;
	
	                        /* For each hook, register its full name (e.g. textShadowBlur) with its root property (e.g. textShadow)
	                           and the hook's position in its template's default value string. */
	                        CSS.Hooks.registered[fullHookName] = [ rootProperty, hookPosition ];
	                    }
	                }
	            },
	
	            /*****************************
	               Injection and Extraction
	            *****************************/
	
	            /* Look up the root property associated with the hook (e.g. return "textShadow" for "textShadowBlur"). */
	            /* Since a hook cannot be set directly (the browser won't recognize it), style updating for hooks is routed through the hook's root property. */
	            getRoot: function (property) {
	                var hookData = CSS.Hooks.registered[property];
	
	                if (hookData) {
	                    return hookData[0];
	                } else {
	                    /* If there was no hook match, return the property name untouched. */
	                    return property;
	                }
	            },
	            /* Convert any rootPropertyValue, null or otherwise, into a space-delimited list of hook values so that
	               the targeted hook can be injected or extracted at its standard position. */
	            cleanRootPropertyValue: function(rootProperty, rootPropertyValue) {
	                /* If the rootPropertyValue is wrapped with "rgb()", "clip()", etc., remove the wrapping to normalize the value before manipulation. */
	                if (CSS.RegEx.valueUnwrap.test(rootPropertyValue)) {
	                    rootPropertyValue = rootPropertyValue.match(CSS.RegEx.valueUnwrap)[1];
	                }
	
	                /* If rootPropertyValue is a CSS null-value (from which there's inherently no hook value to extract),
	                   default to the root's default value as defined in CSS.Hooks.templates. */
	                /* Note: CSS null-values include "none", "auto", and "transparent". They must be converted into their
	                   zero-values (e.g. textShadow: "none" ==> textShadow: "0px 0px 0px black") for hook manipulation to proceed. */
	                if (CSS.Values.isCSSNullValue(rootPropertyValue)) {
	                    rootPropertyValue = CSS.Hooks.templates[rootProperty][1];
	                }
	
	                return rootPropertyValue;
	            },
	            /* Extracted the hook's value from its root property's value. This is used to get the starting value of an animating hook. */
	            extractValue: function (fullHookName, rootPropertyValue) {
	                var hookData = CSS.Hooks.registered[fullHookName];
	
	                if (hookData) {
	                    var hookRoot = hookData[0],
	                        hookPosition = hookData[1];
	
	                    rootPropertyValue = CSS.Hooks.cleanRootPropertyValue(hookRoot, rootPropertyValue);
	
	                    /* Split rootPropertyValue into its constituent hook values then grab the desired hook at its standard position. */
	                    return rootPropertyValue.toString().match(CSS.RegEx.valueSplit)[hookPosition];
	                } else {
	                    /* If the provided fullHookName isn't a registered hook, return the rootPropertyValue that was passed in. */
	                    return rootPropertyValue;
	                }
	            },
	            /* Inject the hook's value into its root property's value. This is used to piece back together the root property
	               once Velocity has updated one of its individually hooked values through tweening. */
	            injectValue: function (fullHookName, hookValue, rootPropertyValue) {
	                var hookData = CSS.Hooks.registered[fullHookName];
	
	                if (hookData) {
	                    var hookRoot = hookData[0],
	                        hookPosition = hookData[1],
	                        rootPropertyValueParts,
	                        rootPropertyValueUpdated;
	
	                    rootPropertyValue = CSS.Hooks.cleanRootPropertyValue(hookRoot, rootPropertyValue);
	
	                    /* Split rootPropertyValue into its individual hook values, replace the targeted value with hookValue,
	                       then reconstruct the rootPropertyValue string. */
	                    rootPropertyValueParts = rootPropertyValue.toString().match(CSS.RegEx.valueSplit);
	                    rootPropertyValueParts[hookPosition] = hookValue;
	                    rootPropertyValueUpdated = rootPropertyValueParts.join(" ");
	
	                    return rootPropertyValueUpdated;
	                } else {
	                    /* If the provided fullHookName isn't a registered hook, return the rootPropertyValue that was passed in. */
	                    return rootPropertyValue;
	                }
	            }
	        },
	
	        /*******************
	           Normalizations
	        *******************/
	
	        /* Normalizations standardize CSS property manipulation by pollyfilling browser-specific implementations (e.g. opacity)
	           and reformatting special properties (e.g. clip, rgba) to look like standard ones. */
	        Normalizations: {
	            /* Normalizations are passed a normalization target (either the property's name, its extracted value, or its injected value),
	               the targeted element (which may need to be queried), and the targeted property value. */
	            registered: {
	                clip: function (type, element, propertyValue) {
	                    switch (type) {
	                        case "name":
	                            return "clip";
	                        /* Clip needs to be unwrapped and stripped of its commas during extraction. */
	                        case "extract":
	                            var extracted;
	
	                            /* If Velocity also extracted this value, skip extraction. */
	                            if (CSS.RegEx.wrappedValueAlreadyExtracted.test(propertyValue)) {
	                                extracted = propertyValue;
	                            } else {
	                                /* Remove the "rect()" wrapper. */
	                                extracted = propertyValue.toString().match(CSS.RegEx.valueUnwrap);
	
	                                /* Strip off commas. */
	                                extracted = extracted ? extracted[1].replace(/,(\s+)?/g, " ") : propertyValue;
	                            }
	
	                            return extracted;
	                        /* Clip needs to be re-wrapped during injection. */
	                        case "inject":
	                            return "rect(" + propertyValue + ")";
	                    }
	                },
	
	                blur: function(type, element, propertyValue) {
	                    switch (type) {
	                        case "name":
	                            return Velocity.State.isFirefox ? "filter" : "-webkit-filter";
	                        case "extract":
	                            var extracted = parseFloat(propertyValue);
	
	                            /* If extracted is NaN, meaning the value isn't already extracted. */
	                            if (!(extracted || extracted === 0)) {
	                                var blurComponent = propertyValue.toString().match(/blur\(([0-9]+[A-z]+)\)/i);
	
	                                /* If the filter string had a blur component, return just the blur value and unit type. */
	                                if (blurComponent) {
	                                    extracted = blurComponent[1];
	                                /* If the component doesn't exist, default blur to 0. */
	                                } else {
	                                    extracted = 0;
	                                }
	                            }
	
	                            return extracted;
	                        /* Blur needs to be re-wrapped during injection. */
	                        case "inject":
	                            /* For the blur effect to be fully de-applied, it needs to be set to "none" instead of 0. */
	                            if (!parseFloat(propertyValue)) {
	                                return "none";
	                            } else {
	                                return "blur(" + propertyValue + ")";
	                            }
	                    }
	                },
	
	                /* <=IE8 do not support the standard opacity property. They use filter:alpha(opacity=INT) instead. */
	                opacity: function (type, element, propertyValue) {
	                    if (IE <= 8) {
	                        switch (type) {
	                            case "name":
	                                return "filter";
	                            case "extract":
	                                /* <=IE8 return a "filter" value of "alpha(opacity=\d{1,3})".
	                                   Extract the value and convert it to a decimal value to match the standard CSS opacity property's formatting. */
	                                var extracted = propertyValue.toString().match(/alpha\(opacity=(.*)\)/i);
	
	                                if (extracted) {
	                                    /* Convert to decimal value. */
	                                    propertyValue = extracted[1] / 100;
	                                } else {
	                                    /* When extracting opacity, default to 1 since a null value means opacity hasn't been set. */
	                                    propertyValue = 1;
	                                }
	
	                                return propertyValue;
	                            case "inject":
	                                /* Opacified elements are required to have their zoom property set to a non-zero value. */
	                                element.style.zoom = 1;
	
	                                /* Setting the filter property on elements with certain font property combinations can result in a
	                                   highly unappealing ultra-bolding effect. There's no way to remedy this throughout a tween, but dropping the
	                                   value altogether (when opacity hits 1) at leasts ensures that the glitch is gone post-tweening. */
	                                if (parseFloat(propertyValue) >= 1) {
	                                    return "";
	                                } else {
	                                  /* As per the filter property's spec, convert the decimal value to a whole number and wrap the value. */
	                                  return "alpha(opacity=" + parseInt(parseFloat(propertyValue) * 100, 10) + ")";
	                                }
	                        }
	                    /* With all other browsers, normalization is not required; return the same values that were passed in. */
	                    } else {
	                        switch (type) {
	                            case "name":
	                                return "opacity";
	                            case "extract":
	                                return propertyValue;
	                            case "inject":
	                                return propertyValue;
	                        }
	                    }
	                }
	            },
	
	            /*****************************
	                Batched Registrations
	            *****************************/
	
	            /* Note: Batched normalizations extend the CSS.Normalizations.registered object. */
	            register: function () {
	
	                /*****************
	                    Transforms
	                *****************/
	
	                /* Transforms are the subproperties contained by the CSS "transform" property. Transforms must undergo normalization
	                   so that they can be referenced in a properties map by their individual names. */
	                /* Note: When transforms are "set", they are actually assigned to a per-element transformCache. When all transform
	                   setting is complete complete, CSS.flushTransformCache() must be manually called to flush the values to the DOM.
	                   Transform setting is batched in this way to improve performance: the transform style only needs to be updated
	                   once when multiple transform subproperties are being animated simultaneously. */
	                /* Note: IE9 and Android Gingerbread have support for 2D -- but not 3D -- transforms. Since animating unsupported
	                   transform properties results in the browser ignoring the *entire* transform string, we prevent these 3D values
	                   from being normalized for these browsers so that tweening skips these properties altogether
	                   (since it will ignore them as being unsupported by the browser.) */
	                if (!(IE <= 9) && !Velocity.State.isGingerbread) {
	                    /* Note: Since the standalone CSS "perspective" property and the CSS transform "perspective" subproperty
	                    share the same name, the latter is given a unique token within Velocity: "transformPerspective". */
	                    CSS.Lists.transformsBase = CSS.Lists.transformsBase.concat(CSS.Lists.transforms3D);
	                }
	
	                for (var i = 0; i < CSS.Lists.transformsBase.length; i++) {
	                    /* Wrap the dynamically generated normalization function in a new scope so that transformName's value is
	                    paired with its respective function. (Otherwise, all functions would take the final for loop's transformName.) */
	                    (function() {
	                        var transformName = CSS.Lists.transformsBase[i];
	
	                        CSS.Normalizations.registered[transformName] = function (type, element, propertyValue) {
	                            switch (type) {
	                                /* The normalized property name is the parent "transform" property -- the property that is actually set in CSS. */
	                                case "name":
	                                    return "transform";
	                                /* Transform values are cached onto a per-element transformCache object. */
	                                case "extract":
	                                    /* If this transform has yet to be assigned a value, return its null value. */
	                                    if (Data(element) === undefined || Data(element).transformCache[transformName] === undefined) {
	                                        /* Scale CSS.Lists.transformsBase default to 1 whereas all other transform properties default to 0. */
	                                        return /^scale/i.test(transformName) ? 1 : 0;
	                                    /* When transform values are set, they are wrapped in parentheses as per the CSS spec.
	                                       Thus, when extracting their values (for tween calculations), we strip off the parentheses. */
	                                    } else {
	                                        return Data(element).transformCache[transformName].replace(/[()]/g, "");
	                                    }
	                                case "inject":
	                                    var invalid = false;
	
	                                    /* If an individual transform property contains an unsupported unit type, the browser ignores the *entire* transform property.
	                                       Thus, protect users from themselves by skipping setting for transform values supplied with invalid unit types. */
	                                    /* Switch on the base transform type; ignore the axis by removing the last letter from the transform's name. */
	                                    switch (transformName.substr(0, transformName.length - 1)) {
	                                        /* Whitelist unit types for each transform. */
	                                        case "translate":
	                                            invalid = !/(%|px|em|rem|vw|vh|\d)$/i.test(propertyValue);
	                                            break;
	                                        /* Since an axis-free "scale" property is supported as well, a little hack is used here to detect it by chopping off its last letter. */
	                                        case "scal":
	                                        case "scale":
	                                            /* Chrome on Android has a bug in which scaled elements blur if their initial scale
	                                               value is below 1 (which can happen with forcefeeding). Thus, we detect a yet-unset scale property
	                                               and ensure that its first value is always 1. More info: http://stackoverflow.com/questions/10417890/css3-animations-with-transform-causes-blurred-elements-on-webkit/10417962#10417962 */
	                                            if (Velocity.State.isAndroid && Data(element).transformCache[transformName] === undefined && propertyValue < 1) {
	                                                propertyValue = 1;
	                                            }
	
	                                            invalid = !/(\d)$/i.test(propertyValue);
	                                            break;
	                                        case "skew":
	                                            invalid = !/(deg|\d)$/i.test(propertyValue);
	                                            break;
	                                        case "rotate":
	                                            invalid = !/(deg|\d)$/i.test(propertyValue);
	                                            break;
	                                    }
	
	                                    if (!invalid) {
	                                        /* As per the CSS spec, wrap the value in parentheses. */
	                                        Data(element).transformCache[transformName] = "(" + propertyValue + ")";
	                                    }
	
	                                    /* Although the value is set on the transformCache object, return the newly-updated value for the calling code to process as normal. */
	                                    return Data(element).transformCache[transformName];
	                            }
	                        };
	                    })();
	                }
	
	                /*************
	                    Colors
	                *************/
	
	                /* Since Velocity only animates a single numeric value per property, color animation is achieved by hooking the individual RGBA components of CSS color properties.
	                   Accordingly, color values must be normalized (e.g. "#ff0000", "red", and "rgb(255, 0, 0)" ==> "255 0 0 1") so that their components can be injected/extracted by CSS.Hooks logic. */
	                for (var i = 0; i < CSS.Lists.colors.length; i++) {
	                    /* Wrap the dynamically generated normalization function in a new scope so that colorName's value is paired with its respective function.
	                       (Otherwise, all functions would take the final for loop's colorName.) */
	                    (function () {
	                        var colorName = CSS.Lists.colors[i];
	
	                        /* Note: In IE<=8, which support rgb but not rgba, color properties are reverted to rgb by stripping off the alpha component. */
	                        CSS.Normalizations.registered[colorName] = function(type, element, propertyValue) {
	                            switch (type) {
	                                case "name":
	                                    return colorName;
	                                /* Convert all color values into the rgb format. (Old IE can return hex values and color names instead of rgb/rgba.) */
	                                case "extract":
	                                    var extracted;
	
	                                    /* If the color is already in its hookable form (e.g. "255 255 255 1") due to having been previously extracted, skip extraction. */
	                                    if (CSS.RegEx.wrappedValueAlreadyExtracted.test(propertyValue)) {
	                                        extracted = propertyValue;
	                                    } else {
	                                        var converted,
	                                            colorNames = {
	                                                black: "rgb(0, 0, 0)",
	                                                blue: "rgb(0, 0, 255)",
	                                                gray: "rgb(128, 128, 128)",
	                                                green: "rgb(0, 128, 0)",
	                                                red: "rgb(255, 0, 0)",
	                                                white: "rgb(255, 255, 255)"
	                                            };
	
	                                        /* Convert color names to rgb. */
	                                        if (/^[A-z]+$/i.test(propertyValue)) {
	                                            if (colorNames[propertyValue] !== undefined) {
	                                                converted = colorNames[propertyValue]
	                                            } else {
	                                                /* If an unmatched color name is provided, default to black. */
	                                                converted = colorNames.black;
	                                            }
	                                        /* Convert hex values to rgb. */
	                                        } else if (CSS.RegEx.isHex.test(propertyValue)) {
	                                            converted = "rgb(" + CSS.Values.hexToRgb(propertyValue).join(" ") + ")";
	                                        /* If the provided color doesn't match any of the accepted color formats, default to black. */
	                                        } else if (!(/^rgba?\(/i.test(propertyValue))) {
	                                            converted = colorNames.black;
	                                        }
	
	                                        /* Remove the surrounding "rgb/rgba()" string then replace commas with spaces and strip
	                                           repeated spaces (in case the value included spaces to begin with). */
	                                        extracted = (converted || propertyValue).toString().match(CSS.RegEx.valueUnwrap)[1].replace(/,(\s+)?/g, " ");
	                                    }
	
	                                    /* So long as this isn't <=IE8, add a fourth (alpha) component if it's missing and default it to 1 (visible). */
	                                    if (!(IE <= 8) && extracted.split(" ").length === 3) {
	                                        extracted += " 1";
	                                    }
	
	                                    return extracted;
	                                case "inject":
	                                    /* If this is IE<=8 and an alpha component exists, strip it off. */
	                                    if (IE <= 8) {
	                                        if (propertyValue.split(" ").length === 4) {
	                                            propertyValue = propertyValue.split(/\s+/).slice(0, 3).join(" ");
	                                        }
	                                    /* Otherwise, add a fourth (alpha) component if it's missing and default it to 1 (visible). */
	                                    } else if (propertyValue.split(" ").length === 3) {
	                                        propertyValue += " 1";
	                                    }
	
	                                    /* Re-insert the browser-appropriate wrapper("rgb/rgba()"), insert commas, and strip off decimal units
	                                       on all values but the fourth (R, G, and B only accept whole numbers). */
	                                    return (IE <= 8 ? "rgb" : "rgba") + "(" + propertyValue.replace(/\s+/g, ",").replace(/\.(\d)+(?=,)/g, "") + ")";
	                            }
	                        };
	                    })();
	                }
	            }
	        },
	
	        /************************
	           CSS Property Names
	        ************************/
	
	        Names: {
	            /* Camelcase a property name into its JavaScript notation (e.g. "background-color" ==> "backgroundColor").
	               Camelcasing is used to normalize property names between and across calls. */
	            camelCase: function (property) {
	                return property.replace(/-(\w)/g, function (match, subMatch) {
	                    return subMatch.toUpperCase();
	                });
	            },
	
	            /* For SVG elements, some properties (namely, dimensional ones) are GET/SET via the element's HTML attributes (instead of via CSS styles). */
	            SVGAttribute: function (property) {
	                var SVGAttributes = "width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2";
	
	                /* Certain browsers require an SVG transform to be applied as an attribute. (Otherwise, application via CSS is preferable due to 3D support.) */
	                if (IE || (Velocity.State.isAndroid && !Velocity.State.isChrome)) {
	                    SVGAttributes += "|transform";
	                }
	
	                return new RegExp("^(" + SVGAttributes + ")$", "i").test(property);
	            },
	
	            /* Determine whether a property should be set with a vendor prefix. */
	            /* If a prefixed version of the property exists, return it. Otherwise, return the original property name.
	               If the property is not at all supported by the browser, return a false flag. */
	            prefixCheck: function (property) {
	                /* If this property has already been checked, return the cached value. */
	                if (Velocity.State.prefixMatches[property]) {
	                    return [ Velocity.State.prefixMatches[property], true ];
	                } else {
	                    var vendors = [ "", "Webkit", "Moz", "ms", "O" ];
	
	                    for (var i = 0, vendorsLength = vendors.length; i < vendorsLength; i++) {
	                        var propertyPrefixed;
	
	                        if (i === 0) {
	                            propertyPrefixed = property;
	                        } else {
	                            /* Capitalize the first letter of the property to conform to JavaScript vendor prefix notation (e.g. webkitFilter). */
	                            propertyPrefixed = vendors[i] + property.replace(/^\w/, function(match) { return match.toUpperCase(); });
	                        }
	
	                        /* Check if the browser supports this property as prefixed. */
	                        if (Type.isString(Velocity.State.prefixElement.style[propertyPrefixed])) {
	                            /* Cache the match. */
	                            Velocity.State.prefixMatches[property] = propertyPrefixed;
	
	                            return [ propertyPrefixed, true ];
	                        }
	                    }
	
	                    /* If the browser doesn't support this property in any form, include a false flag so that the caller can decide how to proceed. */
	                    return [ property, false ];
	                }
	            }
	        },
	
	        /************************
	           CSS Property Values
	        ************************/
	
	        Values: {
	            /* Hex to RGB conversion. Copyright Tim Down: http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb */
	            hexToRgb: function (hex) {
	                var shortformRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
	                    longformRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
	                    rgbParts;
	
	                hex = hex.replace(shortformRegex, function (m, r, g, b) {
	                    return r + r + g + g + b + b;
	                });
	
	                rgbParts = longformRegex.exec(hex);
	
	                return rgbParts ? [ parseInt(rgbParts[1], 16), parseInt(rgbParts[2], 16), parseInt(rgbParts[3], 16) ] : [ 0, 0, 0 ];
	            },
	
	            isCSSNullValue: function (value) {
	                /* The browser defaults CSS values that have not been set to either 0 or one of several possible null-value strings.
	                   Thus, we check for both falsiness and these special strings. */
	                /* Null-value checking is performed to default the special strings to 0 (for the sake of tweening) or their hook
	                   templates as defined as CSS.Hooks (for the sake of hook injection/extraction). */
	                /* Note: Chrome returns "rgba(0, 0, 0, 0)" for an undefined color whereas IE returns "transparent". */
	                return (value == 0 || /^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(value));
	            },
	
	            /* Retrieve a property's default unit type. Used for assigning a unit type when one is not supplied by the user. */
	            getUnitType: function (property) {
	                if (/^(rotate|skew)/i.test(property)) {
	                    return "deg";
	                } else if (/(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(property)) {
	                    /* The above properties are unitless. */
	                    return "";
	                } else {
	                    /* Default to px for all other properties. */
	                    return "px";
	                }
	            },
	
	            /* HTML elements default to an associated display type when they're not set to display:none. */
	            /* Note: This function is used for correctly setting the non-"none" display value in certain Velocity redirects, such as fadeIn/Out. */
	            getDisplayType: function (element) {
	                var tagName = element && element.tagName.toString().toLowerCase();
	
	                if (/^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(tagName)) {
	                    return "inline";
	                } else if (/^(li)$/i.test(tagName)) {
	                    return "list-item";
	                } else if (/^(tr)$/i.test(tagName)) {
	                    return "table-row";
	                } else if (/^(table)$/i.test(tagName)) {
	                    return "table";
	                } else if (/^(tbody)$/i.test(tagName)) {
	                    return "table-row-group";
	                /* Default to "block" when no match is found. */
	                } else {
	                    return "block";
	                }
	            },
	
	            /* The class add/remove functions are used to temporarily apply a "velocity-animating" class to elements while they're animating. */
	            addClass: function (element, className) {
	                if (element.classList) {
	                    element.classList.add(className);
	                } else {
	                    element.className += (element.className.length ? " " : "") + className;
	                }
	            },
	
	            removeClass: function (element, className) {
	                if (element.classList) {
	                    element.classList.remove(className);
	                } else {
	                    element.className = element.className.toString().replace(new RegExp("(^|\\s)" + className.split(" ").join("|") + "(\\s|$)", "gi"), " ");
	                }
	            }
	        },
	
	        /****************************
	           Style Getting & Setting
	        ****************************/
	
	        /* The singular getPropertyValue, which routes the logic for all normalizations, hooks, and standard CSS properties. */
	        getPropertyValue: function (element, property, rootPropertyValue, forceStyleLookup) {
	            /* Get an element's computed property value. */
	            /* Note: Retrieving the value of a CSS property cannot simply be performed by checking an element's
	               style attribute (which only reflects user-defined values). Instead, the browser must be queried for a property's
	               *computed* value. You can read more about getComputedStyle here: https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle */
	            function computePropertyValue (element, property) {
	                /* When box-sizing isn't set to border-box, height and width style values are incorrectly computed when an
	                   element's scrollbars are visible (which expands the element's dimensions). Thus, we defer to the more accurate
	                   offsetHeight/Width property, which includes the total dimensions for interior, border, padding, and scrollbar.
	                   We subtract border and padding to get the sum of interior + scrollbar. */
	                var computedValue = 0;
	
	                /* IE<=8 doesn't support window.getComputedStyle, thus we defer to jQuery, which has an extensive array
	                   of hacks to accurately retrieve IE8 property values. Re-implementing that logic here is not worth bloating the
	                   codebase for a dying browser. The performance repercussions of using jQuery here are minimal since
	                   Velocity is optimized to rarely (and sometimes never) query the DOM. Further, the $.css() codepath isn't that slow. */
	                if (IE <= 8) {
	                    computedValue = $.css(element, property); /* GET */
	                /* All other browsers support getComputedStyle. The returned live object reference is cached onto its
	                   associated element so that it does not need to be refetched upon every GET. */
	                } else {
	                    /* Browsers do not return height and width values for elements that are set to display:"none". Thus, we temporarily
	                       toggle display to the element type's default value. */
	                    var toggleDisplay = false;
	
	                    if (/^(width|height)$/.test(property) && CSS.getPropertyValue(element, "display") === 0) {
	                        toggleDisplay = true;
	                        CSS.setPropertyValue(element, "display", CSS.Values.getDisplayType(element));
	                    }
	
	                    function revertDisplay () {
	                        if (toggleDisplay) {
	                            CSS.setPropertyValue(element, "display", "none");
	                        }
	                    }
	
	                    if (!forceStyleLookup) {
	                        if (property === "height" && CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() !== "border-box") {
	                            var contentBoxHeight = element.offsetHeight - (parseFloat(CSS.getPropertyValue(element, "borderTopWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "borderBottomWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingTop")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingBottom")) || 0);
	                            revertDisplay();
	
	                            return contentBoxHeight;
	                        } else if (property === "width" && CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() !== "border-box") {
	                            var contentBoxWidth = element.offsetWidth - (parseFloat(CSS.getPropertyValue(element, "borderLeftWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "borderRightWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingLeft")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingRight")) || 0);
	                            revertDisplay();
	
	                            return contentBoxWidth;
	                        }
	                    }
	
	                    var computedStyle;
	
	                    /* For elements that Velocity hasn't been called on directly (e.g. when Velocity queries the DOM on behalf
	                       of a parent of an element its animating), perform a direct getComputedStyle lookup since the object isn't cached. */
	                    if (Data(element) === undefined) {
	                        computedStyle = window.getComputedStyle(element, null); /* GET */
	                    /* If the computedStyle object has yet to be cached, do so now. */
	                    } else if (!Data(element).computedStyle) {
	                        computedStyle = Data(element).computedStyle = window.getComputedStyle(element, null); /* GET */
	                    /* If computedStyle is cached, use it. */
	                    } else {
	                        computedStyle = Data(element).computedStyle;
	                    }
	
	                    /* IE and Firefox do not return a value for the generic borderColor -- they only return individual values for each border side's color.
	                       Also, in all browsers, when border colors aren't all the same, a compound value is returned that Velocity isn't setup to parse.
	                       So, as a polyfill for querying individual border side colors, we just return the top border's color and animate all borders from that value. */
	                    if (property === "borderColor") {
	                        property = "borderTopColor";
	                    }
	
	                    /* IE9 has a bug in which the "filter" property must be accessed from computedStyle using the getPropertyValue method
	                       instead of a direct property lookup. The getPropertyValue method is slower than a direct lookup, which is why we avoid it by default. */
	                    if (IE === 9 && property === "filter") {
	                        computedValue = computedStyle.getPropertyValue(property); /* GET */
	                    } else {
	                        computedValue = computedStyle[property];
	                    }
	
	                    /* Fall back to the property's style value (if defined) when computedValue returns nothing,
	                       which can happen when the element hasn't been painted. */
	                    if (computedValue === "" || computedValue === null) {
	                        computedValue = element.style[property];
	                    }
	
	                    revertDisplay();
	                }
	
	                /* For top, right, bottom, and left (TRBL) values that are set to "auto" on elements of "fixed" or "absolute" position,
	                   defer to jQuery for converting "auto" to a numeric value. (For elements with a "static" or "relative" position, "auto" has the same
	                   effect as being set to 0, so no conversion is necessary.) */
	                /* An example of why numeric conversion is necessary: When an element with "position:absolute" has an untouched "left"
	                   property, which reverts to "auto", left's value is 0 relative to its parent element, but is often non-zero relative
	                   to its *containing* (not parent) element, which is the nearest "position:relative" ancestor or the viewport (and always the viewport in the case of "position:fixed"). */
	                if (computedValue === "auto" && /^(top|right|bottom|left)$/i.test(property)) {
	                    var position = computePropertyValue(element, "position"); /* GET */
	
	                    /* For absolute positioning, jQuery's $.position() only returns values for top and left;
	                       right and bottom will have their "auto" value reverted to 0. */
	                    /* Note: A jQuery object must be created here since jQuery doesn't have a low-level alias for $.position().
	                       Not a big deal since we're currently in a GET batch anyway. */
	                    if (position === "fixed" || (position === "absolute" && /top|left/i.test(property))) {
	                        /* Note: jQuery strips the pixel unit from its returned values; we re-add it here to conform with computePropertyValue's behavior. */
	                        computedValue = $(element).position()[property] + "px"; /* GET */
	                    }
	                }
	
	                return computedValue;
	            }
	
	            var propertyValue;
	
	            /* If this is a hooked property (e.g. "clipLeft" instead of the root property of "clip"),
	               extract the hook's value from a normalized rootPropertyValue using CSS.Hooks.extractValue(). */
	            if (CSS.Hooks.registered[property]) {
	                var hook = property,
	                    hookRoot = CSS.Hooks.getRoot(hook);
	
	                /* If a cached rootPropertyValue wasn't passed in (which Velocity always attempts to do in order to avoid requerying the DOM),
	                   query the DOM for the root property's value. */
	                if (rootPropertyValue === undefined) {
	                    /* Since the browser is now being directly queried, use the official post-prefixing property name for this lookup. */
	                    rootPropertyValue = CSS.getPropertyValue(element, CSS.Names.prefixCheck(hookRoot)[0]); /* GET */
	                }
	
	                /* If this root has a normalization registered, peform the associated normalization extraction. */
	                if (CSS.Normalizations.registered[hookRoot]) {
	                    rootPropertyValue = CSS.Normalizations.registered[hookRoot]("extract", element, rootPropertyValue);
	                }
	
	                /* Extract the hook's value. */
	                propertyValue = CSS.Hooks.extractValue(hook, rootPropertyValue);
	
	            /* If this is a normalized property (e.g. "opacity" becomes "filter" in <=IE8) or "translateX" becomes "transform"),
	               normalize the property's name and value, and handle the special case of transforms. */
	            /* Note: Normalizing a property is mutually exclusive from hooking a property since hook-extracted values are strictly
	               numerical and therefore do not require normalization extraction. */
	            } else if (CSS.Normalizations.registered[property]) {
	                var normalizedPropertyName,
	                    normalizedPropertyValue;
	
	                normalizedPropertyName = CSS.Normalizations.registered[property]("name", element);
	
	                /* Transform values are calculated via normalization extraction (see below), which checks against the element's transformCache.
	                   At no point do transform GETs ever actually query the DOM; initial stylesheet values are never processed.
	                   This is because parsing 3D transform matrices is not always accurate and would bloat our codebase;
	                   thus, normalization extraction defaults initial transform values to their zero-values (e.g. 1 for scaleX and 0 for translateX). */
	                if (normalizedPropertyName !== "transform") {
	                    normalizedPropertyValue = computePropertyValue(element, CSS.Names.prefixCheck(normalizedPropertyName)[0]); /* GET */
	
	                    /* If the value is a CSS null-value and this property has a hook template, use that zero-value template so that hooks can be extracted from it. */
	                    if (CSS.Values.isCSSNullValue(normalizedPropertyValue) && CSS.Hooks.templates[property]) {
	                        normalizedPropertyValue = CSS.Hooks.templates[property][1];
	                    }
	                }
	
	                propertyValue = CSS.Normalizations.registered[property]("extract", element, normalizedPropertyValue);
	            }
	
	            /* If a (numeric) value wasn't produced via hook extraction or normalization, query the DOM. */
	            if (!/^[\d-]/.test(propertyValue)) {
	                /* For SVG elements, dimensional properties (which SVGAttribute() detects) are tweened via
	                   their HTML attribute values instead of their CSS style values. */
	                if (Data(element) && Data(element).isSVG && CSS.Names.SVGAttribute(property)) {
	                    /* Since the height/width attribute values must be set manually, they don't reflect computed values.
	                       Thus, we use use getBBox() to ensure we always get values for elements with undefined height/width attributes. */
	                    if (/^(height|width)$/i.test(property)) {
	                        /* Firefox throws an error if .getBBox() is called on an SVG that isn't attached to the DOM. */
	                        try {
	                            propertyValue = element.getBBox()[property];
	                        } catch (error) {
	                            propertyValue = 0;
	                        }
	                    /* Otherwise, access the attribute value directly. */
	                    } else {
	                        propertyValue = element.getAttribute(property);
	                    }
	                } else {
	                    propertyValue = computePropertyValue(element, CSS.Names.prefixCheck(property)[0]); /* GET */
	                }
	            }
	
	            /* Since property lookups are for animation purposes (which entails computing the numeric delta between start and end values),
	               convert CSS null-values to an integer of value 0. */
	            if (CSS.Values.isCSSNullValue(propertyValue)) {
	                propertyValue = 0;
	            }
	
	            if (Velocity.debug >= 2) console.log("Get " + property + ": " + propertyValue);
	
	            return propertyValue;
	        },
	
	        /* The singular setPropertyValue, which routes the logic for all normalizations, hooks, and standard CSS properties. */
	        setPropertyValue: function(element, property, propertyValue, rootPropertyValue, scrollData) {
	            var propertyName = property;
	
	            /* In order to be subjected to call options and element queueing, scroll animation is routed through Velocity as if it were a standard CSS property. */
	            if (property === "scroll") {
	                /* If a container option is present, scroll the container instead of the browser window. */
	                if (scrollData.container) {
	                    scrollData.container["scroll" + scrollData.direction] = propertyValue;
	                /* Otherwise, Velocity defaults to scrolling the browser window. */
	                } else {
	                    if (scrollData.direction === "Left") {
	                        window.scrollTo(propertyValue, scrollData.alternateValue);
	                    } else {
	                        window.scrollTo(scrollData.alternateValue, propertyValue);
	                    }
	                }
	            } else {
	                /* Transforms (translateX, rotateZ, etc.) are applied to a per-element transformCache object, which is manually flushed via flushTransformCache().
	                   Thus, for now, we merely cache transforms being SET. */
	                if (CSS.Normalizations.registered[property] && CSS.Normalizations.registered[property]("name", element) === "transform") {
	                    /* Perform a normalization injection. */
	                    /* Note: The normalization logic handles the transformCache updating. */
	                    CSS.Normalizations.registered[property]("inject", element, propertyValue);
	
	                    propertyName = "transform";
	                    propertyValue = Data(element).transformCache[property];
	                } else {
	                    /* Inject hooks. */
	                    if (CSS.Hooks.registered[property]) {
	                        var hookName = property,
	                            hookRoot = CSS.Hooks.getRoot(property);
	
	                        /* If a cached rootPropertyValue was not provided, query the DOM for the hookRoot's current value. */
	                        rootPropertyValue = rootPropertyValue || CSS.getPropertyValue(element, hookRoot); /* GET */
	
	                        propertyValue = CSS.Hooks.injectValue(hookName, propertyValue, rootPropertyValue);
	                        property = hookRoot;
	                    }
	
	                    /* Normalize names and values. */
	                    if (CSS.Normalizations.registered[property]) {
	                        propertyValue = CSS.Normalizations.registered[property]("inject", element, propertyValue);
	                        property = CSS.Normalizations.registered[property]("name", element);
	                    }
	
	                    /* Assign the appropriate vendor prefix before performing an official style update. */
	                    propertyName = CSS.Names.prefixCheck(property)[0];
	
	                    /* A try/catch is used for IE<=8, which throws an error when "invalid" CSS values are set, e.g. a negative width.
	                       Try/catch is avoided for other browsers since it incurs a performance overhead. */
	                    if (IE <= 8) {
	                        try {
	                            element.style[propertyName] = propertyValue;
	                        } catch (error) { if (Velocity.debug) console.log("Browser does not support [" + propertyValue + "] for [" + propertyName + "]"); }
	                    /* SVG elements have their dimensional properties (width, height, x, y, cx, etc.) applied directly as attributes instead of as styles. */
	                    /* Note: IE8 does not support SVG elements, so it's okay that we skip it for SVG animation. */
	                    } else if (Data(element) && Data(element).isSVG && CSS.Names.SVGAttribute(property)) {
	                        /* Note: For SVG attributes, vendor-prefixed property names are never used. */
	                        /* Note: Not all CSS properties can be animated via attributes, but the browser won't throw an error for unsupported properties. */
	                        element.setAttribute(property, propertyValue);
	                    } else {
	                        element.style[propertyName] = propertyValue;
	                    }
	
	                    if (Velocity.debug >= 2) console.log("Set " + property + " (" + propertyName + "): " + propertyValue);
	                }
	            }
	
	            /* Return the normalized property name and value in case the caller wants to know how these values were modified before being applied to the DOM. */
	            return [ propertyName, propertyValue ];
	        },
	
	        /* To increase performance by batching transform updates into a single SET, transforms are not directly applied to an element until flushTransformCache() is called. */
	        /* Note: Velocity applies transform properties in the same order that they are chronogically introduced to the element's CSS styles. */
	        flushTransformCache: function(element) {
	            var transformString = "";
	
	            /* Certain browsers require that SVG transforms be applied as an attribute. However, the SVG transform attribute takes a modified version of CSS's transform string
	               (units are dropped and, except for skewX/Y, subproperties are merged into their master property -- e.g. scaleX and scaleY are merged into scale(X Y). */
	            if ((IE || (Velocity.State.isAndroid && !Velocity.State.isChrome)) && Data(element).isSVG) {
	                /* Since transform values are stored in their parentheses-wrapped form, we use a helper function to strip out their numeric values.
	                   Further, SVG transform properties only take unitless (representing pixels) values, so it's okay that parseFloat() strips the unit suffixed to the float value. */
	                function getTransformFloat (transformProperty) {
	                    return parseFloat(CSS.getPropertyValue(element, transformProperty));
	                }
	
	                /* Create an object to organize all the transforms that we'll apply to the SVG element. To keep the logic simple,
	                   we process *all* transform properties -- even those that may not be explicitly applied (since they default to their zero-values anyway). */
	                var SVGTransforms = {
	                    translate: [ getTransformFloat("translateX"), getTransformFloat("translateY") ],
	                    skewX: [ getTransformFloat("skewX") ], skewY: [ getTransformFloat("skewY") ],
	                    /* If the scale property is set (non-1), use that value for the scaleX and scaleY values
	                       (this behavior mimics the result of animating all these properties at once on HTML elements). */
	                    scale: getTransformFloat("scale") !== 1 ? [ getTransformFloat("scale"), getTransformFloat("scale") ] : [ getTransformFloat("scaleX"), getTransformFloat("scaleY") ],
	                    /* Note: SVG's rotate transform takes three values: rotation degrees followed by the X and Y values
	                       defining the rotation's origin point. We ignore the origin values (default them to 0). */
	                    rotate: [ getTransformFloat("rotateZ"), 0, 0 ]
	                };
	
	                /* Iterate through the transform properties in the user-defined property map order.
	                   (This mimics the behavior of non-SVG transform animation.) */
	                $.each(Data(element).transformCache, function(transformName) {
	                    /* Except for with skewX/Y, revert the axis-specific transform subproperties to their axis-free master
	                       properties so that they match up with SVG's accepted transform properties. */
	                    if (/^translate/i.test(transformName)) {
	                        transformName = "translate";
	                    } else if (/^scale/i.test(transformName)) {
	                        transformName = "scale";
	                    } else if (/^rotate/i.test(transformName)) {
	                        transformName = "rotate";
	                    }
	
	                    /* Check that we haven't yet deleted the property from the SVGTransforms container. */
	                    if (SVGTransforms[transformName]) {
	                        /* Append the transform property in the SVG-supported transform format. As per the spec, surround the space-delimited values in parentheses. */
	                        transformString += transformName + "(" + SVGTransforms[transformName].join(" ") + ")" + " ";
	
	                        /* After processing an SVG transform property, delete it from the SVGTransforms container so we don't
	                           re-insert the same master property if we encounter another one of its axis-specific properties. */
	                        delete SVGTransforms[transformName];
	                    }
	                });
	            } else {
	                var transformValue,
	                    perspective;
	
	                /* Transform properties are stored as members of the transformCache object. Concatenate all the members into a string. */
	                $.each(Data(element).transformCache, function(transformName) {
	                    transformValue = Data(element).transformCache[transformName];
	
	                    /* Transform's perspective subproperty must be set first in order to take effect. Store it temporarily. */
	                    if (transformName === "transformPerspective") {
	                        perspective = transformValue;
	                        return true;
	                    }
	
	                    /* IE9 only supports one rotation type, rotateZ, which it refers to as "rotate". */
	                    if (IE === 9 && transformName === "rotateZ") {
	                        transformName = "rotate";
	                    }
	
	                    transformString += transformName + transformValue + " ";
	                });
	
	                /* If present, set the perspective subproperty first. */
	                if (perspective) {
	                    transformString = "perspective" + perspective + " " + transformString;
	                }
	            }
	
	            CSS.setPropertyValue(element, "transform", transformString);
	        }
	    };
	
	    /* Register hooks and normalizations. */
	    CSS.Hooks.register();
	    CSS.Normalizations.register();
	
	    /* Allow hook setting in the same fashion as jQuery's $.css(). */
	    Velocity.hook = function (elements, arg2, arg3) {
	        var value = undefined;
	
	        elements = sanitizeElements(elements);
	
	        $.each(elements, function(i, element) {
	            /* Initialize Velocity's per-element data cache if this element hasn't previously been animated. */
	            if (Data(element) === undefined) {
	                Velocity.init(element);
	            }
	
	            /* Get property value. If an element set was passed in, only return the value for the first element. */
	            if (arg3 === undefined) {
	                if (value === undefined) {
	                    value = Velocity.CSS.getPropertyValue(element, arg2);
	                }
	            /* Set property value. */
	            } else {
	                /* sPV returns an array of the normalized propertyName/propertyValue pair used to update the DOM. */
	                var adjustedSet = Velocity.CSS.setPropertyValue(element, arg2, arg3);
	
	                /* Transform properties don't automatically set. They have to be flushed to the DOM. */
	                if (adjustedSet[0] === "transform") {
	                    Velocity.CSS.flushTransformCache(element);
	                }
	
	                value = adjustedSet;
	            }
	        });
	
	        return value;
	    };
	
	    /*****************
	        Animation
	    *****************/
	
	    var animate = function() {
	
	        /******************
	            Call Chain
	        ******************/
	
	        /* Logic for determining what to return to the call stack when exiting out of Velocity. */
	        function getChain () {
	            /* If we are using the utility function, attempt to return this call's promise. If no promise library was detected,
	               default to null instead of returning the targeted elements so that utility function's return value is standardized. */
	            if (isUtility) {
	                return promiseData.promise || null;
	            /* Otherwise, if we're using $.fn, return the jQuery-/Zepto-wrapped element set. */
	            } else {
	                return elementsWrapped;
	            }
	        }
	
	        /*************************
	           Arguments Assignment
	        *************************/
	
	        /* To allow for expressive CoffeeScript code, Velocity supports an alternative syntax in which "elements" (or "e"), "properties" (or "p"), and "options" (or "o")
	           objects are defined on a container object that's passed in as Velocity's sole argument. */
	        /* Note: Some browsers automatically populate arguments with a "properties" object. We detect it by checking for its default "names" property. */
	        var syntacticSugar = (arguments[0] && (arguments[0].p || (($.isPlainObject(arguments[0].properties) && !arguments[0].properties.names) || Type.isString(arguments[0].properties)))),
	            /* Whether Velocity was called via the utility function (as opposed to on a jQuery/Zepto object). */
	            isUtility,
	            /* When Velocity is called via the utility function ($.Velocity()/Velocity()), elements are explicitly
	               passed in as the first parameter. Thus, argument positioning varies. We normalize them here. */
	            elementsWrapped,
	            argumentIndex;
	
	        var elements,
	            propertiesMap,
	            options;
	
	        /* Detect jQuery/Zepto elements being animated via the $.fn method. */
	        if (Type.isWrapped(this)) {
	            isUtility = false;
	
	            argumentIndex = 0;
	            elements = this;
	            elementsWrapped = this;
	        /* Otherwise, raw elements are being animated via the utility function. */
	        } else {
	            isUtility = true;
	
	            argumentIndex = 1;
	            elements = syntacticSugar ? (arguments[0].elements || arguments[0].e) : arguments[0];
	        }
	
	        elements = sanitizeElements(elements);
	
	        if (!elements) {
	            return;
	        }
	
	        if (syntacticSugar) {
	            propertiesMap = arguments[0].properties || arguments[0].p;
	            options = arguments[0].options || arguments[0].o;
	        } else {
	            propertiesMap = arguments[argumentIndex];
	            options = arguments[argumentIndex + 1];
	        }
	
	        /* The length of the element set (in the form of a nodeList or an array of elements) is defaulted to 1 in case a
	           single raw DOM element is passed in (which doesn't contain a length property). */
	        var elementsLength = elements.length,
	            elementsIndex = 0;
	
	        /***************************
	            Argument Overloading
	        ***************************/
	
	        /* Support is included for jQuery's argument overloading: $.animate(propertyMap [, duration] [, easing] [, complete]).
	           Overloading is detected by checking for the absence of an object being passed into options. */
	        /* Note: The stop and finish actions do not accept animation options, and are therefore excluded from this check. */
	        if (!/^(stop|finish)$/i.test(propertiesMap) && !$.isPlainObject(options)) {
	            /* The utility function shifts all arguments one position to the right, so we adjust for that offset. */
	            var startingArgumentPosition = argumentIndex + 1;
	
	            options = {};
	
	            /* Iterate through all options arguments */
	            for (var i = startingArgumentPosition; i < arguments.length; i++) {
	                /* Treat a number as a duration. Parse it out. */
	                /* Note: The following RegEx will return true if passed an array with a number as its first item.
	                   Thus, arrays are skipped from this check. */
	                if (!Type.isArray(arguments[i]) && (/^(fast|normal|slow)$/i.test(arguments[i]) || /^\d/.test(arguments[i]))) {
	                    options.duration = arguments[i];
	                /* Treat strings and arrays as easings. */
	                } else if (Type.isString(arguments[i]) || Type.isArray(arguments[i])) {
	                    options.easing = arguments[i];
	                /* Treat a function as a complete callback. */
	                } else if (Type.isFunction(arguments[i])) {
	                    options.complete = arguments[i];
	                }
	            }
	        }
	
	        /***************
	            Promises
	        ***************/
	
	        var promiseData = {
	                promise: null,
	                resolver: null,
	                rejecter: null
	            };
	
	        /* If this call was made via the utility function (which is the default method of invocation when jQuery/Zepto are not being used), and if
	           promise support was detected, create a promise object for this call and store references to its resolver and rejecter methods. The resolve
	           method is used when a call completes naturally or is prematurely stopped by the user. In both cases, completeCall() handles the associated
	           call cleanup and promise resolving logic. The reject method is used when an invalid set of arguments is passed into a Velocity call. */
	        /* Note: Velocity employs a call-based queueing architecture, which means that stopping an animating element actually stops the full call that
	           triggered it -- not that one element exclusively. Similarly, there is one promise per call, and all elements targeted by a Velocity call are
	           grouped together for the purposes of resolving and rejecting a promise. */
	        if (isUtility && Velocity.Promise) {
	            promiseData.promise = new Velocity.Promise(function (resolve, reject) {
	                promiseData.resolver = resolve;
	                promiseData.rejecter = reject;
	            });
	        }
	
	        /*********************
	           Action Detection
	        *********************/
	
	        /* Velocity's behavior is categorized into "actions": Elements can either be specially scrolled into view,
	           or they can be started, stopped, or reversed. If a literal or referenced properties map is passed in as Velocity's
	           first argument, the associated action is "start". Alternatively, "scroll", "reverse", or "stop" can be passed in instead of a properties map. */
	        var action;
	
	        switch (propertiesMap) {
	            case "scroll":
	                action = "scroll";
	                break;
	
	            case "reverse":
	                action = "reverse";
	                break;
	
	            case "finish":
	            case "stop":
	                /*******************
	                    Action: Stop
	                *******************/
	
	                /* Clear the currently-active delay on each targeted element. */
	                $.each(elements, function(i, element) {
	                    if (Data(element) && Data(element).delayTimer) {
	                        /* Stop the timer from triggering its cached next() function. */
	                        clearTimeout(Data(element).delayTimer.setTimeout);
	
	                        /* Manually call the next() function so that the subsequent queue items can progress. */
	                        if (Data(element).delayTimer.next) {
	                            Data(element).delayTimer.next();
	                        }
	
	                        delete Data(element).delayTimer;
	                    }
	                });
	
	                var callsToStop = [];
	
	                /* When the stop action is triggered, the elements' currently active call is immediately stopped. The active call might have
	                   been applied to multiple elements, in which case all of the call's elements will be stopped. When an element
	                   is stopped, the next item in its animation queue is immediately triggered. */
	                /* An additional argument may be passed in to clear an element's remaining queued calls. Either true (which defaults to the "fx" queue)
	                   or a custom queue string can be passed in. */
	                /* Note: The stop command runs prior to Velocity's Queueing phase since its behavior is intended to take effect *immediately*,
	                   regardless of the element's current queue state. */
	
	                /* Iterate through every active call. */
	                $.each(Velocity.State.calls, function(i, activeCall) {
	                    /* Inactive calls are set to false by the logic inside completeCall(). Skip them. */
	                    if (activeCall) {
	                        /* Iterate through the active call's targeted elements. */
	                        $.each(activeCall[1], function(k, activeElement) {
	                            /* If true was passed in as a secondary argument, clear absolutely all calls on this element. Otherwise, only
	                               clear calls associated with the relevant queue. */
	                            /* Call stopping logic works as follows:
	                               - options === true --> stop current default queue calls (and queue:false calls), including remaining queued ones.
	                               - options === undefined --> stop current queue:"" call and all queue:false calls.
	                               - options === false --> stop only queue:false calls.
	                               - options === "custom" --> stop current queue:"custom" call, including remaining queued ones (there is no functionality to only clear the currently-running queue:"custom" call). */
	                            var queueName = (options === undefined) ? "" : options;
	
	                            if (queueName !== true && (activeCall[2].queue !== queueName) && !(options === undefined && activeCall[2].queue === false)) {
	                                return true;
	                            }
	
	                            /* Iterate through the calls targeted by the stop command. */
	                            $.each(elements, function(l, element) {                                
	                                /* Check that this call was applied to the target element. */
	                                if (element === activeElement) {
	                                    /* Optionally clear the remaining queued calls. */
	                                    if (options === true || Type.isString(options)) {
	                                        /* Iterate through the items in the element's queue. */
	                                        $.each($.queue(element, Type.isString(options) ? options : ""), function(_, item) {
	                                            /* The queue array can contain an "inprogress" string, which we skip. */
	                                            if (Type.isFunction(item)) {
	                                                /* Pass the item's callback a flag indicating that we want to abort from the queue call.
	                                                   (Specifically, the queue will resolve the call's associated promise then abort.)  */
	                                                item(null, true);
	                                            }
	                                        });
	
	                                        /* Clearing the $.queue() array is achieved by resetting it to []. */
	                                        $.queue(element, Type.isString(options) ? options : "", []);
	                                    }
	
	                                    if (propertiesMap === "stop") {
	                                        /* Since "reverse" uses cached start values (the previous call's endValues), these values must be
	                                           changed to reflect the final value that the elements were actually tweened to. */
	                                        /* Note: If only queue:false animations are currently running on an element, it won't have a tweensContainer
	                                           object. Also, queue:false animations can't be reversed. */
	                                        if (Data(element) && Data(element).tweensContainer && queueName !== false) {
	                                            $.each(Data(element).tweensContainer, function(m, activeTween) {
	                                                activeTween.endValue = activeTween.currentValue;
	                                            });
	                                        }
	
	                                        callsToStop.push(i);
	                                    } else if (propertiesMap === "finish") {
	                                        /* To get active tweens to finish immediately, we forcefully shorten their durations to 1ms so that
	                                        they finish upon the next rAf tick then proceed with normal call completion logic. */
	                                        activeCall[2].duration = 1;
	                                    }
	                                }
	                            });
	                        });
	                    }
	                });
	
	                /* Prematurely call completeCall() on each matched active call. Pass an additional flag for "stop" to indicate
	                   that the complete callback and display:none setting should be skipped since we're completing prematurely. */
	                if (propertiesMap === "stop") {
	                    $.each(callsToStop, function(i, j) {
	                        completeCall(j, true);
	                    });
	
	                    if (promiseData.promise) {
	                        /* Immediately resolve the promise associated with this stop call since stop runs synchronously. */
	                        promiseData.resolver(elements);
	                    }
	                }
	
	                /* Since we're stopping, and not proceeding with queueing, exit out of Velocity. */
	                return getChain();
	
	            default:
	                /* Treat a non-empty plain object as a literal properties map. */
	                if ($.isPlainObject(propertiesMap) && !Type.isEmptyObject(propertiesMap)) {
	                    action = "start";
	
	                /****************
	                    Redirects
	                ****************/
	
	                /* Check if a string matches a registered redirect (see Redirects above). */
	                } else if (Type.isString(propertiesMap) && Velocity.Redirects[propertiesMap]) {
	                    var opts = $.extend({}, options),
	                        durationOriginal = opts.duration,
	                        delayOriginal = opts.delay || 0;
	
	                    /* If the backwards option was passed in, reverse the element set so that elements animate from the last to the first. */
	                    if (opts.backwards === true) {
	                        elements = $.extend(true, [], elements).reverse();
	                    }
	
	                    /* Individually trigger the redirect for each element in the set to prevent users from having to handle iteration logic in their redirect. */
	                    $.each(elements, function(elementIndex, element) {
	                        /* If the stagger option was passed in, successively delay each element by the stagger value (in ms). Retain the original delay value. */
	                        if (parseFloat(opts.stagger)) {
	                            opts.delay = delayOriginal + (parseFloat(opts.stagger) * elementIndex);
	                        } else if (Type.isFunction(opts.stagger)) {
	                            opts.delay = delayOriginal + opts.stagger.call(element, elementIndex, elementsLength);
	                        }
	
	                        /* If the drag option was passed in, successively increase/decrease (depending on the presense of opts.backwards)
	                           the duration of each element's animation, using floors to prevent producing very short durations. */
	                        if (opts.drag) {
	                            /* Default the duration of UI pack effects (callouts and transitions) to 1000ms instead of the usual default duration of 400ms. */
	                            opts.duration = parseFloat(durationOriginal) || (/^(callout|transition)/.test(propertiesMap) ? 1000 : DURATION_DEFAULT);
	
	                            /* For each element, take the greater duration of: A) animation completion percentage relative to the original duration,
	                               B) 75% of the original duration, or C) a 200ms fallback (in case duration is already set to a low value).
	                               The end result is a baseline of 75% of the redirect's duration that increases/decreases as the end of the element set is approached. */
	                            opts.duration = Math.max(opts.duration * (opts.backwards ? 1 - elementIndex/elementsLength : (elementIndex + 1) / elementsLength), opts.duration * 0.75, 200);
	                        }
	
	                        /* Pass in the call's opts object so that the redirect can optionally extend it. It defaults to an empty object instead of null to
	                           reduce the opts checking logic required inside the redirect. */
	                        Velocity.Redirects[propertiesMap].call(element, element, opts || {}, elementIndex, elementsLength, elements, promiseData.promise ? promiseData : undefined);
	                    });
	
	                    /* Since the animation logic resides within the redirect's own code, abort the remainder of this call.
	                       (The performance overhead up to this point is virtually non-existant.) */
	                    /* Note: The jQuery call chain is kept intact by returning the complete element set. */
	                    return getChain();
	                } else {
	                    var abortError = "Velocity: First argument (" + propertiesMap + ") was not a property map, a known action, or a registered redirect. Aborting.";
	
	                    if (promiseData.promise) {
	                        promiseData.rejecter(new Error(abortError));
	                    } else {
	                        console.log(abortError);
	                    }
	
	                    return getChain();
	                }
	        }
	
	        /**************************
	            Call-Wide Variables
	        **************************/
	
	        /* A container for CSS unit conversion ratios (e.g. %, rem, and em ==> px) that is used to cache ratios across all elements
	           being animated in a single Velocity call. Calculating unit ratios necessitates DOM querying and updating, and is therefore
	           avoided (via caching) wherever possible. This container is call-wide instead of page-wide to avoid the risk of using stale
	           conversion metrics across Velocity animations that are not immediately consecutively chained. */
	        var callUnitConversionData = {
	                lastParent: null,
	                lastPosition: null,
	                lastFontSize: null,
	                lastPercentToPxWidth: null,
	                lastPercentToPxHeight: null,
	                lastEmToPx: null,
	                remToPx: null,
	                vwToPx: null,
	                vhToPx: null
	            };
	
	        /* A container for all the ensuing tween data and metadata associated with this call. This container gets pushed to the page-wide
	           Velocity.State.calls array that is processed during animation ticking. */
	        var call = [];
	
	        /************************
	           Element Processing
	        ************************/
	
	        /* Element processing consists of three parts -- data processing that cannot go stale and data processing that *can* go stale (i.e. third-party style modifications):
	           1) Pre-Queueing: Element-wide variables, including the element's data storage, are instantiated. Call options are prepared. If triggered, the Stop action is executed.
	           2) Queueing: The logic that runs once this call has reached its point of execution in the element's $.queue() stack. Most logic is placed here to avoid risking it becoming stale.
	           3) Pushing: Consolidation of the tween data followed by its push onto the global in-progress calls container.
	        */
	
	        function processElement () {
	
	            /*************************
	               Part I: Pre-Queueing
	            *************************/
	
	            /***************************
	               Element-Wide Variables
	            ***************************/
	
	            var element = this,
	                /* The runtime opts object is the extension of the current call's options and Velocity's page-wide option defaults. */
	                opts = $.extend({}, Velocity.defaults, options),
	                /* A container for the processed data associated with each property in the propertyMap.
	                   (Each property in the map produces its own "tween".) */
	                tweensContainer = {},
	                elementUnitConversionData;
	
	            /******************
	               Element Init
	            ******************/
	
	            if (Data(element) === undefined) {
	                Velocity.init(element);
	            }
	
	            /******************
	               Option: Delay
	            ******************/
	
	            /* Since queue:false doesn't respect the item's existing queue, we avoid injecting its delay here (it's set later on). */
	            /* Note: Velocity rolls its own delay function since jQuery doesn't have a utility alias for $.fn.delay()
	               (and thus requires jQuery element creation, which we avoid since its overhead includes DOM querying). */
	            if (parseFloat(opts.delay) && opts.queue !== false) {
	                $.queue(element, opts.queue, function(next) {
	                    /* This is a flag used to indicate to the upcoming completeCall() function that this queue entry was initiated by Velocity. See completeCall() for further details. */
	                    Velocity.velocityQueueEntryFlag = true;
	
	                    /* The ensuing queue item (which is assigned to the "next" argument that $.queue() automatically passes in) will be triggered after a setTimeout delay.
	                       The setTimeout is stored so that it can be subjected to clearTimeout() if this animation is prematurely stopped via Velocity's "stop" command. */
	                    Data(element).delayTimer = {
	                        setTimeout: setTimeout(next, parseFloat(opts.delay)),
	                        next: next
	                    };
	                });
	            }
	
	            /*********************
	               Option: Duration
	            *********************/
	
	            /* Support for jQuery's named durations. */
	            switch (opts.duration.toString().toLowerCase()) {
	                case "fast":
	                    opts.duration = 200;
	                    break;
	
	                case "normal":
	                    opts.duration = DURATION_DEFAULT;
	                    break;
	
	                case "slow":
	                    opts.duration = 600;
	                    break;
	
	                default:
	                    /* Remove the potential "ms" suffix and default to 1 if the user is attempting to set a duration of 0 (in order to produce an immediate style change). */
	                    opts.duration = parseFloat(opts.duration) || 1;
	            }
	
	            /************************
	               Global Option: Mock
	            ************************/
	
	            if (Velocity.mock !== false) {
	                /* In mock mode, all animations are forced to 1ms so that they occur immediately upon the next rAF tick.
	                   Alternatively, a multiplier can be passed in to time remap all delays and durations. */
	                if (Velocity.mock === true) {
	                    opts.duration = opts.delay = 1;
	                } else {
	                    opts.duration *= parseFloat(Velocity.mock) || 1;
	                    opts.delay *= parseFloat(Velocity.mock) || 1;
	                }
	            }
	
	            /*******************
	               Option: Easing
	            *******************/
	
	            opts.easing = getEasing(opts.easing, opts.duration);
	
	            /**********************
	               Option: Callbacks
	            **********************/
	
	            /* Callbacks must functions. Otherwise, default to null. */
	            if (opts.begin && !Type.isFunction(opts.begin)) {
	                opts.begin = null;
	            }
	
	            if (opts.progress && !Type.isFunction(opts.progress)) {
	                opts.progress = null;
	            }
	
	            if (opts.complete && !Type.isFunction(opts.complete)) {
	                opts.complete = null;
	            }
	
	            /*********************************
	               Option: Display & Visibility
	            *********************************/
	
	            /* Refer to Velocity's documentation (VelocityJS.org/#displayAndVisibility) for a description of the display and visibility options' behavior. */
	            /* Note: We strictly check for undefined instead of falsiness because display accepts an empty string value. */
	            if (opts.display !== undefined && opts.display !== null) {
	                opts.display = opts.display.toString().toLowerCase();
	
	                /* Users can pass in a special "auto" value to instruct Velocity to set the element to its default display value. */
	                if (opts.display === "auto") {
	                    opts.display = Velocity.CSS.Values.getDisplayType(element);
	                }
	            }
	
	            if (opts.visibility !== undefined && opts.visibility !== null) {
	                opts.visibility = opts.visibility.toString().toLowerCase();
	            }
	
	            /**********************
	               Option: mobileHA
	            **********************/
	
	            /* When set to true, and if this is a mobile device, mobileHA automatically enables hardware acceleration (via a null transform hack)
	               on animating elements. HA is removed from the element at the completion of its animation. */
	            /* Note: Android Gingerbread doesn't support HA. If a null transform hack (mobileHA) is in fact set, it will prevent other tranform subproperties from taking effect. */
	            /* Note: You can read more about the use of mobileHA in Velocity's documentation: VelocityJS.org/#mobileHA. */
	            opts.mobileHA = (opts.mobileHA && Velocity.State.isMobile && !Velocity.State.isGingerbread);
	
	            /***********************
	               Part II: Queueing
	            ***********************/
	
	            /* When a set of elements is targeted by a Velocity call, the set is broken up and each element has the current Velocity call individually queued onto it.
	               In this way, each element's existing queue is respected; some elements may already be animating and accordingly should not have this current Velocity call triggered immediately. */
	            /* In each queue, tween data is processed for each animating property then pushed onto the call-wide calls array. When the last element in the set has had its tweens processed,
	               the call array is pushed to Velocity.State.calls for live processing by the requestAnimationFrame tick. */
	            function buildQueue (next) {
	
	                /*******************
	                   Option: Begin
	                *******************/
	
	                /* The begin callback is fired once per call -- not once per elemenet -- and is passed the full raw DOM element set as both its context and its first argument. */
	                if (opts.begin && elementsIndex === 0) {
	                    /* We throw callbacks in a setTimeout so that thrown errors don't halt the execution of Velocity itself. */
	                    try {
	                        opts.begin.call(elements, elements);
	                    } catch (error) {
	                        setTimeout(function() { throw error; }, 1);
	                    }
	                }
	
	                /*****************************************
	                   Tween Data Construction (for Scroll)
	                *****************************************/
	
	                /* Note: In order to be subjected to chaining and animation options, scroll's tweening is routed through Velocity as if it were a standard CSS property animation. */
	                if (action === "scroll") {
	                    /* The scroll action uniquely takes an optional "offset" option -- specified in pixels -- that offsets the targeted scroll position. */
	                    var scrollDirection = (/^x$/i.test(opts.axis) ? "Left" : "Top"),
	                        scrollOffset = parseFloat(opts.offset) || 0,
	                        scrollPositionCurrent,
	                        scrollPositionCurrentAlternate,
	                        scrollPositionEnd;
	
	                    /* Scroll also uniquely takes an optional "container" option, which indicates the parent element that should be scrolled --
	                       as opposed to the browser window itself. This is useful for scrolling toward an element that's inside an overflowing parent element. */
	                    if (opts.container) {
	                        /* Ensure that either a jQuery object or a raw DOM element was passed in. */
	                        if (Type.isWrapped(opts.container) || Type.isNode(opts.container)) {
	                            /* Extract the raw DOM element from the jQuery wrapper. */
	                            opts.container = opts.container[0] || opts.container;
	                            /* Note: Unlike other properties in Velocity, the browser's scroll position is never cached since it so frequently changes
	                               (due to the user's natural interaction with the page). */
	                            scrollPositionCurrent = opts.container["scroll" + scrollDirection]; /* GET */
	
	                            /* $.position() values are relative to the container's currently viewable area (without taking into account the container's true dimensions
	                               -- say, for example, if the container was not overflowing). Thus, the scroll end value is the sum of the child element's position *and*
	                               the scroll container's current scroll position. */
	                            scrollPositionEnd = (scrollPositionCurrent + $(element).position()[scrollDirection.toLowerCase()]) + scrollOffset; /* GET */
	                        /* If a value other than a jQuery object or a raw DOM element was passed in, default to null so that this option is ignored. */
	                        } else {
	                            opts.container = null;
	                        }
	                    } else {
	                        /* If the window itself is being scrolled -- not a containing element -- perform a live scroll position lookup using
	                           the appropriate cached property names (which differ based on browser type). */
	                        scrollPositionCurrent = Velocity.State.scrollAnchor[Velocity.State["scrollProperty" + scrollDirection]]; /* GET */
	                        /* When scrolling the browser window, cache the alternate axis's current value since window.scrollTo() doesn't let us change only one value at a time. */
	                        scrollPositionCurrentAlternate = Velocity.State.scrollAnchor[Velocity.State["scrollProperty" + (scrollDirection === "Left" ? "Top" : "Left")]]; /* GET */
	
	                        /* Unlike $.position(), $.offset() values are relative to the browser window's true dimensions -- not merely its currently viewable area --
	                           and therefore end values do not need to be compounded onto current values. */
	                        scrollPositionEnd = $(element).offset()[scrollDirection.toLowerCase()] + scrollOffset; /* GET */
	                    }
	
	                    /* Since there's only one format that scroll's associated tweensContainer can take, we create it manually. */
	                    tweensContainer = {
	                        scroll: {
	                            rootPropertyValue: false,
	                            startValue: scrollPositionCurrent,
	                            currentValue: scrollPositionCurrent,
	                            endValue: scrollPositionEnd,
	                            unitType: "",
	                            easing: opts.easing,
	                            scrollData: {
	                                container: opts.container,
	                                direction: scrollDirection,
	                                alternateValue: scrollPositionCurrentAlternate
	                            }
	                        },
	                        element: element
	                    };
	
	                    if (Velocity.debug) console.log("tweensContainer (scroll): ", tweensContainer.scroll, element);
	
	                /******************************************
	                   Tween Data Construction (for Reverse)
	                ******************************************/
	
	                /* Reverse acts like a "start" action in that a property map is animated toward. The only difference is
	                   that the property map used for reverse is the inverse of the map used in the previous call. Thus, we manipulate
	                   the previous call to construct our new map: use the previous map's end values as our new map's start values. Copy over all other data. */
	                /* Note: Reverse can be directly called via the "reverse" parameter, or it can be indirectly triggered via the loop option. (Loops are composed of multiple reverses.) */
	                /* Note: Reverse calls do not need to be consecutively chained onto a currently-animating element in order to operate on cached values;
	                   there is no harm to reverse being called on a potentially stale data cache since reverse's behavior is simply defined
	                   as reverting to the element's values as they were prior to the previous *Velocity* call. */
	                } else if (action === "reverse") {
	                    /* Abort if there is no prior animation data to reverse to. */
	                    if (!Data(element).tweensContainer) {
	                        /* Dequeue the element so that this queue entry releases itself immediately, allowing subsequent queue entries to run. */
	                        $.dequeue(element, opts.queue);
	
	                        return;
	                    } else {
	                        /*********************
	                           Options Parsing
	                        *********************/
	
	                        /* If the element was hidden via the display option in the previous call,
	                           revert display to "auto" prior to reversal so that the element is visible again. */
	                        if (Data(element).opts.display === "none") {
	                            Data(element).opts.display = "auto";
	                        }
	
	                        if (Data(element).opts.visibility === "hidden") {
	                            Data(element).opts.visibility = "visible";
	                        }
	
	                        /* If the loop option was set in the previous call, disable it so that "reverse" calls aren't recursively generated.
	                           Further, remove the previous call's callback options; typically, users do not want these to be refired. */
	                        Data(element).opts.loop = false;
	                        Data(element).opts.begin = null;
	                        Data(element).opts.complete = null;
	
	                        /* Since we're extending an opts object that has already been extended with the defaults options object,
	                           we remove non-explicitly-defined properties that are auto-assigned values. */
	                        if (!options.easing) {
	                            delete opts.easing;
	                        }
	
	                        if (!options.duration) {
	                            delete opts.duration;
	                        }
	
	                        /* The opts object used for reversal is an extension of the options object optionally passed into this
	                           reverse call plus the options used in the previous Velocity call. */
	                        opts = $.extend({}, Data(element).opts, opts);
	
	                        /*************************************
	                           Tweens Container Reconstruction
	                        *************************************/
	
	                        /* Create a deepy copy (indicated via the true flag) of the previous call's tweensContainer. */
	                        var lastTweensContainer = $.extend(true, {}, Data(element).tweensContainer);
	
	                        /* Manipulate the previous tweensContainer by replacing its end values and currentValues with its start values. */
	                        for (var lastTween in lastTweensContainer) {
	                            /* In addition to tween data, tweensContainers contain an element property that we ignore here. */
	                            if (lastTween !== "element") {
	                                var lastStartValue = lastTweensContainer[lastTween].startValue;
	
	                                lastTweensContainer[lastTween].startValue = lastTweensContainer[lastTween].currentValue = lastTweensContainer[lastTween].endValue;
	                                lastTweensContainer[lastTween].endValue = lastStartValue;
	
	                                /* Easing is the only option that embeds into the individual tween data (since it can be defined on a per-property basis).
	                                   Accordingly, every property's easing value must be updated when an options object is passed in with a reverse call.
	                                   The side effect of this extensibility is that all per-property easing values are forcefully reset to the new value. */
	                                if (!Type.isEmptyObject(options)) {
	                                    lastTweensContainer[lastTween].easing = opts.easing;
	                                }
	
	                                if (Velocity.debug) console.log("reverse tweensContainer (" + lastTween + "): " + JSON.stringify(lastTweensContainer[lastTween]), element);
	                            }
	                        }
	
	                        tweensContainer = lastTweensContainer;
	                    }
	
	                /*****************************************
	                   Tween Data Construction (for Start)
	                *****************************************/
	
	                } else if (action === "start") {
	
	                    /*************************
	                        Value Transferring
	                    *************************/
	
	                    /* If this queue entry follows a previous Velocity-initiated queue entry *and* if this entry was created
	                       while the element was in the process of being animated by Velocity, then this current call is safe to use
	                       the end values from the prior call as its start values. Velocity attempts to perform this value transfer
	                       process whenever possible in order to avoid requerying the DOM. */
	                    /* If values aren't transferred from a prior call and start values were not forcefed by the user (more on this below),
	                       then the DOM is queried for the element's current values as a last resort. */
	                    /* Note: Conversely, animation reversal (and looping) *always* perform inter-call value transfers; they never requery the DOM. */
	                    var lastTweensContainer;
	
	                    /* The per-element isAnimating flag is used to indicate whether it's safe (i.e. the data isn't stale)
	                       to transfer over end values to use as start values. If it's set to true and there is a previous
	                       Velocity call to pull values from, do so. */
	                    if (Data(element).tweensContainer && Data(element).isAnimating === true) {
	                        lastTweensContainer = Data(element).tweensContainer;
	                    }
	
	                    /***************************
	                       Tween Data Calculation
	                    ***************************/
	
	                    /* This function parses property data and defaults endValue, easing, and startValue as appropriate. */
	                    /* Property map values can either take the form of 1) a single value representing the end value,
	                       or 2) an array in the form of [ endValue, [, easing] [, startValue] ].
	                       The optional third parameter is a forcefed startValue to be used instead of querying the DOM for
	                       the element's current value. Read Velocity's docmentation to learn more about forcefeeding: VelocityJS.org/#forcefeeding */
	                    function parsePropertyValue (valueData, skipResolvingEasing) {
	                        var endValue = undefined,
	                            easing = undefined,
	                            startValue = undefined;
	
	                        /* Handle the array format, which can be structured as one of three potential overloads:
	                           A) [ endValue, easing, startValue ], B) [ endValue, easing ], or C) [ endValue, startValue ] */
	                        if (Type.isArray(valueData)) {
	                            /* endValue is always the first item in the array. Don't bother validating endValue's value now
	                               since the ensuing property cycling logic does that. */
	                            endValue = valueData[0];
	
	                            /* Two-item array format: If the second item is a number, function, or hex string, treat it as a
	                               start value since easings can only be non-hex strings or arrays. */
	                            if ((!Type.isArray(valueData[1]) && /^[\d-]/.test(valueData[1])) || Type.isFunction(valueData[1]) || CSS.RegEx.isHex.test(valueData[1])) {
	                                startValue = valueData[1];
	                            /* Two or three-item array: If the second item is a non-hex string or an array, treat it as an easing. */
	                            } else if ((Type.isString(valueData[1]) && !CSS.RegEx.isHex.test(valueData[1])) || Type.isArray(valueData[1])) {
	                                easing = skipResolvingEasing ? valueData[1] : getEasing(valueData[1], opts.duration);
	
	                                /* Don't bother validating startValue's value now since the ensuing property cycling logic inherently does that. */
	                                if (valueData[2] !== undefined) {
	                                    startValue = valueData[2];
	                                }
	                            }
	                        /* Handle the single-value format. */
	                        } else {
	                            endValue = valueData;
	                        }
	
	                        /* Default to the call's easing if a per-property easing type was not defined. */
	                        if (!skipResolvingEasing) {
	                            easing = easing || opts.easing;
	                        }
	
	                        /* If functions were passed in as values, pass the function the current element as its context,
	                           plus the element's index and the element set's size as arguments. Then, assign the returned value. */
	                        if (Type.isFunction(endValue)) {
	                            endValue = endValue.call(element, elementsIndex, elementsLength);
	                        }
	
	                        if (Type.isFunction(startValue)) {
	                            startValue = startValue.call(element, elementsIndex, elementsLength);
	                        }
	
	                        /* Allow startValue to be left as undefined to indicate to the ensuing code that its value was not forcefed. */
	                        return [ endValue || 0, easing, startValue ];
	                    }
	
	                    /* Cycle through each property in the map, looking for shorthand color properties (e.g. "color" as opposed to "colorRed"). Inject the corresponding
	                       colorRed, colorGreen, and colorBlue RGB component tweens into the propertiesMap (which Velocity understands) and remove the shorthand property. */
	                    $.each(propertiesMap, function(property, value) {
	                        /* Find shorthand color properties that have been passed a hex string. */
	                        if (RegExp("^" + CSS.Lists.colors.join("$|^") + "$").test(property)) {
	                            /* Parse the value data for each shorthand. */
	                            var valueData = parsePropertyValue(value, true),
	                                endValue = valueData[0],
	                                easing = valueData[1],
	                                startValue = valueData[2];
	
	                            if (CSS.RegEx.isHex.test(endValue)) {
	                                /* Convert the hex strings into their RGB component arrays. */
	                                var colorComponents = [ "Red", "Green", "Blue" ],
	                                    endValueRGB = CSS.Values.hexToRgb(endValue),
	                                    startValueRGB = startValue ? CSS.Values.hexToRgb(startValue) : undefined;
	
	                                /* Inject the RGB component tweens into propertiesMap. */
	                                for (var i = 0; i < colorComponents.length; i++) {
	                                    var dataArray = [ endValueRGB[i] ];
	
	                                    if (easing) {
	                                        dataArray.push(easing);
	                                    }
	
	                                    if (startValueRGB !== undefined) {
	                                        dataArray.push(startValueRGB[i]);
	                                    }
	
	                                    propertiesMap[property + colorComponents[i]] = dataArray;
	                                }
	
	                                /* Remove the intermediary shorthand property entry now that we've processed it. */
	                                delete propertiesMap[property];
	                            }
	                        }
	                    });
	
	                    /* Create a tween out of each property, and append its associated data to tweensContainer. */
	                    for (var property in propertiesMap) {
	
	                        /**************************
	                           Start Value Sourcing
	                        **************************/
	
	                        /* Parse out endValue, easing, and startValue from the property's data. */
	                        var valueData = parsePropertyValue(propertiesMap[property]),
	                            endValue = valueData[0],
	                            easing = valueData[1],
	                            startValue = valueData[2];
	
	                        /* Now that the original property name's format has been used for the parsePropertyValue() lookup above,
	                           we force the property to its camelCase styling to normalize it for manipulation. */
	                        property = CSS.Names.camelCase(property);
	
	                        /* In case this property is a hook, there are circumstances where we will intend to work on the hook's root property and not the hooked subproperty. */
	                        var rootProperty = CSS.Hooks.getRoot(property),
	                            rootPropertyValue = false;
	
	                        /* Other than for the dummy tween property, properties that are not supported by the browser (and do not have an associated normalization) will
	                           inherently produce no style changes when set, so they are skipped in order to decrease animation tick overhead.
	                           Property support is determined via prefixCheck(), which returns a false flag when no supported is detected. */
	                        /* Note: Since SVG elements have some of their properties directly applied as HTML attributes,
	                           there is no way to check for their explicit browser support, and so we skip skip this check for them. */
	                        if (!Data(element).isSVG && rootProperty !== "tween" && CSS.Names.prefixCheck(rootProperty)[1] === false && CSS.Normalizations.registered[rootProperty] === undefined) {
	                            if (Velocity.debug) console.log("Skipping [" + rootProperty + "] due to a lack of browser support.");
	
	                            continue;
	                        }
	
	                        /* If the display option is being set to a non-"none" (e.g. "block") and opacity (filter on IE<=8) is being
	                           animated to an endValue of non-zero, the user's intention is to fade in from invisible, thus we forcefeed opacity
	                           a startValue of 0 if its startValue hasn't already been sourced by value transferring or prior forcefeeding. */
	                        if (((opts.display !== undefined && opts.display !== null && opts.display !== "none") || (opts.visibility !== undefined && opts.visibility !== "hidden")) && /opacity|filter/.test(property) && !startValue && endValue !== 0) {
	                            startValue = 0;
	                        }
	
	                        /* If values have been transferred from the previous Velocity call, extract the endValue and rootPropertyValue
	                           for all of the current call's properties that were *also* animated in the previous call. */
	                        /* Note: Value transferring can optionally be disabled by the user via the _cacheValues option. */
	                        if (opts._cacheValues && lastTweensContainer && lastTweensContainer[property]) {
	                            if (startValue === undefined) {
	                                startValue = lastTweensContainer[property].endValue + lastTweensContainer[property].unitType;
	                            }
	
	                            /* The previous call's rootPropertyValue is extracted from the element's data cache since that's the
	                               instance of rootPropertyValue that gets freshly updated by the tweening process, whereas the rootPropertyValue
	                               attached to the incoming lastTweensContainer is equal to the root property's value prior to any tweening. */
	                            rootPropertyValue = Data(element).rootPropertyValueCache[rootProperty];
	                        /* If values were not transferred from a previous Velocity call, query the DOM as needed. */
	                        } else {
	                            /* Handle hooked properties. */
	                            if (CSS.Hooks.registered[property]) {
	                               if (startValue === undefined) {
	                                    rootPropertyValue = CSS.getPropertyValue(element, rootProperty); /* GET */
	                                    /* Note: The following getPropertyValue() call does not actually trigger a DOM query;
	                                       getPropertyValue() will extract the hook from rootPropertyValue. */
	                                    startValue = CSS.getPropertyValue(element, property, rootPropertyValue);
	                                /* If startValue is already defined via forcefeeding, do not query the DOM for the root property's value;
	                                   just grab rootProperty's zero-value template from CSS.Hooks. This overwrites the element's actual
	                                   root property value (if one is set), but this is acceptable since the primary reason users forcefeed is
	                                   to avoid DOM queries, and thus we likewise avoid querying the DOM for the root property's value. */
	                                } else {
	                                    /* Grab this hook's zero-value template, e.g. "0px 0px 0px black". */
	                                    rootPropertyValue = CSS.Hooks.templates[rootProperty][1];
	                                }
	                            /* Handle non-hooked properties that haven't already been defined via forcefeeding. */
	                            } else if (startValue === undefined) {
	                                startValue = CSS.getPropertyValue(element, property); /* GET */
	                            }
	                        }
	
	                        /**************************
	                           Value Data Extraction
	                        **************************/
	
	                        var separatedValue,
	                            endValueUnitType,
	                            startValueUnitType,
	                            operator = false;
	
	                        /* Separates a property value into its numeric value and its unit type. */
	                        function separateValue (property, value) {
	                            var unitType,
	                                numericValue;
	
	                            numericValue = (value || "0")
	                                .toString()
	                                .toLowerCase()
	                                /* Match the unit type at the end of the value. */
	                                .replace(/[%A-z]+$/, function(match) {
	                                    /* Grab the unit type. */
	                                    unitType = match;
	
	                                    /* Strip the unit type off of value. */
	                                    return "";
	                                });
	
	                            /* If no unit type was supplied, assign one that is appropriate for this property (e.g. "deg" for rotateZ or "px" for width). */
	                            if (!unitType) {
	                                unitType = CSS.Values.getUnitType(property);
	                            }
	
	                            return [ numericValue, unitType ];
	                        }
	
	                        /* Separate startValue. */
	                        separatedValue = separateValue(property, startValue);
	                        startValue = separatedValue[0];
	                        startValueUnitType = separatedValue[1];
	
	                        /* Separate endValue, and extract a value operator (e.g. "+=", "-=") if one exists. */
	                        separatedValue = separateValue(property, endValue);
	                        endValue = separatedValue[0].replace(/^([+-\/*])=/, function(match, subMatch) {
	                            operator = subMatch;
	
	                            /* Strip the operator off of the value. */
	                            return "";
	                        });
	                        endValueUnitType = separatedValue[1];
	
	                        /* Parse float values from endValue and startValue. Default to 0 if NaN is returned. */
	                        startValue = parseFloat(startValue) || 0;
	                        endValue = parseFloat(endValue) || 0;
	
	                        /***************************************
	                           Property-Specific Value Conversion
	                        ***************************************/
	
	                        /* Custom support for properties that don't actually accept the % unit type, but where pollyfilling is trivial and relatively foolproof. */
	                        if (endValueUnitType === "%") {
	                            /* A %-value fontSize/lineHeight is relative to the parent's fontSize (as opposed to the parent's dimensions),
	                               which is identical to the em unit's behavior, so we piggyback off of that. */
	                            if (/^(fontSize|lineHeight)$/.test(property)) {
	                                /* Convert % into an em decimal value. */
	                                endValue = endValue / 100;
	                                endValueUnitType = "em";
	                            /* For scaleX and scaleY, convert the value into its decimal format and strip off the unit type. */
	                            } else if (/^scale/.test(property)) {
	                                endValue = endValue / 100;
	                                endValueUnitType = "";
	                            /* For RGB components, take the defined percentage of 255 and strip off the unit type. */
	                            } else if (/(Red|Green|Blue)$/i.test(property)) {
	                                endValue = (endValue / 100) * 255;
	                                endValueUnitType = "";
	                            }
	                        }
	
	                        /***************************
	                           Unit Ratio Calculation
	                        ***************************/
	
	                        /* When queried, the browser returns (most) CSS property values in pixels. Therefore, if an endValue with a unit type of
	                           %, em, or rem is animated toward, startValue must be converted from pixels into the same unit type as endValue in order
	                           for value manipulation logic (increment/decrement) to proceed. Further, if the startValue was forcefed or transferred
	                           from a previous call, startValue may also not be in pixels. Unit conversion logic therefore consists of two steps:
	                           1) Calculating the ratio of %/em/rem/vh/vw relative to pixels
	                           2) Converting startValue into the same unit of measurement as endValue based on these ratios. */
	                        /* Unit conversion ratios are calculated by inserting a sibling node next to the target node, copying over its position property,
	                           setting values with the target unit type then comparing the returned pixel value. */
	                        /* Note: Even if only one of these unit types is being animated, all unit ratios are calculated at once since the overhead
	                           of batching the SETs and GETs together upfront outweights the potential overhead
	                           of layout thrashing caused by re-querying for uncalculated ratios for subsequently-processed properties. */
	                        /* Todo: Shift this logic into the calls' first tick instance so that it's synced with RAF. */
	                        function calculateUnitRatios () {
	
	                            /************************
	                                Same Ratio Checks
	                            ************************/
	
	                            /* The properties below are used to determine whether the element differs sufficiently from this call's
	                               previously iterated element to also differ in its unit conversion ratios. If the properties match up with those
	                               of the prior element, the prior element's conversion ratios are used. Like most optimizations in Velocity,
	                               this is done to minimize DOM querying. */
	                            var sameRatioIndicators = {
	                                    myParent: element.parentNode || document.body, /* GET */
	                                    position: CSS.getPropertyValue(element, "position"), /* GET */
	                                    fontSize: CSS.getPropertyValue(element, "fontSize") /* GET */
	                                },
	                                /* Determine if the same % ratio can be used. % is based on the element's position value and its parent's width and height dimensions. */
	                                samePercentRatio = ((sameRatioIndicators.position === callUnitConversionData.lastPosition) && (sameRatioIndicators.myParent === callUnitConversionData.lastParent)),
	                                /* Determine if the same em ratio can be used. em is relative to the element's fontSize. */
	                                sameEmRatio = (sameRatioIndicators.fontSize === callUnitConversionData.lastFontSize);
	
	                            /* Store these ratio indicators call-wide for the next element to compare against. */
	                            callUnitConversionData.lastParent = sameRatioIndicators.myParent;
	                            callUnitConversionData.lastPosition = sameRatioIndicators.position;
	                            callUnitConversionData.lastFontSize = sameRatioIndicators.fontSize;
	
	                            /***************************
	                               Element-Specific Units
	                            ***************************/
	
	                            /* Note: IE8 rounds to the nearest pixel when returning CSS values, thus we perform conversions using a measurement
	                               of 100 (instead of 1) to give our ratios a precision of at least 2 decimal values. */
	                            var measurement = 100,
	                                unitRatios = {};
	
	                            if (!sameEmRatio || !samePercentRatio) {
	                                var dummy = Data(element).isSVG ? document.createElementNS("http://www.w3.org/2000/svg", "rect") : document.createElement("div");
	
	                                Velocity.init(dummy);
	                                sameRatioIndicators.myParent.appendChild(dummy);
	
	                                /* To accurately and consistently calculate conversion ratios, the element's cascaded overflow and box-sizing are stripped.
	                                   Similarly, since width/height can be artificially constrained by their min-/max- equivalents, these are controlled for as well. */
	                                /* Note: Overflow must be also be controlled for per-axis since the overflow property overwrites its per-axis values. */
	                                $.each([ "overflow", "overflowX", "overflowY" ], function(i, property) {
	                                    Velocity.CSS.setPropertyValue(dummy, property, "hidden");
	                                });
	                                Velocity.CSS.setPropertyValue(dummy, "position", sameRatioIndicators.position);
	                                Velocity.CSS.setPropertyValue(dummy, "fontSize", sameRatioIndicators.fontSize);
	                                Velocity.CSS.setPropertyValue(dummy, "boxSizing", "content-box");
	
	                                /* width and height act as our proxy properties for measuring the horizontal and vertical % ratios. */
	                                $.each([ "minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height" ], function(i, property) {
	                                    Velocity.CSS.setPropertyValue(dummy, property, measurement + "%");
	                                });
	                                /* paddingLeft arbitrarily acts as our proxy property for the em ratio. */
	                                Velocity.CSS.setPropertyValue(dummy, "paddingLeft", measurement + "em");
	
	                                /* Divide the returned value by the measurement to get the ratio between 1% and 1px. Default to 1 since working with 0 can produce Infinite. */
	                                unitRatios.percentToPxWidth = callUnitConversionData.lastPercentToPxWidth = (parseFloat(CSS.getPropertyValue(dummy, "width", null, true)) || 1) / measurement; /* GET */
	                                unitRatios.percentToPxHeight = callUnitConversionData.lastPercentToPxHeight = (parseFloat(CSS.getPropertyValue(dummy, "height", null, true)) || 1) / measurement; /* GET */
	                                unitRatios.emToPx = callUnitConversionData.lastEmToPx = (parseFloat(CSS.getPropertyValue(dummy, "paddingLeft")) || 1) / measurement; /* GET */
	
	                                sameRatioIndicators.myParent.removeChild(dummy);
	                            } else {
	                                unitRatios.emToPx = callUnitConversionData.lastEmToPx;
	                                unitRatios.percentToPxWidth = callUnitConversionData.lastPercentToPxWidth;
	                                unitRatios.percentToPxHeight = callUnitConversionData.lastPercentToPxHeight;
	                            }
	
	                            /***************************
	                               Element-Agnostic Units
	                            ***************************/
	
	                            /* Whereas % and em ratios are determined on a per-element basis, the rem unit only needs to be checked
	                               once per call since it's exclusively dependant upon document.body's fontSize. If this is the first time
	                               that calculateUnitRatios() is being run during this call, remToPx will still be set to its default value of null,
	                               so we calculate it now. */
	                            if (callUnitConversionData.remToPx === null) {
	                                /* Default to browsers' default fontSize of 16px in the case of 0. */
	                                callUnitConversionData.remToPx = parseFloat(CSS.getPropertyValue(document.body, "fontSize")) || 16; /* GET */
	                            }
	
	                            /* Similarly, viewport units are %-relative to the window's inner dimensions. */
	                            if (callUnitConversionData.vwToPx === null) {
	                                callUnitConversionData.vwToPx = parseFloat(window.innerWidth) / 100; /* GET */
	                                callUnitConversionData.vhToPx = parseFloat(window.innerHeight) / 100; /* GET */
	                            }
	
	                            unitRatios.remToPx = callUnitConversionData.remToPx;
	                            unitRatios.vwToPx = callUnitConversionData.vwToPx;
	                            unitRatios.vhToPx = callUnitConversionData.vhToPx;
	
	                            if (Velocity.debug >= 1) console.log("Unit ratios: " + JSON.stringify(unitRatios), element);
	
	                            return unitRatios;
	                        }
	
	                        /********************
	                           Unit Conversion
	                        ********************/
	
	                        /* The * and / operators, which are not passed in with an associated unit, inherently use startValue's unit. Skip value and unit conversion. */
	                        if (/[\/*]/.test(operator)) {
	                            endValueUnitType = startValueUnitType;
	                        /* If startValue and endValue differ in unit type, convert startValue into the same unit type as endValue so that if endValueUnitType
	                           is a relative unit (%, em, rem), the values set during tweening will continue to be accurately relative even if the metrics they depend
	                           on are dynamically changing during the course of the animation. Conversely, if we always normalized into px and used px for setting values, the px ratio
	                           would become stale if the original unit being animated toward was relative and the underlying metrics change during the animation. */
	                        /* Since 0 is 0 in any unit type, no conversion is necessary when startValue is 0 -- we just start at 0 with endValueUnitType. */
	                        } else if ((startValueUnitType !== endValueUnitType) && startValue !== 0) {
	                            /* Unit conversion is also skipped when endValue is 0, but *startValueUnitType* must be used for tween values to remain accurate. */
	                            /* Note: Skipping unit conversion here means that if endValueUnitType was originally a relative unit, the animation won't relatively
	                               match the underlying metrics if they change, but this is acceptable since we're animating toward invisibility instead of toward visibility,
	                               which remains past the point of the animation's completion. */
	                            if (endValue === 0) {
	                                endValueUnitType = startValueUnitType;
	                            } else {
	                                /* By this point, we cannot avoid unit conversion (it's undesirable since it causes layout thrashing).
	                                   If we haven't already, we trigger calculateUnitRatios(), which runs once per element per call. */
	                                elementUnitConversionData = elementUnitConversionData || calculateUnitRatios();
	
	                                /* The following RegEx matches CSS properties that have their % values measured relative to the x-axis. */
	                                /* Note: W3C spec mandates that all of margin and padding's properties (even top and bottom) are %-relative to the *width* of the parent element. */
	                                var axis = (/margin|padding|left|right|width|text|word|letter/i.test(property) || /X$/.test(property) || property === "x") ? "x" : "y";
	
	                                /* In order to avoid generating n^2 bespoke conversion functions, unit conversion is a two-step process:
	                                   1) Convert startValue into pixels. 2) Convert this new pixel value into endValue's unit type. */
	                                switch (startValueUnitType) {
	                                    case "%":
	                                        /* Note: translateX and translateY are the only properties that are %-relative to an element's own dimensions -- not its parent's dimensions.
	                                           Velocity does not include a special conversion process to account for this behavior. Therefore, animating translateX/Y from a % value
	                                           to a non-% value will produce an incorrect start value. Fortunately, this sort of cross-unit conversion is rarely done by users in practice. */
	                                        startValue *= (axis === "x" ? elementUnitConversionData.percentToPxWidth : elementUnitConversionData.percentToPxHeight);
	                                        break;
	
	                                    case "px":
	                                        /* px acts as our midpoint in the unit conversion process; do nothing. */
	                                        break;
	
	                                    default:
	                                        startValue *= elementUnitConversionData[startValueUnitType + "ToPx"];
	                                }
	
	                                /* Invert the px ratios to convert into to the target unit. */
	                                switch (endValueUnitType) {
	                                    case "%":
	                                        startValue *= 1 / (axis === "x" ? elementUnitConversionData.percentToPxWidth : elementUnitConversionData.percentToPxHeight);
	                                        break;
	
	                                    case "px":
	                                        /* startValue is already in px, do nothing; we're done. */
	                                        break;
	
	                                    default:
	                                        startValue *= 1 / elementUnitConversionData[endValueUnitType + "ToPx"];
	                                }
	                            }
	                        }
	
	                        /*********************
	                           Relative Values
	                        *********************/
	
	                        /* Operator logic must be performed last since it requires unit-normalized start and end values. */
	                        /* Note: Relative *percent values* do not behave how most people think; while one would expect "+=50%"
	                           to increase the property 1.5x its current value, it in fact increases the percent units in absolute terms:
	                           50 points is added on top of the current % value. */
	                        switch (operator) {
	                            case "+":
	                                endValue = startValue + endValue;
	                                break;
	
	                            case "-":
	                                endValue = startValue - endValue;
	                                break;
	
	                            case "*":
	                                endValue = startValue * endValue;
	                                break;
	
	                            case "/":
	                                endValue = startValue / endValue;
	                                break;
	                        }
	
	                        /**************************
	                           tweensContainer Push
	                        **************************/
	
	                        /* Construct the per-property tween object, and push it to the element's tweensContainer. */
	                        tweensContainer[property] = {
	                            rootPropertyValue: rootPropertyValue,
	                            startValue: startValue,
	                            currentValue: startValue,
	                            endValue: endValue,
	                            unitType: endValueUnitType,
	                            easing: easing
	                        };
	
	                        if (Velocity.debug) console.log("tweensContainer (" + property + "): " + JSON.stringify(tweensContainer[property]), element);
	                    }
	
	                    /* Along with its property data, store a reference to the element itself onto tweensContainer. */
	                    tweensContainer.element = element;
	                }
	
	                /*****************
	                    Call Push
	                *****************/
	
	                /* Note: tweensContainer can be empty if all of the properties in this call's property map were skipped due to not
	                   being supported by the browser. The element property is used for checking that the tweensContainer has been appended to. */
	                if (tweensContainer.element) {
	                    /* Apply the "velocity-animating" indicator class. */
	                    CSS.Values.addClass(element, "velocity-animating");
	
	                    /* The call array houses the tweensContainers for each element being animated in the current call. */
	                    call.push(tweensContainer);
	
	                    /* Store the tweensContainer and options if we're working on the default effects queue, so that they can be used by the reverse command. */
	                    if (opts.queue === "") {
	                        Data(element).tweensContainer = tweensContainer;
	                        Data(element).opts = opts;
	                    }
	
	                    /* Switch on the element's animating flag. */
	                    Data(element).isAnimating = true;
	
	                    /* Once the final element in this call's element set has been processed, push the call array onto
	                       Velocity.State.calls for the animation tick to immediately begin processing. */
	                    if (elementsIndex === elementsLength - 1) {
	                        /* Add the current call plus its associated metadata (the element set and the call's options) onto the global call container.
	                           Anything on this call container is subjected to tick() processing. */
	                        Velocity.State.calls.push([ call, elements, opts, null, promiseData.resolver ]);
	
	                        /* If the animation tick isn't running, start it. (Velocity shuts it off when there are no active calls to process.) */
	                        if (Velocity.State.isTicking === false) {
	                            Velocity.State.isTicking = true;
	
	                            /* Start the tick loop. */
	                            tick();
	                        }
	                    } else {
	                        elementsIndex++;
	                    }
	                }
	            }
	
	            /* When the queue option is set to false, the call skips the element's queue and fires immediately. */
	            if (opts.queue === false) {
	                /* Since this buildQueue call doesn't respect the element's existing queue (which is where a delay option would have been appended),
	                   we manually inject the delay property here with an explicit setTimeout. */
	                if (opts.delay) {
	                    setTimeout(buildQueue, opts.delay);
	                } else {
	                    buildQueue();
	                }
	            /* Otherwise, the call undergoes element queueing as normal. */
	            /* Note: To interoperate with jQuery, Velocity uses jQuery's own $.queue() stack for queuing logic. */
	            } else {
	                $.queue(element, opts.queue, function(next, clearQueue) {
	                    /* If the clearQueue flag was passed in by the stop command, resolve this call's promise. (Promises can only be resolved once,
	                       so it's fine if this is repeatedly triggered for each element in the associated call.) */
	                    if (clearQueue === true) {
	                        if (promiseData.promise) {
	                            promiseData.resolver(elements);
	                        }
	
	                        /* Do not continue with animation queueing. */
	                        return true;
	                    }
	
	                    /* This flag indicates to the upcoming completeCall() function that this queue entry was initiated by Velocity.
	                       See completeCall() for further details. */
	                    Velocity.velocityQueueEntryFlag = true;
	
	                    buildQueue(next);
	                });
	            }
	
	            /*********************
	                Auto-Dequeuing
	            *********************/
	
	            /* As per jQuery's $.queue() behavior, to fire the first non-custom-queue entry on an element, the element
	               must be dequeued if its queue stack consists *solely* of the current call. (This can be determined by checking
	               for the "inprogress" item that jQuery prepends to active queue stack arrays.) Regardless, whenever the element's
	               queue is further appended with additional items -- including $.delay()'s or even $.animate() calls, the queue's
	               first entry is automatically fired. This behavior contrasts that of custom queues, which never auto-fire. */
	            /* Note: When an element set is being subjected to a non-parallel Velocity call, the animation will not begin until
	               each one of the elements in the set has reached the end of its individually pre-existing queue chain. */
	            /* Note: Unfortunately, most people don't fully grasp jQuery's powerful, yet quirky, $.queue() function.
	               Lean more here: http://stackoverflow.com/questions/1058158/can-somebody-explain-jquery-queue-to-me */
	            if ((opts.queue === "" || opts.queue === "fx") && $.queue(element)[0] !== "inprogress") {
	                $.dequeue(element);
	            }
	        }
	
	        /**************************
	           Element Set Iteration
	        **************************/
	
	        /* If the "nodeType" property exists on the elements variable, we're animating a single element.
	           Place it in an array so that $.each() can iterate over it. */
	        $.each(elements, function(i, element) {
	            /* Ensure each element in a set has a nodeType (is a real element) to avoid throwing errors. */
	            if (Type.isNode(element)) {
	                processElement.call(element);
	            }
	        });
	
	        /******************
	           Option: Loop
	        ******************/
	
	        /* The loop option accepts an integer indicating how many times the element should loop between the values in the
	           current call's properties map and the element's property values prior to this call. */
	        /* Note: The loop option's logic is performed here -- after element processing -- because the current call needs
	           to undergo its queue insertion prior to the loop option generating its series of constituent "reverse" calls,
	           which chain after the current call. Two reverse calls (two "alternations") constitute one loop. */
	        var opts = $.extend({}, Velocity.defaults, options),
	            reverseCallsCount;
	
	        opts.loop = parseInt(opts.loop);
	        reverseCallsCount = (opts.loop * 2) - 1;
	
	        if (opts.loop) {
	            /* Double the loop count to convert it into its appropriate number of "reverse" calls.
	               Subtract 1 from the resulting value since the current call is included in the total alternation count. */
	            for (var x = 0; x < reverseCallsCount; x++) {
	                /* Since the logic for the reverse action occurs inside Queueing and therefore this call's options object
	                   isn't parsed until then as well, the current call's delay option must be explicitly passed into the reverse
	                   call so that the delay logic that occurs inside *Pre-Queueing* can process it. */
	                var reverseOptions = {
	                    delay: opts.delay,
	                    progress: opts.progress
	                };
	
	                /* If a complete callback was passed into this call, transfer it to the loop redirect's final "reverse" call
	                   so that it's triggered when the entire redirect is complete (and not when the very first animation is complete). */
	                if (x === reverseCallsCount - 1) {
	                    reverseOptions.display = opts.display;
	                    reverseOptions.visibility = opts.visibility;
	                    reverseOptions.complete = opts.complete;
	                }
	
	                animate(elements, "reverse", reverseOptions);
	            }
	        }
	
	        /***************
	            Chaining
	        ***************/
	
	        /* Return the elements back to the call chain, with wrapped elements taking precedence in case Velocity was called via the $.fn. extension. */
	        return getChain();
	    };
	
	    /* Turn Velocity into the animation function, extended with the pre-existing Velocity object. */
	    Velocity = $.extend(animate, Velocity);
	    /* For legacy support, also expose the literal animate method. */
	    Velocity.animate = animate;
	
	    /**************
	        Timing
	    **************/
	
	    /* Ticker function. */
	    var ticker = window.requestAnimationFrame || rAFShim;
	
	    /* Inactive browser tabs pause rAF, which results in all active animations immediately sprinting to their completion states when the tab refocuses.
	       To get around this, we dynamically switch rAF to setTimeout (which the browser *doesn't* pause) when the tab loses focus. We skip this for mobile
	       devices to avoid wasting battery power on inactive tabs. */
	    /* Note: Tab focus detection doesn't work on older versions of IE, but that's okay since they don't support rAF to begin with. */
	    if (!Velocity.State.isMobile && document.hidden !== undefined) {
	        document.addEventListener("visibilitychange", function() {
	            /* Reassign the rAF function (which the global tick() function uses) based on the tab's focus state. */
	            if (document.hidden) {
	                ticker = function(callback) {
	                    /* The tick function needs a truthy first argument in order to pass its internal timestamp check. */
	                    return setTimeout(function() { callback(true) }, 16);
	                };
	
	                /* The rAF loop has been paused by the browser, so we manually restart the tick. */
	                tick();
	            } else {
	                ticker = window.requestAnimationFrame || rAFShim;
	            }
	        });
	    }
	
	    /************
	        Tick
	    ************/
	
	    /* Note: All calls to Velocity are pushed to the Velocity.State.calls array, which is fully iterated through upon each tick. */
	    function tick (timestamp) {
	        /* An empty timestamp argument indicates that this is the first tick occurence since ticking was turned on.
	           We leverage this metadata to fully ignore the first tick pass since RAF's initial pass is fired whenever
	           the browser's next tick sync time occurs, which results in the first elements subjected to Velocity
	           calls being animated out of sync with any elements animated immediately thereafter. In short, we ignore
	           the first RAF tick pass so that elements being immediately consecutively animated -- instead of simultaneously animated
	           by the same Velocity call -- are properly batched into the same initial RAF tick and consequently remain in sync thereafter. */
	        if (timestamp) {
	            /* We ignore RAF's high resolution timestamp since it can be significantly offset when the browser is
	               under high stress; we opt for choppiness over allowing the browser to drop huge chunks of frames. */
	            var timeCurrent = (new Date).getTime();
	
	            /********************
	               Call Iteration
	            ********************/
	
	            var callsLength = Velocity.State.calls.length;
	
	            /* To speed up iterating over this array, it is compacted (falsey items -- calls that have completed -- are removed)
	               when its length has ballooned to a point that can impact tick performance. This only becomes necessary when animation
	               has been continuous with many elements over a long period of time; whenever all active calls are completed, completeCall() clears Velocity.State.calls. */
	            if (callsLength > 10000) {
	                Velocity.State.calls = compactSparseArray(Velocity.State.calls);
	            }
	
	            /* Iterate through each active call. */
	            for (var i = 0; i < callsLength; i++) {
	                /* When a Velocity call is completed, its Velocity.State.calls entry is set to false. Continue on to the next call. */
	                if (!Velocity.State.calls[i]) {
	                    continue;
	                }
	
	                /************************
	                   Call-Wide Variables
	                ************************/
	
	                var callContainer = Velocity.State.calls[i],
	                    call = callContainer[0],
	                    opts = callContainer[2],
	                    timeStart = callContainer[3],
	                    firstTick = !!timeStart,
	                    tweenDummyValue = null;
	
	                /* If timeStart is undefined, then this is the first time that this call has been processed by tick().
	                   We assign timeStart now so that its value is as close to the real animation start time as possible.
	                   (Conversely, had timeStart been defined when this call was added to Velocity.State.calls, the delay
	                   between that time and now would cause the first few frames of the tween to be skipped since
	                   percentComplete is calculated relative to timeStart.) */
	                /* Further, subtract 16ms (the approximate resolution of RAF) from the current time value so that the
	                   first tick iteration isn't wasted by animating at 0% tween completion, which would produce the
	                   same style value as the element's current value. */
	                if (!timeStart) {
	                    timeStart = Velocity.State.calls[i][3] = timeCurrent - 16;
	                }
	
	                /* The tween's completion percentage is relative to the tween's start time, not the tween's start value
	                   (which would result in unpredictable tween durations since JavaScript's timers are not particularly accurate).
	                   Accordingly, we ensure that percentComplete does not exceed 1. */
	                var percentComplete = Math.min((timeCurrent - timeStart) / opts.duration, 1);
	
	                /**********************
	                   Element Iteration
	                **********************/
	
	                /* For every call, iterate through each of the elements in its set. */
	                for (var j = 0, callLength = call.length; j < callLength; j++) {
	                    var tweensContainer = call[j],
	                        element = tweensContainer.element;
	
	                    /* Check to see if this element has been deleted midway through the animation by checking for the
	                       continued existence of its data cache. If it's gone, skip animating this element. */
	                    if (!Data(element)) {
	                        continue;
	                    }
	
	                    var transformPropertyExists = false;
	
	                    /**********************************
	                       Display & Visibility Toggling
	                    **********************************/
	
	                    /* If the display option is set to non-"none", set it upfront so that the element can become visible before tweening begins.
	                       (Otherwise, display's "none" value is set in completeCall() once the animation has completed.) */
	                    if (opts.display !== undefined && opts.display !== null && opts.display !== "none") {
	                        if (opts.display === "flex") {
	                            var flexValues = [ "-webkit-box", "-moz-box", "-ms-flexbox", "-webkit-flex" ];
	
	                            $.each(flexValues, function(i, flexValue) {
	                                CSS.setPropertyValue(element, "display", flexValue);
	                            });
	                        }
	
	                        CSS.setPropertyValue(element, "display", opts.display);
	                    }
	
	                    /* Same goes with the visibility option, but its "none" equivalent is "hidden". */
	                    if (opts.visibility !== undefined && opts.visibility !== "hidden") {
	                        CSS.setPropertyValue(element, "visibility", opts.visibility);
	                    }
	
	                    /************************
	                       Property Iteration
	                    ************************/
	
	                    /* For every element, iterate through each property. */
	                    for (var property in tweensContainer) {
	                        /* Note: In addition to property tween data, tweensContainer contains a reference to its associated element. */
	                        if (property !== "element") {
	                            var tween = tweensContainer[property],
	                                currentValue,
	                                /* Easing can either be a pre-genereated function or a string that references a pre-registered easing
	                                   on the Velocity.Easings object. In either case, return the appropriate easing *function*. */
	                                easing = Type.isString(tween.easing) ? Velocity.Easings[tween.easing] : tween.easing;
	
	                            /******************************
	                               Current Value Calculation
	                            ******************************/
	
	                            /* If this is the last tick pass (if we've reached 100% completion for this tween),
	                               ensure that currentValue is explicitly set to its target endValue so that it's not subjected to any rounding. */
	                            if (percentComplete === 1) {
	                                currentValue = tween.endValue;
	                            /* Otherwise, calculate currentValue based on the current delta from startValue. */
	                            } else {
	                                var tweenDelta = tween.endValue - tween.startValue;
	                                currentValue = tween.startValue + (tweenDelta * easing(percentComplete, opts, tweenDelta));
	
	                                /* If no value change is occurring, don't proceed with DOM updating. */
	                                if (!firstTick && (currentValue === tween.currentValue)) {
	                                    continue;
	                                }
	                            }
	
	                            tween.currentValue = currentValue;
	
	                            /* If we're tweening a fake 'tween' property in order to log transition values, update the one-per-call variable so that
	                               it can be passed into the progress callback. */ 
	                            if (property === "tween") {
	                                tweenDummyValue = currentValue;
	                            } else {
	                                /******************
	                                   Hooks: Part I
	                                ******************/
	
	                                /* For hooked properties, the newly-updated rootPropertyValueCache is cached onto the element so that it can be used
	                                   for subsequent hooks in this call that are associated with the same root property. If we didn't cache the updated
	                                   rootPropertyValue, each subsequent update to the root property in this tick pass would reset the previous hook's
	                                   updates to rootPropertyValue prior to injection. A nice performance byproduct of rootPropertyValue caching is that
	                                   subsequently chained animations using the same hookRoot but a different hook can use this cached rootPropertyValue. */
	                                if (CSS.Hooks.registered[property]) {
	                                    var hookRoot = CSS.Hooks.getRoot(property),
	                                        rootPropertyValueCache = Data(element).rootPropertyValueCache[hookRoot];
	
	                                    if (rootPropertyValueCache) {
	                                        tween.rootPropertyValue = rootPropertyValueCache;
	                                    }
	                                }
	
	                                /*****************
	                                    DOM Update
	                                *****************/
	
	                                /* setPropertyValue() returns an array of the property name and property value post any normalization that may have been performed. */
	                                /* Note: To solve an IE<=8 positioning bug, the unit type is dropped when setting a property value of 0. */
	                                var adjustedSetData = CSS.setPropertyValue(element, /* SET */
	                                                                           property,
	                                                                           tween.currentValue + (parseFloat(currentValue) === 0 ? "" : tween.unitType),
	                                                                           tween.rootPropertyValue,
	                                                                           tween.scrollData);
	
	                                /*******************
	                                   Hooks: Part II
	                                *******************/
	
	                                /* Now that we have the hook's updated rootPropertyValue (the post-processed value provided by adjustedSetData), cache it onto the element. */
	                                if (CSS.Hooks.registered[property]) {
	                                    /* Since adjustedSetData contains normalized data ready for DOM updating, the rootPropertyValue needs to be re-extracted from its normalized form. ?? */
	                                    if (CSS.Normalizations.registered[hookRoot]) {
	                                        Data(element).rootPropertyValueCache[hookRoot] = CSS.Normalizations.registered[hookRoot]("extract", null, adjustedSetData[1]);
	                                    } else {
	                                        Data(element).rootPropertyValueCache[hookRoot] = adjustedSetData[1];
	                                    }
	                                }
	
	                                /***************
	                                   Transforms
	                                ***************/
	
	                                /* Flag whether a transform property is being animated so that flushTransformCache() can be triggered once this tick pass is complete. */
	                                if (adjustedSetData[0] === "transform") {
	                                    transformPropertyExists = true;
	                                }
	
	                            }
	                        }
	                    }
	
	                    /****************
	                        mobileHA
	                    ****************/
	
	                    /* If mobileHA is enabled, set the translate3d transform to null to force hardware acceleration.
	                       It's safe to override this property since Velocity doesn't actually support its animation (hooks are used in its place). */
	                    if (opts.mobileHA) {
	                        /* Don't set the null transform hack if we've already done so. */
	                        if (Data(element).transformCache.translate3d === undefined) {
	                            /* All entries on the transformCache object are later concatenated into a single transform string via flushTransformCache(). */
	                            Data(element).transformCache.translate3d = "(0px, 0px, 0px)";
	
	                            transformPropertyExists = true;
	                        }
	                    }
	
	                    if (transformPropertyExists) {
	                        CSS.flushTransformCache(element);
	                    }
	                }
	
	                /* The non-"none" display value is only applied to an element once -- when its associated call is first ticked through.
	                   Accordingly, it's set to false so that it isn't re-processed by this call in the next tick. */
	                if (opts.display !== undefined && opts.display !== "none") {
	                    Velocity.State.calls[i][2].display = false;
	                }
	                if (opts.visibility !== undefined && opts.visibility !== "hidden") {
	                    Velocity.State.calls[i][2].visibility = false;
	                }
	
	                /* Pass the elements and the timing data (percentComplete, msRemaining, timeStart, tweenDummyValue) into the progress callback. */
	                if (opts.progress) {
	                    opts.progress.call(callContainer[1],
	                                       callContainer[1],
	                                       percentComplete,
	                                       Math.max(0, (timeStart + opts.duration) - timeCurrent),
	                                       timeStart,
	                                       tweenDummyValue);
	                }
	
	                /* If this call has finished tweening, pass its index to completeCall() to handle call cleanup. */
	                if (percentComplete === 1) {
	                    completeCall(i);
	                }
	            }
	        }
	
	        /* Note: completeCall() sets the isTicking flag to false when the last call on Velocity.State.calls has completed. */
	        if (Velocity.State.isTicking) {
	            ticker(tick);
	        }
	    }
	
	    /**********************
	        Call Completion
	    **********************/
	
	    /* Note: Unlike tick(), which processes all active calls at once, call completion is handled on a per-call basis. */
	    function completeCall (callIndex, isStopped) {
	        /* Ensure the call exists. */
	        if (!Velocity.State.calls[callIndex]) {
	            return false;
	        }
	
	        /* Pull the metadata from the call. */
	        var call = Velocity.State.calls[callIndex][0],
	            elements = Velocity.State.calls[callIndex][1],
	            opts = Velocity.State.calls[callIndex][2],
	            resolver = Velocity.State.calls[callIndex][4];
	
	        var remainingCallsExist = false;
	
	        /*************************
	           Element Finalization
	        *************************/
	
	        for (var i = 0, callLength = call.length; i < callLength; i++) {
	            var element = call[i].element;
	
	            /* If the user set display to "none" (intending to hide the element), set it now that the animation has completed. */
	            /* Note: display:none isn't set when calls are manually stopped (via Velocity("stop"). */
	            /* Note: Display gets ignored with "reverse" calls and infinite loops, since this behavior would be undesirable. */
	            if (!isStopped && !opts.loop) {
	                if (opts.display === "none") {
	                    CSS.setPropertyValue(element, "display", opts.display);
	                }
	
	                if (opts.visibility === "hidden") {
	                    CSS.setPropertyValue(element, "visibility", opts.visibility);
	                }
	            }
	
	            /* If the element's queue is empty (if only the "inprogress" item is left at position 0) or if its queue is about to run
	               a non-Velocity-initiated entry, turn off the isAnimating flag. A non-Velocity-initiatied queue entry's logic might alter
	               an element's CSS values and thereby cause Velocity's cached value data to go stale. To detect if a queue entry was initiated by Velocity,
	               we check for the existence of our special Velocity.queueEntryFlag declaration, which minifiers won't rename since the flag
	               is assigned to jQuery's global $ object and thus exists out of Velocity's own scope. */
	            if (opts.loop !== true && ($.queue(element)[1] === undefined || !/\.velocityQueueEntryFlag/i.test($.queue(element)[1]))) {
	                /* The element may have been deleted. Ensure that its data cache still exists before acting on it. */
	                if (Data(element)) {
	                    Data(element).isAnimating = false;
	                    /* Clear the element's rootPropertyValueCache, which will become stale. */
	                    Data(element).rootPropertyValueCache = {};
	
	                    var transformHAPropertyExists = false;
	                    /* If any 3D transform subproperty is at its default value (regardless of unit type), remove it. */
	                    $.each(CSS.Lists.transforms3D, function(i, transformName) {
	                        var defaultValue = /^scale/.test(transformName) ? 1 : 0,
	                            currentValue = Data(element).transformCache[transformName];
	
	                        if (Data(element).transformCache[transformName] !== undefined && new RegExp("^\\(" + defaultValue + "[^.]").test(currentValue)) {
	                            transformHAPropertyExists = true;
	
	                            delete Data(element).transformCache[transformName];
	                        }
	                    });
	
	                    /* Mobile devices have hardware acceleration removed at the end of the animation in order to avoid hogging the GPU's memory. */
	                    if (opts.mobileHA) {
	                        transformHAPropertyExists = true;
	                        delete Data(element).transformCache.translate3d;
	                    }
	
	                    /* Flush the subproperty removals to the DOM. */
	                    if (transformHAPropertyExists) {
	                        CSS.flushTransformCache(element);
	                    }
	
	                    /* Remove the "velocity-animating" indicator class. */
	                    CSS.Values.removeClass(element, "velocity-animating");
	                }
	            }
	
	            /*********************
	               Option: Complete
	            *********************/
	
	            /* Complete is fired once per call (not once per element) and is passed the full raw DOM element set as both its context and its first argument. */
	            /* Note: Callbacks aren't fired when calls are manually stopped (via Velocity("stop"). */
	            if (!isStopped && opts.complete && !opts.loop && (i === callLength - 1)) {
	                /* We throw callbacks in a setTimeout so that thrown errors don't halt the execution of Velocity itself. */
	                try {
	                    opts.complete.call(elements, elements);
	                } catch (error) {
	                    setTimeout(function() { throw error; }, 1);
	                }
	            }
	
	            /**********************
	               Promise Resolving
	            **********************/
	
	            /* Note: Infinite loops don't return promises. */
	            if (resolver && opts.loop !== true) {
	                resolver(elements);
	            }
	
	            /****************************
	               Option: Loop (Infinite)
	            ****************************/
	
	            if (Data(element) && opts.loop === true && !isStopped) {
	                /* If a rotateX/Y/Z property is being animated to 360 deg with loop:true, swap tween start/end values to enable
	                   continuous iterative rotation looping. (Otherise, the element would just rotate back and forth.) */
	                $.each(Data(element).tweensContainer, function(propertyName, tweenContainer) {
	                    if (/^rotate/.test(propertyName) && parseFloat(tweenContainer.endValue) === 360) {
	                        tweenContainer.endValue = 0;
	                        tweenContainer.startValue = 360;
	                    }
	
	                    if (/^backgroundPosition/.test(propertyName) && parseFloat(tweenContainer.endValue) === 100 && tweenContainer.unitType === "%") {
	                        tweenContainer.endValue = 0;
	                        tweenContainer.startValue = 100;
	                    }
	                });
	
	                Velocity(element, "reverse", { loop: true, delay: opts.delay });
	            }
	
	            /***************
	               Dequeueing
	            ***************/
	
	            /* Fire the next call in the queue so long as this call's queue wasn't set to false (to trigger a parallel animation),
	               which would have already caused the next call to fire. Note: Even if the end of the animation queue has been reached,
	               $.dequeue() must still be called in order to completely clear jQuery's animation queue. */
	            if (opts.queue !== false) {
	                $.dequeue(element, opts.queue);
	            }
	        }
	
	        /************************
	           Calls Array Cleanup
	        ************************/
	
	        /* Since this call is complete, set it to false so that the rAF tick skips it. This array is later compacted via compactSparseArray().
	          (For performance reasons, the call is set to false instead of being deleted from the array: http://www.html5rocks.com/en/tutorials/speed/v8/) */
	        Velocity.State.calls[callIndex] = false;
	
	        /* Iterate through the calls array to determine if this was the final in-progress animation.
	           If so, set a flag to end ticking and clear the calls array. */
	        for (var j = 0, callsLength = Velocity.State.calls.length; j < callsLength; j++) {
	            if (Velocity.State.calls[j] !== false) {
	                remainingCallsExist = true;
	
	                break;
	            }
	        }
	
	        if (remainingCallsExist === false) {
	            /* tick() will detect this flag upon its next iteration and subsequently turn itself off. */
	            Velocity.State.isTicking = false;
	
	            /* Clear the calls array so that its length is reset. */
	            delete Velocity.State.calls;
	            Velocity.State.calls = [];
	        }
	    }
	
	    /******************
	        Frameworks
	    ******************/
	
	    /* Both jQuery and Zepto allow their $.fn object to be extended to allow wrapped elements to be subjected to plugin calls.
	       If either framework is loaded, register a "velocity" extension pointing to Velocity's core animate() method.  Velocity
	       also registers itself onto a global container (window.jQuery || window.Zepto || window) so that certain features are
	       accessible beyond just a per-element scope. This master object contains an .animate() method, which is later assigned to $.fn
	       (if jQuery or Zepto are present). Accordingly, Velocity can both act on wrapped DOM elements and stand alone for targeting raw DOM elements. */
	    global.Velocity = Velocity;
	
	    if (global !== window) {
	        /* Assign the element function to Velocity's core animate() method. */
	        global.fn.velocity = animate;
	        /* Assign the object function's defaults to Velocity's global defaults object. */
	        global.fn.velocity.defaults = Velocity.defaults;
	    }
	
	    /***********************
	       Packaged Redirects
	    ***********************/
	
	    /* slideUp, slideDown */
	    $.each([ "Down", "Up" ], function(i, direction) {
	        Velocity.Redirects["slide" + direction] = function (element, options, elementsIndex, elementsSize, elements, promiseData) {
	            var opts = $.extend({}, options),
	                begin = opts.begin,
	                complete = opts.complete,
	                computedValues = { height: "", marginTop: "", marginBottom: "", paddingTop: "", paddingBottom: "" },
	                inlineValues = {};
	
	            if (opts.display === undefined) {
	                /* Show the element before slideDown begins and hide the element after slideUp completes. */
	                /* Note: Inline elements cannot have dimensions animated, so they're reverted to inline-block. */
	                opts.display = (direction === "Down" ? (Velocity.CSS.Values.getDisplayType(element) === "inline" ? "inline-block" : "block") : "none");
	            }
	
	            opts.begin = function() {
	                /* If the user passed in a begin callback, fire it now. */
	                begin && begin.call(elements, elements);
	
	                /* Cache the elements' original vertical dimensional property values so that we can animate back to them. */
	                for (var property in computedValues) {
	                    inlineValues[property] = element.style[property];
	
	                    /* For slideDown, use forcefeeding to animate all vertical properties from 0. For slideUp,
	                       use forcefeeding to start from computed values and animate down to 0. */
	                    var propertyValue = Velocity.CSS.getPropertyValue(element, property);
	                    computedValues[property] = (direction === "Down") ? [ propertyValue, 0 ] : [ 0, propertyValue ];
	                }
	
	                /* Force vertical overflow content to clip so that sliding works as expected. */
	                inlineValues.overflow = element.style.overflow;
	                element.style.overflow = "hidden";
	            }
	
	            opts.complete = function() {
	                /* Reset element to its pre-slide inline values once its slide animation is complete. */
	                for (var property in inlineValues) {
	                    element.style[property] = inlineValues[property];
	                }
	
	                /* If the user passed in a complete callback, fire it now. */
	                complete && complete.call(elements, elements);
	                promiseData && promiseData.resolver(elements);
	            };
	
	            Velocity(element, computedValues, opts);
	        };
	    });
	
	    /* fadeIn, fadeOut */
	    $.each([ "In", "Out" ], function(i, direction) {
	        Velocity.Redirects["fade" + direction] = function (element, options, elementsIndex, elementsSize, elements, promiseData) {
	            var opts = $.extend({}, options),
	                propertiesMap = { opacity: (direction === "In") ? 1 : 0 },
	                originalComplete = opts.complete;
	
	            /* Since redirects are triggered individually for each element in the animated set, avoid repeatedly triggering
	               callbacks by firing them only when the final element has been reached. */
	            if (elementsIndex !== elementsSize - 1) {
	                opts.complete = opts.begin = null;
	            } else {
	                opts.complete = function() {
	                    if (originalComplete) {
	                        originalComplete.call(elements, elements);
	                    }
	
	                    promiseData && promiseData.resolver(elements);
	                }
	            }
	
	            /* If a display was passed in, use it. Otherwise, default to "none" for fadeOut or the element-specific default for fadeIn. */
	            /* Note: We allow users to pass in "null" to skip display setting altogether. */
	            if (opts.display === undefined) {
	                opts.display = (direction === "In" ? "auto" : "none");
	            }
	
	            Velocity(this, propertiesMap, opts);
	        };
	    });
	
	    return Velocity;
	}((window.jQuery || window.Zepto || window), window, document);
	}));
	
	/******************
	   Known Issues
	******************/
	
	/* The CSS spec mandates that the translateX/Y/Z transforms are %-relative to the element itself -- not its parent.
	Velocity, however, doesn't make this distinction. Thus, converting to or from the % unit with these subproperties
	will produce an inaccurate conversion value. The same issue exists with the cx/cy attributes of SVG circles and ellipses. */

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isIE9 = memoize(function() {
			return /msie 9\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0;
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isIE9();
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function createStyleElement() {
		var styleElement = document.createElement("style");
		var head = getHeadElement();
		styleElement.type = "text/css";
		head.appendChild(styleElement);
		return styleElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement());
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else {
			styleElement = createStyleElement();
			update = applyToTag.bind(null, styleElement);
			remove = function () {
				styleElement.parentNode.removeChild(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	function replaceText(source, id, replacement) {
		var boundaries = ["/** >>" + id + " **/", "/** " + id + "<< **/"];
		var start = source.lastIndexOf(boundaries[0]);
		var wrappedReplacement = replacement
			? (boundaries[0] + replacement + boundaries[1])
			: "";
		if (source.lastIndexOf(boundaries[0]) >= 0) {
			var end = source.lastIndexOf(boundaries[1]) + boundaries[1].length;
			return source.slice(0, start) + wrappedReplacement + source.slice(end);
		} else {
			return source + wrappedReplacement;
		}
	}
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(styleElement.styleSheet.cssText, index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap && typeof btoa === "function") {
			try {
				css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(JSON.stringify(sourceMap)) + " */";
				css = "@import url(\"data:text/css;base64," + btoa(css) + "\")";
			} catch(e) {}
		}
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Kefir.js v1.0.0
	 *  https://github.com/pozadi/kefir
	 */
	;(function(global){
	  "use strict";
	
	  var Kefir = {};
	
	
	function and() {
	  for (var i = 0; i < arguments.length; i++) {
	    if (!arguments[i]) {
	      return arguments[i];
	    }
	  }
	  return arguments[i - 1];
	}
	
	function or() {
	  for (var i = 0; i < arguments.length; i++) {
	    if (arguments[i]) {
	      return arguments[i];
	    }
	  }
	  return arguments[i - 1];
	}
	
	function not(x) {
	  return !x;
	}
	
	function concat(a, b) {
	  var result, length, i, j;
	  if (a.length === 0) {  return b  }
	  if (b.length === 0) {  return a  }
	  j = 0;
	  result = new Array(a.length + b.length);
	  length = a.length;
	  for (i = 0; i < length; i++, j++) {
	    result[j] = a[i];
	  }
	  length = b.length;
	  for (i = 0; i < length; i++, j++) {
	    result[j] = b[i];
	  }
	  return result;
	}
	
	function find(arr, value) {
	  var length = arr.length
	    , i;
	  for (i = 0; i < length; i++) {
	    if (arr[i] === value) {  return i  }
	  }
	  return -1;
	}
	
	function findByPred(arr, pred) {
	  var length = arr.length
	    , i;
	  for (i = 0; i < length; i++) {
	    if (pred(arr[i])) {  return i  }
	  }
	  return -1;
	}
	
	function cloneArray(input) {
	  var length = input.length
	    , result = new Array(length)
	    , i;
	  for (i = 0; i < length; i++) {
	    result[i] = input[i];
	  }
	  return result;
	}
	
	function remove(input, index) {
	  var length = input.length
	    , result, i, j;
	  if (index >= 0 && index < length) {
	    if (length === 1) {
	      return [];
	    } else {
	      result = new Array(length - 1);
	      for (i = 0, j = 0; i < length; i++) {
	        if (i !== index) {
	          result[j] = input[i];
	          j++;
	        }
	      }
	      return result;
	    }
	  } else {
	    return input;
	  }
	}
	
	function removeByPred(input, pred) {
	  return remove(input, findByPred(input, pred));
	}
	
	function map(input, fn) {
	  var length = input.length
	    , result = new Array(length)
	    , i;
	  for (i = 0; i < length; i++) {
	    result[i] = fn(input[i]);
	  }
	  return result;
	}
	
	function forEach(arr, fn) {
	  var length = arr.length
	    , i;
	  for (i = 0; i < length; i++) {  fn(arr[i])  }
	}
	
	function fillArray(arr, value) {
	  var length = arr.length
	    , i;
	  for (i = 0; i < length; i++) {
	    arr[i] = value;
	  }
	}
	
	function contains(arr, value) {
	  return find(arr, value) !== -1;
	}
	
	function rest(arr, start, onEmpty) {
	  if (arr.length > start) {
	    return Array.prototype.slice.call(arr, start);
	  }
	  return onEmpty;
	}
	
	function slide(cur, next, max) {
	  var length = Math.min(max, cur.length + 1),
	      offset = cur.length - length + 1,
	      result = new Array(length),
	      i;
	  for (i = offset; i < length; i++) {
	    result[i - offset] = cur[i];
	  }
	  result[length - 1] = next;
	  return result;
	}
	
	function isEqualArrays(a, b) {
	  var length, i;
	  if (a == null && b == null) {
	    return true;
	  }
	  if (a == null || b == null) {
	    return false;
	  }
	  if (a.length !== b.length) {
	    return false;
	  }
	  for (i = 0, length = a.length; i < length; i++) {
	    if (a[i] !== b[i]) {
	      return false;
	    }
	  }
	  return true;
	}
	
	function spread(fn, length) {
	  switch(length) {
	    case 0:  return function(a) {  return fn()  };
	    case 1:  return function(a) {  return fn(a[0])  };
	    case 2:  return function(a) {  return fn(a[0], a[1])  };
	    case 3:  return function(a) {  return fn(a[0], a[1], a[2])  };
	    case 4:  return function(a) {  return fn(a[0], a[1], a[2], a[3])  };
	    default: return function(a) {  return fn.apply(null, a)  };
	  }
	}
	
	function apply(fn, c, a) {
	  var aLength = a ? a.length : 0;
	  if (c == null) {
	    switch (aLength) {
	      case 0:  return fn();
	      case 1:  return fn(a[0]);
	      case 2:  return fn(a[0], a[1]);
	      case 3:  return fn(a[0], a[1], a[2]);
	      case 4:  return fn(a[0], a[1], a[2], a[3]);
	      default: return fn.apply(null, a);
	    }
	  } else {
	    switch (aLength) {
	      case 0:  return fn.call(c);
	      default: return fn.apply(c, a);
	    }
	  }
	}
	
	function get(map, key, notFound) {
	  if (map && key in map) {
	    return map[key];
	  } else {
	    return notFound;
	  }
	}
	
	function own(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	function createObj(proto) {
	  var F = function() {};
	  F.prototype = proto;
	  return new F();
	}
	
	function extend(target /*, mixin1, mixin2...*/) {
	  var length = arguments.length
	    , i, prop;
	  for (i = 1; i < length; i++) {
	    for (prop in arguments[i]) {
	      target[prop] = arguments[i][prop];
	    }
	  }
	  return target;
	}
	
	function inherit(Child, Parent /*, mixin1, mixin2...*/) {
	  var length = arguments.length
	    , i;
	  Child.prototype = createObj(Parent.prototype);
	  Child.prototype.constructor = Child;
	  for (i = 2; i < length; i++) {
	    extend(Child.prototype, arguments[i]);
	  }
	  return Child;
	}
	
	var NOTHING = ['<nothing>'];
	var END = 'end';
	var VALUE = 'value';
	var ERROR = 'error';
	var ANY = 'any';
	
	function noop() {}
	
	function id(x) {
	  return x;
	}
	
	function strictEqual(a, b) {
	  return a === b;
	}
	
	function defaultDiff(a, b) {
	  return [a, b]
	}
	
	var now = Date.now ?
	  function() { return Date.now() } :
	  function() { return new Date().getTime() };
	
	function isFn(fn) {
	  return typeof fn === 'function';
	}
	
	function isUndefined(x) {
	  return typeof x === 'undefined';
	}
	
	function isArrayLike(xs) {
	  return isArray(xs) || isArguments(xs);
	}
	
	var isArray = Array.isArray || function(xs) {
	  return Object.prototype.toString.call(xs) === '[object Array]';
	}
	
	var isArguments = function(xs) {
	  return Object.prototype.toString.call(xs) === '[object Arguments]';
	}
	
	// For IE
	if (!isArguments(arguments)) {
	  isArguments = function(obj) {
	    return !!(obj && own(obj, 'callee'));
	  }
	}
	
	function withInterval(name, mixin) {
	
	  function AnonymousStream(wait, args) {
	    Stream.call(this);
	    this._wait = wait;
	    this._intervalId = null;
	    var $ = this;
	    this._$onTick = function() {  $._onTick()  }
	    this._init(args);
	  }
	
	  inherit(AnonymousStream, Stream, {
	
	    _name: name,
	
	    _init: function(args) {},
	    _free: function() {},
	
	    _onTick: function() {},
	
	    _onActivation: function() {
	      this._intervalId = setInterval(this._$onTick, this._wait);
	    },
	    _onDeactivation: function() {
	      if (this._intervalId !== null) {
	        clearInterval(this._intervalId);
	        this._intervalId = null;
	      }
	    },
	
	    _clear: function() {
	      Stream.prototype._clear.call(this);
	      this._$onTick = null;
	      this._free();
	    }
	
	  }, mixin);
	
	  Kefir[name] = function(wait) {
	    return new AnonymousStream(wait, rest(arguments, 1, []));
	  }
	}
	
	function withOneSource(name, mixin, options) {
	
	
	  options = extend({
	    streamMethod: function(StreamClass, PropertyClass) {
	      return function() {  return new StreamClass(this, arguments)  }
	    },
	    propertyMethod: function(StreamClass, PropertyClass) {
	      return function() {  return new PropertyClass(this, arguments)  }
	    }
	  }, options || {});
	
	
	
	  mixin = extend({
	    _init: function(args) {},
	    _free: function() {},
	
	    _handleValue: function(x, isCurrent) {  this._send(VALUE, x, isCurrent)  },
	    _handleError: function(x, isCurrent) {  this._send(ERROR, x, isCurrent)  },
	    _handleEnd: function(__, isCurrent) {  this._send(END, null, isCurrent)  },
	
	    _handleAny: function(event) {
	      switch (event.type) {
	        case VALUE: this._handleValue(event.value, event.current); break;
	        case ERROR: this._handleError(event.value, event.current); break;
	        case END: this._handleEnd(event.value, event.current); break;
	      }
	    },
	
	    _onActivation: function() {
	      this._source.onAny(this._$handleAny);
	    },
	    _onDeactivation: function() {
	      this._source.offAny(this._$handleAny);
	    }
	  }, mixin || {});
	
	
	
	  function buildClass(BaseClass) {
	    function AnonymousObservable(source, args) {
	      BaseClass.call(this);
	      this._source = source;
	      this._name = source._name + '.' + name;
	      this._init(args);
	      var $ = this;
	      this._$handleAny = function(event) {  $._handleAny(event)  }
	    }
	
	    inherit(AnonymousObservable, BaseClass, {
	      _clear: function() {
	        BaseClass.prototype._clear.call(this);
	        this._source = null;
	        this._$handleAny = null;
	        this._free();
	      }
	    }, mixin);
	
	    return AnonymousObservable;
	  }
	
	
	  var AnonymousStream = buildClass(Stream);
	  var AnonymousProperty = buildClass(Property);
	
	  if (options.streamMethod) {
	    Stream.prototype[name] = options.streamMethod(AnonymousStream, AnonymousProperty);
	  }
	
	  if (options.propertyMethod) {
	    Property.prototype[name] = options.propertyMethod(AnonymousStream, AnonymousProperty);
	  }
	
	}
	
	function withTwoSources(name, mixin /*, options*/) {
	
	  mixin = extend({
	    _init: function(args) {},
	    _free: function() {},
	
	    _handlePrimaryValue: function(x, isCurrent) {  this._send(VALUE, x, isCurrent)  },
	    _handlePrimaryError: function(x, isCurrent) {  this._send(ERROR, x, isCurrent)  },
	    _handlePrimaryEnd: function(__, isCurrent) {  this._send(END, null, isCurrent)  },
	
	    _handleSecondaryValue: function(x, isCurrent) {  this._lastSecondary = x  },
	    _handleSecondaryError: function(x, isCurrent) {  this._send(ERROR, x, isCurrent)  },
	    _handleSecondaryEnd: function(__, isCurrent) {},
	
	    _handlePrimaryAny: function(event) {
	      switch (event.type) {
	        case VALUE:
	          this._handlePrimaryValue(event.value, event.current);
	          break;
	        case ERROR:
	          this._handlePrimaryError(event.value, event.current);
	          break;
	        case END:
	          this._handlePrimaryEnd(event.value, event.current);
	          break;
	      }
	    },
	    _handleSecondaryAny: function(event) {
	      switch (event.type) {
	        case VALUE:
	          this._handleSecondaryValue(event.value, event.current);
	          break;
	        case ERROR:
	          this._handleSecondaryError(event.value, event.current);
	          break;
	        case END:
	          this._handleSecondaryEnd(event.value, event.current);
	          this._removeSecondary();
	          break;
	      }
	    },
	
	    _removeSecondary: function() {
	      if (this._secondary !== null) {
	        this._secondary.offAny(this._$handleSecondaryAny);
	        this._$handleSecondaryAny = null;
	        this._secondary = null;
	      }
	    },
	
	    _onActivation: function() {
	      if (this._secondary !== null) {
	        this._secondary.onAny(this._$handleSecondaryAny);
	      }
	      if (this._alive) {
	        this._primary.onAny(this._$handlePrimaryAny);
	      }
	    },
	    _onDeactivation: function() {
	      if (this._secondary !== null) {
	        this._secondary.offAny(this._$handleSecondaryAny);
	      }
	      this._primary.offAny(this._$handlePrimaryAny);
	    }
	  }, mixin || {});
	
	
	
	  function buildClass(BaseClass) {
	    function AnonymousObservable(primary, secondary, args) {
	      BaseClass.call(this);
	      this._primary = primary;
	      this._secondary = secondary;
	      this._name = primary._name + '.' + name;
	      this._lastSecondary = NOTHING;
	      var $ = this;
	      this._$handleSecondaryAny = function(event) {  $._handleSecondaryAny(event)  }
	      this._$handlePrimaryAny = function(event) {  $._handlePrimaryAny(event)  }
	      this._init(args);
	    }
	
	    inherit(AnonymousObservable, BaseClass, {
	      _clear: function() {
	        BaseClass.prototype._clear.call(this);
	        this._primary = null;
	        this._secondary = null;
	        this._lastSecondary = null;
	        this._$handleSecondaryAny = null;
	        this._$handlePrimaryAny = null;
	        this._free();
	      }
	    }, mixin);
	
	    return AnonymousObservable;
	  }
	
	
	  var AnonymousStream = buildClass(Stream);
	  var AnonymousProperty = buildClass(Property);
	
	  Stream.prototype[name] = function(secondary) {
	    return new AnonymousStream(this, secondary, rest(arguments, 1, []));
	  }
	
	  Property.prototype[name] = function(secondary) {
	    return new AnonymousProperty(this, secondary, rest(arguments, 1, []));
	  }
	
	}
	
	// Subscribers
	
	function Subscribers() {
	  this._items = [];
	}
	
	extend(Subscribers, {
	  callOne: function(fnData, event) {
	    if (fnData.type === ANY) {
	      fnData.fn(event);
	    } else if (fnData.type === event.type) {
	      if (fnData.type === VALUE || fnData.type === ERROR) {
	        fnData.fn(event.value);
	      } else {
	        fnData.fn();
	      }
	    }
	  },
	  callOnce: function(type, fn, event) {
	    if (type === ANY) {
	      fn(event);
	    } else if (type === event.type) {
	      if (type === VALUE || type === ERROR) {
	        fn(event.value);
	      } else {
	        fn();
	      }
	    }
	  }
	});
	
	
	extend(Subscribers.prototype, {
	  add: function(type, fn, _key) {
	    this._items = concat(this._items, [{
	      type: type,
	      fn: fn,
	      key: _key || null
	    }]);
	  },
	  remove: function(type, fn, _key) {
	    var pred = isArray(_key) ?
	      function(fnData) {return fnData.type === type && isEqualArrays(fnData.key, _key)} :
	      function(fnData) {return fnData.type === type && fnData.fn === fn};
	    this._items = removeByPred(this._items, pred);
	  },
	  callAll: function(event) {
	    var items = this._items;
	    for (var i = 0; i < items.length; i++) {
	      Subscribers.callOne(items[i], event);
	    }
	  },
	  isEmpty: function() {
	    return this._items.length === 0;
	  }
	});
	
	
	
	
	
	// Events
	
	function Event(type, value, current) {
	  return {type: type, value: value, current: !!current};
	}
	
	var CURRENT_END = Event(END, undefined, true);
	
	
	
	
	
	// Observable
	
	function Observable() {
	  this._subscribers = new Subscribers();
	  this._active = false;
	  this._alive = true;
	}
	Kefir.Observable = Observable;
	
	extend(Observable.prototype, {
	
	  _name: 'observable',
	
	  _onActivation: function() {},
	  _onDeactivation: function() {},
	
	  _setActive: function(active) {
	    if (this._active !== active) {
	      this._active = active;
	      if (active) {
	        this._onActivation();
	      } else {
	        this._onDeactivation();
	      }
	    }
	  },
	
	  _clear: function() {
	    this._setActive(false);
	    this._alive = false;
	    this._subscribers = null;
	  },
	
	  _send: function(type, x, isCurrent) {
	    if (this._alive) {
	      this._subscribers.callAll(Event(type, x, isCurrent));
	      if (type === END) {  this._clear()  }
	    }
	  },
	
	  _on: function(type, fn, _key) {
	    if (this._alive) {
	      this._subscribers.add(type, fn, _key);
	      this._setActive(true);
	    } else {
	      Subscribers.callOnce(type, fn, CURRENT_END);
	    }
	    return this;
	  },
	
	  _off: function(type, fn, _key) {
	    if (this._alive) {
	      this._subscribers.remove(type, fn, _key);
	      if (this._subscribers.isEmpty()) {
	        this._setActive(false);
	      }
	    }
	    return this;
	  },
	
	  onValue:  function(fn, _key) {  return this._on(VALUE, fn, _key)   },
	  onError:  function(fn, _key) {  return this._on(ERROR, fn, _key)   },
	  onEnd:    function(fn, _key) {  return this._on(END, fn, _key)     },
	  onAny:    function(fn, _key) {  return this._on(ANY, fn, _key)     },
	
	  offValue: function(fn, _key) {  return this._off(VALUE, fn, _key)  },
	  offError: function(fn, _key) {  return this._off(ERROR, fn, _key)  },
	  offEnd:   function(fn, _key) {  return this._off(END, fn, _key)    },
	  offAny:   function(fn, _key) {  return this._off(ANY, fn, _key)    }
	
	});
	
	
	// extend() can't handle `toString` in IE8
	Observable.prototype.toString = function() {  return '[' + this._name + ']'  };
	
	
	
	
	
	
	
	
	
	// Stream
	
	function Stream() {
	  Observable.call(this);
	}
	Kefir.Stream = Stream;
	
	inherit(Stream, Observable, {
	
	  _name: 'stream'
	
	});
	
	
	
	
	
	
	
	// Property
	
	function Property() {
	  Observable.call(this);
	  this._current = NOTHING;
	  this._currentError = NOTHING;
	}
	Kefir.Property = Property;
	
	inherit(Property, Observable, {
	
	  _name: 'property',
	
	  _send: function(type, x, isCurrent) {
	    if (this._alive) {
	      if (!isCurrent) {
	        this._subscribers.callAll(Event(type, x));
	      }
	      if (type === VALUE) {  this._current = x  }
	      if (type === ERROR) {  this._currentError = x  }
	      if (type === END) {  this._clear()  }
	    }
	  },
	
	  _on: function(type, fn, _key) {
	    if (this._alive) {
	      this._subscribers.add(type, fn, _key);
	      this._setActive(true);
	    }
	    if (this._current !== NOTHING) {
	      Subscribers.callOnce(type, fn, Event(VALUE, this._current, true));
	    }
	    if (this._currentError !== NOTHING) {
	      Subscribers.callOnce(type, fn, Event(ERROR, this._currentError, true));
	    }
	    if (!this._alive) {
	      Subscribers.callOnce(type, fn, CURRENT_END);
	    }
	    return this;
	  }
	
	});
	
	
	
	
	
	
	// Log
	
	Observable.prototype.log = function(name) {
	  name = name || this.toString();
	  this.onAny(function(event) {
	    var typeStr = '<' + event.type + (event.current ? ':current' : '') + '>';
	    if (event.type === VALUE || event.type === ERROR) {
	      console.log(name, typeStr, event.value);
	    } else {
	      console.log(name, typeStr);
	    }
	  }, ['__logKey__', this, name]);
	  return this;
	}
	
	Observable.prototype.offLog = function(name) {
	  name = name || this.toString();
	  this.offAny(null, ['__logKey__', this, name]);
	  return this;
	}
	
	
	
	// Kefir.withInterval()
	
	withInterval('withInterval', {
	  _init: function(args) {
	    this._fn = args[0];
	    var $ = this;
	    this._emitter = {
	      emit: function(x) {  $._send(VALUE, x)  },
	      error: function(x) {  $._send(ERROR, x)  },
	      end: function() {  $._send(END)  }
	    }
	  },
	  _free: function() {
	    this._fn = null;
	    this._emitter = null;
	  },
	  _onTick: function() {
	    this._fn(this._emitter);
	  }
	});
	
	
	
	
	
	// Kefir.fromPoll()
	
	withInterval('fromPoll', {
	  _init: function(args) {
	    this._fn = args[0];
	  },
	  _free: function() {
	    this._fn = null;
	  },
	  _onTick: function() {
	    this._send(VALUE, this._fn());
	  }
	});
	
	
	
	
	
	// Kefir.interval()
	
	withInterval('interval', {
	  _init: function(args) {
	    this._x = args[0];
	  },
	  _free: function() {
	    this._x = null;
	  },
	  _onTick: function() {
	    this._send(VALUE, this._x);
	  }
	});
	
	
	
	
	// Kefir.sequentially()
	
	withInterval('sequentially', {
	  _init: function(args) {
	    this._xs = cloneArray(args[0]);
	    if (this._xs.length === 0) {
	      this._send(END)
	    }
	  },
	  _free: function() {
	    this._xs = null;
	  },
	  _onTick: function() {
	    switch (this._xs.length) {
	      case 1:
	        this._send(VALUE, this._xs[0]);
	        this._send(END);
	        break;
	      default:
	        this._send(VALUE, this._xs.shift());
	    }
	  }
	});
	
	
	
	
	// Kefir.repeatedly()
	
	withInterval('repeatedly', {
	  _init: function(args) {
	    this._xs = cloneArray(args[0]);
	    this._i = -1;
	  },
	  _onTick: function() {
	    if (this._xs.length > 0) {
	      this._i = (this._i + 1) % this._xs.length;
	      this._send(VALUE, this._xs[this._i]);
	    }
	  }
	});
	
	
	
	
	
	// Kefir.later()
	
	withInterval('later', {
	  _init: function(args) {
	    this._x = args[0];
	  },
	  _free: function() {
	    this._x = null;
	  },
	  _onTick: function() {
	    this._send(VALUE, this._x);
	    this._send(END);
	  }
	});
	
	function _AbstractPool(options) {
	  Stream.call(this);
	
	  this._queueLim = get(options, 'queueLim', 0);
	  this._concurLim = get(options, 'concurLim', -1);
	  this._drop = get(options, 'drop', 'new');
	  if (this._concurLim === 0) {
	    throw new Error('options.concurLim can\'t be 0');
	  }
	
	  var $ = this;
	  this._$handleSubAny = function(event) {  $._handleSubAny(event)  };
	
	  this._queue = [];
	  this._curSources = [];
	  this._activating = false;
	}
	
	inherit(_AbstractPool, Stream, {
	
	  _name: 'abstractPool',
	
	  _add: function(obj, toObs) {
	    toObs = toObs || id;
	    if (this._concurLim === -1 || this._curSources.length < this._concurLim) {
	      this._addToCur(toObs(obj));
	    } else {
	      if (this._queueLim === -1 || this._queue.length < this._queueLim) {
	        this._addToQueue(toObs(obj));
	      } else if (this._drop === 'old') {
	        this._removeOldest();
	        this._add(toObs(obj));
	      }
	    }
	  },
	  _addAll: function(obss) {
	    var $ = this;
	    forEach(obss, function(obs) {  $._add(obs)  });
	  },
	  _remove: function(obs) {
	    if (this._removeCur(obs) === -1) {
	      this._removeQueue(obs);
	    }
	  },
	
	  _addToQueue: function(obs) {
	    this._queue = concat(this._queue, [obs]);
	  },
	  _addToCur: function(obs) {
	    this._curSources = concat(this._curSources, [obs]);
	    if (this._active) {  this._subscribe(obs)  }
	  },
	  _subscribe: function(obs) {
	    var $ = this;
	    obs.onAny(this._$handleSubAny);
	    obs.onEnd(function() {  $._removeCur(obs)  }, [this, obs]);
	  },
	  _unsubscribe: function(obs) {
	    obs.offAny(this._$handleSubAny);
	    obs.offEnd(null, [this, obs]);
	  },
	  _handleSubAny: function(event) {
	    if (event.type === VALUE || event.type === ERROR) {
	      this._send(event.type, event.value, event.current && this._activating);
	    }
	  },
	
	  _removeQueue: function(obs) {
	    var index = find(this._queue, obs);
	    this._queue = remove(this._queue, index);
	    return index;
	  },
	  _removeCur: function(obs) {
	    if (this._active) {  this._unsubscribe(obs)  }
	    var index = find(this._curSources, obs);
	    this._curSources = remove(this._curSources, index);
	    if (index !== -1) {
	      if (this._queue.length !== 0) {
	        this._pullQueue();
	      } else if (this._curSources.length === 0) {
	        this._onEmpty();
	      }
	    }
	    return index;
	  },
	  _removeOldest: function() {
	    this._removeCur(this._curSources[0]);
	  },
	
	  _pullQueue: function() {
	    if (this._queue.length !== 0) {
	      this._queue = cloneArray(this._queue);
	      this._addToCur(this._queue.shift());
	    }
	  },
	
	  _onActivation: function() {
	    var sources = this._curSources
	      , i;
	    this._activating = true;
	    for (i = 0; i < sources.length; i++) {  this._subscribe(sources[i])  }
	    this._activating = false;
	  },
	  _onDeactivation: function() {
	    var sources = this._curSources
	      , i;
	    for (i = 0; i < sources.length; i++) {  this._unsubscribe(sources[i])  }
	  },
	
	  _isEmpty: function() {  return this._curSources.length === 0  },
	  _onEmpty: function() {},
	
	  _clear: function() {
	    Stream.prototype._clear.call(this);
	    this._queue = null;
	    this._curSources = null;
	    this._$handleSubAny = null;
	  }
	
	});
	
	
	
	
	
	// .merge()
	
	var MergeLike = {
	  _onEmpty: function() {
	    if (this._initialised) {  this._send(END, null, this._activating)  }
	  }
	};
	
	function Merge(sources) {
	  _AbstractPool.call(this);
	  if (sources.length === 0) {  this._send(END)  } else {  this._addAll(sources)  }
	  this._initialised = true;
	}
	
	inherit(Merge, _AbstractPool, extend({_name: 'merge'}, MergeLike));
	
	Kefir.merge = function(obss) {
	  return new Merge(obss);
	}
	
	Observable.prototype.merge = function(other) {
	  return Kefir.merge([this, other]);
	}
	
	
	
	
	// .concat()
	
	function Concat(sources) {
	  _AbstractPool.call(this, {concurLim: 1, queueLim: -1});
	  if (sources.length === 0) {  this._send(END)  } else {  this._addAll(sources)  }
	  this._initialised = true;
	}
	
	inherit(Concat, _AbstractPool, extend({_name: 'concat'}, MergeLike));
	
	Kefir.concat = function(obss) {
	  return new Concat(obss);
	}
	
	Observable.prototype.concat = function(other) {
	  return Kefir.concat([this, other]);
	}
	
	
	
	
	
	
	// .pool()
	
	function Pool() {
	  _AbstractPool.call(this);
	}
	
	inherit(Pool, _AbstractPool, {
	
	  _name: 'pool',
	
	  plug: function(obs) {
	    this._add(obs);
	    return this;
	  },
	  unplug: function(obs) {
	    this._remove(obs);
	    return this;
	  }
	
	});
	
	Kefir.pool = function() {
	  return new Pool();
	}
	
	
	
	
	
	// .bus()
	
	function Bus() {
	  _AbstractPool.call(this);
	}
	
	inherit(Bus, _AbstractPool, {
	
	  _name: 'bus',
	
	  plug: function(obs) {
	    this._add(obs);
	    return this;
	  },
	  unplug: function(obs) {
	    this._remove(obs);
	    return this;
	  },
	
	  emit: function(x) {
	    this._send(VALUE, x);
	    return this;
	  },
	  error: function(x) {
	    this._send(ERROR, x);
	    return this;
	  },
	  end: function() {
	    this._send(END);
	    return this;
	  }
	
	});
	
	Kefir.bus = function() {
	  return new Bus();
	}
	
	
	
	
	
	// .flatMap()
	
	function FlatMap(source, fn, options) {
	  _AbstractPool.call(this, options);
	  this._source = source;
	  this._fn = fn || id;
	  this._mainEnded = false;
	  this._lastCurrent = null;
	
	  var $ = this;
	  this._$handleMainSource = function(event) {  $._handleMainSource(event)  };
	}
	
	inherit(FlatMap, _AbstractPool, {
	
	  _onActivation: function() {
	    _AbstractPool.prototype._onActivation.call(this);
	    if (this._active) {
	      this._activating = true;
	      this._source.onAny(this._$handleMainSource);
	      this._activating = false;
	    }
	  },
	  _onDeactivation: function() {
	    _AbstractPool.prototype._onDeactivation.call(this);
	    this._source.offAny(this._$handleMainSource);
	  },
	
	  _handleMainSource: function(event) {
	    if (event.type === VALUE) {
	      if (!event.current || this._lastCurrent !== event.value) {
	        this._add(event.value, this._fn);
	      }
	      this._lastCurrent = event.value;
	    }
	    if (event.type === ERROR) {
	      this._send(ERROR, event.value, event.current);
	    }
	    if (event.type === END) {
	      if (this._isEmpty()) {
	        this._send(END, null, event.current);
	      } else {
	        this._mainEnded = true;
	      }
	    }
	  },
	
	  _onEmpty: function() {
	    if (this._mainEnded) {  this._send(END)  }
	  },
	
	  _clear: function() {
	    _AbstractPool.prototype._clear.call(this);
	    this._source = null;
	    this._lastCurrent = null;
	    this._$handleMainSource = null;
	  }
	
	});
	
	Observable.prototype.flatMap = function(fn) {
	  return new FlatMap(this, fn)
	    .setName(this, 'flatMap');
	}
	
	Observable.prototype.flatMapLatest = function(fn) {
	  return new FlatMap(this, fn, {concurLim: 1, drop: 'old'})
	    .setName(this, 'flatMapLatest');
	}
	
	Observable.prototype.flatMapFirst = function(fn) {
	  return new FlatMap(this, fn, {concurLim: 1})
	    .setName(this, 'flatMapFirst');
	}
	
	Observable.prototype.flatMapConcat = function(fn) {
	  return new FlatMap(this, fn, {queueLim: -1, concurLim: 1})
	    .setName(this, 'flatMapConcat');
	}
	
	Observable.prototype.flatMapConcurLimit = function(fn, limit) {
	  var result;
	  if (limit === 0) {
	    result = Kefir.never();
	  } else {
	    if (limit < 0) {  limit = -1  }
	    result = new FlatMap(this, fn, {queueLim: -1, concurLim: limit});
	  }
	  return result.setName(this, 'flatMapConcurLimit');
	}
	
	
	
	
	
	
	// .zip()
	
	function Zip(sources, combinator) {
	  Stream.call(this);
	  if (sources.length === 0) {
	    this._send(END);
	  } else {
	    this._buffers = map(sources, function(source) {
	      return isArray(source) ? cloneArray(source) : [];
	    });
	    this._sources = map(sources, function(source) {
	      return isArray(source) ? Kefir.never() : source;
	    });
	    this._combinator = combinator ? spread(combinator, this._sources.length) : id;
	    this._aliveCount = 0;
	  }
	}
	
	
	inherit(Zip, Stream, {
	
	  _name: 'zip',
	
	  _onActivation: function() {
	    var i, length = this._sources.length;
	    this._drainArrays();
	    this._aliveCount = length;
	    for (i = 0; i < length; i++) {
	      this._sources[i].onAny(this._bindHandleAny(i), [this, i]);
	    }
	  },
	
	  _onDeactivation: function() {
	    for (var i = 0; i < this._sources.length; i++) {
	      this._sources[i].offAny(null, [this, i]);
	    }
	  },
	
	  _emit: function(isCurrent) {
	    var values = new Array(this._buffers.length);
	    for (var i = 0; i < this._buffers.length; i++) {
	      values[i] = this._buffers[i].shift();
	    }
	    this._send(VALUE, this._combinator(values), isCurrent);
	  },
	
	  _isFull: function() {
	    for (var i = 0; i < this._buffers.length; i++) {
	      if (this._buffers[i].length === 0) {
	        return false;
	      }
	    }
	    return true;
	  },
	
	  _emitIfFull: function(isCurrent) {
	    if (this._isFull()) {
	      this._emit(isCurrent);
	    }
	  },
	
	  _drainArrays: function() {
	    while (this._isFull()) {
	      this._emit(true);
	    }
	  },
	
	  _bindHandleAny: function(i) {
	    var $ = this;
	    return function(event) {  $._handleAny(i, event)  };
	  },
	
	  _handleAny: function(i, event) {
	    if (event.type === VALUE) {
	      this._buffers[i].push(event.value);
	      this._emitIfFull(event.current);
	    }
	    if (event.type === ERROR) {
	      this._send(ERROR, event.value, event.current);
	    }
	    if (event.type === END) {
	      this._aliveCount--;
	      if (this._aliveCount === 0) {
	        this._send(END, null, event.current);
	      }
	    }
	  },
	
	  _clear: function() {
	    Stream.prototype._clear.call(this);
	    this._sources = null;
	    this._buffers = null;
	    this._combinator = null;
	  }
	
	});
	
	Kefir.zip = function(sources, combinator) {
	  return new Zip(sources, combinator);
	}
	
	Observable.prototype.zip = function(other, combinator) {
	  return new Zip([this, other], combinator);
	}
	
	
	
	
	
	
	// .sampledBy()
	
	function SampledBy(passive, active, combinator) {
	  Stream.call(this);
	  if (active.length === 0) {
	    this._send(END);
	  } else {
	    this._passiveCount = passive.length;
	    this._sources = concat(passive, active);
	    this._combinator = combinator ? spread(combinator, this._sources.length) : id;
	    this._aliveCount = 0;
	    this._currents = new Array(this._sources.length);
	    fillArray(this._currents, NOTHING);
	    this._activating = false;
	    this._emitAfterActivation = false;
	    this._endAfterActivation = false;
	  }
	}
	
	
	inherit(SampledBy, Stream, {
	
	  _name: 'sampledBy',
	
	  _onActivation: function() {
	    var length = this._sources.length,
	        i;
	    this._aliveCount = length - this._passiveCount;
	    this._activating = true;
	    for (i = 0; i < length; i++) {
	      this._sources[i].onAny(this._bindHandleAny(i), [this, i]);
	    }
	    this._activating = false;
	    if (this._emitAfterActivation) {
	      this._emitAfterActivation = false;
	      this._emitIfFull(true);
	    }
	    if (this._endAfterActivation) {
	      this._send(END, null, true);
	    }
	  },
	
	  _onDeactivation: function() {
	    var length = this._sources.length,
	        i;
	    for (i = 0; i < length; i++) {
	      this._sources[i].offAny(null, [this, i]);
	    }
	  },
	
	  _emitIfFull: function(isCurrent) {
	    if (!contains(this._currents, NOTHING)) {
	      var combined = cloneArray(this._currents);
	      combined = this._combinator(combined);
	      this._send(VALUE, combined, isCurrent);
	    }
	  },
	
	  _bindHandleAny: function(i) {
	    var $ = this;
	    return function(event) {  $._handleAny(i, event)  };
	  },
	
	  _handleAny: function(i, event) {
	    if (event.type === VALUE) {
	      this._currents[i] = event.value;
	      if (i >= this._passiveCount) {
	        if (this._activating) {
	          this._emitAfterActivation = true;
	        } else {
	          this._emitIfFull(event.current);
	        }
	      }
	    }
	    if (event.type === ERROR) {
	      this._send(ERROR, event.value, event.current);
	    }
	    if (event.type === END) {
	      if (i >= this._passiveCount) {
	        this._aliveCount--;
	        if (this._aliveCount === 0) {
	          if (this._activating) {
	            this._endAfterActivation = true;
	          } else {
	            this._send(END, null, event.current);
	          }
	        }
	      }
	    }
	  },
	
	  _clear: function() {
	    Stream.prototype._clear.call(this);
	    this._sources = null;
	    this._currents = null;
	    this._combinator = null;
	  }
	
	});
	
	Kefir.sampledBy = function(passive, active, combinator) {
	  return new SampledBy(passive, active, combinator);
	}
	
	Observable.prototype.sampledBy = function(other, combinator) {
	  return Kefir.sampledBy([this], [other], combinator || id);
	}
	
	
	
	
	// .combine()
	
	Kefir.combine = function(sources, combinator) {
	  return new SampledBy([], sources, combinator).setName('combine');
	}
	
	Observable.prototype.combine = function(other, combinator) {
	  return Kefir.combine([this, other], combinator);
	}
	
	function produceStream(StreamClass, PropertyClass) {
	  return function() {  return new StreamClass(this, arguments)  }
	}
	function produceProperty(StreamClass, PropertyClass) {
	  return function() {  return new PropertyClass(this, arguments)  }
	}
	
	
	
	// .toProperty()
	
	withOneSource('toProperty', {
	  _init: function(args) {
	    if (args.length > 0) {
	      this._send(VALUE, args[0]);
	    }
	  }
	}, {propertyMethod: produceProperty, streamMethod: produceProperty});
	
	
	
	
	
	// .changes()
	
	withOneSource('changes', {
	  _handleValue: function(x, isCurrent) {
	    if (!isCurrent) {
	      this._send(VALUE, x);
	    }
	  },
	  _handleError: function(x, isCurrent) {
	    if (!isCurrent) {
	      this._send(ERROR, x);
	    }
	  }
	}, {
	  streamMethod: function() {
	    return function() {
	      return this;
	    }
	  },
	  propertyMethod: produceStream
	});
	
	
	
	
	// .withHandler()
	
	withOneSource('withHandler', {
	  _init: function(args) {
	    this._handler = args[0];
	    this._forcedCurrent = false;
	    var $ = this;
	    this._emitter = {
	      emit: function(x) {  $._send(VALUE, x, $._forcedCurrent)  },
	      error: function(x) {  $._send(ERROR, x, $._forcedCurrent)  },
	      end: function() {  $._send(END, null, $._forcedCurrent)  }
	    }
	  },
	  _free: function() {
	    this._handler = null;
	    this._emitter = null;
	  },
	  _handleAny: function(event) {
	    this._forcedCurrent = event.current;
	    this._handler(this._emitter, event);
	    this._forcedCurrent = false;
	  }
	});
	
	
	
	
	// .flatten(fn)
	
	withOneSource('flatten', {
	  _init: function(args) {
	    this._fn = args[0] ? args[0] : id;
	  },
	  _free: function() {
	    this._fn = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    var xs = this._fn(x);
	    for (var i = 0; i < xs.length; i++) {
	      this._send(VALUE, xs[i], isCurrent);
	    }
	  }
	});
	
	
	
	
	
	
	
	// .transduce(transducer)
	
	function xformForObs(obs) {
	  return {
	    step: function(res, input) {
	      obs._send(VALUE, input, obs._forcedCurrent);
	      return null;
	    },
	    result: function(res) {
	      obs._send(END, null, obs._forcedCurrent);
	      return null;
	    }
	  };
	}
	
	withOneSource('transduce', {
	  _init: function(args) {
	    this._xform = args[0](xformForObs(this));
	  },
	  _free: function() {
	    this._xform = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    this._forcedCurrent = isCurrent;
	    if (this._xform.step(null, x) !== null) {
	      this._xform.result(null);
	    }
	    this._forcedCurrent = false;
	  },
	  _handleEnd: function(__, isCurrent) {
	    this._forcedCurrent = isCurrent;
	    this._xform.result(null);
	    this._forcedCurrent = false;
	  }
	});
	
	
	
	
	
	var withFnArgMixin = {
	  _init: function(args) {  this._fn = args[0] || id  },
	  _free: function() {  this._fn = null  }
	};
	
	
	
	// .map(fn)
	
	withOneSource('map', extend({
	  _handleValue: function(x, isCurrent) {
	    this._send(VALUE, this._fn(x), isCurrent);
	  }
	}, withFnArgMixin));
	
	
	
	
	// .mapErrors(fn)
	
	withOneSource('mapErrors', extend({
	  _handleError: function(x, isCurrent) {
	    this._send(ERROR, this._fn(x), isCurrent);
	  }
	}, withFnArgMixin));
	
	
	
	// .errorsToValues(fn)
	
	function defaultErrorsToValuesHandler(x) {
	  return {
	    convert: true,
	    value: x
	  };
	}
	
	withOneSource('errorsToValues', extend({
	  _init: function(args) {
	    this._fn = args[0] || defaultErrorsToValuesHandler;
	  },
	  _free: function() {
	    this._fn = null;
	  },
	  _handleError: function(x, isCurrent) {
	    var result = this._fn(x);
	    var type = result.convert ? VALUE : ERROR;
	    var newX = result.convert ? result.value : x;
	    this._send(type, newX, isCurrent);
	  }
	}));
	
	
	
	// .valuesToErrors(fn)
	
	function defaultValuesToErrorsHandler(x) {
	  return {
	    convert: true,
	    error: x
	  };
	}
	
	withOneSource('valuesToErrors', extend({
	  _init: function(args) {
	    this._fn = args[0] || defaultValuesToErrorsHandler;
	  },
	  _free: function() {
	    this._fn = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    var result = this._fn(x);
	    var type = result.convert ? ERROR : VALUE;
	    var newX = result.convert ? result.error : x;
	    this._send(type, newX, isCurrent);
	  }
	}));
	
	
	
	
	// .filter(fn)
	
	withOneSource('filter', extend({
	  _handleValue: function(x, isCurrent) {
	    if (this._fn(x)) {
	      this._send(VALUE, x, isCurrent);
	    }
	  }
	}, withFnArgMixin));
	
	
	
	
	// .filterErrors(fn)
	
	withOneSource('filterErrors', extend({
	  _handleError: function(x, isCurrent) {
	    if (this._fn(x)) {
	      this._send(ERROR, x, isCurrent);
	    }
	  }
	}, withFnArgMixin));
	
	
	
	
	// .takeWhile(fn)
	
	withOneSource('takeWhile', extend({
	  _handleValue: function(x, isCurrent) {
	    if (this._fn(x)) {
	      this._send(VALUE, x, isCurrent);
	    } else {
	      this._send(END, null, isCurrent);
	    }
	  }
	}, withFnArgMixin));
	
	
	
	
	
	// .take(n)
	
	withOneSource('take', {
	  _init: function(args) {
	    this._n = args[0];
	    if (this._n <= 0) {
	      this._send(END);
	    }
	  },
	  _handleValue: function(x, isCurrent) {
	    this._n--;
	    this._send(VALUE, x, isCurrent);
	    if (this._n === 0) {
	      this._send(END, null, isCurrent);
	    }
	  }
	});
	
	
	
	
	
	// .skip(n)
	
	withOneSource('skip', {
	  _init: function(args) {
	    this._n = Math.max(0, args[0]);
	  },
	  _handleValue: function(x, isCurrent) {
	    if (this._n === 0) {
	      this._send(VALUE, x, isCurrent);
	    } else {
	      this._n--;
	    }
	  }
	});
	
	
	
	
	// .skipDuplicates([fn])
	
	withOneSource('skipDuplicates', {
	  _init: function(args) {
	    this._fn = args[0] || strictEqual;
	    this._prev = NOTHING;
	  },
	  _free: function() {
	    this._fn = null;
	    this._prev = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    if (this._prev === NOTHING || !this._fn(this._prev, x)) {
	      this._prev = x;
	      this._send(VALUE, x, isCurrent);
	    }
	  }
	});
	
	
	
	
	
	// .skipWhile(fn)
	
	withOneSource('skipWhile', {
	  _init: function(args) {
	    this._fn = args[0] || id;
	    this._skip = true;
	  },
	  _free: function() {
	    this._fn = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    if (!this._skip) {
	      this._send(VALUE, x, isCurrent);
	      return;
	    }
	    if (!this._fn(x)) {
	      this._skip = false;
	      this._fn = null;
	      this._send(VALUE, x, isCurrent);
	    }
	  }
	});
	
	
	
	
	
	// .diff(fn, seed)
	
	withOneSource('diff', {
	  _init: function(args) {
	    this._fn = args[0] || defaultDiff;
	    this._prev = args.length > 1 ? args[1] : NOTHING;
	  },
	  _free: function() {
	    this._prev = null;
	    this._fn = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    if (this._prev !== NOTHING) {
	      this._send(VALUE, this._fn(this._prev, x), isCurrent);
	    }
	    this._prev = x;
	  }
	});
	
	
	
	
	
	// .scan(fn, seed)
	
	withOneSource('scan', {
	  _init: function(args) {
	    this._fn = args[0];
	    if (args.length > 1) {
	      this._send(VALUE, args[1], true);
	    }
	  },
	  _free: function() {
	    this._fn = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    if (this._current !== NOTHING) {
	      x = this._fn(this._current, x);
	    }
	    this._send(VALUE, x, isCurrent);
	  }
	}, {streamMethod: produceProperty});
	
	
	
	
	
	// .reduce(fn, seed)
	
	withOneSource('reduce', {
	  _init: function(args) {
	    this._fn = args[0];
	    this._result = args.length > 1 ? args[1] : NOTHING;
	  },
	  _free: function() {
	    this._fn = null;
	    this._result = null;
	  },
	  _handleValue: function(x) {
	    this._result = (this._result === NOTHING) ? x : this._fn(this._result, x);
	  },
	  _handleEnd: function(__, isCurrent) {
	    if (this._result !== NOTHING) {
	      this._send(VALUE, this._result, isCurrent);
	    }
	    this._send(END, null, isCurrent);
	  }
	});
	
	
	
	
	// .mapEnd(fn)
	
	withOneSource('mapEnd', {
	  _init: function(args) {
	    this._fn = args[0];
	  },
	  _free: function() {
	    this._fn = null;
	  },
	  _handleEnd: function(__, isCurrent) {
	    this._send(VALUE, this._fn(), isCurrent);
	    this._send(END, null, isCurrent);
	  }
	});
	
	
	
	
	// .skipValue()
	
	withOneSource('skipValues', {
	  _handleValue: function() {}
	});
	
	
	
	// .skipError()
	
	withOneSource('skipErrors', {
	  _handleError: function() {}
	});
	
	
	
	// .skipEnd()
	
	withOneSource('skipEnd', {
	  _handleEnd: function() {}
	});
	
	
	
	// .endOnError(fn)
	
	withOneSource('endOnError', extend({
	  _handleError: function(x, isCurrent) {
	    this._send(ERROR, x, isCurrent);
	    this._send(END, null, isCurrent);
	  }
	}));
	
	
	
	// .slidingWindow(max[, min])
	
	withOneSource('slidingWindow', {
	  _init: function(args) {
	    this._max = args[0];
	    this._min = args[1] || 0;
	    this._buff = [];
	  },
	  _free: function() {
	    this._buff = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    this._buff = slide(this._buff, x, this._max);
	    if (this._buff.length >= this._min) {
	      this._send(VALUE, this._buff, isCurrent);
	    }
	  }
	});
	
	
	
	
	// .bufferWhile([predicate], [options])
	
	withOneSource('bufferWhile', {
	  _init: function(args) {
	    this._fn = args[0] || id;
	    this._flushOnEnd = get(args[1], 'flushOnEnd', true);
	    this._buff = [];
	  },
	  _free: function() {
	    this._buff = null;
	  },
	  _flush: function(isCurrent) {
	    if (this._buff !== null && this._buff.length !== 0) {
	      this._send(VALUE, this._buff, isCurrent);
	      this._buff = [];
	    }
	  },
	  _handleValue: function(x, isCurrent) {
	    this._buff.push(x);
	    if (!this._fn(x)) {
	      this._flush(isCurrent);
	    }
	  },
	  _handleEnd: function(x, isCurrent) {
	    if (this._flushOnEnd) {
	      this._flush(isCurrent);
	    }
	    this._send(END, null, isCurrent);
	  }
	});
	
	
	
	
	
	// .debounce(wait, {immediate})
	
	withOneSource('debounce', {
	  _init: function(args) {
	    this._wait = Math.max(0, args[0]);
	    this._immediate = get(args[1], 'immediate', false);
	    this._lastAttempt = 0;
	    this._timeoutId = null;
	    this._laterValue = null;
	    this._endLater = false;
	    var $ = this;
	    this._$later = function() {  $._later()  };
	  },
	  _free: function() {
	    this._laterValue = null;
	    this._$later = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    if (isCurrent) {
	      this._send(VALUE, x, isCurrent);
	    } else {
	      this._lastAttempt = now();
	      if (this._immediate && !this._timeoutId) {
	        this._send(VALUE, x);
	      }
	      if (!this._timeoutId) {
	        this._timeoutId = setTimeout(this._$later, this._wait);
	      }
	      if (!this._immediate) {
	        this._laterValue = x;
	      }
	    }
	  },
	  _handleEnd: function(__, isCurrent) {
	    if (isCurrent) {
	      this._send(END, null, isCurrent);
	    } else {
	      if (this._timeoutId && !this._immediate) {
	        this._endLater = true;
	      } else {
	        this._send(END);
	      }
	    }
	  },
	  _later: function() {
	    var last = now() - this._lastAttempt;
	    if (last < this._wait && last >= 0) {
	      this._timeoutId = setTimeout(this._$later, this._wait - last);
	    } else {
	      this._timeoutId = null;
	      if (!this._immediate) {
	        this._send(VALUE, this._laterValue);
	        this._laterValue = null;
	      }
	      if (this._endLater) {
	        this._send(END);
	      }
	    }
	  }
	});
	
	
	
	
	
	// .throttle(wait, {leading, trailing})
	
	withOneSource('throttle', {
	  _init: function(args) {
	    this._wait = Math.max(0, args[0]);
	    this._leading = get(args[1], 'leading', true);
	    this._trailing = get(args[1], 'trailing', true);
	    this._trailingValue = null;
	    this._timeoutId = null;
	    this._endLater = false;
	    this._lastCallTime = 0;
	    var $ = this;
	    this._$trailingCall = function() {  $._trailingCall()  };
	  },
	  _free: function() {
	    this._trailingValue = null;
	    this._$trailingCall = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    if (isCurrent) {
	      this._send(VALUE, x, isCurrent);
	    } else {
	      var curTime = now();
	      if (this._lastCallTime === 0 && !this._leading) {
	        this._lastCallTime = curTime;
	      }
	      var remaining = this._wait - (curTime - this._lastCallTime);
	      if (remaining <= 0) {
	        this._cancelTraling();
	        this._lastCallTime = curTime;
	        this._send(VALUE, x);
	      } else if (this._trailing) {
	        this._cancelTraling();
	        this._trailingValue = x;
	        this._timeoutId = setTimeout(this._$trailingCall, remaining);
	      }
	    }
	  },
	  _handleEnd: function(__, isCurrent) {
	    if (isCurrent) {
	      this._send(END, null, isCurrent);
	    } else {
	      if (this._timeoutId) {
	        this._endLater = true;
	      } else {
	        this._send(END);
	      }
	    }
	  },
	  _cancelTraling: function() {
	    if (this._timeoutId !== null) {
	      clearTimeout(this._timeoutId);
	      this._timeoutId = null;
	    }
	  },
	  _trailingCall: function() {
	    this._send(VALUE, this._trailingValue);
	    this._timeoutId = null;
	    this._trailingValue = null;
	    this._lastCallTime = !this._leading ? 0 : now();
	    if (this._endLater) {
	      this._send(END);
	    }
	  }
	});
	
	
	
	
	
	// .delay()
	
	withOneSource('delay', {
	  _init: function(args) {
	    this._wait = Math.max(0, args[0]);
	    this._buff = [];
	    var $ = this;
	    this._$shiftBuff = function() {  $._send(VALUE, $._buff.shift())  }
	  },
	  _free: function() {
	    this._buff = null;
	    this._$shiftBuff = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    if (isCurrent) {
	      this._send(VALUE, x, isCurrent);
	    } else {
	      this._buff.push(x);
	      setTimeout(this._$shiftBuff, this._wait);
	    }
	  },
	  _handleEnd: function(__, isCurrent) {
	    if (isCurrent) {
	      this._send(END, null, isCurrent);
	    } else {
	      var $ = this;
	      setTimeout(function() {  $._send(END)  }, this._wait);
	    }
	  }
	});
	
	// Kefir.fromBinder(fn)
	
	function FromBinder(fn) {
	  Stream.call(this);
	  this._fn = fn;
	  this._unsubscribe = null;
	}
	
	inherit(FromBinder, Stream, {
	
	  _name: 'fromBinder',
	
	  _onActivation: function() {
	    var $ = this
	      , isCurrent = true
	      , emitter = {
	        emit: function(x) {  $._send(VALUE, x, isCurrent)  },
	        error: function(x) {  $._send(ERROR, x, isCurrent)  },
	        end: function() {  $._send(END, null, isCurrent)  }
	      };
	    this._unsubscribe = this._fn(emitter) || null;
	
	    // work around https://github.com/pozadi/kefir/issues/35
	    if (!this._active && this._unsubscribe !== null) {
	      this._unsubscribe();
	      this._unsubscribe = null;
	    }
	
	    isCurrent = false;
	  },
	  _onDeactivation: function() {
	    if (this._unsubscribe !== null) {
	      this._unsubscribe();
	      this._unsubscribe = null;
	    }
	  },
	
	  _clear: function() {
	    Stream.prototype._clear.call(this);
	    this._fn = null;
	  }
	
	})
	
	Kefir.fromBinder = function(fn) {
	  return new FromBinder(fn);
	}
	
	
	
	
	
	
	// Kefir.emitter()
	
	function Emitter() {
	  Stream.call(this);
	}
	
	inherit(Emitter, Stream, {
	  _name: 'emitter',
	  emit: function(x) {
	    this._send(VALUE, x);
	    return this;
	  },
	  error: function(x) {
	    this._send(ERROR, x);
	    return this;
	  },
	  end: function() {
	    this._send(END);
	    return this;
	  }
	});
	
	Kefir.emitter = function() {
	  return new Emitter();
	}
	
	Kefir.Emitter = Emitter;
	
	
	
	
	
	
	
	// Kefir.never()
	
	var neverObj = new Stream();
	neverObj._send(END);
	neverObj._name = 'never';
	Kefir.never = function() {  return neverObj  }
	
	
	
	
	
	// Kefir.constant(x)
	
	function Constant(x) {
	  Property.call(this);
	  this._send(VALUE, x);
	  this._send(END);
	}
	
	inherit(Constant, Property, {
	  _name: 'constant'
	})
	
	Kefir.constant = function(x) {
	  return new Constant(x);
	}
	
	
	
	
	// Kefir.constantError(x)
	
	function ConstantError(x) {
	  Property.call(this);
	  this._send(ERROR, x);
	  this._send(END);
	}
	
	inherit(ConstantError, Property, {
	  _name: 'constantError'
	})
	
	Kefir.constantError = function(x) {
	  return new ConstantError(x);
	}
	
	
	// .setName
	
	Observable.prototype.setName = function(sourceObs, selfName /* or just selfName */) {
	  this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;
	  return this;
	}
	
	
	
	// .mapTo
	
	Observable.prototype.mapTo = function(value) {
	  return this.map(function() {  return value  }).setName(this, 'mapTo');
	}
	
	
	
	// .pluck
	
	Observable.prototype.pluck = function(propertyName) {
	  return this.map(function(x) {
	    return x[propertyName];
	  }).setName(this, 'pluck');
	}
	
	
	
	// .invoke
	
	Observable.prototype.invoke = function(methodName /*, arg1, arg2... */) {
	  var args = rest(arguments, 1);
	  return this.map(args ?
	    function(x) {  return apply(x[methodName], x, args)  } :
	    function(x) {  return x[methodName]()  }
	  ).setName(this, 'invoke');
	}
	
	
	
	
	// .timestamp
	
	Observable.prototype.timestamp = function() {
	  return this.map(function(x) {  return {value: x, time: now()}  }).setName(this, 'timestamp');
	}
	
	
	
	
	// .tap
	
	Observable.prototype.tap = function(fn) {
	  return this.map(function(x) {
	    fn(x);
	    return x;
	  }).setName(this, 'tap');
	}
	
	
	
	// .and
	
	Kefir.and = function(observables) {
	  return Kefir.combine(observables, and).setName('and');
	}
	
	Observable.prototype.and = function(other) {
	  return this.combine(other, and).setName('and');
	}
	
	
	
	// .or
	
	Kefir.or = function(observables) {
	  return Kefir.combine(observables, or).setName('or');
	}
	
	Observable.prototype.or = function(other) {
	  return this.combine(other, or).setName('or');
	}
	
	
	
	// .not
	
	Observable.prototype.not = function() {
	  return this.map(not).setName(this, 'not');
	}
	
	
	
	// .awaiting
	
	Observable.prototype.awaiting = function(other) {
	  return Kefir.merge([
	    this.mapTo(true),
	    other.mapTo(false)
	  ]).skipDuplicates().toProperty(false).setName(this, 'awaiting');
	}
	
	
	
	
	// .fromCallback
	
	Kefir.fromCallback = function(callbackConsumer) {
	  var called = false;
	  return Kefir.fromBinder(function(emitter) {
	    if (!called) {
	      callbackConsumer(function(x) {
	        emitter.emit(x);
	        emitter.end();
	      });
	      called = true;
	    }
	  }).setName('fromCallback');
	}
	
	
	
	
	// .fromNodeCallback
	
	Kefir.fromNodeCallback = function(callbackConsumer) {
	  var called = false;
	  return Kefir.fromBinder(function(emitter) {
	    if (!called) {
	      callbackConsumer(function(error, x) {
	        if (error) {
	          emitter.error(error);
	        } else {
	          emitter.emit(x);
	        }
	        emitter.end();
	      });
	      called = true;
	    }
	  }).setName('fromNodeCallback');
	}
	
	
	
	
	// .fromPromise
	
	Kefir.fromPromise = function(promise) {
	  var called = false;
	  return Kefir.fromBinder(function(emitter) {
	    if (!called) {
	      var onValue = function(x) {
	        emitter.emit(x);
	        emitter.end();
	      };
	      var onError = function(x) {
	        emitter.error(x);
	        emitter.end();
	      };
	      var _promise = promise.then(onValue, onError);
	
	      // prevent promise/A+ libraries like Q to swallow exceptions
	      if (_promise && isFn(_promise.done)) {
	        _promise.done();
	      }
	
	      called = true;
	    }
	  }).toProperty().setName('fromPromise');
	}
	
	
	
	
	
	
	// .fromSubUnsub
	
	Kefir.fromSubUnsub = function(sub, unsub, transformer) {
	  return Kefir.fromBinder(function(emitter) {
	    var handler = transformer ? function() {
	      emitter.emit(apply(transformer, this, arguments));
	    } : emitter.emit;
	    sub(handler);
	    return function() {  unsub(handler)  };
	  });
	}
	
	
	
	
	// .fromEvent
	
	var subUnsubPairs = [
	  ['addEventListener', 'removeEventListener'],
	  ['addListener', 'removeListener'],
	  ['on', 'off']
	];
	
	Kefir.fromEvent = function(target, eventName, transformer) {
	  var pair, sub, unsub;
	
	  for (var i = 0; i < subUnsubPairs.length; i++) {
	    pair = subUnsubPairs[i];
	    if (isFn(target[pair[0]]) && isFn(target[pair[1]])) {
	      sub = pair[0];
	      unsub = pair[1];
	      break;
	    }
	  }
	
	  if (sub === undefined) {
	    throw new Error('target don\'t support any of ' +
	      'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');
	  }
	
	  return Kefir.fromSubUnsub(
	    function(handler) {  target[sub](eventName, handler)  },
	    function(handler) {  target[unsub](eventName, handler)  },
	    transformer
	  ).setName('fromEvent');
	}
	
	var withTwoSourcesAndBufferMixin = {
	  _init: function(args) {
	    this._buff = [];
	    this._flushOnEnd = get(args[0], 'flushOnEnd', true);
	  },
	  _free: function() {
	    this._buff = null;
	  },
	  _flush: function(isCurrent) {
	    if (this._buff !== null && this._buff.length !== 0) {
	      this._send(VALUE, this._buff, isCurrent);
	      this._buff = [];
	    }
	  },
	
	  _handlePrimaryEnd: function(__, isCurrent) {
	    if (this._flushOnEnd) {
	      this._flush(isCurrent);
	    }
	    this._send(END, null, isCurrent);
	  }
	};
	
	
	
	withTwoSources('bufferBy', extend({
	
	  _onActivation: function() {
	    this._primary.onAny(this._$handlePrimaryAny);
	    if (this._alive && this._secondary !== null) {
	      this._secondary.onAny(this._$handleSecondaryAny);
	    }
	  },
	
	  _handlePrimaryValue: function(x, isCurrent) {
	    this._buff.push(x);
	  },
	
	  _handleSecondaryValue: function(x, isCurrent) {
	    this._flush(isCurrent);
	  },
	
	  _handleSecondaryEnd: function(x, isCurrent) {
	    if (!this._flushOnEnd) {
	      this._send(END, null, isCurrent);
	    }
	  }
	
	}, withTwoSourcesAndBufferMixin));
	
	
	
	
	withTwoSources('bufferWhileBy', extend({
	
	  _handlePrimaryValue: function(x, isCurrent) {
	    this._buff.push(x);
	    if (this._lastSecondary !== NOTHING && !this._lastSecondary) {
	      this._flush(isCurrent);
	    }
	  },
	
	  _handleSecondaryEnd: function(x, isCurrent) {
	    if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {
	      this._send(END, null, isCurrent);
	    }
	  }
	
	}, withTwoSourcesAndBufferMixin));
	
	
	
	
	
	withTwoSources('filterBy', {
	
	  _handlePrimaryValue: function(x, isCurrent) {
	    if (this._lastSecondary !== NOTHING && this._lastSecondary) {
	      this._send(VALUE, x, isCurrent);
	    }
	  },
	
	  _handleSecondaryEnd: function(__, isCurrent) {
	    if (this._lastSecondary === NOTHING || !this._lastSecondary) {
	      this._send(END, null, isCurrent);
	    }
	  }
	
	});
	
	
	
	withTwoSources('skipUntilBy', {
	
	  _handlePrimaryValue: function(x, isCurrent) {
	    if (this._lastSecondary !== NOTHING) {
	      this._send(VALUE, x, isCurrent);
	    }
	  },
	
	  _handleSecondaryEnd: function(__, isCurrent) {
	    if (this._lastSecondary === NOTHING) {
	      this._send(END, null, isCurrent);
	    }
	  }
	
	});
	
	
	
	withTwoSources('takeUntilBy', {
	
	  _handleSecondaryValue: function(x, isCurrent) {
	    this._send(END, null, isCurrent);
	  }
	
	});
	
	
	
	withTwoSources('takeWhileBy', {
	
	  _handlePrimaryValue: function(x, isCurrent) {
	    if (this._lastSecondary !== NOTHING) {
	      this._send(VALUE, x, isCurrent);
	    }
	  },
	
	  _handleSecondaryValue: function(x, isCurrent) {
	    this._lastSecondary = x;
	    if (!this._lastSecondary) {
	      this._send(END, null, isCurrent);
	    }
	  },
	
	  _handleSecondaryEnd: function(__, isCurrent) {
	    if (this._lastSecondary === NOTHING) {
	      this._send(END, null, isCurrent);
	    }
	  }
	
	});
	
	
	
	
	withTwoSources('skipWhileBy', {
	
	  _init: function() {
	    this._hasFalseyFromSecondary = false;
	  },
	
	  _handlePrimaryValue: function(x, isCurrent) {
	    if (this._hasFalseyFromSecondary) {
	      this._send(VALUE, x, isCurrent);
	    }
	  },
	
	  _handleSecondaryValue: function(x, isCurrent) {
	    this._hasFalseyFromSecondary = this._hasFalseyFromSecondary || !x;
	  },
	
	  _handleSecondaryEnd: function(__, isCurrent) {
	    if (!this._hasFalseyFromSecondary) {
	      this._send(END, null, isCurrent);
	    }
	  }
	
	});
	
	
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return Kefir;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    global.Kefir = Kefir;
	  } else if (typeof module === "object" && typeof exports === "object") {
	    module.exports = Kefir;
	    Kefir.Kefir = Kefir;
	  } else {
	    global.Kefir = Kefir;
	  }
	
	}(this));

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Tween.js - Licensed under the MIT license
	 * https://github.com/sole/tween.js
	 * ----------------------------------------------
	 *
	 * See https://github.com/sole/tween.js/graphs/contributors for the full list of contributors.
	 * Thank you all, you're awesome!
	 */
	
	// performance.now polyfill
	( function ( root ) {
	
		if ( 'performance' in root === false ) {
			root.performance = {};
		}
	
		// IE 8
		Date.now = ( Date.now || function () {
			return new Date().getTime();
		} );
	
		if ( 'now' in root.performance === false ) {
			var offset = root.performance.timing && root.performance.timing.navigationStart ? performance.timing.navigationStart
			                                                                                : Date.now();
	
			root.performance.now = function () {
				return Date.now() - offset;
			};
		}
	
	} )( this );
	
	var TWEEN = TWEEN || ( function () {
	
		var _tweens = [];
	
		return {
	
			REVISION: '14',
	
			getAll: function () {
	
				return _tweens;
	
			},
	
			removeAll: function () {
	
				_tweens = [];
	
			},
	
			add: function ( tween ) {
	
				_tweens.push( tween );
	
			},
	
			remove: function ( tween ) {
	
				var i = _tweens.indexOf( tween );
	
				if ( i !== -1 ) {
	
					_tweens.splice( i, 1 );
	
				}
	
			},
	
			update: function ( time ) {
	
				if ( _tweens.length === 0 ) return false;
	
				var i = 0;
	
				time = time !== undefined ? time : window.performance.now();
	
				while ( i < _tweens.length ) {
	
					if ( _tweens[ i ].update( time ) ) {
	
						i++;
	
					} else {
	
						_tweens.splice( i, 1 );
	
					}
	
				}
	
				return true;
	
			}
		};
	
	} )();
	
	TWEEN.Tween = function ( object ) {
	
		var _object = object;
		var _valuesStart = {};
		var _valuesEnd = {};
		var _valuesStartRepeat = {};
		var _duration = 1000;
		var _repeat = 0;
		var _yoyo = false;
		var _isPlaying = false;
		var _reversed = false;
		var _delayTime = 0;
		var _startTime = null;
		var _easingFunction = TWEEN.Easing.Linear.None;
		var _interpolationFunction = TWEEN.Interpolation.Linear;
		var _chainedTweens = [];
		var _onStartCallback = null;
		var _onStartCallbackFired = false;
		var _onUpdateCallback = null;
		var _onCompleteCallback = null;
		var _onStopCallback = null;
	
		// Set all starting values present on the target object
		for ( var field in object ) {
	
			_valuesStart[ field ] = parseFloat(object[field], 10);
	
		}
	
		this.to = function ( properties, duration ) {
	
			if ( duration !== undefined ) {
	
				_duration = duration;
	
			}
	
			_valuesEnd = properties;
	
			return this;
	
		};
	
		this.start = function ( time ) {
	
			TWEEN.add( this );
	
			_isPlaying = true;
	
			_onStartCallbackFired = false;
	
			_startTime = time !== undefined ? time : window.performance.now();
			_startTime += _delayTime;
	
			for ( var property in _valuesEnd ) {
	
				// check if an Array was provided as property value
				if ( _valuesEnd[ property ] instanceof Array ) {
	
					if ( _valuesEnd[ property ].length === 0 ) {
	
						continue;
	
					}
	
					// create a local copy of the Array with the start value at the front
					_valuesEnd[ property ] = [ _object[ property ] ].concat( _valuesEnd[ property ] );
	
				}
	
				_valuesStart[ property ] = _object[ property ];
	
				if( ( _valuesStart[ property ] instanceof Array ) === false ) {
					_valuesStart[ property ] *= 1.0; // Ensures we're using numbers, not strings
				}
	
				_valuesStartRepeat[ property ] = _valuesStart[ property ] || 0;
	
			}
	
			return this;
	
		};
	
		this.stop = function () {
	
			if ( !_isPlaying ) {
				return this;
			}
	
			TWEEN.remove( this );
			_isPlaying = false;
	
			if ( _onStopCallback !== null ) {
	
				_onStopCallback.call( _object );
	
			}
	
			this.stopChainedTweens();
			return this;
	
		};
	
		this.stopChainedTweens = function () {
	
			for ( var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++ ) {
	
				_chainedTweens[ i ].stop();
	
			}
	
		};
	
		this.delay = function ( amount ) {
	
			_delayTime = amount;
			return this;
	
		};
	
		this.repeat = function ( times ) {
	
			_repeat = times;
			return this;
	
		};
	
		this.yoyo = function( yoyo ) {
	
			_yoyo = yoyo;
			return this;
	
		};
	
	
		this.easing = function ( easing ) {
	
			_easingFunction = easing;
			return this;
	
		};
	
		this.interpolation = function ( interpolation ) {
	
			_interpolationFunction = interpolation;
			return this;
	
		};
	
		this.chain = function () {
	
			_chainedTweens = arguments;
			return this;
	
		};
	
		this.onStart = function ( callback ) {
	
			_onStartCallback = callback;
			return this;
	
		};
	
		this.onUpdate = function ( callback ) {
	
			_onUpdateCallback = callback;
			return this;
	
		};
	
		this.onComplete = function ( callback ) {
	
			_onCompleteCallback = callback;
			return this;
	
		};
	
		this.onStop = function ( callback ) {
	
			_onStopCallback = callback;
			return this;
	
		};
	
		this.update = function ( time ) {
	
			var property;
	
			if ( time < _startTime ) {
	
				return true;
	
			}
	
			if ( _onStartCallbackFired === false ) {
	
				if ( _onStartCallback !== null ) {
	
					_onStartCallback.call( _object );
	
				}
	
				_onStartCallbackFired = true;
	
			}
	
			var elapsed = ( time - _startTime ) / _duration;
			elapsed = elapsed > 1 ? 1 : elapsed;
	
			var value = _easingFunction( elapsed );
	
			for ( property in _valuesEnd ) {
	
				var start = _valuesStart[ property ] || 0;
				var end = _valuesEnd[ property ];
	
				if ( end instanceof Array ) {
	
					_object[ property ] = _interpolationFunction( end, value );
	
				} else {
	
					// Parses relative end values with start as base (e.g.: +10, -3)
					if ( typeof(end) === "string" ) {
						end = start + parseFloat(end, 10);
					}
	
					// protect against non numeric properties.
					if ( typeof(end) === "number" ) {
						_object[ property ] = start + ( end - start ) * value;
					}
	
				}
	
			}
	
			if ( _onUpdateCallback !== null ) {
	
				_onUpdateCallback.call( _object, value );
	
			}
	
			if ( elapsed == 1 ) {
	
				if ( _repeat > 0 ) {
	
					if( isFinite( _repeat ) ) {
						_repeat--;
					}
	
					// reassign starting values, restart by making startTime = now
					for( property in _valuesStartRepeat ) {
	
						if ( typeof( _valuesEnd[ property ] ) === "string" ) {
							_valuesStartRepeat[ property ] = _valuesStartRepeat[ property ] + parseFloat(_valuesEnd[ property ], 10);
						}
	
						if (_yoyo) {
							var tmp = _valuesStartRepeat[ property ];
							_valuesStartRepeat[ property ] = _valuesEnd[ property ];
							_valuesEnd[ property ] = tmp;
						}
	
						_valuesStart[ property ] = _valuesStartRepeat[ property ];
	
					}
	
					if (_yoyo) {
						_reversed = !_reversed;
					}
	
					_startTime = time + _delayTime;
	
					return true;
	
				} else {
	
					if ( _onCompleteCallback !== null ) {
	
						_onCompleteCallback.call( _object );
	
					}
	
					for ( var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++ ) {
	
						_chainedTweens[ i ].start( time );
	
					}
	
					return false;
	
				}
	
			}
	
			return true;
	
		};
	
	};
	
	
	TWEEN.Easing = {
	
		Linear: {
	
			None: function ( k ) {
	
				return k;
	
			}
	
		},
	
		Quadratic: {
	
			In: function ( k ) {
	
				return k * k;
	
			},
	
			Out: function ( k ) {
	
				return k * ( 2 - k );
	
			},
	
			InOut: function ( k ) {
	
				if ( ( k *= 2 ) < 1 ) return 0.5 * k * k;
				return - 0.5 * ( --k * ( k - 2 ) - 1 );
	
			}
	
		},
	
		Cubic: {
	
			In: function ( k ) {
	
				return k * k * k;
	
			},
	
			Out: function ( k ) {
	
				return --k * k * k + 1;
	
			},
	
			InOut: function ( k ) {
	
				if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k;
				return 0.5 * ( ( k -= 2 ) * k * k + 2 );
	
			}
	
		},
	
		Quartic: {
	
			In: function ( k ) {
	
				return k * k * k * k;
	
			},
	
			Out: function ( k ) {
	
				return 1 - ( --k * k * k * k );
	
			},
	
			InOut: function ( k ) {
	
				if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k;
				return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 );
	
			}
	
		},
	
		Quintic: {
	
			In: function ( k ) {
	
				return k * k * k * k * k;
	
			},
	
			Out: function ( k ) {
	
				return --k * k * k * k * k + 1;
	
			},
	
			InOut: function ( k ) {
	
				if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k;
				return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 );
	
			}
	
		},
	
		Sinusoidal: {
	
			In: function ( k ) {
	
				return 1 - Math.cos( k * Math.PI / 2 );
	
			},
	
			Out: function ( k ) {
	
				return Math.sin( k * Math.PI / 2 );
	
			},
	
			InOut: function ( k ) {
	
				return 0.5 * ( 1 - Math.cos( Math.PI * k ) );
	
			}
	
		},
	
		Exponential: {
	
			In: function ( k ) {
	
				return k === 0 ? 0 : Math.pow( 1024, k - 1 );
	
			},
	
			Out: function ( k ) {
	
				return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k );
	
			},
	
			InOut: function ( k ) {
	
				if ( k === 0 ) return 0;
				if ( k === 1 ) return 1;
				if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 );
				return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 );
	
			}
	
		},
	
		Circular: {
	
			In: function ( k ) {
	
				return 1 - Math.sqrt( 1 - k * k );
	
			},
	
			Out: function ( k ) {
	
				return Math.sqrt( 1 - ( --k * k ) );
	
			},
	
			InOut: function ( k ) {
	
				if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1);
				return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1);
	
			}
	
		},
	
		Elastic: {
	
			In: function ( k ) {
	
				var s, a = 0.1, p = 0.4;
				if ( k === 0 ) return 0;
				if ( k === 1 ) return 1;
				if ( !a || a < 1 ) { a = 1; s = p / 4; }
				else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
				return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
	
			},
	
			Out: function ( k ) {
	
				var s, a = 0.1, p = 0.4;
				if ( k === 0 ) return 0;
				if ( k === 1 ) return 1;
				if ( !a || a < 1 ) { a = 1; s = p / 4; }
				else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
				return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );
	
			},
	
			InOut: function ( k ) {
	
				var s, a = 0.1, p = 0.4;
				if ( k === 0 ) return 0;
				if ( k === 1 ) return 1;
				if ( !a || a < 1 ) { a = 1; s = p / 4; }
				else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
				if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
				return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;
	
			}
	
		},
	
		Back: {
	
			In: function ( k ) {
	
				var s = 1.70158;
				return k * k * ( ( s + 1 ) * k - s );
	
			},
	
			Out: function ( k ) {
	
				var s = 1.70158;
				return --k * k * ( ( s + 1 ) * k + s ) + 1;
	
			},
	
			InOut: function ( k ) {
	
				var s = 1.70158 * 1.525;
				if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );
				return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );
	
			}
	
		},
	
		Bounce: {
	
			In: function ( k ) {
	
				return 1 - TWEEN.Easing.Bounce.Out( 1 - k );
	
			},
	
			Out: function ( k ) {
	
				if ( k < ( 1 / 2.75 ) ) {
	
					return 7.5625 * k * k;
	
				} else if ( k < ( 2 / 2.75 ) ) {
	
					return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;
	
				} else if ( k < ( 2.5 / 2.75 ) ) {
	
					return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;
	
				} else {
	
					return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;
	
				}
	
			},
	
			InOut: function ( k ) {
	
				if ( k < 0.5 ) return TWEEN.Easing.Bounce.In( k * 2 ) * 0.5;
				return TWEEN.Easing.Bounce.Out( k * 2 - 1 ) * 0.5 + 0.5;
	
			}
	
		}
	
	};
	
	TWEEN.Interpolation = {
	
		Linear: function ( v, k ) {
	
			var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEEN.Interpolation.Utils.Linear;
	
			if ( k < 0 ) return fn( v[ 0 ], v[ 1 ], f );
			if ( k > 1 ) return fn( v[ m ], v[ m - 1 ], m - f );
	
			return fn( v[ i ], v[ i + 1 > m ? m : i + 1 ], f - i );
	
		},
	
		Bezier: function ( v, k ) {
	
			var b = 0, n = v.length - 1, pw = Math.pow, bn = TWEEN.Interpolation.Utils.Bernstein, i;
	
			for ( i = 0; i <= n; i++ ) {
				b += pw( 1 - k, n - i ) * pw( k, i ) * v[ i ] * bn( n, i );
			}
	
			return b;
	
		},
	
		CatmullRom: function ( v, k ) {
	
			var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEEN.Interpolation.Utils.CatmullRom;
	
			if ( v[ 0 ] === v[ m ] ) {
	
				if ( k < 0 ) i = Math.floor( f = m * ( 1 + k ) );
	
				return fn( v[ ( i - 1 + m ) % m ], v[ i ], v[ ( i + 1 ) % m ], v[ ( i + 2 ) % m ], f - i );
	
			} else {
	
				if ( k < 0 ) return v[ 0 ] - ( fn( v[ 0 ], v[ 0 ], v[ 1 ], v[ 1 ], -f ) - v[ 0 ] );
				if ( k > 1 ) return v[ m ] - ( fn( v[ m ], v[ m ], v[ m - 1 ], v[ m - 1 ], f - m ) - v[ m ] );
	
				return fn( v[ i ? i - 1 : 0 ], v[ i ], v[ m < i + 1 ? m : i + 1 ], v[ m < i + 2 ? m : i + 2 ], f - i );
	
			}
	
		},
	
		Utils: {
	
			Linear: function ( p0, p1, t ) {
	
				return ( p1 - p0 ) * t + p0;
	
			},
	
			Bernstein: function ( n , i ) {
	
				var fc = TWEEN.Interpolation.Utils.Factorial;
				return fc( n ) / fc( i ) / fc( n - i );
	
			},
	
			Factorial: ( function () {
	
				var a = [ 1 ];
	
				return function ( n ) {
	
					var s = 1, i;
					if ( a[ n ] ) return a[ n ];
					for ( i = n; i > 1; i-- ) s *= i;
					return a[ n ] = s;
	
				};
	
			} )(),
	
			CatmullRom: function ( p0, p1, p2, p3, t ) {
	
				var v0 = ( p2 - p0 ) * 0.5, v1 = ( p3 - p1 ) * 0.5, t2 = t * t, t3 = t * t2;
				return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
			}
	
		}
	
	};
	
	// UMD (Universal Module Definition)
	( function ( root ) {
	
		if ( true ) {
	
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return TWEEN;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
		} else if ( typeof exports === 'object' ) {
	
			// Node.js
			module.exports = TWEEN;
	
		} else {
	
			// Global variable
			root.TWEEN = TWEEN;
	
		}
	
	} )( this );


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;;(function(global){
	  "use strict";
	
	
	
	  function init(Kefir, $) {
	
	
	
	    $.fn.asKefirStream = function(eventName, selector, transformer) {
	      var $el = this;
	      if (transformer == null && selector != null && 'string' !== typeof selector) {
	        transformer = selector;
	        selector = null;
	      }
	      return Kefir.fromSubUnsub(
	        function(handler) {  $el.on(eventName, selector, handler)  },
	        function(handler) {  $el.off(eventName, selector, handler)  },
	        transformer
	      ).setName('asKefirStream');
	    }
	
	
	
	    $.fn.asKefirProperty = function(eventName, selector, getter) {
	      if (getter == null) {
	        getter = selector;
	        selector = null;
	      }
	      return this.asKefirStream(eventName, selector, getter)
	        .toProperty(getter())
	        .setName('asKefirProperty');
	    }
	
	
	
	  }
	
	
	
	
	  var exports = {
	    init: init
	  };
	
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return exports;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    global.KefirJQuery = exports;
	  } else if (typeof module === "object" && typeof exports === "object") {
	    module.exports = exports;
	  } else {
	    global.KefirJQuery = exports;
	  }
	
	}(this));


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {// Generated by CoffeeScript 1.6.2
	/** echo  * @license echo  * while read i do echo  *  done echo
	*/
	
	
	(function() {
	  var Color, K, PITHIRD, TWOPI, X, Y, Z, bezier, brewer, chroma, clip_rgb, colors, cos, css2rgb, hex2rgb, hsi2rgb, hsl2rgb, hsv2rgb, lab2lch, lab2rgb, lab_xyz, lch2lab, lch2rgb, limit, luminance, luminance_x, rgb2hex, rgb2hsi, rgb2hsl, rgb2hsv, rgb2lab, rgb2lch, rgb_xyz, root, type, unpack, xyz_lab, xyz_rgb, _ref;
	
	  chroma = function(x, y, z, m) {
	    return new Color(x, y, z, m);
	  };
	
	  if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
	    module.exports = chroma;
	  }
	
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return chroma;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else {
	    root = typeof exports !== "undefined" && exports !== null ? exports : this;
	    root.chroma = chroma;
	  }
	
	  chroma.color = function(x, y, z, m) {
	    return new Color(x, y, z, m);
	  };
	
	  chroma.hsl = function(h, s, l, a) {
	    return new Color(h, s, l, a, 'hsl');
	  };
	
	  chroma.hsv = function(h, s, v, a) {
	    return new Color(h, s, v, a, 'hsv');
	  };
	
	  chroma.rgb = function(r, g, b, a) {
	    return new Color(r, g, b, a, 'rgb');
	  };
	
	  chroma.hex = function(x) {
	    return new Color(x);
	  };
	
	  chroma.css = function(x) {
	    return new Color(x);
	  };
	
	  chroma.lab = function(l, a, b) {
	    return new Color(l, a, b, 'lab');
	  };
	
	  chroma.lch = function(l, c, h) {
	    return new Color(l, c, h, 'lch');
	  };
	
	  chroma.hsi = function(h, s, i) {
	    return new Color(h, s, i, 'hsi');
	  };
	
	  chroma.gl = function(r, g, b, a) {
	    return new Color(r * 255, g * 255, b * 255, a, 'gl');
	  };
	
	  chroma.interpolate = function(a, b, f, m) {
	    if ((a == null) || (b == null)) {
	      return '#000';
	    }
	    if (type(a) === 'string') {
	      a = new Color(a);
	    }
	    if (type(b) === 'string') {
	      b = new Color(b);
	    }
	    return a.interpolate(f, b, m);
	  };
	
	  chroma.mix = chroma.interpolate;
	
	  chroma.contrast = function(a, b) {
	    var l1, l2;
	
	    if (type(a) === 'string') {
	      a = new Color(a);
	    }
	    if (type(b) === 'string') {
	      b = new Color(b);
	    }
	    l1 = a.luminance();
	    l2 = b.luminance();
	    if (l1 > l2) {
	      return (l1 + 0.05) / (l2 + 0.05);
	    } else {
	      return (l2 + 0.05) / (l1 + 0.05);
	    }
	  };
	
	  chroma.luminance = function(color) {
	    return chroma(color).luminance();
	  };
	
	  chroma._Color = Color;
	
	  /**
	      chroma.js
	  
	      Copyright (c) 2011-2013, Gregor Aisch
	      All rights reserved.
	  
	      Redistribution and use in source and binary forms, with or without
	      modification, are permitted provided that the following conditions are met:
	  
	      * Redistributions of source code must retain the above copyright notice, this
	        list of conditions and the following disclaimer.
	  
	      * Redistributions in binary form must reproduce the above copyright notice,
	        this list of conditions and the following disclaimer in the documentation
	        and/or other materials provided with the distribution.
	  
	      * The name Gregor Aisch may not be used to endorse or promote products
	        derived from this software without specific prior written permission.
	  
	      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	  
	      @source: https://github.com/gka/chroma.js
	  */
	
	
	  Color = (function() {
	    function Color() {
	      var a, arg, args, m, me, me_rgb, x, y, z, _i, _len, _ref, _ref1, _ref2, _ref3;
	
	      me = this;
	      args = [];
	      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
	        arg = arguments[_i];
	        if (arg != null) {
	          args.push(arg);
	        }
	      }
	      if (args.length === 0) {
	        _ref = [255, 0, 255, 1, 'rgb'], x = _ref[0], y = _ref[1], z = _ref[2], a = _ref[3], m = _ref[4];
	      } else if (type(args[0]) === "array") {
	        if (args[0].length === 3) {
	          _ref1 = args[0], x = _ref1[0], y = _ref1[1], z = _ref1[2];
	          a = 1;
	        } else if (args[0].length === 4) {
	          _ref2 = args[0], x = _ref2[0], y = _ref2[1], z = _ref2[2], a = _ref2[3];
	        } else {
	          throw 'unknown input argument';
	        }
	        m = args[1];
	      } else if (type(args[0]) === "string") {
	        x = args[0];
	        m = 'hex';
	      } else if (type(args[0]) === "object") {
	        _ref3 = args[0]._rgb, x = _ref3[0], y = _ref3[1], z = _ref3[2], a = _ref3[3];
	        m = 'rgb';
	      } else if (args.length >= 3) {
	        x = args[0];
	        y = args[1];
	        z = args[2];
	      }
	      if (args.length === 3) {
	        m = 'rgb';
	        a = 1;
	      } else if (args.length === 4) {
	        if (type(args[3]) === "string") {
	          m = args[3];
	          a = 1;
	        } else if (type(args[3]) === "number") {
	          m = 'rgb';
	          a = args[3];
	        }
	      } else if (args.length === 5) {
	        a = args[3];
	        m = args[4];
	      }
	      if (a == null) {
	        a = 1;
	      }
	      if (m === 'rgb') {
	        me._rgb = [x, y, z, a];
	      } else if (m === 'gl') {
	        me._rgb = [x * 255, y * 255, z * 255, a];
	      } else if (m === 'hsl') {
	        me._rgb = hsl2rgb(x, y, z);
	        me._rgb[3] = a;
	      } else if (m === 'hsv') {
	        me._rgb = hsv2rgb(x, y, z);
	        me._rgb[3] = a;
	      } else if (m === 'hex') {
	        me._rgb = hex2rgb(x);
	      } else if (m === 'lab') {
	        me._rgb = lab2rgb(x, y, z);
	        me._rgb[3] = a;
	      } else if (m === 'lch') {
	        me._rgb = lch2rgb(x, y, z);
	        me._rgb[3] = a;
	      } else if (m === 'hsi') {
	        me._rgb = hsi2rgb(x, y, z);
	        me._rgb[3] = a;
	      }
	      me_rgb = clip_rgb(me._rgb);
	    }
	
	    Color.prototype.rgb = function() {
	      return this._rgb.slice(0, 3);
	    };
	
	    Color.prototype.rgba = function() {
	      return this._rgb;
	    };
	
	    Color.prototype.hex = function() {
	      return rgb2hex(this._rgb);
	    };
	
	    Color.prototype.toString = function() {
	      return this.name();
	    };
	
	    Color.prototype.hsl = function() {
	      return rgb2hsl(this._rgb);
	    };
	
	    Color.prototype.hsv = function() {
	      return rgb2hsv(this._rgb);
	    };
	
	    Color.prototype.lab = function() {
	      return rgb2lab(this._rgb);
	    };
	
	    Color.prototype.lch = function() {
	      return rgb2lch(this._rgb);
	    };
	
	    Color.prototype.hsi = function() {
	      return rgb2hsi(this._rgb);
	    };
	
	    Color.prototype.gl = function() {
	      return [this._rgb[0] / 255, this._rgb[1] / 255, this._rgb[2] / 255, this._rgb[3]];
	    };
	
	    Color.prototype.luminance = function() {
	      return luminance(this._rgb);
	    };
	
	    Color.prototype.name = function() {
	      var h, k;
	
	      h = this.hex();
	      for (k in chroma.colors) {
	        if (h === chroma.colors[k]) {
	          return k;
	        }
	      }
	      return h;
	    };
	
	    Color.prototype.alpha = function(alpha) {
	      if (arguments.length) {
	        this._rgb[3] = alpha;
	        return this;
	      }
	      return this._rgb[3];
	    };
	
	    Color.prototype.css = function(mode) {
	      var hsl, me, rgb, rnd;
	
	      if (mode == null) {
	        mode = 'rgb';
	      }
	      me = this;
	      rgb = me._rgb;
	      if (mode.length === 3 && rgb[3] < 1) {
	        mode += 'a';
	      }
	      if (mode === 'rgb') {
	        return mode + '(' + rgb.slice(0, 3).join(',') + ')';
	      } else if (mode === 'rgba') {
	        return mode + '(' + rgb.join(',') + ')';
	      } else if (mode === 'hsl' || mode === 'hsla') {
	        hsl = me.hsl();
	        rnd = function(a) {
	          return Math.round(a * 100) / 100;
	        };
	        hsl[0] = rnd(hsl[0]);
	        hsl[1] = rnd(hsl[1] * 100) + '%';
	        hsl[2] = rnd(hsl[2] * 100) + '%';
	        if (mode.length === 4) {
	          hsl[3] = rgb[3];
	        }
	        return mode + '(' + hsl.join(',') + ')';
	      }
	    };
	
	    Color.prototype.interpolate = function(f, col, m) {
	      /*
	      interpolates between colors
	      f = 0 --> me
	      f = 1 --> col
	      */
	
	      var dh, hue, hue0, hue1, lbv, lbv0, lbv1, me, res, sat, sat0, sat1, xyz0, xyz1;
	
	      me = this;
	      if (m == null) {
	        m = 'rgb';
	      }
	      if (type(col) === "string") {
	        col = new Color(col);
	      }
	      if (m === 'hsl' || m === 'hsv' || m === 'lch' || m === 'hsi') {
	        if (m === 'hsl') {
	          xyz0 = me.hsl();
	          xyz1 = col.hsl();
	        } else if (m === 'hsv') {
	          xyz0 = me.hsv();
	          xyz1 = col.hsv();
	        } else if (m === 'hsi') {
	          xyz0 = me.hsi();
	          xyz1 = col.hsi();
	        } else if (m === 'lch') {
	          xyz0 = me.lch();
	          xyz1 = col.lch();
	        }
	        if (m.substr(0, 1) === 'h') {
	          hue0 = xyz0[0], sat0 = xyz0[1], lbv0 = xyz0[2];
	          hue1 = xyz1[0], sat1 = xyz1[1], lbv1 = xyz1[2];
	        } else {
	          lbv0 = xyz0[0], sat0 = xyz0[1], hue0 = xyz0[2];
	          lbv1 = xyz1[0], sat1 = xyz1[1], hue1 = xyz1[2];
	        }
	        if (!isNaN(hue0) && !isNaN(hue1)) {
	          if (hue1 > hue0 && hue1 - hue0 > 180) {
	            dh = hue1 - (hue0 + 360);
	          } else if (hue1 < hue0 && hue0 - hue1 > 180) {
	            dh = hue1 + 360 - hue0;
	          } else {
	            dh = hue1 - hue0;
	          }
	          hue = hue0 + f * dh;
	        } else if (!isNaN(hue0)) {
	          hue = hue0;
	          if ((lbv1 === 1 || lbv1 === 0) && m !== 'hsv') {
	            sat = sat0;
	          }
	        } else if (!isNaN(hue1)) {
	          hue = hue1;
	          if ((lbv0 === 1 || lbv0 === 0) && m !== 'hsv') {
	            sat = sat1;
	          }
	        } else {
	          hue = Number.NaN;
	        }
	        if (sat == null) {
	          sat = sat0 + f * (sat1 - sat0);
	        }
	        lbv = lbv0 + f * (lbv1 - lbv0);
	        if (m.substr(0, 1) === 'h') {
	          res = new Color(hue, sat, lbv, m);
	        } else {
	          res = new Color(lbv, sat, hue, m);
	        }
	      } else if (m === 'rgb') {
	        xyz0 = me._rgb;
	        xyz1 = col._rgb;
	        res = new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m);
	      } else if (m === 'lab') {
	        xyz0 = me.lab();
	        xyz1 = col.lab();
	        res = new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m);
	      } else {
	        throw "color mode " + m + " is not supported";
	      }
	      res.alpha(me.alpha() + f * (col.alpha() - me.alpha()));
	      return res;
	    };
	
	    Color.prototype.premultiply = function() {
	      var a, rgb;
	
	      rgb = this.rgb();
	      a = this.alpha();
	      return chroma(rgb[0] * a, rgb[1] * a, rgb[2] * a, a);
	    };
	
	    Color.prototype.darken = function(amount) {
	      var lch, me;
	
	      if (amount == null) {
	        amount = 20;
	      }
	      me = this;
	      lch = me.lch();
	      lch[0] -= amount;
	      return chroma.lch(lch).alpha(me.alpha());
	    };
	
	    Color.prototype.darker = function(amount) {
	      return this.darken(amount);
	    };
	
	    Color.prototype.brighten = function(amount) {
	      if (amount == null) {
	        amount = 20;
	      }
	      return this.darken(-amount);
	    };
	
	    Color.prototype.brighter = function(amount) {
	      return this.brighten(amount);
	    };
	
	    Color.prototype.saturate = function(amount) {
	      var lch, me;
	
	      if (amount == null) {
	        amount = 20;
	      }
	      me = this;
	      lch = me.lch();
	      lch[1] += amount;
	      return chroma.lch(lch).alpha(me.alpha());
	    };
	
	    Color.prototype.desaturate = function(amount) {
	      if (amount == null) {
	        amount = 20;
	      }
	      return this.saturate(-amount);
	    };
	
	    return Color;
	
	  })();
	
	  clip_rgb = function(rgb) {
	    var i;
	
	    for (i in rgb) {
	      if (i < 3) {
	        if (rgb[i] < 0) {
	          rgb[i] = 0;
	        }
	        if (rgb[i] > 255) {
	          rgb[i] = 255;
	        }
	      } else if (i === 3) {
	        if (rgb[i] < 0) {
	          rgb[i] = 0;
	        }
	        if (rgb[i] > 1) {
	          rgb[i] = 1;
	        }
	      }
	    }
	    return rgb;
	  };
	
	  css2rgb = function(css) {
	    var hsl, i, m, rgb, _i, _j, _k, _l;
	
	    css = css.toLowerCase();
	    if ((chroma.colors != null) && chroma.colors[css]) {
	      return hex2rgb(chroma.colors[css]);
	    }
	    if (m = css.match(/rgb\(\s*(\-?\d+),\s*(\-?\d+)\s*,\s*(\-?\d+)\s*\)/)) {
	      rgb = m.slice(1, 4);
	      for (i = _i = 0; _i <= 2; i = ++_i) {
	        rgb[i] = +rgb[i];
	      }
	      rgb[3] = 1;
	    } else if (m = css.match(/rgba\(\s*(\-?\d+),\s*(\-?\d+)\s*,\s*(\-?\d+)\s*,\s*([01]|[01]?\.\d+)\)/)) {
	      rgb = m.slice(1, 5);
	      for (i = _j = 0; _j <= 3; i = ++_j) {
	        rgb[i] = +rgb[i];
	      }
	    } else if (m = css.match(/rgb\(\s*(\-?\d+(?:\.\d+)?)%,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*\)/)) {
	      rgb = m.slice(1, 4);
	      for (i = _k = 0; _k <= 2; i = ++_k) {
	        rgb[i] = Math.round(rgb[i] * 2.55);
	      }
	      rgb[3] = 1;
	    } else if (m = css.match(/rgba\(\s*(\-?\d+(?:\.\d+)?)%,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)/)) {
	      rgb = m.slice(1, 5);
	      for (i = _l = 0; _l <= 2; i = ++_l) {
	        rgb[i] = Math.round(rgb[i] * 2.55);
	      }
	      rgb[3] = +rgb[3];
	    } else if (m = css.match(/hsl\(\s*(\-?\d+(?:\.\d+)?),\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*\)/)) {
	      hsl = m.slice(1, 4);
	      hsl[1] *= 0.01;
	      hsl[2] *= 0.01;
	      rgb = hsl2rgb(hsl);
	      rgb[3] = 1;
	    } else if (m = css.match(/hsla\(\s*(\-?\d+(?:\.\d+)?),\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)/)) {
	      hsl = m.slice(1, 4);
	      hsl[1] *= 0.01;
	      hsl[2] *= 0.01;
	      rgb = hsl2rgb(hsl);
	      rgb[3] = +m[4];
	    }
	    return rgb;
	  };
	
	  hex2rgb = function(hex) {
	    var a, b, g, r, rgb, u;
	
	    if (hex.match(/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) {
	      if (hex.length === 4 || hex.length === 7) {
	        hex = hex.substr(1);
	      }
	      if (hex.length === 3) {
	        hex = hex.split("");
	        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
	      }
	      u = parseInt(hex, 16);
	      r = u >> 16;
	      g = u >> 8 & 0xFF;
	      b = u & 0xFF;
	      return [r, g, b, 1];
	    }
	    if (hex.match(/^#?([A-Fa-f0-9]{8})$/)) {
	      if (hex.length === 9) {
	        hex = hex.substr(1);
	      }
	      u = parseInt(hex, 16);
	      r = u >> 24 & 0xFF;
	      g = u >> 16 & 0xFF;
	      b = u >> 8 & 0xFF;
	      a = u & 0xFF;
	      return [r, g, b, a];
	    }
	    if (rgb = css2rgb(hex)) {
	      return rgb;
	    }
	    throw "unknown color: " + hex;
	  };
	
	  hsi2rgb = function(h, s, i) {
	    /*
	    borrowed from here:
	    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp
	    */
	
	    var b, g, r, _ref;
	
	    _ref = unpack(arguments), h = _ref[0], s = _ref[1], i = _ref[2];
	    h /= 360;
	    if (h < 1 / 3) {
	      b = (1 - s) / 3;
	      r = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
	      g = 1 - (b + r);
	    } else if (h < 2 / 3) {
	      h -= 1 / 3;
	      r = (1 - s) / 3;
	      g = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
	      b = 1 - (r + g);
	    } else {
	      h -= 2 / 3;
	      g = (1 - s) / 3;
	      b = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
	      r = 1 - (g + b);
	    }
	    r = limit(i * r * 3);
	    g = limit(i * g * 3);
	    b = limit(i * b * 3);
	    return [r * 255, g * 255, b * 255];
	  };
	
	  hsl2rgb = function() {
	    var b, c, g, h, i, l, r, s, t1, t2, t3, _i, _ref, _ref1;
	
	    _ref = unpack(arguments), h = _ref[0], s = _ref[1], l = _ref[2];
	    if (s === 0) {
	      r = g = b = l * 255;
	    } else {
	      t3 = [0, 0, 0];
	      c = [0, 0, 0];
	      t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
	      t1 = 2 * l - t2;
	      h /= 360;
	      t3[0] = h + 1 / 3;
	      t3[1] = h;
	      t3[2] = h - 1 / 3;
	      for (i = _i = 0; _i <= 2; i = ++_i) {
	        if (t3[i] < 0) {
	          t3[i] += 1;
	        }
	        if (t3[i] > 1) {
	          t3[i] -= 1;
	        }
	        if (6 * t3[i] < 1) {
	          c[i] = t1 + (t2 - t1) * 6 * t3[i];
	        } else if (2 * t3[i] < 1) {
	          c[i] = t2;
	        } else if (3 * t3[i] < 2) {
	          c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6;
	        } else {
	          c[i] = t1;
	        }
	      }
	      _ref1 = [Math.round(c[0] * 255), Math.round(c[1] * 255), Math.round(c[2] * 255)], r = _ref1[0], g = _ref1[1], b = _ref1[2];
	    }
	    return [r, g, b];
	  };
	
	  hsv2rgb = function() {
	    var b, f, g, h, i, p, q, r, s, t, v, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
	
	    _ref = unpack(arguments), h = _ref[0], s = _ref[1], v = _ref[2];
	    v *= 255;
	    if (s === 0) {
	      r = g = b = v;
	    } else {
	      if (h === 360) {
	        h = 0;
	      }
	      if (h > 360) {
	        h -= 360;
	      }
	      if (h < 0) {
	        h += 360;
	      }
	      h /= 60;
	      i = Math.floor(h);
	      f = h - i;
	      p = v * (1 - s);
	      q = v * (1 - s * f);
	      t = v * (1 - s * (1 - f));
	      switch (i) {
	        case 0:
	          _ref1 = [v, t, p], r = _ref1[0], g = _ref1[1], b = _ref1[2];
	          break;
	        case 1:
	          _ref2 = [q, v, p], r = _ref2[0], g = _ref2[1], b = _ref2[2];
	          break;
	        case 2:
	          _ref3 = [p, v, t], r = _ref3[0], g = _ref3[1], b = _ref3[2];
	          break;
	        case 3:
	          _ref4 = [p, q, v], r = _ref4[0], g = _ref4[1], b = _ref4[2];
	          break;
	        case 4:
	          _ref5 = [t, p, v], r = _ref5[0], g = _ref5[1], b = _ref5[2];
	          break;
	        case 5:
	          _ref6 = [v, p, q], r = _ref6[0], g = _ref6[1], b = _ref6[2];
	      }
	    }
	    r = Math.round(r);
	    g = Math.round(g);
	    b = Math.round(b);
	    return [r, g, b];
	  };
	
	  K = 18;
	
	  X = 0.950470;
	
	  Y = 1;
	
	  Z = 1.088830;
	
	  lab2lch = function() {
	    var a, b, c, h, l, _ref;
	
	    _ref = unpack(arguments), l = _ref[0], a = _ref[1], b = _ref[2];
	    c = Math.sqrt(a * a + b * b);
	    h = Math.atan2(b, a) / Math.PI * 180;
	    return [l, c, h];
	  };
	
	  lab2rgb = function(l, a, b) {
	    /*
	    adapted to match d3 implementation
	    */
	
	    var g, r, x, y, z, _ref, _ref1;
	
	    if (l !== void 0 && l.length === 3) {
	      _ref = l, l = _ref[0], a = _ref[1], b = _ref[2];
	    }
	    if (l !== void 0 && l.length === 3) {
	      _ref1 = l, l = _ref1[0], a = _ref1[1], b = _ref1[2];
	    }
	    y = (l + 16) / 116;
	    x = y + a / 500;
	    z = y - b / 200;
	    x = lab_xyz(x) * X;
	    y = lab_xyz(y) * Y;
	    z = lab_xyz(z) * Z;
	    r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);
	    g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);
	    b = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);
	    return [limit(r, 0, 255), limit(g, 0, 255), limit(b, 0, 255), 1];
	  };
	
	  lab_xyz = function(x) {
	    if (x > 0.206893034) {
	      return x * x * x;
	    } else {
	      return (x - 4 / 29) / 7.787037;
	    }
	  };
	
	  xyz_rgb = function(r) {
	    return Math.round(255 * (r <= 0.00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055));
	  };
	
	  lch2lab = function() {
	    /*
	    Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel. These formulas were invented by David Dalrymple to obtain maximum contrast without going out of gamut if the parameters are in the range 0-1.
	    A saturation multiplier was added by Gregor Aisch
	    */
	
	    var c, h, l, _ref;
	
	    _ref = unpack(arguments), l = _ref[0], c = _ref[1], h = _ref[2];
	    h = h * Math.PI / 180;
	    return [l, Math.cos(h) * c, Math.sin(h) * c];
	  };
	
	  lch2rgb = function(l, c, h) {
	    var L, a, b, g, r, _ref, _ref1;
	
	    _ref = lch2lab(l, c, h), L = _ref[0], a = _ref[1], b = _ref[2];
	    _ref1 = lab2rgb(L, a, b), r = _ref1[0], g = _ref1[1], b = _ref1[2];
	    return [limit(r, 0, 255), limit(g, 0, 255), limit(b, 0, 255)];
	  };
	
	  luminance = function(r, g, b) {
	    var _ref;
	
	    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];
	    r = luminance_x(r);
	    g = luminance_x(g);
	    b = luminance_x(b);
	    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
	  };
	
	  luminance_x = function(x) {
	    x /= 255;
	    if (x <= 0.03928) {
	      return x / 12.92;
	    } else {
	      return Math.pow((x + 0.055) / 1.055, 2.4);
	    }
	  };
	
	  rgb2hex = function() {
	    var b, g, r, str, u, _ref;
	
	    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];
	    u = r << 16 | g << 8 | b;
	    str = "000000" + u.toString(16);
	    return "#" + str.substr(str.length - 6);
	  };
	
	  rgb2hsi = function() {
	    /*
	    borrowed from here:
	    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp
	    */
	
	    var TWOPI, b, g, h, i, min, r, s, _ref;
	
	    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];
	    TWOPI = Math.PI * 2;
	    r /= 255;
	    g /= 255;
	    b /= 255;
	    min = Math.min(r, g, b);
	    i = (r + g + b) / 3;
	    s = 1 - min / i;
	    if (s === 0) {
	      h = 0;
	    } else {
	      h = ((r - g) + (r - b)) / 2;
	      h /= Math.sqrt((r - g) * (r - g) + (r - b) * (g - b));
	      h = Math.acos(h);
	      if (b > g) {
	        h = TWOPI - h;
	      }
	      h /= TWOPI;
	    }
	    return [h * 360, s, i];
	  };
	
	  rgb2hsl = function(r, g, b) {
	    var h, l, max, min, s, _ref;
	
	    if (r !== void 0 && r.length >= 3) {
	      _ref = r, r = _ref[0], g = _ref[1], b = _ref[2];
	    }
	    r /= 255;
	    g /= 255;
	    b /= 255;
	    min = Math.min(r, g, b);
	    max = Math.max(r, g, b);
	    l = (max + min) / 2;
	    if (max === min) {
	      s = 0;
	      h = Number.NaN;
	    } else {
	      s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
	    }
	    if (r === max) {
	      h = (g - b) / (max - min);
	    } else if (g === max) {
	      h = 2 + (b - r) / (max - min);
	    } else if (b === max) {
	      h = 4 + (r - g) / (max - min);
	    }
	    h *= 60;
	    if (h < 0) {
	      h += 360;
	    }
	    return [h, s, l];
	  };
	
	  rgb2hsv = function() {
	    var b, delta, g, h, max, min, r, s, v, _ref;
	
	    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];
	    min = Math.min(r, g, b);
	    max = Math.max(r, g, b);
	    delta = max - min;
	    v = max / 255.0;
	    if (max === 0) {
	      h = Number.NaN;
	      s = 0;
	    } else {
	      s = delta / max;
	      if (r === max) {
	        h = (g - b) / delta;
	      }
	      if (g === max) {
	        h = 2 + (b - r) / delta;
	      }
	      if (b === max) {
	        h = 4 + (r - g) / delta;
	      }
	      h *= 60;
	      if (h < 0) {
	        h += 360;
	      }
	    }
	    return [h, s, v];
	  };
	
	  rgb2lab = function() {
	    var b, g, r, x, y, z, _ref;
	
	    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];
	    r = rgb_xyz(r);
	    g = rgb_xyz(g);
	    b = rgb_xyz(b);
	    x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / X);
	    y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / Y);
	    z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / Z);
	    return [116 * y - 16, 500 * (x - y), 200 * (y - z)];
	  };
	
	  rgb_xyz = function(r) {
	    if ((r /= 255) <= 0.04045) {
	      return r / 12.92;
	    } else {
	      return Math.pow((r + 0.055) / 1.055, 2.4);
	    }
	  };
	
	  xyz_lab = function(x) {
	    if (x > 0.008856) {
	      return Math.pow(x, 1 / 3);
	    } else {
	      return 7.787037 * x + 4 / 29;
	    }
	  };
	
	  rgb2lch = function() {
	    var a, b, g, l, r, _ref, _ref1;
	
	    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];
	    _ref1 = rgb2lab(r, g, b), l = _ref1[0], a = _ref1[1], b = _ref1[2];
	    return lab2lch(l, a, b);
	  };
	
	  /*
	      chroma.js
	  
	      Copyright (c) 2011-2013, Gregor Aisch
	      All rights reserved.
	  
	      Redistribution and use in source and binary forms, with or without
	      modification, are permitted provided that the following conditions are met:
	  
	      * Redistributions of source code must retain the above copyright notice, this
	        list of conditions and the following disclaimer.
	  
	      * Redistributions in binary form must reproduce the above copyright notice,
	        this list of conditions and the following disclaimer in the documentation
	        and/or other materials provided with the distribution.
	  
	      * The name Gregor Aisch may not be used to endorse or promote products
	        derived from this software without specific prior written permission.
	  
	      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	  
	      @source: https://github.com/gka/chroma.js
	  */
	
	
	  chroma.scale = function(colors, positions) {
	    var classifyValue, f, getClass, getColor, resetCache, setColors, setDomain, tmap, _colorCache, _colors, _correctLightness, _domain, _fixed, _max, _min, _mode, _nacol, _numClasses, _out, _pos, _spread;
	
	    _mode = 'rgb';
	    _nacol = chroma('#ccc');
	    _spread = 0;
	    _fixed = false;
	    _domain = [0, 1];
	    _colors = [];
	    _out = false;
	    _pos = [];
	    _min = 0;
	    _max = 1;
	    _correctLightness = false;
	    _numClasses = 0;
	    _colorCache = {};
	    setColors = function(colors, positions) {
	      var c, col, _i, _j, _ref, _ref1, _ref2;
	
	      if (colors == null) {
	        colors = ['#ddd', '#222'];
	      }
	      if ((colors != null) && type(colors) === 'string' && (((_ref = chroma.brewer) != null ? _ref[colors] : void 0) != null)) {
	        colors = chroma.brewer[colors];
	      }
	      if (type(colors) === 'array') {
	        colors = colors.slice(0);
	        for (c = _i = 0, _ref1 = colors.length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; c = 0 <= _ref1 ? ++_i : --_i) {
	          col = colors[c];
	          if (type(col) === "string") {
	            colors[c] = chroma(col);
	          }
	        }
	        if (positions != null) {
	          _pos = positions;
	        } else {
	          _pos = [];
	          for (c = _j = 0, _ref2 = colors.length - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; c = 0 <= _ref2 ? ++_j : --_j) {
	            _pos.push(c / (colors.length - 1));
	          }
	        }
	      }
	      resetCache();
	      return _colors = colors;
	    };
	    setDomain = function(domain) {
	      if (domain == null) {
	        domain = [];
	      }
	      /*
	      # use this if you want to display a limited number of data classes
	      # possible methods are "equalinterval", "quantiles", "custom"
	      */
	
	      _domain = domain;
	      _min = domain[0];
	      _max = domain[domain.length - 1];
	      resetCache();
	      if (domain.length === 2) {
	        return _numClasses = 0;
	      } else {
	        return _numClasses = domain.length - 1;
	      }
	    };
	    getClass = function(value) {
	      var i, n;
	
	      if (_domain != null) {
	        n = _domain.length - 1;
	        i = 0;
	        while (i < n && value >= _domain[i]) {
	          i++;
	        }
	        return i - 1;
	      }
	      return 0;
	    };
	    tmap = function(t) {
	      return t;
	    };
	    classifyValue = function(value) {
	      var i, maxc, minc, n, val;
	
	      val = value;
	      if (_domain.length > 2) {
	        n = _domain.length - 1;
	        i = getClass(value);
	        minc = _domain[0] + (_domain[1] - _domain[0]) * (0 + _spread * 0.5);
	        maxc = _domain[n - 1] + (_domain[n] - _domain[n - 1]) * (1 - _spread * 0.5);
	        val = _min + ((_domain[i] + (_domain[i + 1] - _domain[i]) * 0.5 - minc) / (maxc - minc)) * (_max - _min);
	      }
	      return val;
	    };
	    getColor = function(val, bypassMap) {
	      var c, col, f0, i, k, p, t, _i, _ref;
	
	      if (bypassMap == null) {
	        bypassMap = false;
	      }
	      if (isNaN(val)) {
	        return _nacol;
	      }
	      if (!bypassMap) {
	        if (_domain.length > 2) {
	          c = getClass(val);
	          t = c / (_numClasses - 1);
	        } else {
	          t = f0 = (val - _min) / (_max - _min);
	          t = Math.min(1, Math.max(0, t));
	        }
	      } else {
	        t = val;
	      }
	      if (!bypassMap) {
	        t = tmap(t);
	      }
	      k = Math.floor(t * 10000);
	      if (_colorCache[k]) {
	        col = _colorCache[k];
	      } else {
	        if (type(_colors) === 'array') {
	          for (i = _i = 0, _ref = _pos.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
	            p = _pos[i];
	            if (t <= p) {
	              col = _colors[i];
	              break;
	            }
	            if (t >= p && i === _pos.length - 1) {
	              col = _colors[i];
	              break;
	            }
	            if (t > p && t < _pos[i + 1]) {
	              t = (t - p) / (_pos[i + 1] - p);
	              col = chroma.interpolate(_colors[i], _colors[i + 1], t, _mode);
	              break;
	            }
	          }
	        } else if (type(_colors) === 'function') {
	          col = _colors(t);
	        }
	        _colorCache[k] = col;
	      }
	      return col;
	    };
	    resetCache = function() {
	      return _colorCache = {};
	    };
	    setColors(colors, positions);
	    f = function(v) {
	      var c;
	
	      c = getColor(v);
	      if (_out && c[_out]) {
	        return c[_out]();
	      } else {
	        return c;
	      }
	    };
	    f.domain = function(domain, classes, mode, key) {
	      var d;
	
	      if (mode == null) {
	        mode = 'e';
	      }
	      if (!arguments.length) {
	        return _domain;
	      }
	      if (classes != null) {
	        d = chroma.analyze(domain, key);
	        if (classes === 0) {
	          domain = [d.min, d.max];
	        } else {
	          domain = chroma.limits(d, mode, classes);
	        }
	      }
	      setDomain(domain);
	      return f;
	    };
	    f.mode = function(_m) {
	      if (!arguments.length) {
	        return _mode;
	      }
	      _mode = _m;
	      resetCache();
	      return f;
	    };
	    f.range = function(colors, _pos) {
	      setColors(colors, _pos);
	      return f;
	    };
	    f.out = function(_o) {
	      _out = _o;
	      return f;
	    };
	    f.spread = function(val) {
	      if (!arguments.length) {
	        return _spread;
	      }
	      _spread = val;
	      return f;
	    };
	    f.correctLightness = function(v) {
	      if (!arguments.length) {
	        return _correctLightness;
	      }
	      _correctLightness = v;
	      resetCache();
	      if (_correctLightness) {
	        tmap = function(t) {
	          var L0, L1, L_actual, L_diff, L_ideal, max_iter, pol, t0, t1;
	
	          L0 = getColor(0, true).lab()[0];
	          L1 = getColor(1, true).lab()[0];
	          pol = L0 > L1;
	          L_actual = getColor(t, true).lab()[0];
	          L_ideal = L0 + (L1 - L0) * t;
	          L_diff = L_actual - L_ideal;
	          t0 = 0;
	          t1 = 1;
	          max_iter = 20;
	          while (Math.abs(L_diff) > 1e-2 && max_iter-- > 0) {
	            (function() {
	              if (pol) {
	                L_diff *= -1;
	              }
	              if (L_diff < 0) {
	                t0 = t;
	                t += (t1 - t) * 0.5;
	              } else {
	                t1 = t;
	                t += (t0 - t) * 0.5;
	              }
	              L_actual = getColor(t, true).lab()[0];
	              return L_diff = L_actual - L_ideal;
	            })();
	          }
	          return t;
	        };
	      } else {
	        tmap = function(t) {
	          return t;
	        };
	      }
	      return f;
	    };
	    f.colors = function(out) {
	      var i, samples, _i, _j, _len, _ref;
	
	      if (out == null) {
	        out = 'hex';
	      }
	      colors = [];
	      samples = [];
	      if (_domain.length > 2) {
	        for (i = _i = 1, _ref = _domain.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
	          samples.push((_domain[i - 1] + _domain[i]) * 0.5);
	        }
	      } else {
	        samples = _domain;
	      }
	      for (_j = 0, _len = samples.length; _j < _len; _j++) {
	        i = samples[_j];
	        colors.push(f(i)[out]());
	      }
	      return colors;
	    };
	    return f;
	  };
	
	  if ((_ref = chroma.scales) == null) {
	    chroma.scales = {};
	  }
	
	  chroma.scales.cool = function() {
	    return chroma.scale([chroma.hsl(180, 1, .9), chroma.hsl(250, .7, .4)]);
	  };
	
	  chroma.scales.hot = function() {
	    return chroma.scale(['#000', '#f00', '#ff0', '#fff'], [0, .25, .75, 1]).mode('rgb');
	  };
	
	  /*
	      chroma.js
	  
	      Copyright (c) 2011-2013, Gregor Aisch
	      All rights reserved.
	  
	      Redistribution and use in source and binary forms, with or without
	      modification, are permitted provided that the following conditions are met:
	  
	      * Redistributions of source code must retain the above copyright notice, this
	        list of conditions and the following disclaimer.
	  
	      * Redistributions in binary form must reproduce the above copyright notice,
	        this list of conditions and the following disclaimer in the documentation
	        and/or other materials provided with the distribution.
	  
	      * The name Gregor Aisch may not be used to endorse or promote products
	        derived from this software without specific prior written permission.
	  
	      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	  
	      @source: https://github.com/gka/chroma.js
	  */
	
	
	  chroma.analyze = function(data, key, filter) {
	    var add, k, r, val, visit, _i, _len;
	
	    r = {
	      min: Number.MAX_VALUE,
	      max: Number.MAX_VALUE * -1,
	      sum: 0,
	      values: [],
	      count: 0
	    };
	    if (filter == null) {
	      filter = function() {
	        return true;
	      };
	    }
	    add = function(val) {
	      if ((val != null) && !isNaN(val)) {
	        r.values.push(val);
	        r.sum += val;
	        if (val < r.min) {
	          r.min = val;
	        }
	        if (val > r.max) {
	          r.max = val;
	        }
	        r.count += 1;
	      }
	    };
	    visit = function(val, k) {
	      if (filter(val, k)) {
	        if ((key != null) && type(key) === 'function') {
	          return add(key(val));
	        } else if ((key != null) && type(key) === 'string' || type(key) === 'number') {
	          return add(val[key]);
	        } else {
	          return add(val);
	        }
	      }
	    };
	    if (type(data) === 'array') {
	      for (_i = 0, _len = data.length; _i < _len; _i++) {
	        val = data[_i];
	        visit(val);
	      }
	    } else {
	      for (k in data) {
	        val = data[k];
	        visit(val, k);
	      }
	    }
	    r.domain = [r.min, r.max];
	    r.limits = function(mode, num) {
	      return chroma.limits(r, mode, num);
	    };
	    return r;
	  };
	
	  chroma.limits = function(data, mode, num) {
	    var assignments, best, centroids, cluster, clusterSizes, dist, i, j, kClusters, limits, max, max_log, min, min_log, mindist, n, nb_iters, newCentroids, p, pb, pr, repeat, sum, tmpKMeansBreaks, value, values, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _s, _t, _u, _v, _w;
	
	    if (mode == null) {
	      mode = 'equal';
	    }
	    if (num == null) {
	      num = 7;
	    }
	    if (data.values == null) {
	      data = chroma.analyze(data);
	    }
	    min = data.min;
	    max = data.max;
	    sum = data.sum;
	    values = data.values.sort(function(a, b) {
	      return a - b;
	    });
	    limits = [];
	    if (mode.substr(0, 1) === 'c') {
	      limits.push(min);
	      limits.push(max);
	    }
	    if (mode.substr(0, 1) === 'e') {
	      limits.push(min);
	      for (i = _i = 1, _ref1 = num - 1; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
	        limits.push(min + (i / num) * (max - min));
	      }
	      limits.push(max);
	    } else if (mode.substr(0, 1) === 'l') {
	      if (min <= 0) {
	        throw 'Logarithmic scales are only possible for values > 0';
	      }
	      min_log = Math.LOG10E * Math.log(min);
	      max_log = Math.LOG10E * Math.log(max);
	      limits.push(min);
	      for (i = _j = 1, _ref2 = num - 1; 1 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 1 <= _ref2 ? ++_j : --_j) {
	        limits.push(Math.pow(10, min_log + (i / num) * (max_log - min_log)));
	      }
	      limits.push(max);
	    } else if (mode.substr(0, 1) === 'q') {
	      limits.push(min);
	      for (i = _k = 1, _ref3 = num - 1; 1 <= _ref3 ? _k <= _ref3 : _k >= _ref3; i = 1 <= _ref3 ? ++_k : --_k) {
	        p = values.length * i / num;
	        pb = Math.floor(p);
	        if (pb === p) {
	          limits.push(values[pb]);
	        } else {
	          pr = p - pb;
	          limits.push(values[pb] * pr + values[pb + 1] * (1 - pr));
	        }
	      }
	      limits.push(max);
	    } else if (mode.substr(0, 1) === 'k') {
	      /*
	      implementation based on
	      http://code.google.com/p/figue/source/browse/trunk/figue.js#336
	      simplified for 1-d input values
	      */
	
	      n = values.length;
	      assignments = new Array(n);
	      clusterSizes = new Array(num);
	      repeat = true;
	      nb_iters = 0;
	      centroids = null;
	      centroids = [];
	      centroids.push(min);
	      for (i = _l = 1, _ref4 = num - 1; 1 <= _ref4 ? _l <= _ref4 : _l >= _ref4; i = 1 <= _ref4 ? ++_l : --_l) {
	        centroids.push(min + (i / num) * (max - min));
	      }
	      centroids.push(max);
	      while (repeat) {
	        for (j = _m = 0, _ref5 = num - 1; 0 <= _ref5 ? _m <= _ref5 : _m >= _ref5; j = 0 <= _ref5 ? ++_m : --_m) {
	          clusterSizes[j] = 0;
	        }
	        for (i = _n = 0, _ref6 = n - 1; 0 <= _ref6 ? _n <= _ref6 : _n >= _ref6; i = 0 <= _ref6 ? ++_n : --_n) {
	          value = values[i];
	          mindist = Number.MAX_VALUE;
	          for (j = _o = 0, _ref7 = num - 1; 0 <= _ref7 ? _o <= _ref7 : _o >= _ref7; j = 0 <= _ref7 ? ++_o : --_o) {
	            dist = Math.abs(centroids[j] - value);
	            if (dist < mindist) {
	              mindist = dist;
	              best = j;
	            }
	          }
	          clusterSizes[best]++;
	          assignments[i] = best;
	        }
	        newCentroids = new Array(num);
	        for (j = _p = 0, _ref8 = num - 1; 0 <= _ref8 ? _p <= _ref8 : _p >= _ref8; j = 0 <= _ref8 ? ++_p : --_p) {
	          newCentroids[j] = null;
	        }
	        for (i = _q = 0, _ref9 = n - 1; 0 <= _ref9 ? _q <= _ref9 : _q >= _ref9; i = 0 <= _ref9 ? ++_q : --_q) {
	          cluster = assignments[i];
	          if (newCentroids[cluster] === null) {
	            newCentroids[cluster] = values[i];
	          } else {
	            newCentroids[cluster] += values[i];
	          }
	        }
	        for (j = _r = 0, _ref10 = num - 1; 0 <= _ref10 ? _r <= _ref10 : _r >= _ref10; j = 0 <= _ref10 ? ++_r : --_r) {
	          newCentroids[j] *= 1 / clusterSizes[j];
	        }
	        repeat = false;
	        for (j = _s = 0, _ref11 = num - 1; 0 <= _ref11 ? _s <= _ref11 : _s >= _ref11; j = 0 <= _ref11 ? ++_s : --_s) {
	          if (newCentroids[j] !== centroids[i]) {
	            repeat = true;
	            break;
	          }
	        }
	        centroids = newCentroids;
	        nb_iters++;
	        if (nb_iters > 200) {
	          repeat = false;
	        }
	      }
	      kClusters = {};
	      for (j = _t = 0, _ref12 = num - 1; 0 <= _ref12 ? _t <= _ref12 : _t >= _ref12; j = 0 <= _ref12 ? ++_t : --_t) {
	        kClusters[j] = [];
	      }
	      for (i = _u = 0, _ref13 = n - 1; 0 <= _ref13 ? _u <= _ref13 : _u >= _ref13; i = 0 <= _ref13 ? ++_u : --_u) {
	        cluster = assignments[i];
	        kClusters[cluster].push(values[i]);
	      }
	      tmpKMeansBreaks = [];
	      for (j = _v = 0, _ref14 = num - 1; 0 <= _ref14 ? _v <= _ref14 : _v >= _ref14; j = 0 <= _ref14 ? ++_v : --_v) {
	        tmpKMeansBreaks.push(kClusters[j][0]);
	        tmpKMeansBreaks.push(kClusters[j][kClusters[j].length - 1]);
	      }
	      tmpKMeansBreaks = tmpKMeansBreaks.sort(function(a, b) {
	        return a - b;
	      });
	      limits.push(tmpKMeansBreaks[0]);
	      for (i = _w = 1, _ref15 = tmpKMeansBreaks.length - 1; _w <= _ref15; i = _w += 2) {
	        if (!isNaN(tmpKMeansBreaks[i])) {
	          limits.push(tmpKMeansBreaks[i]);
	        }
	      }
	    }
	    return limits;
	  };
	
	  /**
	  	ColorBrewer colors for chroma.js
	  
	  	Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The 
	  	Pennsylvania State University.
	  
	  	Licensed under the Apache License, Version 2.0 (the "License"); 
	  	you may not use this file except in compliance with the License.
	  	You may obtain a copy of the License at	
	  	http://www.apache.org/licenses/LICENSE-2.0
	  
	  	Unless required by applicable law or agreed to in writing, software distributed
	  	under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
	  	CONDITIONS OF ANY KIND, either express or implied. See the License for the
	  	specific language governing permissions and limitations under the License.
	  
	      @preserve
	  */
	
	
	  chroma.brewer = brewer = {
	    OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],
	    PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],
	    BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],
	    Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],
	    BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],
	    YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],
	    YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],
	    Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
	    RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],
	    Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
	    YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],
	    Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
	    GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],
	    Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],
	    YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],
	    PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],
	    Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
	    PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],
	    Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
	    RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
	    RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
	    PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
	    PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
	    RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
	    BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
	    RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],
	    PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],
	    Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
	    Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
	    Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
	    Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
	    Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
	    Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],
	    Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
	    Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2']
	  };
	
	  /**
	  	X11 color names
	  
	  	http://www.w3.org/TR/css3-color/#svg-color
	  */
	
	
	  chroma.colors = colors = {
	    indigo: "#4b0082",
	    gold: "#ffd700",
	    hotpink: "#ff69b4",
	    firebrick: "#b22222",
	    indianred: "#cd5c5c",
	    yellow: "#ffff00",
	    mistyrose: "#ffe4e1",
	    darkolivegreen: "#556b2f",
	    olive: "#808000",
	    darkseagreen: "#8fbc8f",
	    pink: "#ffc0cb",
	    tomato: "#ff6347",
	    lightcoral: "#f08080",
	    orangered: "#ff4500",
	    navajowhite: "#ffdead",
	    lime: "#00ff00",
	    palegreen: "#98fb98",
	    darkslategrey: "#2f4f4f",
	    greenyellow: "#adff2f",
	    burlywood: "#deb887",
	    seashell: "#fff5ee",
	    mediumspringgreen: "#00fa9a",
	    fuchsia: "#ff00ff",
	    papayawhip: "#ffefd5",
	    blanchedalmond: "#ffebcd",
	    chartreuse: "#7fff00",
	    dimgray: "#696969",
	    black: "#000000",
	    peachpuff: "#ffdab9",
	    springgreen: "#00ff7f",
	    aquamarine: "#7fffd4",
	    white: "#ffffff",
	    orange: "#ffa500",
	    lightsalmon: "#ffa07a",
	    darkslategray: "#2f4f4f",
	    brown: "#a52a2a",
	    ivory: "#fffff0",
	    dodgerblue: "#1e90ff",
	    peru: "#cd853f",
	    lawngreen: "#7cfc00",
	    chocolate: "#d2691e",
	    crimson: "#dc143c",
	    forestgreen: "#228b22",
	    darkgrey: "#a9a9a9",
	    lightseagreen: "#20b2aa",
	    cyan: "#00ffff",
	    mintcream: "#f5fffa",
	    silver: "#c0c0c0",
	    antiquewhite: "#faebd7",
	    mediumorchid: "#ba55d3",
	    skyblue: "#87ceeb",
	    gray: "#808080",
	    darkturquoise: "#00ced1",
	    goldenrod: "#daa520",
	    darkgreen: "#006400",
	    floralwhite: "#fffaf0",
	    darkviolet: "#9400d3",
	    darkgray: "#a9a9a9",
	    moccasin: "#ffe4b5",
	    saddlebrown: "#8b4513",
	    grey: "#808080",
	    darkslateblue: "#483d8b",
	    lightskyblue: "#87cefa",
	    lightpink: "#ffb6c1",
	    mediumvioletred: "#c71585",
	    slategrey: "#708090",
	    red: "#ff0000",
	    deeppink: "#ff1493",
	    limegreen: "#32cd32",
	    darkmagenta: "#8b008b",
	    palegoldenrod: "#eee8aa",
	    plum: "#dda0dd",
	    turquoise: "#40e0d0",
	    lightgrey: "#d3d3d3",
	    lightgoldenrodyellow: "#fafad2",
	    darkgoldenrod: "#b8860b",
	    lavender: "#e6e6fa",
	    maroon: "#800000",
	    yellowgreen: "#9acd32",
	    sandybrown: "#f4a460",
	    thistle: "#d8bfd8",
	    violet: "#ee82ee",
	    navy: "#000080",
	    magenta: "#ff00ff",
	    dimgrey: "#696969",
	    tan: "#d2b48c",
	    rosybrown: "#bc8f8f",
	    olivedrab: "#6b8e23",
	    blue: "#0000ff",
	    lightblue: "#add8e6",
	    ghostwhite: "#f8f8ff",
	    honeydew: "#f0fff0",
	    cornflowerblue: "#6495ed",
	    slateblue: "#6a5acd",
	    linen: "#faf0e6",
	    darkblue: "#00008b",
	    powderblue: "#b0e0e6",
	    seagreen: "#2e8b57",
	    darkkhaki: "#bdb76b",
	    snow: "#fffafa",
	    sienna: "#a0522d",
	    mediumblue: "#0000cd",
	    royalblue: "#4169e1",
	    lightcyan: "#e0ffff",
	    green: "#008000",
	    mediumpurple: "#9370db",
	    midnightblue: "#191970",
	    cornsilk: "#fff8dc",
	    paleturquoise: "#afeeee",
	    bisque: "#ffe4c4",
	    slategray: "#708090",
	    darkcyan: "#008b8b",
	    khaki: "#f0e68c",
	    wheat: "#f5deb3",
	    teal: "#008080",
	    darkorchid: "#9932cc",
	    deepskyblue: "#00bfff",
	    salmon: "#fa8072",
	    darkred: "#8b0000",
	    steelblue: "#4682b4",
	    palevioletred: "#db7093",
	    lightslategray: "#778899",
	    aliceblue: "#f0f8ff",
	    lightslategrey: "#778899",
	    lightgreen: "#90ee90",
	    orchid: "#da70d6",
	    gainsboro: "#dcdcdc",
	    mediumseagreen: "#3cb371",
	    lightgray: "#d3d3d3",
	    mediumturquoise: "#48d1cc",
	    lemonchiffon: "#fffacd",
	    cadetblue: "#5f9ea0",
	    lightyellow: "#ffffe0",
	    lavenderblush: "#fff0f5",
	    coral: "#ff7f50",
	    purple: "#800080",
	    aqua: "#00ffff",
	    whitesmoke: "#f5f5f5",
	    mediumslateblue: "#7b68ee",
	    darkorange: "#ff8c00",
	    mediumaquamarine: "#66cdaa",
	    darksalmon: "#e9967a",
	    beige: "#f5f5dc",
	    blueviolet: "#8a2be2",
	    azure: "#f0ffff",
	    lightsteelblue: "#b0c4de",
	    oldlace: "#fdf5e6"
	  };
	
	  /*
	      chroma.js
	  
	      Copyright (c) 2011-2013, Gregor Aisch
	      All rights reserved.
	  
	      Redistribution and use in source and binary forms, with or without
	      modification, are permitted provided that the following conditions are met:
	  
	      * Redistributions of source code must retain the above copyright notice, this
	        list of conditions and the following disclaimer.
	  
	      * Redistributions in binary form must reproduce the above copyright notice,
	        this list of conditions and the following disclaimer in the documentation
	        and/or other materials provided with the distribution.
	  
	      * The name Gregor Aisch may not be used to endorse or promote products
	        derived from this software without specific prior written permission.
	  
	      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	  
	      @source: https://github.com/gka/chroma.js
	  */
	
	
	  type = (function() {
	    /*
	    for browser-safe type checking+
	    ported from jQuery's $.type
	    */
	
	    var classToType, name, _i, _len, _ref1;
	
	    classToType = {};
	    _ref1 = "Boolean Number String Function Array Date RegExp Undefined Null".split(" ");
	    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	      name = _ref1[_i];
	      classToType["[object " + name + "]"] = name.toLowerCase();
	    }
	    return function(obj) {
	      var strType;
	
	      strType = Object.prototype.toString.call(obj);
	      return classToType[strType] || "object";
	    };
	  })();
	
	  limit = function(x, min, max) {
	    if (min == null) {
	      min = 0;
	    }
	    if (max == null) {
	      max = 1;
	    }
	    if (x < min) {
	      x = min;
	    }
	    if (x > max) {
	      x = max;
	    }
	    return x;
	  };
	
	  unpack = function(args) {
	    if (args.length >= 3) {
	      return args;
	    } else {
	      return args[0];
	    }
	  };
	
	  TWOPI = Math.PI * 2;
	
	  PITHIRD = Math.PI / 3;
	
	  cos = Math.cos;
	
	  /*
	  interpolates between a set of colors uzing a bezier spline
	  */
	
	
	  bezier = function(colors) {
	    var I, I0, I1, c, lab0, lab1, lab2, lab3, _ref1, _ref2, _ref3;
	
	    colors = (function() {
	      var _i, _len, _results;
	
	      _results = [];
	      for (_i = 0, _len = colors.length; _i < _len; _i++) {
	        c = colors[_i];
	        _results.push(chroma(c));
	      }
	      return _results;
	    })();
	    if (colors.length === 2) {
	      _ref1 = (function() {
	        var _i, _len, _results;
	
	        _results = [];
	        for (_i = 0, _len = colors.length; _i < _len; _i++) {
	          c = colors[_i];
	          _results.push(c.lab());
	        }
	        return _results;
	      })(), lab0 = _ref1[0], lab1 = _ref1[1];
	      I = function(t) {
	        var i, lab;
	
	        lab = (function() {
	          var _i, _results;
	
	          _results = [];
	          for (i = _i = 0; _i <= 2; i = ++_i) {
	            _results.push(lab0[i] + t * (lab1[i] - lab0[i]));
	          }
	          return _results;
	        })();
	        return chroma.lab.apply(chroma, lab);
	      };
	    } else if (colors.length === 3) {
	      _ref2 = (function() {
	        var _i, _len, _results;
	
	        _results = [];
	        for (_i = 0, _len = colors.length; _i < _len; _i++) {
	          c = colors[_i];
	          _results.push(c.lab());
	        }
	        return _results;
	      })(), lab0 = _ref2[0], lab1 = _ref2[1], lab2 = _ref2[2];
	      I = function(t) {
	        var i, lab;
	
	        lab = (function() {
	          var _i, _results;
	
	          _results = [];
	          for (i = _i = 0; _i <= 2; i = ++_i) {
	            _results.push((1 - t) * (1 - t) * lab0[i] + 2 * (1 - t) * t * lab1[i] + t * t * lab2[i]);
	          }
	          return _results;
	        })();
	        return chroma.lab.apply(chroma, lab);
	      };
	    } else if (colors.length === 4) {
	      _ref3 = (function() {
	        var _i, _len, _results;
	
	        _results = [];
	        for (_i = 0, _len = colors.length; _i < _len; _i++) {
	          c = colors[_i];
	          _results.push(c.lab());
	        }
	        return _results;
	      })(), lab0 = _ref3[0], lab1 = _ref3[1], lab2 = _ref3[2], lab3 = _ref3[3];
	      I = function(t) {
	        var i, lab;
	
	        lab = (function() {
	          var _i, _results;
	
	          _results = [];
	          for (i = _i = 0; _i <= 2; i = ++_i) {
	            _results.push((1 - t) * (1 - t) * (1 - t) * lab0[i] + 3 * (1 - t) * (1 - t) * t * lab1[i] + 3 * (1 - t) * t * t * lab2[i] + t * t * t * lab3[i]);
	          }
	          return _results;
	        })();
	        return chroma.lab.apply(chroma, lab);
	      };
	    } else if (colors.length === 5) {
	      I0 = bezier(colors.slice(0, 3));
	      I1 = bezier(colors.slice(2, 5));
	      I = function(t) {
	        if (t < 0.5) {
	          return I0(t * 2);
	        } else {
	          return I1((t - 0.5) * 2);
	        }
	      };
	    }
	    return I;
	  };
	
	  chroma.interpolate.bezier = bezier;
	
	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92)(module)))

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAKrklEQVR42u2da8wVxR3Gf3O430VEQUVJkEriDVo0aGhKIUi8ENRQBIUUYosYDWn4AtpI/GAT0IQ0pPUDlkCLotQGKEZKQUuBiCGChiYaNa2taUhNrTaC8IbLy9MPO8eekPeyl5mdPcf5fX7f3f88z7Ozs7NnZiESiUQikUikIJIukbQ4KuFN38WSLqlqcUMkHVLCY9Eu5/o+ZrU9JGlIlc2XpHZJi6JtzvRdZDVV5ULQgfmNIVgQ7Sus74ILzK9OCLowv85ZSfdFG3Pre5/VsDPChcAO+I6qe85JmlMRQae4+JuSap1jteuOo6UPDFNc+RfSJml6YEFHSjqW4u+OSRoZuNbpVrO0lNcTSLooo/l1vpI0OZCgfes1p/jbuqB9A9U62WqVlUOSLqqq+XVOSLo1gKjr6wWkDIAkrQ9Q561Wo7z4C4ED8+t8IWlCiaIuazx5hgBI0rIS65xgtSmK+xA4NL/OfyTdWIKo0y4cRWcMwFlJ00qo80ariSvchcCD+XX+Jelaj6KOlvTZhSfNGADZY4z2WOe1VgvXFA+BR/PrHJN0jQdRB0r6S0cnzBEA2WMN9FDnNVYDX+QPQQnm1/m7pKscimokbensZDkDIHtM47DOq2zbfZM9BCWaX+dvkq50JOzKrk5UIACStNJRjVfaNpdF+hAEML/O+5IuLSjsrE7mzV0FoF3SrII1XmrbWjbpQiDpRYXjQ0kjcgp7U5oJlIIBqE9o3ZSzxhG2jaF4Me2U6XsBizycdVpT0lBJH6U5uIMAyJ5raI7p88MBdX0v9RS3fdFzJGCxhyQNTllrTdJraQ/sKACy56ylrHFwoNtqnSOZXxhJuljS2wGL/rOk/inqfDbLQR0GQJKeTXG8/rYtoXhb0sV5ByyDJO0PWPwbkvp1Ud8DWQ/oOACS9EAXx+pn2xCK/ZIGuZhU2RuwEa9K6t1BXeMlnaxAAE5KGt/BcXrb2kOx19nklU3yzoCN2SKpR0M9wyR9nOdAHgIgW8uwhmP06GoyqgR2dtVz5g1BH0k7AjZqsxW2V5F7qqcA1McsvWyNmwPqtENSn7S+mowh6AE8D4T6xe8WoA1YmPcAxhjTXQAK1LcR6AfcH0ifDcCPjTHtXgJgBeoJ/Bp4gCbEcwBCshn4oTHmXJZ/quUQ8BywAFhHpCqsAxZkNT9XAGwIzgNLgOei9sF5DlhiPaGUANgQyBjzKPBM9CAYzxhjHjXG5L5t1YpWYIxZDqyOXpTOaqt9IWouKjHGrABWRk9KY6XVvLh3jucKfgKscX3c+BTw//KAZcaYnzvTw3mFydLwtVUNQRMHQMBSY8wvnOrhpdJkafjzQI8YACe0k0zwbHCuh7e4JkvDN1QtBE0YgHZgkTFmkxc9vPZZydLwl4DeMQC5OAPMM8Zs9XWCmmextwJzgNNx4J6Z08Acn+Z77wEarqrpwHagf+wBUnEKuMcYs8f3iWolib4HmAmcjBd2t5wEZpZhfmk9QMPVdSvwB2BI7AE65EvgDmPMW2WdsFZyA48CB+NF3ikHrUa0XAAkXQ68AdwRfe6UO4A3rFatEwDb9R8GJkWPu2UScFgl7aRSK8H8+fbKHxm9Tc1I2xPMb9oASOopaRWwieR3cpFs9AM2SVplf4bXPE8B9ifSvwWmVk3VJn0X8CeSSaHPKx8Au3J2OzC6ipdVE78N/AfJ5JDTp4SaY/Pvt48yo4m4ZjRw0GpcrQDYxRCrSF789I9eeaM/8JIdFzh5y2ocmD8YeIFkqrfytNC6gFeB+caY48ECYLd52w6Ma5ZLqMUWhnxgxwUfln4LkHQXcKiZzG9BxgGHrBflBMBuw7Yc2EHAlzqRrxkC7JC0PM82dlkXhw4kWRfYtB+BaOG1gQBbSdYHfuU8AHZHz+3Adc18ubR4AADes+OCvzq7Bdi98d5pdvO/IVwHvFN0P8NIJBKJRCKRSCQSiUQirUeqmUBJi4HFLdFgYyZ209bDLeLtOmPMOicBsMIsB35GBdf8ZwxAq08FtwM/NcasdtYDNIhzO/AyMDQGoJL8F5hrjNnt9BZwgUDjgN8D34oBqBQfAbOMMR9k+ac8O4V+ANwC7IxDqMqwE7glq/m5AmBD8CXJbwBXk2xeFAmDrAczrSd+ngK66TJnk+ySPSDeAkrlJLDQGPM774+BKULwHWAbMCoGoBT+CdxrjDlS9ECudgo9AkwEDsRe2TsHgIkuzHcWABuCfwPTiNvI+2QdMM1q7cY3LyMT6UfAL6nQ9nBNfgs4AzxqjPmVcz28DU+l7wGvAMNjAArxGfADY8w+L3p4fUaRrraDwwkxALl41w72PvF1At8bRX4CTCaZPo5k42Vgsk/zvQfAhuCUMWYesILkRUWka9qBFcaYecaYU979KbNlkmaSrCQeHErdit8CjpOs+H21rBOWvU/gLmB/vMg7Zb/ViJYLgKReJN+2uzv63Cl3A5utVq0TAPvx5y3A7Ohxt8wGtnT0weymHAPYjxhvA2bEx8BM/NE+ArY1bQ8gaQDJPgIz4oWdmRkk6/4HNGUPIGkIyQ8VbquSqk04E3gQuDPv+/4gPYCki+xo9rZ4IRfmNmCX1bT6AZA0HNhL3BjaJZOAvVbb6gZA0mUkG0OPj545ZzzJBtKXVTIAkkaR/FjhhuiVN24ADlitqxMA+9ZvLzA2euSdsfZ2cHUlAiBprL3yx0RvSmOM7QnGBg2AXSSylyb4MWgLMsr2BOOCBEDSeJKXF1dEL4JxBbDfelFeACR9G3idiv3c6xvKcOB164n/AEj6PrAPGBagsV8An1bYjE9tjWUzDNhnvclE1tXB3wVeAwYFaOQpks+q1YDdQK5Xph6ngs8CtwPnST6OGeK7CSeAu4wx7tdnSJoi6YTCcKox3ZIeyXugFO3MyyONvaStOQQnJE1xbf6dktoCNei0pDs7qGlDhQKwoRPNTgfSrK0jzfKaP1vSmUANOWN/R9hRXX0kvVmBALwpqU8nx5oZWLvZRc2fK+lsoAac6+4DSZIul3QsYACOdfeZV0n327aE4KykuXnNf0hSe6DC2yU9mLLOm7PcnhwGoE3SzSlrfDCwlg9lNf/hgAWft7uSZal3UYAALMpY42LbtlAheDhtoY8rHO2SFubssZ4uMQBP56xxYcALS5IeT1PkvYEGLuclLSkwXqlJ2lFCAHZIKjKFviRQT3BG0r1pi5wfYODyhIMnlmGSPvYYgI/td5GL1vlEgAH1/KxFlhmCpxzOWVwv6biHAByXdL3DOp+qrPklh2CNh1nL2Z11szkDcL7wM3XH51pTWfNLCsFaX5Pikp50GIAnPda5trLmew7B+jwfOsxQs5G01UEAtpZQ5/rKmu8pBBuLjKQz1DxA0tECATjqe2VOwxPMxsqa7zgEr0jqWdb7UUljJH2eIwCfSxpTYp09rTbVNN9RCLaVaX5DzVPr7zRSBuCspKkB6uxpNaqm+QVDsKuzt2Yl1bw0QwCWBqyzj9WqmubnDMEeSX0JjKTfuPibEursazWrpvkNhd6TYtp4dxXMt/X2cvE3JYZgd4rp3XtCF9pVT/CWpEFE8mo7yGpYrSs/ZQjelTQ02lhY26FWy2qa30kIjrp4aRL5WtthDfMZ1TP/ghC8L2lEtM25tiOstvOrXmgt2hW1jUQikUjl+R+jQsvkl9W6QAAAAABJRU5ErkJggg=="

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAIi0lEQVR42u2dW4hVZRTHf86MOpqXbMwsuggZ+hDa9UHoYoU9FGGJVKRCQ2EGEtGLFBg99GAEPQQ9GJgR2AXJwCgkiUIwkUyZ6EJiBtIkmEWpo+k4s3tobTie5szZl+/71rf3rB+spzln77X/6z977/NdwTAMwzAMozwzgdUmgzdWi8ZRMh3YCyTAWquVc9aKtntF62iLnwBDQK/VzBm9omkSowmai99oglVWu9Ksaip+VCZoVfw0BoFlVsPCLBMNW+mraoKZQN8oyaVxHng4EkEXO/pMCB4W7drp26fxYtjuP785zgBLlAW9HOjP8Ll++awmS0SzrPoGvRNcnLP4aZwCblMStLsh53akgnYr5XqbaJVX371SmyiLn8ZJYJGCqJsacshigES+E5pFolFRfb2aoGzx0/gTuDGgqM81nT+rARL5bihuFG3K6uvFBK6Kn8ZxYEEAUe8Z4S06jwEG5Ri+WSCauNLXqQlcFz+No8A8j6LOAX4f4bx5DJDIMeZ4zHOeaOFaXycm8FX8NPqBuR5EnQJ82+KceQ2QyLGmeMhzrmjgS99SJvBd/DR+Aa52KOo44INRzlfEAIkcc5zDPK+Wa/etbyEThCp+Gj8DVzoS9sU25ypqgESO7YIr5ZpD6ZvLBKGLn8YPwKySwi5l5HZzVwYYknOUYZZca2h9M5tgi0JyafwEzC4o7MKMDShlDJA2aC0smONsuUYtfbdkbTL9XjHJfQWaNWcABzMev6wBEjnXjALN5/sUdf0+TxP3TOAbxWT3AtMy5toBfJLj2C4MkMg5OzLmOE3psZrGNxToMLoE+Fox6S+ByRnyfDXncV0ZIJFzt2OyXIuWjl9LLQsxFdilmPznwKRR8nuswDFdGiCRHFoxSa5BS79dUsPSjSpfKF7Ex8CEEfK6ARiIwAADkkszEyR3Ld2+cNl4NQn4VPFiPgA6G/LpAQ4XPJZrAySSS0/DMTrbNEb5jk/b3DkLMRHYrnhR74qw40s+U30YIH1nGS85vquo03aplRc6gbcUL+59YHPJY/gyQCK5va+oz1tNd0ovdCk3FiURG0AztkhtgtABbDQDRBMbc7RJOO11e8MMoB5vOO6lzM0rZgC1eIVI2GAGCB4biIz1ZoBgsZ5IeRYYNgN4i2HROGrWRm6CqhpgmApNu+8l27w2M0C2OE8Fp9uvitQEVTPAeSo8zX4ZcNYMUDjOUoPp9UuBf8wAueMfyg9AjYYlBfvux6oBBtCfTu+cuyk27XmsGeCUaFVLFgF/mQFaxl8Enj4fugepD/gKoxVfiUa15Apgjz0C2sYe0ap2t/7f7CUwc/yGzkoqXlgJnLafgbnjtGhXWbqIs5u4ai2BGwg41MsVPehOiKhbX8DnXDjsPGoWEmbhg7HWG/gLxWclB+ORiFr86jgeYEA0jo5OeVbFPhikDiOChkXrzliKPw3dGUNjdUzgdrJPoffGPODHColWt1HBP+J3qb1RuT+Cdn2bF/BfDe4PWfhxwDraL8ZkBggXQ1IT7xNEpgAfVlSkus8NTKQ2U3wVfy7wXcUFqrsBEqmR89VXlwInaiDOWDBAIrWqzXAywzAMwzAMwzAMwzDckLXteLVEHbilzd/31eQ635RwxjrinfNvLYEXTidf58tV9+Jmc0MzgJ/4U2rklfnobntiBmi93c78UM+X6eTbpcMM4Dc+IeDu4SkdVGcgaF0NkA4QDb5MbCPLiWPe/1gzwCnRPgpuBo6YAYLFEdE8Kmahu7/QWDHALspvsOmN8cS/jHyVDbBRNI6eJ4lvebgqG+CsaFop7gSOmQFKxzHRspJcA+w3AxSO/aJhpZkMvGcGyB3vkW3n1MoQS2dS7Abw2pmjzQPA32aAlvG3aFRbxqO7nWrsBvi4Kj/zihZ/qz0C2sbWOppgArDNXgIzxzZG3jC7kkwCdtivgNyxAw8bQIfmImCntQMUjp2iYSWZDuy2lsDSsRuFwR5luZg4FoauS1/AHtG0ElwKHMB6A13HAdE2ai4DviXuLtWqGiARbS+LtfhXAQcjF7AOA0IOitbR9fodqoB4dRkSdiimXsLrqM54wDoNCj0i2qsyH/i1QqLVbVj4rwScDNLMDcQ54mesTQw5JrUIyk3A8QqKVdeZQcelJkG4CzipdKF/AEcjNsBRyVFDm5NSG6/cjt6CkQPAHcBi4FyEBjgnud2B3qYZJ6RGXlis+J9/usndT0dogKeb7pKnFe8Ei10X/z7gjNIFnZXzN7M5IgNsbqGZ1tyIMy00K8TykrfcpORttdUYuYkFextdG2C35DISDyhrV3ry6KPAoNIFnKf9BklXAP2KBuin/Tavj6A3GnpQaliIJ9DbFGIIWJExz1tzPp5cGeCMnDsLK5S1fCJv8Z9STHiY/CuS9SoYoDdnjqvRW0xjSGqaiecVGzSGgMcL3rFeDmiAlwvm+Di6W+08nyXJh5ReXIaBNSXeVzrItn1dWQNsp9ySLGuU7gTnpLaZWKnw4vKCg18sPcBhjwY4jJs9fF9QeKHOvRN5SBO85LDN4vo2rZVFDXBCju2Kl2IufkgTvOah1XL5KLfZIgYYxs+CTK/FXPwQJnjdY7/FeocGWO8xz9djLr5PE2zC70aH4xh5OlpeA2wLkOemmIvvwwRvE2Zxw4uAvhIG6CPMzJwO0STa4rs0wVagi3Bcy4V99FkN8Id8NxRdlJ897bX4LkzwUeDip9zd0KeRxQCD8p3QdIlG0Ra/jAl2jNJrFoJnchjgGcU8J5J/NnXQ4hcxwU6gG33ecfQZ33STfVa1SvFTHszQbPxZJMWHbCtvxLI6R7do165590HtREe7E+wBpmIUZSqtZ1mr/udnMcEBYIbVsDQz+P9s66iKP5IJ+nDTaWL8R09De0aUxW80wQ/AbKuZc2aLtitjT7TDamXaGoZhGNHzL3j1mpmSzf34AAAAAElFTkSuQmCC"

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAKOUlEQVR42u2d689VxRnFfwNyvwmoAavWRIMkNSKtRm2kgihaLHLpGzFc0lLNqzbEGL9gTDDGTxATTYi2CQnF2koKtlChogWtWqNo0FK0GtGibQilrUqqIERuqx/Oc+oJfS/n7LP3nplzZv0Be6/nWWsue/bMM06SiB8HgIXOuafKeJmkmcAvgGGxJ861gAHeAWY55/5a5kslnQ/8FvhGzMnrE7n464HLyxYfwN55uXFIBigZJ4B7gA7n3EFv3Wfl3R3G5UQaAsrBZ8B859zTIZGSdAPwBDAiGaA4vGfj/a4QyUm6wOYF49MQkD82AZeFKr4NCbuAy4xrMkBeDQtYDsx2zn0efJda4TjbOAffu4Y+BBwCfuScWxvjBEvSXOBnwOBkgMbxNxvvd8b8mSVpgs0Lzk1DQP34A3BJ7OLbkLATuMRiSgaoA8uB65xzn9IisFius9jSENANDgOdzrlf0sKQtABYCQxKBvgK+4DvO+e20QaQdAXwG2BsGgLgNRvv20J8GxK22bzgtXY3wDPAVOfcP2gzWMxTLQdta4BvAxNoX0ywHLStAUYAWyVd3W7KW8xb8fzzKIQ5wBBgk6Rr20j8a6n8LxiSJoEVDDYTzGwD8Wea+EEsD4e0EDQAWCdpTguLPwdYZ7GSDPD/6G8mWNiC4i808fuHxCvEpeC+wGpJi1pI/EXAaouNZID6TLBK0uIWEH8xsCpE8UM2AIADVki6K2Lx7wJWWCwkA2QzwcOSlkYo/lLg4ZDFh7g2hS53zt0TifjLgCUxcI1pU+gSScsjEH95LOLH1gNU8RNgsXNOgQnvgEeAH8eUzFjPBq4E7nDOnQhE/D7AT4HO2BIZ8+HQNcAPnHPHPIt/CvBzYF6MSWx2DvAY4GvL9jxgpaS+HsXva72RL/HXmgZNBZEVL0rqJ6mvpDXyh42SBngQf4C92xfWWO77mRaZkNUAH0oaXdsSJK31mIzNkgaVKP4ge6cvrK3t+SSNNk1KMcAXki7uIin9JW3ymJQXJA0tQfyh9i5f2CSpfxe8LjZtCjfAvF5axvMek/NHScMKFH+YvcMXnu+pp5M0r2gDPFhHkgY3MyblgO2SRhUg/ih7ti+8KGlwHTwfLMoAT9v3bj3JGi7pdY/JelPSaTmKf5o90xdelzS83jUJ0ypXA7wvaWSDSRsh6Q2PSXtH0tgcxB9rz/KFNySNaJDzSNMsFwMctBOuWZI3RtIuj8l7IgcDPOGR/y5JYzLynmDaNWWA481u1JR0hqR3PXWbp+ZggFM9DWfvSjqjSe4zTcPMBrgvpzH0LEm7YxPfowl2SzorJ+73ZTXAWvvDlVcSz5H0UWziezDBR5LOyfMvZU+LdN0Z4K0iFlUknS9pb2zil2iCvVaBtIjFq7fqNcDHks4tMIkXSNoXm/glmGCflZkrive5pm2PBjgqaWoJSbxI0iexiV+gCT6RdFEJvKeaxt0a4O4SkzhR0v7YxC/ABPslTSyR993dGWCVhyReIelAbOLnaIIDqlQLKZv3qpMN8LqkgZ6SeGU9CxahiZ+DCQ5KutIT54FVztjMc6znJF4r6XCD4gdTlNmWvRsxwWF5Pg5vS9x7kTQ5kCTeJOlYHcnbmeePnpx/GO2sg/8xSTcFwnlyaEmcc/IsNeSWn6EnOKoWPv6eVxIXdrN+HbT4dZjguFrw2HtRSVx0kgmiEL8HExxXCx13LyuJi2MUvxsTLE6KZktiZ4gTvgYnhp1JyYSEhISEhISEhISEhISEhISEhISEhISEhISEhISEhK9Qb0WSFEN29Ak4cWOAv6hy126s4i+wGMak5txY4kbXbLE+FqMJJC2o2ea+UzV1FRN6TtxISTu62Eu/IFLxq9jRaJ2ldhR/mKRtPRyoWBCp+FVsK7KOYVbC/QLhMVDSll5O1RyRNCtg8WcZx56wxdc5zC61l/R4IOJvrfNcXZA9QS8t/2RsDcEEkh6vng6+0yOJAZKebfBkbVAmaFD8Kp6VhyrnNZzvrD0eflQebvCWdIqkDRnP1gdhgoziV7FBlQsnyuZ8dfUMZm2BiE8lnVey+E82WV3DqwmaFL+KJ8s0gaTzTOsuS8TslDSkBBJ9JD2WU30dLybISfwqHitjxVDSkJOPsHdVJWx9nvUBuyDhakuUxGiCnMX/X4meEvK+vt46gUsLJLKioBp7pZigIPGrWFEg76WNFIo8IamjABIPFVxls1ATFCx+FQ8VwLvDNG2oVOznki7MkcT9JdXZLcQEJYlfxf058r7QtMxULPrDPH5iSLq35ErbuZqgZPGruDcH3r1eJlXPfQEbm5mhSrq9u+6nYByRNDuHJM6uY3m3CJyQdHuTX1q9XmtXj7AzgAcykvgh8Ch+rlDvB4zP4Tnj7VllwwGPWg6z4AHTrleR6sWiBsXv9NTyqzV5bstxCLhNvVy8UHBP0Nkg30X1PrwRAxyWdGmdBOZ7TNhxSbcUMAm8xXNM8+vkeWkjRTcbvTZur6QzeyEw18OEqbYO380Ffgbe3Esdw6IntnN74XemGryPIcvFka909xdL0gxPE6bqpK+j6IHZvql9xjijh7+qrzT6wKx3B6/ugsB0SV96SsxhSdNLXAqe3mBt4zzxZVexSlqd5WHN3B5+R83Lp0g65CkhB+Sh5q2kyWqu1H0zOCRpSg2XO7I+yElSxhwcBaYBJ4BngMGUjwPADc65lz39Dp4EPA342Od3CPgula39W7J+qjZjAIB/Av2BUR4ScBC40Tn3Ah5hLXEjMNTD6/cDR4DM5w6aNYAvfApMc879KQQykr5prTC6vf8xHr36GLgmFPEBjMs1xi0qxNYD7DXx3wuRnKTxwHPA11IPkD/2AFNCFd96gveAKcY1GSBH7AYmOec+CL5LrXCcZJyTAXLAB9by/x7NuFrhOsW4JwM0gbet5UfTpdaYYI/1BG8nA2TDn4Gpzrl/ESmM+1SLJRmgAbxm3f7HRA6LYYrFlAxQB14FrnfO/YcWgcVyvcWWDNADnqOywvcZLQaLaZrFmAzQBX5PZW3/C1oUFtuNFmsyQA02mPiHaXFYjDdazMkAwK+Buc65I7QJLNa5FrtfLp7/BfwOmOOcO0obQpXyPOuB77VrD/Admx23K663HLTtEDAc2CBpSRu2/iU2DxjezkNALX4F3OKcO9Tiwg8GVgE3h8AntP0AO4DZMf34aVD8r1urn5g+A7vGRGC7pKtaUPyrgO0hiR+iAQBOB7ZIurWFxL+Vyp7B04P7JA18S9hKYHGsn4n2mfcIEOwV8jHsCXwZ6HDO/Tsy8c+gstAzKWSesWwK3WOTwzcjEf9bNtk7O3SusewJPBt4qYzDnzmI3wG8FIP4MRkAYAiwTtIyBXgNi5VkWQasM65RINaTQZuBeaHsG5A0AlgDTI8tkbEaAOB9YKbvcwJ2GOQpYFyMSYz5Vq5xwKuSpnkUfxqVbV7jYk1i7NeyjQQ2+/iZZO/cbByihZP0Bq2Blc65lSWJ30nAizuN4L95XUljsHU73wAAAABJRU5ErkJggg=="

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAITklEQVR42u2dW4hWZRSGnxkdD+NhPKeSGajohaQVXghZo2EXiWgypNgIiWIFEuKNGBRdeDEieCF0UVBK0EEkg6QQJRIhQrJEKUOphMiCSjGPeZixi9af4/gf9uE77r1eWFfD7L3Wet9/H779rbUAbhfALgJLcIclcs4i5C76AL4DpuIeU+XcKgCP9hEwFH8YKj6oABxbN7AJaMI/msSXbhWAG7sALCI8LBLfVAAW7QdgOuFiuvioArBgnwDDCR/DxVcVgCHrAbqAfsSDfuJzjwogn10BlhMvlksMKoAMdgaYRfyYJbGoAFLY58BoioPREpMKIIF1Af0pHvpLbCqAGnYV6KT46JRYVQC97DdgLuXBXIlZBQB8BUykfJgosZdaAJ8BrZQXrZKD0grgQsku/dVuBRfKfgu4DCwoIfkLJHZ9CJTVsoUlIn9hQCuEwbyO/IPbbV2+sERi1dfAKnYdWFZg8pdJjLoQVMduAasKSP4qiU1XAhOKYHWByF8dKPlBfw3sAdYXgPz1hL0vIPjNIBsiJn8D4W8KiWLb0qsRkv9qJLmNZu9aV0Tkd0WU16h2sG6NgPytkeU0un3sbxBGQUhfNIlvWhfgwN4EmgMiv1l80sogh/YeYWwd6y++lLI2cCfwoUfn38FvvUA/8cFX/B8KB14EcAhokSS87zEJnwADPZA/EL8VQO9L7luEC6cC+Jm7t233A3Z7TMZnwGCH5A/G706e3X2ufKOFEycCuALMrpKUAcA+j0n5Aje9AobKuXzFuU9y3RezM+4xSP0PKxv8MnwWQBwGhlkkf5icw2fBTL0r3UrbAtiWIEmtOe9Jee1rYJQF8kfJsX3FdYhkG2i32RLApynevYcDRzwm6xtgjEHyx8gxfcVzhOSl8c3ClVEBnAZGpkxaG3DUY9K+ByYYIH+CHMtXHEcll2kwUjgzIoDLZK/SHQ+c8rxYlBc+F3lOSQ6zYBbJdh03bMaUd6PmOOCkp8vmCAMCGOHpdnZScpcHS2jcvKruH18zdA+9H/gpQvJ9ieAnyZkJvJZVALsNf3V7ADeNEkyT71oEZyRXJr9S7k4rgBOWFlWmAmcjJN+VCM5ip+vpUOE0kQD+BB60mMTpwO8Rkm9bBL9jtwXeg8JtXQHcBJ50kMSHgL8iJN+WCP6SnNjGk8JxTQFsdJjEh4HzEZJvWgTnJReusLGWAN72kMS5wKUIyTclgkv4KY9/u68AjgCDPCXxMbKVSfsmP68ILkvsPjCol8+cNbRkmgcLgWspyW8jHLSlFME1/JfDTxDuaQ8kic+SrH7uOGY/9JjCGPEtSd3js4H43B5aEpdVeUoN+Zef9kpwk2KXvxvBKqqvX4dOfiMRdFPMsncrWN1HBLGQX0sE3RSr3N0J1kdKfjURrFc6s2FdoA98aR4M1ymNCoVCoVAoFAqFQqFQKBQKhUKhUCgUCoVCoVDchWaNobwYz3818jHPE+6UGMYrnekwmjtbrG9FKoJO7mxzP87dfRUVdTASOMa9e+k7IyW/YsdI32epdBhG7YHKsYigGvm9B2UPC83hlkD8GAQcoH5VzQ1gacDkLxUf68VwAH91mFW5fzcQ8g+SfKRcZ2S//L52MBARvIs49LJHJwYC+0lXWRuaCNKQX7H9+OlyXsHL9CoPv4mfCd79gY/JVlsfigiykF+xj/Ez9GIBd2ow/3fmHDDFMfl7yNddw7cI8pBfsT2ORTBFuK7aIuY4MMSBE83ALsz01/ElAhPkV2wXblYMh3BvCfs9zuzF7lSuJu5uURKjCEyS37tFj+287yVhn0Cbkzp3YKfHnisR2CC/Yjss+l1rkmnNmb0dFpzYjt0um7ZFYJP8im234HcHtWcY13TkIjDToBOv46bPri0RuCC/Yq8b9HumcJmpWXTf4VBZ8QpuO22bFoFL8iv2igG/kwyTSjSWLc8T6ov4GaF+A3jGQBKfSbC8a8N6JHd53rSSjLVL5MyWjE48T+N+9TZtswEBbPbof7fkMAu2JDxHYmfS9rhZ5+mXX0ncCwZvAS94FHIP6buMrE5x/FTNDeckdOA5jwnrBtZYeAhc4zmm5xL6OYd0TTdT97Of2MCB5R4emHr34Vth8TVwBfX7GNp+sF3ewL+JpJ/HkNqRL+t8xVrs6YGp8tDXgX10eI5xcQ2/Bgo3TmYH76ziwNPAdU+JuSbnd4WnU15mTdr1GrFmnSKe2ZGXep18PnDVU0Iu4afnbTv5Wt3nsauS8wpeynGsXJejduBxsg0tNmEXgXn4w7wGq2w27Yrkvj3nLSn3nJtzHn/58/GP+R6vBOfIP3/J2yJH3hk7jxAOHsHsDCSXFp3DfwCzCQ+zxTcVgEX7FZhBuJghPqoALNgvwDTCxzTxVQVg0H4EJhMPJovPKgADdhqYRHyYJL6rAHLYCeA+4sV91J7ZqwJoYMeAscSPsdxb7awCaGBfEcZQSFMYQe2qZxVAla+NbRQPbRm/1pVKAAdxU5nkC0NIXgVdOgHsBwZTfAwmfTV04QWwFxhAeTCA6mVapRTAHsLpUuISLeSvjo5eAPtKSn5vEewrswD+pvYetzJgseSg1LeAW8CmEpK/CX+7p4N8C/gAaC0B8a0Sq74FVLFvI/vqlxaTJUZdB6D+jp8nCkj+E4S5YyjI9enrwNoCkb8WfzUTUX8OfjPy18QWiUE/B+eww8C4CMkfJ77rhhAD9gvwaETkP0o8+wKj2bx4GTfFn3nRIb7qplAL1gN0EeYYlmbxrSeynEZZzfIpYW0aaROftDLIoZ0ijCKRGeLLbRWAezsPPOWR/KfEh9sqgPJ9TArlY04uawKOFmS17S0xF1hH+s5dQeJfa2zWd/WF1MkAAAAASUVORK5CYII="

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3wYQChYPcVWL9QAAD2dJREFUeNrtnX+sXVWVxz/rtq8tVs0DrCCQqVIGRowpFNDRCCSDwYgdqQhK0RAzaKIMji8wA6IwAkVEoVjjTHGM/GFJJOhYICLFP5hR0BHJVCAByUCdajLMoLS21AK278d3/jjrkdvbc+/5tc85+77elTSF5p691l6/99p7r23MYZC0GBirOMykmb04V3lkc1zQq4FjKw7/NHDHXFUMmyNCHyToiYqo1uVQjKFVBhtiK+8V+kQJIWZB3jF7vcTQKIQNkeDTrHyihLXmhSJeZV0ffNErgg2BtXcLYqKgJZa2yAJ5xSCaog8TNiTWPpHD2hphco7cYyJDOaNSBItY8BM5rKpVy8rIS7Loj0IRLBLhX9iHcdFbUAUP9jSwoe25WETMmhjGGFohh1kXg1JbJFYyEbObnMvztRaYcWHMFhGBx2s0LFhLwo82JkZiBI3xwVrU/Dnn7gOGhcZ4Yi1p+7oDUfAljWM4vaKkxZI+Jemr2he+6v++mBG0zitrwPLnjla36y2Hg2d9tHlWk8dHlp/Ju/EB/Fs8zMIfCX4u83Ek/AOYnyPhDy9fLQSRKQnf/wAHAbsBNc03YBvwT8DdZrar4vxeC6wCLgFeR/PlcwNeDbwMHBVVYjhAQ7epHZiR9Likv5P0moDzfI2P+bjjaAO21eEJOjUs9Z52y28aJoH7gSuA9Wb2x2AmmIy13se+33E1Dbudt+u6lonHAhc2HmazYpOkrQ1bxwuSNkhaLqlT47w7jmOD42wStkaTa/latS8RDSrAjKTnJF0j6egG53+043yuwZCwNcP4xhsJAS7k1V3/1FZCMg08CXwRuMXM/ruxrCzBdYvjftJpaQr3i8CGnnAAsLqMF+iUEH7alu4dLQj/Z8A1wLeqZvolBbEL+JbT8LMWlKD7XGTpfKBTUfiz1t9kUrQL+FdPyO4ys5fbWgU57ruAy52mJhVxstGkMCvu9/x2a03x/gVJX5a0LMKizTKn7YWa8oKtBZLx8aAeIIK4L2ALcANws5n9OjYFcJpudhq3NFEAC5EP5A0BYy3H/d3A94B1ZvZ8rKVbp22d07q7IZz98oGxIAowwPqbjPuLgdOA0yWNxaoATtvpTmuTxZnJsl6gMyRZfwd4J3Al8O46iz1VikTAu53Gd1apsja5KsgiciyCrL+b1tOALwBnSVoYkfAXAmc5bac1Kfwcq4KxUgoQUcGnl963AZ93JehEYvlnOU1va0n4pRPCTsSJX9+5Am8HrgY+KOmgFoV/EPBBp+XttHzXskxC2Ik48ctSghOAzwGrJM1rQfjzSM4JfM5pieWqfaGEsDNk1t+rBMuBq4CPSnp1g8JfDHzUcS+PSPiFvUCeeBWb9fcqwfGeeZ8naX4Dwp8PnOc4jyfOLitpXiBfCEhx/zFafy8c5674Ij/CVZfwXwtc5AnfcbEyI8UL9A0DnZzuvxZ+AtuBPYHGOwb4LHBBHcUiH/MCx3FMoGH3OA/qLhv3DQOdlpI/Af8FXOtLl1Bl0zeS7MxdLOnggMI/GLjYx35joGF3+9yvdV6EVoLi1cE+O37jJRiWtRu4Q9Klkub5Ltqtkl4KuGv4rKTPSFoUQPiLfKxnA+7yveRzXuY8uNR5Umg3MAftmfLstJD87QK+AXzbzKZ9F20tcCfJ0ecQieERbq2XSTq0gvAPBS7zsY4IlPC97HNda2a/NrNp4NvOk10NeIFCq4DQyd80sAm4zcy2dyUtW4CvOGNC5QRv8Nj38TJHxP2bj/sYbwgY8+8EbvI5z85/O3Cb8ybYyaI+yWC6AvTJ/gks/Add87ekEPsUyX763YGUwEguclwGfFbSkgLCX+LJ3qWEuwyyx+e21sx+lTL/Le4JH6Te42X75AGdhrJ/kRye/Gdg8wCNfRK4EbgH2BsI9+u8aLO8wDfL/ZslgWjY63O60cyeGPC7zc6jJ2taGey3Gug0FP+fA/4FuM/MZjJ++7iHg02B8O8AvgM8UeCbJ/ybHYHi8Caf0+MZLnsGuM959VxjRaGUs2Wlz5mnrAJ2SvrHonFY0imSNkqarJBt75C0psyS0DPoNTmy80Ew6XM4pWj+4TzbWWUV0Gc1sM9Zzk7N7n+S5NTshhJXtTZ7TvBAyZj4B+BW4BtmVtiSzWynZ+a3+lhlcp4HfA6bC+L+o9cINtawCtu/KDRIQyp4gBlJP5D0lgrjmKR3SbpP0lRBy78+RDFI0sE+VhFPMOU0v0uSVcD9FufhTEUP0NfDd2pa/gl4FPg68FSFZYyAn3v8fAiYyWn564Fby1h+Cg073Ausz+kJZoCfOs0P+xzKwlPOw0erJIWDloN1nV75P+CbwAM5kr4s4qeBnwDX+9+Dxpt12zeZ2bMB19PPAjf52DszhP8KrWY2VRHvjIeRbzpPg0Nd26dfA+514YUQgCQ9CCwgOW17SsrafKdb6XqP30HBzHZKWu//ezEwnuL1/tMV5ScVLX8fA5B0e6AVyf4eoKYC0A/N7KXAApgEfkRyIfMXPS5x1vLXhrT8Pp5gbYonkNP0ReBHTmtIvC8BP6ylIBRqA6gpkLRQ0gckbfbkaLuk6yQd0SANRzjO7U7DL52mhRHzLVXO82suANVhhXsk3ePLmAmPubfU4fYH0PC/km5xGk53vt1TNd+pGboLQhODloDjDAH4Nu2KIjX+GmhY4jQsGhKe7Sfr+QwpmNmfgF+2TMPzwPMMMXQYwQENIwUYKcAIRgowgpECjGCkACMYKcAIRgowgpECjGCkANGDpMMknS/pxBZpONFpOGwuKcBqRf7Kh/cC+DTJ/v8XJJ1U5ehVCfwm6SSSnkDrgU832Z+gJM3p2/5DuB18qKTLJf3et2L3+snbkxuk4WTHuddp+L3TdGjEfEuVc4cCzQQKIFta0yQWAp8gue2zhORU0BhwNnClpBPq9ARu+SeQNIc423Gb03IZ8Im6zgQE5ukr2/6dPPfHSsBFkt4UWoOBT5K83bMkJZStdJd8ch1K4GOe7DhWpoTPJU7bJ0NeTXfcbyJpTBES7jCzF+tKAj8ETIRihDdn+BhJh/AjSb+rt8Ct8vPAipBK4GOtIOlCcrbj6gVz2q4APhaqSYXzcMJ5OjSrgAXAh4Hzq7rErrYsE8DhGT83kp59V4fyBF2Wf5WPnTXm4cBnCNCuxnl3vvNyQZMKUHUlYMBhHhfPKSsIb8i02q1qKflu6Y4B73drXRGAR1mWnzb3pU7z6rKNq5xn5zgPD6PCDeXMg7+hVwJddwNnJP1U0qlFlcBvs/yNpGdK3svbI+luv2NoZQTg397tY5WBZ3wOi0vgPtV5NxP4bmDqzaDgK4Eua3gHyTn6owsQPM+1/x8o35BpgXuCK0t6ghX+7fsruN9jSLqLnFOwmeXRzrN3EL4N3T4HfztQrK1YyTCzypPCw3MIfxFJ+9UrgL8IoIArgaskvbmAAr7ZY/7KAAI4zudybp7Do86jCedZ5Rwtq+1fPwSFHh3IAYs8i71A0qsGENsB3ueWf3wg3PM9Jhc5PbzEvwl1aPZ44O+B9w1qcO28ucB5Feqk8cCb393E1BUGZuH1JOXbc9OWSJ7xrnLLOymQ6xPwGPAl4JEC3z3i31S6lNnjiU7yua1KWxk5T851Hr2+Jhnsd+/jFQWoqSDUC0uBvwXO6E7M/L/PdMtfHlD4DwPXARv9GHk+aSW/3Qis8TFCKcFyzwnOTJn/Gc6bpTXLYJ+b31kxJvTG0GxB5RLgrV2a/14v4IRquT7jgvsSsKnMJVX/ZpOP8TD5rqbnmf/sewfv7fKEb3WerAiZ9BW+99lgo8gpSbdJOkrSmZL+XdJ0oCaM05IekPSeEA9K+HvB7/ExQ9L4Y5/7Uc6LqTYaRfYmOWn3x1ZLCv1KyGyv/XnAnwN/GagqOQ38B0mnsR+HuKtnZjOS/s09wBjJe0BV3yfoAKeS7Cs8A/x1gDGzrD/fvc8QXiDnw5EzXmAJZVVTkjZJ+qu6NoN87E0F29VkeYI9OVvQbg1t/fRZ5qTfIg0PFrC+PUXSSeMG4OehmjP0eILZJhWTTvsZAZaJHWqq8Wdl/32TwJqLQnXAFHAvcJ2ZPVS1LUuGEkyZ2UMkHb7vddzRQZE3H/LE3dBFoZCwl6Sx4mym3hT8wnHeR7iOpiEhd9u/fgpQ+iXKhoW/EbjWzB5psjmDmc2Y2SPuCTbGpARFk79OnwlWeo+2AfgTSQPKL3u1ri141Gm4y2mK1fr7tv0bFAJi9QKz/favN7PH6kj4iiSGZvYYSVu4UO8dNLr06wyYXOn3aGsW/neBr2R03W5aEZ4gaQz53baUoOw7z1lJYKn3aGuC3cDtwA1p/fYjUIJf+TL0dhp6Oj7D9ecq/HQyJlXqPdqaEr7vAzeb2dORLkdx2m52Wvc2bP2l3nnu5JhUDAmhuWvdS/yw12m1Fq0/0/UXqQPEkBDOJzkdu8bv40X3WqeXik8k2UI+n/ra8FZO/MoiSqstp7aVz7kXULbef7+klZIWRCT8BU7T/QH3CTL3AlLawBfeuymyA9cvIWxyVTCPpAZ/DfCRQcfLGhT+q4CPOE1nEHhXr2DWX2+n17waV6MH6N5J/K2kKyQd2aLwj3QafhvwUclcHqCIRw7lAWJaFRjwZyTHq66WdGwL18OPJbmBdLnT0iT+0ll/JQWIsEB0CMmdwTXAqSFOAOVg/uxhjjWO+5BhKPgEU4CI8oFZWEhymvZGkmPni2pk/iKSY9s3Os6FEQi/nQ7vA/KBT0n6jZqHGc89LqmjUYM3prik60GspuE3A/jdTml+gBJscya18ed3kr4uaVnAeS7zMX/X4ry21SF8q8ktPePLoeep9x3cVJK8Gvc94E4z+0PF+R1Ccj37PJLjW00XoeaR3FSaJjlAWynpayMcRN1wKmYYKr6OlGDEz5ESjPiYSfz4SBEyeTfepPCtron0Wa8SVfISmfC7eEbKOn+4eNbHE4xCQmS8spa1+g5g8kD1Bs6fMZK6five0iKZ5AGlCCk8ac04mt7BStvEOKBygwFesZV4bxFOfk56gwGesFUjsAgYwVwOC7HP14bAImbPHgyNMnTNjT6Cj8bjWSTMGhQWGBav0MfaiTnnsYgZ13u1Oc0rtOoZeiydgvRHocg2xBZEG2FigHvPojVKDxbdBYsCMXQQk3uhMNNTrJs+Qh9EU/Q5TJQKkNMrDHKzDPASeSENX168Q7OKiV4BcsbbfpaYpRhZkHfMaPKSOasAJWJxHiHmgTxeZWjrFUOrACXjdRkIlleMFCAexSgCc3qT6v8BxEO8QcgE4YwAAAAASUVORK5CYII="

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3wYQChU063MxEgAADjZJREFUeNrtnWuMXVUVgL9zb4cpDJAptYHQxiLFGopEXgViBAkSpIhGbAqWaIn6g0hARlSeAlIe9QFSo1Eg8RFMpI3pI2qAmKAUTSkEhCZgsS1MTCwCpU5L6WMe944/9rpwOXPuPa+199lnelYy6fPsvfZ6773XWjtgckMf0JNzjFFgz2QlUDDJGb0YmJtz7M3Aw5NVMIJJwvRujB7IOc/yBIJRWmEISqzlYaYPZGBiHCQdM2wlSiMQQYkYH6XlAxm0NSmksSrLO8znvSAEJdD2dkYMpNTEPBqZNK7ohpP3biIoibYPJNA2V0SOiz0GYoTTK0EIPGb8QAKtKlqzusUlcfh7IQiBJ8xf0oFw3mtQDgu2GXio6LUEHhFroIw+NEcMs9wHoQ480ZIBn83kZF5vUAAxlvisER5YPKduISiI+d76RE+UwBkdggIlfzKaey234IwmQUHSvvwAZXwW5SitVewDvg7cB4y3/dwnf99HBYXTqu7Q3y8HNhxAvj4NjAKbgFnAFqHTmfKzRf5+k/y/UkpzS5L7K82PpV1/F/r1+W4BOml+S+t3l0WKC7QE+0PWwKolqDtkfmXys7sEa0JQr5h/YAtBYIn5/wEOBt4RH+YSxoG3gJ8Ba4G3c453OPB54CrgA7g/PQ2AQ4F9wnivlKtTwPdWaDvj6qcJbAS+ARymuM7DZMyNMkcRa3vLRmBYV9b8lmSeLtGsa5P5Z+AuYKUEU1owAjwHvApMB46xuIXuBNuBP7gIDPNu9fqAQcfasUvM4ceAmsV112SOh2ROl2scTEB3Z9Afg8SgQ5P/OvA94FiH6z9W5nzdoUsYjFG+/qwSnUX7F7f9uaiApAG8JCb/x2KeXcGrMuddgkPD4dx7hNabeX/G1GIXViCp9Nm2AGPAOmCh7DaKgoMFh3WCkwsLkNQKO/f7rgRgF7BCgqAaxUMNOENw2uVQAJzHA2kkzoYANIXAPwDmeHhwM0dw22UpLhjMYZFzxwBF+/1xYCtwN3AP8IqHAvCK4Ha34OriAMxZPNCfUsq0LcDbEnD1luAIt1dwfduBBcjKn1QWoJP2uzx46APOBj5J/np/m9AjOJ7teF8+assKZPUxNmKABvBXYIEnwV+UMi0QHBuOYgDru4Ksg9raBTQw2TIXeeYOegWnDZaYn0QAMilrrQQHPmF8TwduBi70aBt4oeB0eoE4qQeEmQMLBwdBTeAfwCIPDoIWCS62j4QHbfCt5nHg1w0C4CTgJsxdfb0AHOoy902Ciy+V1ioBYR7td2EB2i3BS8DlmKQJl7uSy2Vu15dBqvxL4q980/6wJZgH3CimeIqDOafIXDfK3D52WYmyAoldQNj8g6ng8Tmv7yNiir+GSeGyBYfLHDfLnL7CHia2yol0A7UOhxnhAk4bMA7sAIaVxjsOuAG4zNJhUY+MfYPMpQHDQgPbx8YDwtOeOAFwFfyNA/8CbpetyztK4x4DXAdcCUxTxHeajHmdzKEB78jabxdaaAtBpmAwb/CXNAgcAq6VSHoO8Atgr2JguA24BpiqQMipMtY2xYBvr6x5jtDgWqGJVhCYmZ/tH+Q5SuwmALuAZZjkynbz/WtFIRgXht0cmictTJcxtinitVfWelxonmV0zyfIIgDh08HUApA1s7eTAIxhEieifOjxQpj9ipZgO3A92VLED5Nvtytq/n5Z47wOMcwKOmcWDWbkRVee1mKif01oAE8C92Luy8OwCXOfvlYpMAwwhRzfksBtRopvZ8g316JXDDIsa7sX+GfEv2+Vf3sSuzmGHeMALf8fZQFaBRsLE5w9nITJ6x9WtAT/Bs5Lgf958o2W5g/Lmk5KsC1fSHQBioYFmMDXmqPDn9eBB4BHZGHdYCPwQ+BRpfmHgN8BL6b45kX5ZkgpGn9U1rQx5v82hUYPCM2cHQqlDhZSWICdwK0Z/PB8YLUsIKvmDQF3ZNwS9su3QznmH5U1zM8Qf9wqtMtrARIF95rmv10ARiToybJ3rgEfBx4jW8r1Dkx+3swc65gpY+wgW+r6Y7KGLFfExwC/EhpqCkAkf7W2f+0C0AT+CJyQM5D7hJjFsZSaf6fSYdA0GWsoJfMfEdzzBJAnCA2bOQUg1sL3K5p/MJUzzwHnkz9Bog6cQ/JUqx2YpMyZ6MFMGTOJJWgATwjOeS+nakLDVmEqSlbgXR7byl75L/Ag8HiCoC/J9nGdaOG6mPF2AvcDP5LDGy3YJmPeL3N0C+LacR3LOW9TaPig0FQdbF2f/gT4k+J+dlz2xweJOZsfYVp3Aj+Xn50W1tQaH8y9QH8Ejs+KoKxD72y/AfxWaUfiZAcA9lKia8DngKdC++QhOUo9AvtwhMw1FDpreEpwq1nkk6YLeDfO094B2IZe4GLxi03xy0uBox3icLTMuYP38hMvxu/ClUg+1zG3Xedgii1bB0DP4287t4bgOITpjrEac4S83SEOu4VGB4sbvQdYo+DzbUKd9zec2iCuSn0H4AqmAqeQ7oxfG2YIDlNLQrMJvJ5CeWG/mN4iYbtjy2MlqKrgAIZKACoBqKASgAoqAaigEoAKKgGooBKACioBqKASgDLAkcAXgZMLxOFkweHIySQATnrO5oRDgasx9/O3Aafitkw7kDlvExyuxm1/gizQse6jbNfB0zFFmm9irmJHMDeCpznE4TSZc0RweFNwmu4x3Try2UZCyGxLi+jFVOy8wcQ8vFXYb9XSak2zion5iW8IbrZyAmYrCsCExF/tK+GlwIcsSPA1mPeIoip2hjF38vMtCUEgY68humqpKbhdg25pOkLLpcoCYDUr+GVMXqAWIXowTQ5eI74MbK2FmKDl89cQXy72GvBN9JpUTBNavmxDAGztAg4CLpUIOa9JbLVlGQCOSsCoC4FbxE8HSsw/DfiujB035lFiBTTa1fQKDS8VmjoJELQKQ1odvhfnYMQU4ArSdx1riraeqkCbpJofVc59BdkzrwOh3VbyVwalKgzRLA1rAn8HzsogBH3AVzE5bFkrctfmiAlaPn8t2SuVt8ga+jLMfZbQromD0jCbxaENTMeqNI881IEvY3oG5C0NX53REpwq3+YtEX9Z1pKmmeUcoVkDR8Wh2m4gbLL3AT9N4MPBJFheginR1qjNHxETfnwK/I+Xb0aUcHhR/HiS5NGjhFb70OkP0FW5OwWBHduKZYQWUy8DDok5mfwM8B2i26hkjSNmk75DyGz0KqfmAd+WtXULvA8RGl2CXqZx4rZ/mm5gsEtgtKSDYPUCX8Dk22t15mhvKj01pcAu4r3iEy1cnpc19nZg1JIY2lkP8G03iWoCTwMXhAKzAPgsE0u+8hJ8PdmbSbeaQa9XxmmDrDW8/guENk0KahIVBdoXQwGmkOIq4MQ2yV+Aacd2htLevUXoZZj2LFmKVBvy7TIZq6m0/tZ7BwvaLOGJQpNTlA+wUjf+ctUocgz4JaZU6Xx0n1lpYEqqP6100FWTsR5XxvEJWfssoUVcAwwrjSLDQU57Q6GBNiug/UpIvc00fxi9RyAbYrK/LwRuKlmTv8ivPZiWL3UFoToLc528RVyC9psHmdv+aliBJCd3TTlg0dKqMTHZ52LvMuhcmWNM0RIMJ4wxBrW1nw7bnCgrgCWCap1vj4mJvlsCSRvdt1tNKkYF90+h0wLG6hl/nPZHmd3EveY9gTFMN5KlwN+wW6I9JnPcLnP6Wg6e+M2HJH5X+1BIE0Yw3bhakboreFrmfERw8A0SH/50EgBrL1EqM3+1aOMzSgFfmsDwGZl7tWdCoPbmg8/Pxu3DdNYu+rWuVorYCiae3Zf62TifrcA+TOPlO4EXcPNKd7fA8AXBZaXgNim0v5s0Ffl07F7gN+hdFGnCPMFtLyV6OhZLg9oQgN2YLtpz8RfmCo67Kcnj0XG7APX3aHMEfKsw3bg2eywAmwXHVY4Dw8zvPCfZBobPBYrYFgbiX0fwH0YEV5fBadS2L9Fbj0nP34sOCKdgsmPvwNTj+fhaZyC43SG4TilY+9X7PKbxMbaCwFYP/otwc4SaFA4SnLK+bZA1BrAS+KUNCKOEwOY5wCimKfNX6J5e5goOEVyeJd/rJmkFIA0/rAtBv+ODoNZDUNej+y5AWpgpOGg+MJVUAPo1mJ/2Dt6XXUEAfBBTkXuLBECuy8PnytzXCS4u588c9buKB2xbgPBjjCuBs3HT8KImc61E75HLNBbAqd/PGg+4FIBWYsV64EvYbdw8VeZYj14iSxoBUPf7WdOQRjFVO+3tx8+U38/CPJbU79gkz8IkVQ4Dr6B/Lj8duByT0PlR3LfX2YV5cbx9v5/b9OfJQ+smBPMxvfRdQz+mkncG770poAFzMM0frsTtwxTt0MC8XaTGfJQClz5MQUO7ZG4R4dqO3Xdwo6BVDvZ78dP/yzneEZiyrkWy33d9CFUXgW5gEmgLCfo0zwgq8IiuWqnIcTHBJvx9gsZn5i/R9vm2BKASghIyX1sAkgjBVpmzEoTOjO+TraZ15tsQgDghOKeyBrFav1C2nNaZX0QAUwWHntGqbnFRYUuwoXIJqUz+BheaHzhaZA/m8iK8SGSRD4sQ7DmAGN9OEyJMvhOauL7BCke2YUF46AAQgnY6EEELp3QIPFz8ZLUGnSxhoUoQeEAIJrlb8Hq9QQk04uG2oHJPyZhOB8Z7Y/ECT4jVzS1QIqsQpe34HPMEHhMuXNocZRWKtgztmk5K/L0Q5KDEGkRBbqKTeY/D1UsL5mOBRVIf2o3IYchC9LB204Hp3XDyPobxVQCSWIVuZpYuViIpRM2XdN7S7GLKIABJ/G0nTYwTjDhIOqZPccmkFYC0vjgJE5NAEqtS2vOKMgtAFn+dBTTjikoAPBGMNDCpL6n+D87XLq2wwaW/AAAAAElFTkSuQmCC"

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(38), __webpack_require__(39), __webpack_require__(3), __webpack_require__(5), __webpack_require__(91), __webpack_require__(42), __webpack_require__(40)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, P, U, KefirSignalHandler, uniqueID, deltaJs, defer) {
		'use strict';
	
		return deltaJs.selected.then(function () {
	
			/* however (often) this is loaded, create the class only once */
			if (U.isDefined(window._amy_Artefact)) {
				return window._amy_Artefact;
			}
	
			/** {@export @class Artefact @extends KefirSignalHandler}
	   * Use this as a subclass (or just mix it in) to provide support for
	   * events and observable properties through Kefir.js.
	   *
	   * Users can pass a promise through the 'beforeConstruction' option. If done, the
	   * artefact waits on that promise before calling its 'construct' method.
	   * Similarly, users of instances of this class should test the 'constructed' property.
	   * If it is defined, it is a promise that has to be waited for.
	   * If not, the object instance can be used synchronously after construction.
	   */
			window._amy_Artefact = deltaJs.vp('Artefact', U.newSubclass(KefirSignalHandler, function (superFn) {
				return function Artefact(options) {
					superFn.apply(this, arguments);
	
					this._options = options;
					var id = options.id;
					var type = options.type;
					var parent = options.parent;
					var beforeConstruction = options.beforeConstruction;
	
					/* set hierarchy stuff */
					this._id = id || uniqueID(type);
					this._type = type;
					this._parent = parent;
					this._children = [];
					if (parent) {
						U.array(parent, '_children').push(this);
					}
	
					/* create events */
					this.newEvent('destroy');
	
					/* possibly wait for something before construction (like plugins)? */
					this.beforeConstruction(beforeConstruction);
	
					/* give the root artefact a way to register other artefacts by ID */
					if (this.root === this) {
						this._artefactsByID = {};
						this._registerArtefact = function (artefact) {
							U.getDef(this._artefactsByID, artefact.id, defer).resolve(artefact);
						};
					}
				};
			}, /** @lends Artefact.prototype */Object.defineProperties({
	
				/** {@public}{@method}
	    * Allow a promise to be inserted on which the rest of construction should wait.
	    *
	    * @param possiblePromise {*}  - a value that might be a promise
	    */
				beforeConstruction: function beforeConstruction(possiblePromise) {
	
					/* if no promise is passed in, ignore, to keep construction synchronous */
					if (!possiblePromise || !$.isFunction(possiblePromise.then)) {
						return;
					}
	
					/* if this is the first promise passed in, initialize 'this.constructed' */
					if (!this.constructed) {
						this.constructed = P.resolve(this);
					}
	
					/* insert the new promise into the chain for 'this.constructed' resolution */
					this.constructed = this.constructed.tap(function () {
						return P.resolve(possiblePromise);
					});
				},
	
				/** {@public}{@method}
	    *
	    * Get a promise to an artefact given its ID.
	    *
	    * @param  id {String}   - the id of the required artefact
	    * @return {P<Artefact>} - the promise to the artefact that has the given id
	    */
				artefactById: function artefactById(id) {
					return U.getDef(this.root._artefactsByID, id, defer).promise;
				},
	
				/** {@public}{@method}
	    *
	    * Traverse the Artefact hierarchy with this as root.
	    *
	    * @param fn {(Artefact) => Boolean} - the function to call on each artefact
	    */
				traverseArtefacts: function traverseArtefacts(fn) {
					var options = arguments[1] === undefined ? {} : arguments[1];
					var order = options.order;
	
					if (!order) {
						order = 'prefix';
					}
	
					if (order === 'prefix') {
						fn(this);
					}
					this.children.forEach(function (child) {
						child.traverseArtefacts(fn, options);
					});
					if (order === 'postfix') {
						fn(this);
					}
				},
	
				/** {@public}{@method}
	    *
	    * Traverse the Artefact hierarchy with this as root.
	    *
	    * @param fn {(Artefact) => Boolean} - the function to call on each artefact
	    */
				traverseArtefactsByType: function traverseArtefactsByType(type, fn) {
					var options = arguments[2] === undefined ? {} : arguments[2];
					var order = options.order;
	
					if (!order) {
						order = 'prefix';
					}
	
					if (order === 'prefix' && this.type === type) {
						fn(this);
					}
					if (options.beforeGoingIn) {
						options.beforeGoingIn(this);
					}
					this.closestDescendantsByType(type).forEach(function (descendent) {
						descendent.traverseArtefactsByType(type, fn, options);
					});
					if (options.beforeGoingOut) {
						options.beforeGoingOut(this);
					}
					if (order === 'postfix' && this.type === type) {
						fn(this);
					}
				},
	
				/** {@public}{@method}
	    *
	    * Retrieve the closest ancestor (parent, parent's parent, ...)
	    * of this artefact with the given type.
	    *
	    * @return {Artefact|undefined} - the closest ancestor of the given type, unless there is none
	    */
				closestAncestorByType: function closestAncestorByType(type) {
					var result = this;
					do {
						result = result.parent;
					} while (result && result.type && result.type !== type);
					return result;
				},
	
				/** {@public}{@method}
	    *
	    * Retrieve the closest descendant (children, children's children, ...)
	    * of this artefact with the given type.
	    *
	    * @return {[Artefact]} - the closest descendants of the given type; none of them
	    *                        are descendant from any other
	    */
				closestDescendantsByType: function closestDescendantsByType(type) {
					var result = [];
					this.children.forEach(function (child) {
						if (child.type === type) {
							result.push(child);
						} else {
							result = result.concat(child.closestDescendantsByType(type));
						}
					});
					return result;
				},
	
				/** {@public}{@method}
	    *
	    * Indicate that this artefact will never be used again, allowing it
	    * to do any necessary cleanup.
	    */
				destroy: function destroy() {
					this.destroyed = true; // TODO: make this a property?
					this.trigger('destroy');
					this.children.forEach(function (child) {
						child.destroy();
					});
				}
	
			}, {
				options: {
	
					/** {@public}{@property}
	     *
	     * @return {Object} - the options provided through the constructor
	     */
	
					get: function () {
						return this._options;
					},
					configurable: true,
					enumerable: true
				},
				id: {
	
					/** {@public}{@property}
	     *
	     * @return {String} - the unique identifier belonging to this artefact
	     */
	
					get: function () {
						return this._id;
					},
					configurable: true,
					enumerable: true
				},
				type: {
	
					/** {@public}{@property}
	     *
	     * @return {String} - the type of this artefact
	     */
	
					get: function () {
						return this._type;
					},
					configurable: true,
					enumerable: true
				},
				parent: {
	
					/** {@public}{@property}
	     *
	     * @return {Artefact|undefined} - the parent of this artefact, unless this is the root
	     */
	
					get: function () {
						return this._parent;
					},
					configurable: true,
					enumerable: true
				},
				children: {
	
					/** {@public}{@property}
	     *
	     * @return {[Artefact]} - the children of this artefact
	     */
	
					get: function () {
						return this._children;
					},
					configurable: true,
					enumerable: true
				},
				root: {
	
					/** {@public}{@property}
	     *
	     * @return {Artefact} - the root of the artefact hierarchy
	     */
	
					get: function () {
						if (!this._root) {
							this._root = this.parent ? this.parent.root : this;
						}
						return this._root;
					},
					configurable: true,
					enumerable: true
				}
			})));
	
			/** {@function Artefact.newSubclass}
	   * A static convenience function for creating a subclass of {@link Artefact}.
	   */
			window._amy_Artefact.newSubclass = function newSubClass(name, constructor) {
				var prototype = arguments[2] === undefined ? {} : arguments[2];
				var optionDefaults = arguments[3] === undefined ? {} : arguments[3];
	
				return deltaJs.vp(name, U.newSubclass(window._amy_Artefact, function (superFn) {
					return function () {
						var _this = this;
	
						var options = arguments[0] === undefined ? {} : arguments[0];
	
						/* process options */
						var processedOptions = options;
						Object.keys(optionDefaults).forEach(function (key) {
							if (U.isUndefined(processedOptions[key])) {
								processedOptions[key] = optionDefaults[key];
							}
						});
						processedOptions.type = name;
	
						/* call super-constructor */
						superFn.call(this, U.extend(options, processedOptions));
	
						/* call this constructor */
						constructor.call(this, processedOptions);
	
						/* then run the 'construct' method */
						if (this.constructed) {
							// construct asynchronously
							this.constructed = this.constructed.then(function () {
								if ($.isFunction(_this.construct)) {
									return P.resolve(_this.construct(options))['return'](_this);
								}
								return _this;
							});
						} else if ($.isFunction(this.construct)) {
							this.beforeConstruction(this.construct(options));
						}
	
						/* register this artefact to the circuitboard */
						(this.constructed || P.resolve()).then(function () {
							_this.root._registerArtefact(_this);
						});
					};
				}, U.extend({}, prototype, Object.defineProperties({}, {
					circuitboard: {
						get: function () {
							if (!this._circuitboard) {
								this._circuitboard = this.closestAncestorByType('Circuitboard');
							}
							return this._circuitboard;
						},
						configurable: true,
						enumerable: true
					}
				}))));
			};
	
			return window._amy_Artefact;
		}).tap(function (c) {
			$.circuitboard.Artefact = c;
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(84);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(71)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/D3Vertex.scss", function() {
			var newContent = require("!!/home/mhelvens/Projects/apinatomy/node_modules/css-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/autoprefixer-loader/index.js!/home/mhelvens/Projects/apinatomy/node_modules/sass-loader/index.js!/home/mhelvens/Projects/apinatomy/src/D3Vertex.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(85)();
	exports.push([module.id, "", ""]);

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function() {
		var list = [];
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
		return list;
	}

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define(factory);
		else if(typeof exports === 'object')
			exports["DeltaJs"] = factory();
		else
			root["DeltaJs"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		__webpack_require__(1);
		module.exports = __webpack_require__(2);
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = __webpack_require__(8);
	
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
		
		Object.defineProperty(exports, '__esModule', {
		                    value: true
		});
		/* import utilities */
		
		var _extend = __webpack_require__(3);
		
		/* import the DeltaJs class */
		
		var _DeltaJs = __webpack_require__(4);
		
		var _DeltaJs2 = _interopRequireWildcard(_DeltaJs);
		
		/* make Target classes available under the DeltaJs symbol */
		
		var _ReadableTarget$WritableTarget = __webpack_require__(5);
		
		/* make Path classes available under the DeltaJs symbol */
		
		var _Path = __webpack_require__(6);
		
		var _Path2 = _interopRequireWildcard(_Path);
		
		/* make Error classes available under the DeltaJs symbol */
		
		var _ApplicationError$PreconditionFailure$MultipleOverloadsApplicationError$NoOverloadsApplicationError$CompositionError$MultipleOverloadsCompositionError$ConstraintFailure$ApplicationOrderCycle$UnresolvedDeltaConflict$MultipleActiveProxiesError = __webpack_require__(7);
		
		_extend.extend(_DeltaJs2['default'], { ReadableTarget: _ReadableTarget$WritableTarget.ReadableTarget, WritableTarget: _ReadableTarget$WritableTarget.WritableTarget });
		_extend.extend(_DeltaJs2['default'], { Path: _Path2['default'] });
		_extend.extend(_DeltaJs2['default'], { ApplicationError: _ApplicationError$PreconditionFailure$MultipleOverloadsApplicationError$NoOverloadsApplicationError$CompositionError$MultipleOverloadsCompositionError$ConstraintFailure$ApplicationOrderCycle$UnresolvedDeltaConflict$MultipleActiveProxiesError.ApplicationError, PreconditionFailure: _ApplicationError$PreconditionFailure$MultipleOverloadsApplicationError$NoOverloadsApplicationError$CompositionError$MultipleOverloadsCompositionError$ConstraintFailure$ApplicationOrderCycle$UnresolvedDeltaConflict$MultipleActiveProxiesError.PreconditionFailure, MultipleOverloadsApplicationError: _ApplicationError$PreconditionFailure$MultipleOverloadsApplicationError$NoOverloadsApplicationError$CompositionError$MultipleOverloadsCompositionError$ConstraintFailure$ApplicationOrderCycle$UnresolvedDeltaConflict$MultipleActiveProxiesError.MultipleOverloadsApplicationError,
		                    NoOverloadsApplicationError: _ApplicationError$PreconditionFailure$MultipleOverloadsApplicationError$NoOverloadsApplicationError$CompositionError$MultipleOverloadsCompositionError$ConstraintFailure$ApplicationOrderCycle$UnresolvedDeltaConflict$MultipleActiveProxiesError.NoOverloadsApplicationError, CompositionError: _ApplicationError$PreconditionFailure$MultipleOverloadsApplicationError$NoOverloadsApplicationError$CompositionError$MultipleOverloadsCompositionError$ConstraintFailure$ApplicationOrderCycle$UnresolvedDeltaConflict$MultipleActiveProxiesError.CompositionError,
		                    MultipleOverloadsCompositionError: _ApplicationError$PreconditionFailure$MultipleOverloadsApplicationError$NoOverloadsApplicationError$CompositionError$MultipleOverloadsCompositionError$ConstraintFailure$ApplicationOrderCycle$UnresolvedDeltaConflict$MultipleActiveProxiesError.MultipleOverloadsCompositionError, ConstraintFailure: _ApplicationError$PreconditionFailure$MultipleOverloadsApplicationError$NoOverloadsApplicationError$CompositionError$MultipleOverloadsCompositionError$ConstraintFailure$ApplicationOrderCycle$UnresolvedDeltaConflict$MultipleActiveProxiesError.ConstraintFailure,
		                    ApplicationOrderCycle: _ApplicationError$PreconditionFailure$MultipleOverloadsApplicationError$NoOverloadsApplicationError$CompositionError$MultipleOverloadsCompositionError$ConstraintFailure$ApplicationOrderCycle$UnresolvedDeltaConflict$MultipleActiveProxiesError.ApplicationOrderCycle, UnresolvedDeltaConflict: _ApplicationError$PreconditionFailure$MultipleOverloadsApplicationError$NoOverloadsApplicationError$CompositionError$MultipleOverloadsCompositionError$ConstraintFailure$ApplicationOrderCycle$UnresolvedDeltaConflict$MultipleActiveProxiesError.UnresolvedDeltaConflict,
		                    MultipleActiveProxiesError: _ApplicationError$PreconditionFailure$MultipleOverloadsApplicationError$NoOverloadsApplicationError$CompositionError$MultipleOverloadsCompositionError$ConstraintFailure$ApplicationOrderCycle$UnresolvedDeltaConflict$MultipleActiveProxiesError.MultipleActiveProxiesError });
		
		/* export the DeltaJs class */
		exports['default'] = _DeltaJs2['default'];
		module.exports = exports['default'];
	
	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };
		
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		/*  extend the first passed object with the properties     */
		/*  of the other objects, from left to right, and returns  */
		/*  the first passed object                                */
		exports.extend = extend;
		exports.o = o;
		exports.a = a;
		exports.m = m;
		exports.s = s;
		
		/* a simple `assert` function, to express a condition that is expected to be true */
		exports.assert = assert;
		
		/* test if a value is `undefined` */
		exports.isUndefined = isUndefined;
		
		/* test if a value is defined (not `undefined`) */
		exports.isDefined = isDefined;
		
		/* repeat a string a given number of times */
		exports.repeat = repeat;
		
		/* shift every line in a string right by a given number of spaces */
		exports.indent = indent;
		exports.oncePer = oncePer;
		exports.mapEqual = mapEqual;
		exports.customIndexOf = customIndexOf;
		exports.arraysEqual = arraysEqual;
		exports.arraysHaveSameElements = arraysHaveSameElements;
		exports.swapLastTwo = swapLastTwo;
		
		function extend(obj1) {
			for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				rest[_key - 1] = arguments[_key];
			}
		
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;
		
			try {
				for (var _iterator = rest[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var obj = _step.value;
					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;
		
					try {
						for (var _iterator2 = Object.keys(obj)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							var key = _step2.value;
		
							Object.defineProperty(obj1, key, Object.getOwnPropertyDescriptor(obj, key));
						}
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2['return']) {
								_iterator2['return']();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator['return']) {
						_iterator['return']();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		
			return obj1;
		}
		
		var _default = function _default(ds) {
			return function (object) {
				for (var _len2 = arguments.length, rest = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
					rest[_key2 - 1] = arguments[_key2];
				}
		
				var keys = rest.slice(0, -1);
				var def = rest[rest.length - 1];
				if (keys.length === 0) {
					return object;
				}
				var last = ds.apply(undefined, [object].concat(_toConsumableArray(keys.slice(0, -1))));
				if (last instanceof Map) {
					if (isUndefined(last.get(keys[keys.length - 1]))) {
						last.set(keys[keys.length - 1], def);
					}
					return last.get(keys[keys.length - 1]);
				} else {
					if (isUndefined(last[keys[keys.length - 1]])) {
						last[keys[keys.length - 1]] = def;
					}
					return last[keys[keys.length - 1]];
				}
			};
		};
		
		function o(object) {
			for (var _len3 = arguments.length, keys = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
				keys[_key3 - 1] = arguments[_key3];
			}
		
			return _default(o).apply(undefined, [object].concat(keys, [{}]));
		}
		
		function a(object) {
			for (var _len4 = arguments.length, keys = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
				keys[_key4 - 1] = arguments[_key4];
			}
		
			return _default(o).apply(undefined, [object].concat(keys, [[]]));
		}
		
		function m(object) {
			for (var _len5 = arguments.length, keys = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
				keys[_key5 - 1] = arguments[_key5];
			}
		
			return _default(m).apply(undefined, [object].concat(keys, [new Map()]));
		}
		
		function s(object) {
			for (var _len6 = arguments.length, keys = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
				keys[_key6 - 1] = arguments[_key6];
			}
		
			return _default(m).apply(undefined, [object].concat(keys, [new Set()]));
		}
		
		function assert(condition, message) {
			if (!condition) {
				throw new Error(message || 'Assertion failed');
			}
		}
		
		function isUndefined(val) {
			return typeof val === 'undefined';
		}
		
		function isDefined(val) {
			return typeof val !== 'undefined';
		}
		
		function repeat(nr, str) {
			return new Array(nr + 1).join(str);
		}
		
		function indent(str, amount) {
			var char = arguments[2] === undefined ? ' ' : arguments[2];
		
			return str.replace(/^(?!\s*$)/mg, repeat(amount, char));
		}
		
		/* run a function only once per obj+string combo */
		var _oncePerSymbols = {};
		
		function oncePer(obj, key, fn) {
			var opFn = function opFn(obj) {
				if (!_oncePerSymbols[key]) {
					_oncePerSymbols[key] = Symbol('once per:' + key);
				}
				if (obj[_oncePerSymbols[key]]) {
					return;
				}
				obj[_oncePerSymbols[key]] = true;
				return fn.call(obj, obj);
			};
			if (typeof obj === 'string') {
				var _ref = [obj, key];
				key = _ref[0];
				fn = _ref[1];
		
				return opFn;
			} else {
				return opFn(obj);
			}
		}
		
		/* shorthand specifier for composition preconditions */
		var t = function t(type1, type2) {
			return function (d1, d2) {
				return d1.type === type1 && d2.type === type2;
			};
		};
		
		exports.t = t;
		/* shorthand specifier for composition implementations */
		var define_d = function define_d(deltaJs) {
			return function (type, fn) {
				if (typeof fn === 'string') {
					fn = (function (v) {
						return function (o) {
							return o[v];
						};
					})(fn);
				}
				return function (d1, d2) {
					return new deltaJs.Delta[type](fn && fn({ d1: d1, d2: d2, p1: d1.arg, p2: d2.arg }));
				};
			};
		};
		
		exports.define_d = define_d;
		
		function mapEqual(a, b) {
			var eq = arguments[2] === undefined ? function (x, y) {
				return x === y;
			} : arguments[2];
		
			if (a.size !== b.size) {
				return false;
			}
			var aKeys = [].concat(_toConsumableArray(a.keys())).sort();
			var bKeys = [].concat(_toConsumableArray(b.keys())).sort();
			for (var i = 0; i < aKeys.length; ++i) {
				if (aKeys[i] !== bKeys[i]) {
					return false;
				}
				if (!eq(a.get(aKeys[i]), b.get(bKeys[i]))) {
					return false;
				}
			}
			return true;
		}
		
		function customIndexOf(a, value) {
			var eq = arguments[2] === undefined ? function (x, y) {
				return x === y;
			} : arguments[2];
		
			for (var i = 0; i < a.length; ++i) {
				if (eq(a[i], value)) {
					return i;
				}
			}
			return -1;
		}
		
		function arraysEqual(a, b) {
			var eq = arguments[2] === undefined ? function (x, y) {
				return x === y;
			} : arguments[2];
		
			if (a.length !== b.length) {
				return false;
			}
			for (var i = 0; i < a.length; ++i) {
				if (!eq(a[i], b[i])) {
					return false;
				}
			}
			return true;
		}
		
		function arraysHaveSameElements(a, b) {
			var eq = arguments[2] === undefined ? function (x, y) {
				return x === y;
			} : arguments[2];
		
			if (a.length !== b.length) {
				return false;
			}
			var bb = [].concat(_toConsumableArray(b));
			for (var i = 0; i < a.length; ++i) {
				var found = false;
				for (var j = 0; j < bb.length; ++j) {
					if (eq(a[i], bb[j])) {
						bb.splice(j, 1);
						found = true;
						break;
					}
				}
				if (!found) {
					return false;
				}
			}
			return true;
		}
		
		function swapLastTwo(a) {
			return a.slice(0, -2).concat([a[a.length - 1], a[a.length - 2]]);
		}
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
		
		var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };
		
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		/* import internal stuff */
		
		var _extend$assert$isUndefined$isDefined$arraysEqual = __webpack_require__(3);
		
		var _Path = __webpack_require__(6);
		
		var _Path2 = _interopRequireWildcard(_Path);
		
		var _ReadableTarget$WritableTarget$rt$wt = __webpack_require__(5);
		
		var _define_OperationTypes = __webpack_require__(9);
		
		var _define_OperationTypes2 = _interopRequireWildcard(_define_OperationTypes);
		
		var _define_Delta = __webpack_require__(10);
		
		var _define_Delta2 = _interopRequireWildcard(_define_Delta);
		
		var _define_Overloaded = __webpack_require__(11);
		
		var _define_Overloaded2 = _interopRequireWildcard(_define_Overloaded);
		
		var _define_Modify = __webpack_require__(12);
		
		var _define_Modify2 = _interopRequireWildcard(_define_Modify);
		
		var _define_basicOperations = __webpack_require__(13);
		
		var _define_basicOperations2 = _interopRequireWildcard(_define_basicOperations);
		
		var _define_PutIntoArray = __webpack_require__(14);
		
		var _define_PutIntoArray2 = _interopRequireWildcard(_define_PutIntoArray);
		
		var _define_PutIntoFunction = __webpack_require__(15);
		
		var _define_PutIntoFunction2 = _interopRequireWildcard(_define_PutIntoFunction);
		
		var _define_DeltaModel = __webpack_require__(16);
		
		var _define_DeltaModel2 = _interopRequireWildcard(_define_DeltaModel);
		
		var _define_features = __webpack_require__(17);
		
		var _define_features2 = _interopRequireWildcard(_define_features);
		
		var _define_variationPoints = __webpack_require__(18);
		
		var _define_variationPoints2 = _interopRequireWildcard(_define_variationPoints);
		
		var _define_applicationConditions = __webpack_require__(19);
		
		var _define_applicationConditions2 = _interopRequireWildcard(_define_applicationConditions);
		
		var _define_ContainerProxy = __webpack_require__(20);
		
		var _define_ContainerProxy2 = _interopRequireWildcard(_define_ContainerProxy);
		
		/**
		 * @public
		 * @class DeltaJs
		 * @classdesc
		 * This class offers every functionality you need from delta modeling.
		 * Each instance offers its own operation types and variation points
		 * and acts as a facade (as in design pattern) to the more specific
		 * subsystems of delta.js.
		 *
		 * Using multiple `DeltaJs` instances allows you to use different sets
		 * of deltas and rules in the same project that work independently
		 * from each other. But you will usually need only one DeltaJs
		 * instance per application.
		 */
		
		var DeltaJs = function DeltaJs() {
			_classCallCheck(this, DeltaJs);
		
			_define_OperationTypes2['default'](this);
			_define_ContainerProxy2['default'](this);
			_define_Delta2['default'](this);
			_define_Overloaded2['default'](this);
			_define_Modify2['default'](this);
			_define_basicOperations2['default'](this);
			_define_PutIntoArray2['default'](this);
			_define_PutIntoFunction2['default'](this);
			_define_DeltaModel2['default'](this);
			_define_features2['default'](this);
			_define_variationPoints2['default'](this);
			_define_applicationConditions2['default'](this);
		};
		
		exports['default'] = DeltaJs;
		module.exports = exports['default'];
	
	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		
		var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
		
		var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
		
		var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.wt = wt;
		exports.rt = rt;
		
		var ReadableTarget = (function () {
			function ReadableTarget(value) {
				_classCallCheck(this, ReadableTarget);
		
				this._val = value;
			}
		
			_createClass(ReadableTarget, [{
				key: "getValue",
				value: function getValue() {
					return this._val;
				}
			}, {
				key: "value",
				get: function () {
					return this.getValue();
				},
				set: function (v) {
					this.setValue(v);
				}
			}]);
		
			return ReadableTarget;
		})();
		
		exports.ReadableTarget = ReadableTarget;
		
		var WritableTarget = (function (_ReadableTarget) {
			function WritableTarget(obj, prop) {
				_classCallCheck(this, WritableTarget);
		
				_get(Object.getPrototypeOf(WritableTarget.prototype), "constructor", this).call(this);
				this._obj = obj;
				this._prop = prop;
			}
		
			_inherits(WritableTarget, _ReadableTarget);
		
			_createClass(WritableTarget, [{
				key: "getValue",
				value: function getValue() {
					return this._obj[this._prop];
				}
			}, {
				key: "setValue",
				value: function setValue(v) {
					this._obj[this._prop] = v;
				}
			}, {
				key: "delete",
				value: function _delete() {
					delete this._obj[this._prop];
				}
			}]);
		
			return WritableTarget;
		})(ReadableTarget);
		
		exports.WritableTarget = WritableTarget;
		
		function wt(obj, prop) {
			return new WritableTarget(obj, prop);
		}
		
		function rt(obj, prop) {
			return new ReadableTarget(obj, prop);
		}
	
	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } };
		
		var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		
		var _assert$isDefined = __webpack_require__(3);
		
		var Path = (function () {
			function Path() {
				var str = arguments[0] === undefined ? '' : arguments[0];
		
				_classCallCheck(this, Path);
		
				///////////////////////  11111  22222222222  33  //
				var match = str.match(/^([.#]?)(\w*|\(\w+\))(.*)$/);
				_assert$isDefined.assert(match, 'The path string \'' + str + '\' is not well formed.');
		
				var _match = _slicedToArray(match, 4);
		
				var lead = _match[1];
				var prop = _match[2];
				var rest = _match[3];
		
				if (lead === '#') {
					// The # separator is used in the JsDoc sense, and is translated to '.(instance).'
					this.set(new Path('.(instance).' + prop + '' + rest));
				} else if (prop !== '') {
					this._prop = prop;
					if (rest !== '') {
						this._rest = new Path(rest);
					}
				}
			}
		
			_createClass(Path, [{
				key: 'set',
				value: function set(other) {
					this._prop = other._prop;
					this._rest = other._rest;
				}
			}, {
				key: 'prop',
				get: function () {
					return this._prop;
				}
			}, {
				key: 'rest',
				get: function () {
					return this._rest;
				}
			}, {
				key: 'toString',
				value: function toString() {
					var result = '';
					if (_assert$isDefined.isDefined(this.prop)) {
						result += this.prop;
						if (_assert$isDefined.isDefined(this.rest)) {
							result += '.' + this.rest.toString();
						}
					}
					return result;
				}
			}]);
		
			return Path;
		})();
		
		exports['default'] = Path;
		module.exports = exports['default'];
	
		// TODO: implement that the `.(instance).` members are actually included in instances
	
	/***/ },
	/* 7 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };
		
		var _bind = Function.prototype.bind;
		var _slice = Array.prototype.slice;
		
		var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
		
		var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };
		
		var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
		
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		
		var ApplicationError = (function (_Error) {
			function ApplicationError() {
				_classCallCheck(this, ApplicationError);
		
				if (_Error != null) {
					var _this = new (_bind.apply(_Error, [null].concat(_slice.call(arguments))))();
		
					_this.__proto__ = ApplicationError.prototype;
					return _this;
				}
		
				return _this;
			}
		
			_inherits(ApplicationError, _Error);
		
			return ApplicationError;
		})(Error);
		
		exports.ApplicationError = ApplicationError;
		
		var PreconditionFailure = (function (_ApplicationError) {
			function PreconditionFailure(delta, value) {
				_classCallCheck(this, PreconditionFailure);
		
				_get(Object.getPrototypeOf(PreconditionFailure.prototype), 'constructor', this).call(this);
				this.name = 'PreconditionFailure';
				this.message = 'This delta of type \'' + delta.type + '\' cannot apply to this value of type \'' + typeof value + '\'.';
				this.delta = delta;
				this.value = value;
			}
		
			_inherits(PreconditionFailure, _ApplicationError);
		
			return PreconditionFailure;
		})(ApplicationError);
		
		exports.PreconditionFailure = PreconditionFailure;
		
		var MultipleOverloadsApplicationError = (function (_PreconditionFailure) {
			function MultipleOverloadsApplicationError(delta, value) {
				var errors = arguments[2] === undefined ? [] : arguments[2];
		
				_classCallCheck(this, MultipleOverloadsApplicationError);
		
				_get(Object.getPrototypeOf(MultipleOverloadsApplicationError.prototype), 'constructor', this).call(this, delta, value);
				this.name = 'MultipleOverloadsApplicationError';
				this.message = 'None of the delta-types ' + delta.overloads.map(function (d) {
					return '\'' + d.type + '\'';
				}).join(',') + ' can apply to this value of type \'' + typeof value + '\'.' + errors.map(function (e) {
					return '\n-- ' + e.message;
				}).join('');
				this.errors = errors;
			}
		
			_inherits(MultipleOverloadsApplicationError, _PreconditionFailure);
		
			return MultipleOverloadsApplicationError;
		})(PreconditionFailure);
		
		exports.MultipleOverloadsApplicationError = MultipleOverloadsApplicationError;
		
		var NoOverloadsApplicationError = (function (_PreconditionFailure2) {
			function NoOverloadsApplicationError(delta, value) {
				_classCallCheck(this, NoOverloadsApplicationError);
		
				_get(Object.getPrototypeOf(NoOverloadsApplicationError.prototype), 'constructor', this).call(this, delta, value);
				this.name = 'NoOverloadsApplicationError';
				this.message = 'This delta of type \'' + delta.type + '\' has no specific deltas assigned to it, so it cannot apply to this value of type \'' + typeof value + '.';
			}
		
			_inherits(NoOverloadsApplicationError, _PreconditionFailure2);
		
			return NoOverloadsApplicationError;
		})(PreconditionFailure);
		
		exports.NoOverloadsApplicationError = NoOverloadsApplicationError;
		
		var CompositionError = (function (_Error2) {
			function CompositionError(delta1, delta2) {
				_classCallCheck(this, CompositionError);
		
				var _this2 = new _Error2();
		
				_this2.__proto__ = CompositionError.prototype;
		
				_this2.name = 'CompositionError';
				_this2.message = 'This delta of type \'' + delta1.type + '\' cannot be composed with this other delta of type \'' + delta2.type + '\'.';
				_this2.delta1 = delta1;
				_this2.delta2 = delta2;
				return _this2;
			}
		
			_inherits(CompositionError, _Error2);
		
			return CompositionError;
		})(Error);
		
		exports.CompositionError = CompositionError;
		
		var MultipleOverloadsCompositionError = (function (_CompositionError) {
			function MultipleOverloadsCompositionError(delta1, delta2) {
				var errors = arguments[2] === undefined ? [] : arguments[2];
		
				_classCallCheck(this, MultipleOverloadsCompositionError);
		
				_get(Object.getPrototypeOf(MultipleOverloadsCompositionError.prototype), 'constructor', this).call(this, delta1, delta2);
				this.name = 'MultipleOverloadsCompositionError';
				this.message = 'There are no overloads to compose this delta of type \'' + delta1.type + '\' with this other delta of type \'' + delta2.type + '\'.' + errors.map(function (e) {
					return '\n-- ' + e.message;
				}).join('');
				this.errors = errors;
			}
		
			_inherits(MultipleOverloadsCompositionError, _CompositionError);
		
			return MultipleOverloadsCompositionError;
		})(CompositionError);
		
		exports.MultipleOverloadsCompositionError = MultipleOverloadsCompositionError;
		
		var ConstraintFailure = (function (_Error3) {
			function ConstraintFailure(feature) {
				_classCallCheck(this, ConstraintFailure);
		
				var _this3 = new _Error3();
		
				_this3.__proto__ = ConstraintFailure.prototype;
		
				_this3.name = 'ConstraintFailure';
				_this3.message = 'The feature \'' + feature.name + '\' is both selected and excluded by its constraints.';
				_this3.feature = feature;
				return _this3;
			}
		
			_inherits(ConstraintFailure, _Error3);
		
			return ConstraintFailure;
		})(Error);
		
		exports.ConstraintFailure = ConstraintFailure;
		
		var ApplicationOrderCycle = (function (_Error4) {
			function ApplicationOrderCycle(cycle) {
				_classCallCheck(this, ApplicationOrderCycle);
		
				var _this4 = new _Error4();
		
				_this4.__proto__ = ApplicationOrderCycle.prototype;
		
				_this4.name = 'ApplicationOrderCycle';
				_this4.message = 'The new application order created a cycle: ' + cycle + '}';
				_this4.cycle = cycle;
				return _this4;
			}
		
			_inherits(ApplicationOrderCycle, _Error4);
		
			return ApplicationOrderCycle;
		})(Error);
		
		exports.ApplicationOrderCycle = ApplicationOrderCycle;
		
		var UnresolvedDeltaConflict = (function (_ApplicationError2) {
			function UnresolvedDeltaConflict(deltaNames) {
				_classCallCheck(this, UnresolvedDeltaConflict);
		
				_get(Object.getPrototypeOf(UnresolvedDeltaConflict.prototype), 'constructor', this).call(this);
				this.name = 'UnresolvedDeltaConflict';
				deltaNames = [].concat(_toConsumableArray(deltaNames));
				var nameList = deltaNames.slice(0, -1).map(function (name) {
					return '\'' + name + '\'';
				}).join(',');
				this.message = 'There is an unresolved conflict between deltas ' + nameList + ' and \'' + deltaNames[deltaNames.length - 1] + '\'.';
				this.deltaNames = deltaNames;
			}
		
			_inherits(UnresolvedDeltaConflict, _ApplicationError2);
		
			return UnresolvedDeltaConflict;
		})(ApplicationError);
		
		exports.UnresolvedDeltaConflict = UnresolvedDeltaConflict;
		
		var MultipleActiveProxiesError = (function (_Error5) {
			function MultipleActiveProxiesError() {
				_classCallCheck(this, MultipleActiveProxiesError);
		
				var _this5 = new _Error5();
		
				_this5.__proto__ = MultipleActiveProxiesError.prototype;
		
				_this5.name = 'MultipleActiveProxiesError';
				_this5.message = 'Only one Proxy per path can be active at any given time.';
				return _this5;
			}
		
			_inherits(MultipleActiveProxiesError, _Error5);
		
			return MultipleActiveProxiesError;
		})(Error);
		
		exports.MultipleActiveProxiesError = MultipleActiveProxiesError;
	
	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = __webpack_require__(21);
	
	
	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _bind = Function.prototype.bind;
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		/* import internal stuff */
		
		var _extend$oncePer$assert$isUndefined = __webpack_require__(3);
		
		exports['default'] = _extend$oncePer$assert$isUndefined.oncePer('operation types', function (deltaJs) {
		
			_extend$oncePer$assert$isUndefined.oncePer(deltaJs.constructor, 'operation types', function (DeltaJs) {
				_extend$oncePer$assert$isUndefined.extend(DeltaJs.prototype, /** @lends DeltaJs.prototype */{
		
					/**
		    * This method allows you to tell delta.js about a new kind of delta operation.
		    * This was also done for existing operations like `modify`, `add`, `remove`, and so on.
		    * @param name          {string}    - name of the new operation type
		    * @param DeltaSubclass {function}  - the new operation class
		    * @param ProxySubclass {?function} - the optional custom `Proxy` subclass for this operation-type
		    */
					newOperationType: function newOperationType(name, DeltaSubclass) {
						var ProxySubclass = arguments[2] === undefined ? null : arguments[2];
		
						/* sanity checks */
						_extend$oncePer$assert$isUndefined.assert(name[0] === name[0].toUpperCase(), 'Names of delta operation classes must start with a capital letter - \'' + name + '\' does not.');
						_extend$oncePer$assert$isUndefined.assert(_extend$oncePer$assert$isUndefined.isUndefined(this.Delta[name]), 'The \'' + name + '\' operation type already exists.');
		
						/* store the operation class */
						this.Delta[name] = DeltaSubclass;
		
						/* set the (optional) Proxy class */
						DeltaSubclass.Proxy = ProxySubclass;
		
						/* fetch certain given methods (if they exist) that need to be slightly augmented */
						var givenApplyTo = DeltaSubclass.prototype.applyTo || function () {};
		
						/* augment the class prototype */
						_extend$oncePer$assert$isUndefined.extend(DeltaSubclass.prototype, {
							applyTo: function applyTo(target) {
								var options = arguments[1] === undefined ? {} : arguments[1];
		
								/* should this delta only be applied for a specific feature selection? */
								if (!this.selected) {
									return;
								}
		
								/* if the target is not already in Target form, make it so now */
								if (!(target instanceof DeltaJs.ReadableTarget)) {
									target = new DeltaJs.ReadableTarget(target);
								}
		
								/* option defaults */
								if (_extend$oncePer$assert$isUndefined.isUndefined(options.weak)) {
									options.weak = false;
								}
		
								/* does the target satisfy the precondition of the delta? */
								var judgment = this.evaluatePrecondition(target, options);
								if (judgment !== true) {
									throw judgment;
								}
		
								/* OK, then apply it if a method to do so was included in the operation */
								givenApplyTo.call(this, target, options);
							},
							type: name
						});
		
						/* create any given methods with default handler */
						var lowercaseName = name[0].toLowerCase() + name.slice(1);
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;
		
						try {
							for (var _iterator = (DeltaSubclass.prototype.methods || [lowercaseName])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var method = _step.value;
		
								this.ContainerProxy.newProxyMethod(method, function () {
									for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
										args[_key] = arguments[_key];
									}
		
									return new (_bind.apply(DeltaSubclass, [null].concat(args)))();
								});
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator['return']) {
									_iterator['return']();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}
		
						/* return the new class */
						return DeltaSubclass;
					}
		
				});
			});
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
		
		var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };
		
		var _defineProperty = function (obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: key == null || typeof Symbol == 'undefined' || key.constructor !== Symbol, configurable: true, writable: true }); };
		
		var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		/* import internal stuff */
		
		var _extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo = __webpack_require__(3);
		
		var _ReadableTarget$wt = __webpack_require__(5);
		
		var _PreconditionFailure$CompositionError = __webpack_require__(7);
		
		var _define_Composed = __webpack_require__(22);
		
		var _define_Composed2 = _interopRequireWildcard(_define_Composed);
		
		exports['default'] = _extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.oncePer('Delta', function (deltaJs) {
		
			/**
		  * @class DeltaJs#Delta
		  */
			deltaJs.Delta = (function () {
				function Delta() {
					for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
						args[_key] = arguments[_key];
					}
		
					_classCallCheck(this, Delta);
		
					this.id = ++deltaJs.Delta._nextID;
					this.args = args;
				}
		
				_createClass(Delta, [{
					key: 'arg',
					get: function () {
						return this.args[0];
					},
					set: function (v) {
						this.args[0] = v;
					}
				}, {
					key: 'clone',
		
					/**
		    * This method should be overwritten by subclasses to make a clone of 'this' delta.
		    * @abstract
		    * @nosideeffects
		    * @return {DeltaJs#Delta} - a clone of this delta
		    */
					value: function clone() {
						return new this.constructor(this.arg);
					}
				}, {
					key: 'evaluatePrecondition',
		
					/**
		    * @protected
		    * @param target                        {DeltaJs.ReadableTarget}
		    * @param options                       {object}
		    * @param options.skipWeakPreconditions {boolean}
		    * @return {Boolean|PreconditionFailure} - `true` if the precondition is satisfied, otherwise
		    *                                        `false` or an instance of `DeltaJs.PreconditionFailure`
		    */
					value: function evaluatePrecondition(target) {
						var options = arguments[1] === undefined ? {} : arguments[1];
						var weak = options.weak;
		
						if (this.precondition) {
							var judgment = this.precondition(target, options);
							if (judgment instanceof _PreconditionFailure$CompositionError.PreconditionFailure) {
								return judgment;
							} else if (!judgment) {
								return new _PreconditionFailure$CompositionError.PreconditionFailure(this, target.value);
							}
						}
						return true;
					}
				}, {
					key: 'appliedTo',
		
					/**
		    * @nosideeffects
		    * @param value   {*}       - any given value
		    * @param options {?object} - the (optional) options for this delta application
		    * @return {*} - the value resulting in this delta being applied to the given `value`
		    */
					value: function appliedTo(value) {
						var options = arguments[1] === undefined ? {} : arguments[1];
		
						if (value instanceof _ReadableTarget$wt.ReadableTarget) {
							value = value.value;
						}
						if (typeof value.clone === 'function') {
							value = value.clone();
						}
						var obj = { value: value };
						this.applyTo(_ReadableTarget$wt.wt(obj, 'value'), options);
						return obj.value;
					}
				}, {
					key: 'toString',
		
					/**
		    * @param options {object?}
		    * @return {string}
		    */
					value: function toString() {
						var options = arguments[0] === undefined ? {} : arguments[0];
		
						var str = this.type;
						if (options.targetProp) {
							str += ' ‹' + options.targetProp + '›';
						}
						if (this.args.length > 0) {
							str += ': ' + this.args.map(function (a) {
								return JSON.stringify(a);
							}).join(',');
						}
						if (options.debug) {
							str += ' (' + this.id + ')';
						}
						return str;
					}
				}]);
		
				return Delta;
			})();
			deltaJs.Delta._nextID = 0;
		
			var _multiDispatchOptions = new Map();
		
			/**
		  * To create new 'multiple dispatch' functions for mixed types of deltas.
		  * Any number of candidate functions can be created,
		  * which are then selected based on their precondition predicates.
		  * @private
		  * @param name                        {string}
		  * @param staticMethodName            {string}
		  * @param methodName                  {string}
		  * @param options                     {object}
		  * @param [options.onTrue=undefined]  {function}
		  * @param [options.onFalse=undefined] {function}
		  * @param [options.onDefault=false]   {function|boolean}
		  * @param [options.commutative=false] {boolean}
		  * @param [options.arity=2]           {number}
		  */
			function newMultiDispatch(name, staticMethodName, methodName) {
				var _extend;
		
				var options = arguments[3] === undefined ? {} : arguments[3];
		
				/* set option defaults */
				if (_extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.isUndefined(options.commutative)) {
					options.commutative = false;
				}
				if (_extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.isUndefined(options.arity)) {
					options.arity = 2;
				}
				if (_extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.isUndefined(options.onTrue)) {
					options.onTrue = function () {
						for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
							args[_key2] = arguments[_key2];
						}
		
						return args.slice(0, options.arity);
					};
				}
				if (_extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.isUndefined(options.onFalse)) {
					options.onFalse = function () {
						throw new Error('Failure in finding a ' + name + '!');
					};
				}
				if (options.onDefault === 'onTrue') {
					options.onDefault = options.onTrue;
				} else if (options.onDefault === 'onFalse' || _extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.isUndefined(options.onDefault)) {
					options.onDefault = options.onFalse;
				}
		
				/* augment the options and store them */
				_extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.extend(options, {
					name: name, staticMethodName: staticMethodName, methodName: methodName,
					creationMethodName: 'new' + name[0].toUpperCase() + '' + name.slice(1),
					storageSymbol: Symbol('multiDispatch:' + name)
				});
				_multiDispatchOptions.set(name, options);
		
				/* short names for all relevant options */
				var creationMethodName = options.creationMethodName;
				var storageSymbol = options.storageSymbol;
				var onTrue = options.onTrue;
				var onFalse = options.onFalse;
				var onDefault = options.onDefault;
				var commutative = options.commutative;
				var arity = options.arity;
		
				/* set static Delta members */
				_extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.extend(deltaJs.Delta, (_extend = {}, _defineProperty(_extend, storageSymbol, []), _defineProperty(_extend, creationMethodName, function (precondition, value) {
					var options = arguments[2] === undefined ? {} : arguments[2];
		
					if (_extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.isUndefined(options.weak)) {
						options.weak = false;
					}
					if (_extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.isUndefined(deltaJs.Delta[storageSymbol])) {
						deltaJs.Delta[storageSymbol] = [];
					} // TODO: investigate why this is sometimes necessary
					deltaJs.Delta[storageSymbol].push({ precondition: precondition, value: value, options: options });
				}), _defineProperty(_extend, staticMethodName, function () {
					for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
						args[_key3] = arguments[_key3];
					}
		
					var deltas = args.slice(0, arity),
					    callOptions = args[arity] || {};
		
					/* defaults */
					if (_extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.isUndefined(callOptions.weak)) {
						callOptions.weak = false;
					}
		
					/* use the first composition function for which these deltas satisfy the precondition */
					var fn = function fn() {},
					    found = false,
					    commuting = false;
					if (_extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.isUndefined(deltaJs.Delta[storageSymbol])) {
						deltaJs.Delta[storageSymbol] = [];
					} // TODO: investigate why this is sometimes necessary
					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;
		
					try {
						for (var _iterator = deltaJs.Delta[storageSymbol][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							var _step$value = _step.value;
							var precondition = _step$value.precondition;
							var value = _step$value.value;
							var _options = _step$value.options;
		
							if (_options.weak && !callOptions.weak) {
								continue;
							} // only test weak rules when doing weak invocation
							if (precondition.apply(undefined, _toConsumableArray(deltas))) {
								fn = value;
								found = true;
								break;
							} else if (commutative && precondition.apply(undefined, _toConsumableArray(_extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.swapLastTwo(deltas)))) {
								fn = value;
								found = true;
								commuting = true;
								break;
							}
						}
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator['return']) {
								_iterator['return']();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}
		
					/* if no function was found, set the proper function */
					if (!found) {
						fn = onDefault;
					} else if (fn === false) {
						fn = onFalse;
					} else if (fn === true) {
						fn = onTrue;
					}
		
					/* return the result */
					if (commuting) {
						return fn.apply(undefined, _toConsumableArray(_extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.swapLastTwo(deltas)).concat([callOptions]));
					} else {
						return fn.apply(undefined, _toConsumableArray(deltas).concat([callOptions]));
					}
				}), _extend));
		
				/* set instance Delta members */
				_extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.extend(deltaJs.Delta.prototype, _defineProperty({}, methodName, function () {
					var _deltaJs$Delta;
		
					for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
						args[_key4] = arguments[_key4];
					}
		
					return (_deltaJs$Delta = deltaJs.Delta)[staticMethodName].apply(_deltaJs$Delta, [this].concat(args));
				}));
		
				/* set static DeltaJs members */
				_extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.oncePer(deltaJs.constructor, 'multiDispatch:' + name, function () {
					_extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.extend(deltaJs.constructor.prototype, _defineProperty({}, creationMethodName, function (precondition, value) {
						var options = arguments[2] === undefined ? {} : arguments[2];
		
						return this.Delta[creationMethodName](precondition, value, options);
					}));
				});
			}
		
			function customMultiDispatchGiven(name) {
				for (var _len5 = arguments.length, deltas = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
					deltas[_key5 - 1] = arguments[_key5];
				}
		
				var _multiDispatchOptions$get = _multiDispatchOptions.get(name);
		
				var storageSymbol = _multiDispatchOptions$get.storageSymbol;
				var commutative = _multiDispatchOptions$get.commutative;
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;
		
				try {
					for (var _iterator2 = deltaJs.Delta[storageSymbol][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var _step2$value = _step2.value;
						var precondition = _step2$value.precondition;
						var value = _step2$value.value;
		
						if (precondition.apply(undefined, deltas) || commutative && precondition.apply(undefined, _toConsumableArray(_extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.swapLastTwo(deltas)))) {
							return typeof value === 'function';
						}
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2['return']) {
							_iterator2['return']();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
		
				return false;
			}
		
			////////////////////////////////////////////////////////////////////////////////
			newMultiDispatch('composition', '_binaryComposed', 'composedWith', {
				onTrue: function onTrue(d1, d2, opt) {
					return new deltaJs.Delta.Composed([d1, d2], opt);
				},
				onFalse: function onFalse(d1, d2) {
					throw new _PreconditionFailure$CompositionError.CompositionError(d1, d2);
				},
				onDefault: 'onFalse'
			});
			deltaJs.Delta.composed = function composed() {
				for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
					args[_key6] = arguments[_key6];
				}
		
				/* separate arguments */
				var options = undefined,
				    deltas = undefined;
				if (!(args[args.length - 1] instanceof deltaJs.Delta) && typeof args[args.length - 1] !== 'undefined') {
					deltas = args.slice(0, args.length - 1);
					options = args[args.length - 1];
				} else {
					deltas = args;
					options = {};
				}
				/* compose the list of deltas, and pass the options to each binary composition */
				return deltas.map(function (d) {
					return d || new deltaJs.Delta.NoOp();
				}).reduce(function (d1, d2) {
					return deltaJs.Delta._binaryComposed(d1, d2, options);
				}, new deltaJs.Delta.NoOp());
			};
			////////////////////////////////////////////////////////////////////////////////
			newMultiDispatch('refinement', 'refines', 'refines', {
				onTrue: function onTrue(d1, d2) {
					return true;
				},
				onFalse: function onFalse(d1, d2) {
					return false;
				},
				onDefault: function onDefault(d1, d2, opt) {
					return d1.equals(d2, opt);
				}
			});
			////////////////////////////////////////////////////////////////////////////////
			newMultiDispatch('equality', 'equal', 'equals', {
				onTrue: function onTrue(d1, d2) {
					return true;
				},
				onFalse: function onFalse(d1, d2) {
					return false;
				},
				onDefault: function onDefault(d1, d2, opt) {
					if (customMultiDispatchGiven('refinement', d1, d2)) {
						return d1.refines(d2, opt) && d2.refines(d1, opt);
					} else {
						return d1.type === d2.type && _extend$oncePer$isDefined$isUndefined$arraysEqual$swapLastTwo.arraysEqual(d1.args, d2.args);
					}
				},
				commutative: true
			});
			////////////////////////////////////////////////////////////////////////////////
			newMultiDispatch('commutation', 'commute', 'commutesWith', {
				onTrue: function onTrue(d1, d2) {
					return true;
				},
				onFalse: function onFalse(d1, d2) {
					return false;
				},
				onDefault: function onDefault(d1, d2, opt) {
					return d1.composedWith(d2, opt).equals(d2.composedWith(d1, opt), opt);
				},
				commutative: true
			});
			////////////////////////////////////////////////////////////////////////////////
			newMultiDispatch('resolution', 'resolves', 'resolves', {
				onTrue: function onTrue(d1, d2, d3) {
					return true;
				},
				onFalse: function onFalse(d1, d2, d3) {
					return false;
				},
				onDefault: function onDefault(d1, d2, d3, opt) {
					return deltaJs.Delta.composed(d2, d3, d1, opt).equals(deltaJs.Delta.composed(d3, d2, d1, opt), opt);
				},
				arity: 3,
				commutative: true
			});
			////////////////////////////////////////////////////////////////////////////////
		
			/* define deltaJs.Delta.Composed for use in compositions */
			_define_Composed2['default'](deltaJs);
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
		
		var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
		
		var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
		
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		/* import internal stuff */
		
		var _indent$oncePer$arraysEqual$t = __webpack_require__(3);
		
		var _define_OperationTypes = __webpack_require__(9);
		
		var _define_OperationTypes2 = _interopRequireWildcard(_define_OperationTypes);
		
		var _define_Delta = __webpack_require__(10);
		
		var _define_Delta2 = _interopRequireWildcard(_define_Delta);
		
		var _MultipleOverloadsApplicationError$NoOverloadsApplicationError$MultipleOverloadsCompositionError = __webpack_require__(7);
		
		exports['default'] = _indent$oncePer$arraysEqual$t.oncePer('Overloaded', function (deltaJs) {
		
			_define_OperationTypes2['default'](deltaJs);
			_define_Delta2['default'](deltaJs);
		
			deltaJs.newOperationType('Overloaded', (function (_deltaJs$Delta) {
				function Overloaded() {
					for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
						args[_key] = arguments[_key];
					}
		
					_classCallCheck(this, Overloaded);
		
					_get(Object.getPrototypeOf(Overloaded.prototype), 'constructor', this).apply(this, args);
					this.overloads = this.arg || [];
				}
		
				_inherits(Overloaded, _deltaJs$Delta);
		
				_createClass(Overloaded, [{
					key: 'clone',
		
					/** {@public}{@method}{@nosideeffects}
		    * @return {DeltaJs#Delta.Overloaded} - a clone of this delta
		    */
					value: function clone() {
						var result = _get(Object.getPrototypeOf(Overloaded.prototype), 'clone', this).call(this);
						result.overloads = this.overloads.map(function (delta) {
							return delta.clone();
						});
						return result;
					}
				}, {
					key: 'precondition',
					value: function precondition(target, options) {
						/* find any overload with a precondition satisfied by the target; gather any errors */
						var errors = [];
						var success = this.overloads.some(function (delta) {
							var judgment = delta.evaluatePrecondition(target, options);
							if (judgment !== true) {
								errors.push(judgment);
								return false;
							}
							return true;
						});
						/* if none are satisfied, return the appropriate error */
						if (!success) {
							if (errors.length === 0) {
								return new _MultipleOverloadsApplicationError$NoOverloadsApplicationError$MultipleOverloadsCompositionError.NoOverloadsApplicationError(this, target.value);
							} else if (errors.length === 1) {
								return errors[0];
							} else {
								return new _MultipleOverloadsApplicationError$NoOverloadsApplicationError$MultipleOverloadsCompositionError.MultipleOverloadsApplicationError(this, target.value, errors);
							}
						}
						/* otherwise, return true */
						return true;
					}
				}, {
					key: 'applyTo',
		
					/** {@public}{@method}
		    * @param target  {Delta.WritableTarget} - the target to which to apply this delta
		    * @param options {object?}              - the (optional) options for this delta application
		    */
					value: function applyTo(target) {
						var options = arguments[1] === undefined ? {} : arguments[1];
		
						/* apply the first overload that applies to the target; gather any errors */
						var errors = [];
						var success = this.overloads.some(function (delta) {
							var judgment = delta.evaluatePrecondition(target);
							if (judgment !== true) {
								errors.push(judgment);
								return false;
							}
							delta.applyTo(target, options);
							return true;
						});
						/* if none apply, throw an appropriate error */
						if (!success) {
							if (errors.length === 0) {
								throw new _MultipleOverloadsApplicationError$NoOverloadsApplicationError$MultipleOverloadsCompositionError.NoOverloadsApplicationError(this, target.value);
							} else if (errors.length === 1) {
								throw errors[0];
							} else {
								throw new _MultipleOverloadsApplicationError$NoOverloadsApplicationError$MultipleOverloadsCompositionError.MultipleOverloadsApplicationError(this, target.value, errors);
							}
						}
					}
				}, {
					key: 'toString',
		
					/** {@public}{@method}
		    * @param options {object?}
		    * @return {string}
		    */
					value: function toString() {
						var options = arguments[0] === undefined ? {} : arguments[0];
		
						var str = _get(Object.getPrototypeOf(Overloaded.prototype), 'toString', this).call(this, options);
						var overloads = this.overloads.map(function (delta) {
							return delta.toString(options);
						}).join('\n');
						str += '\n' + _indent$oncePer$arraysEqual$t.indent(overloads, 4);
						return str;
					}
				}]);
		
				return Overloaded;
			})(deltaJs.Delta));
		
			/* composition */
			deltaJs.newComposition(function (d1, d2) {
				return d1 instanceof deltaJs.Delta.Overloaded || d2 instanceof deltaJs.Delta.Overloaded;
			}, function (d1, d2, opt) {
				var D1 = d1 instanceof deltaJs.Delta.Overloaded ? d1.overloads : [d1];
				var D2 = d2 instanceof deltaJs.Delta.Overloaded ? d2.overloads : [d2];
				var result = new deltaJs.Delta.Overloaded();
				var errors = [];
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;
		
				try {
					for (var _iterator = D1[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var delta1 = _step.value;
						var _iteratorNormalCompletion2 = true;
						var _didIteratorError2 = false;
						var _iteratorError2 = undefined;
		
						try {
							for (var _iterator2 = D2[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
								var delta2 = _step2.value;
		
								try {
									result.overloads.push(delta1.composedWith(delta2, opt));
								} catch (error) {
									errors.push(error);
								}
							}
						} catch (err) {
							_didIteratorError2 = true;
							_iteratorError2 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion2 && _iterator2['return']) {
									_iterator2['return']();
								}
							} finally {
								if (_didIteratorError2) {
									throw _iteratorError2;
								}
							}
						}
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator['return']) {
							_iterator['return']();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
		
				if (result.overloads.length === 0) {
					throw new _MultipleOverloadsApplicationError$NoOverloadsApplicationError$MultipleOverloadsCompositionError.MultipleOverloadsCompositionError(d1, d2, errors);
				}
				return result;
			});
		
			/* equality */
			deltaJs.newEquality(_indent$oncePer$arraysEqual$t.t('Overloaded', 'Overloaded'), function (d1, d2, opt) {
				return _indent$oncePer$arraysEqual$t.arraysEqual(d1.overloads, d2.overloads, function (x, y) {
					return x.equals(y, opt);
				});
			});
		
			/* commutation ***********************************************/
			deltaJs.newCommutation(_indent$oncePer$arraysEqual$t.t('Overloaded', 'Overloaded'), function (d1, d2, opt) {
				for (var i = 0; i < d1.overloads.length; ++i) {
					if (!d1.overloads[i].commutesWith(d2.overloads[i], opt)) {
						return false;
					}
				}
				// TODO: the above is a hack; fix it properly
				return true;
			});
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
		
		var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } };
		
		var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
		
		var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
		
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		/* import internal stuff */
		
		var _extend$indent$t$oncePer$mapEqual = __webpack_require__(3);
		
		var _Path = __webpack_require__(6);
		
		var _Path2 = _interopRequireWildcard(_Path);
		
		var _wt = __webpack_require__(5);
		
		var _define_OperationTypes = __webpack_require__(9);
		
		var _define_OperationTypes2 = _interopRequireWildcard(_define_OperationTypes);
		
		var _define_ContainerProxy = __webpack_require__(20);
		
		var _define_ContainerProxy2 = _interopRequireWildcard(_define_ContainerProxy);
		
		exports['default'] = _extend$indent$t$oncePer$mapEqual.oncePer('Modify', function (deltaJs) {
		
			_define_OperationTypes2['default'](deltaJs);
			_define_ContainerProxy2['default'](deltaJs);
		
			//noinspection JSUnusedLocalSymbols
			deltaJs.newOperationType('Modify', (function (_deltaJs$Delta) {
				function Modify() {
					var _this = this;
		
					for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
						args[_key] = arguments[_key];
					}
		
					_classCallCheck(this, Modify);
		
					_get(Object.getPrototypeOf(Modify.prototype), 'constructor', this).apply(this, args);
					this.subDeltas = new Map(this.arg && Object.keys(this.arg).map(function (key) {
						return [key, _this.arg[key]];
					}));
				}
		
				_inherits(Modify, _deltaJs$Delta);
		
				_createClass(Modify, [{
					key: 'clone',
		
					/**
		    * @nosideeffects
		    * @return {DeltaJs#Delta.Modify} - a clone of this delta
		    */
					value: function clone() {
						var result = _get(Object.getPrototypeOf(Modify.prototype), 'clone', this).call(this);
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;
		
						try {
							for (var _iterator = this.subDeltas[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var _step$value = _slicedToArray(_step.value, 2);
		
								var key = _step$value[0];
								var delta = _step$value[1];
		
								result.subDeltas.set(key, delta.clone());
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator['return']) {
									_iterator['return']();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}
		
						return result;
					}
				}, {
					key: 'precondition',
		
					/**
		    * @public
		    * @method
		    * @param target {*}
		    * @param options {object}
		    */
					value: function precondition(target) {
						var options = arguments[1] === undefined ? {} : arguments[1];
		
						if (!(target.value instanceof Object)) {
							return false;
						}
						var _iteratorNormalCompletion2 = true;
						var _didIteratorError2 = false;
						var _iteratorError2 = undefined;
		
						try {
							for (var _iterator2 = this.subDeltas[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
								var _step2$value = _slicedToArray(_step2.value, 2);
		
								var prop = _step2$value[0];
								var delta = _step2$value[1];
		
								if (!options.restrictToProperty || options.restrictToProperty === prop) {
									var judgment = delta.evaluatePrecondition(_wt.wt(target.value, prop), _extend$indent$t$oncePer$mapEqual.extend({}, options, { restrictToProperty: null }));
									if (judgment !== true) {
										return judgment;
									}
								}
							}
						} catch (err) {
							_didIteratorError2 = true;
							_iteratorError2 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion2 && _iterator2['return']) {
									_iterator2['return']();
								}
							} finally {
								if (_didIteratorError2) {
									throw _iteratorError2;
								}
							}
						}
		
						return true;
					}
				}, {
					key: 'applyTo',
		
					/**
		    * @public
		    * @method
		    * @param target  {Delta.WritableTarget} - the target to which to apply this delta
		    * @param options {object?}              - the (optional) options for this delta application
		    */
					value: function applyTo(target) {
						var options = arguments[1] === undefined ? {} : arguments[1];
						var _iteratorNormalCompletion3 = true;
						var _didIteratorError3 = false;
						var _iteratorError3 = undefined;
		
						try {
							for (var _iterator3 = this.subDeltas[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
								var _step3$value = _slicedToArray(_step3.value, 2);
		
								var prop = _step3$value[0];
								var delta = _step3$value[1];
		
								if (!options.restrictToProperty || options.restrictToProperty === prop) {
									delta.applyTo(_wt.wt(target.value, prop), _extend$indent$t$oncePer$mapEqual.extend({}, options, { restrictToProperty: null }));
								}
							}
						} catch (err) {
							_didIteratorError3 = true;
							_iteratorError3 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion3 && _iterator3['return']) {
									_iterator3['return']();
								}
							} finally {
								if (_didIteratorError3) {
									throw _iteratorError3;
								}
							}
						}
					}
				}, {
					key: 'toString',
		
					/**
		    * @public
		    * @method
		    * @param options {object?}
		    * @return {string}
		    */
					value: function toString() {
						var options = arguments[0] === undefined ? {} : arguments[0];
		
						var str = _get(Object.getPrototypeOf(Modify.prototype), 'toString', this).call(this, options);
						if (this.subDeltas.size > 0) {
							var deltas = this.subDeltas.entries().map(function (_ref) {
								var _ref2 = _slicedToArray(_ref, 2);
		
								var prop = _ref2[0];
								var delta = _ref2[1];
								return delta.toString(_extend$indent$t$oncePer$mapEqual.extend({}, options, { targetProp: prop }));
							}).join('\n');
							str += '\n' + _extend$indent$t$oncePer$mapEqual.indent(deltas, 4);
						}
						return str;
					}
				}]);
		
				return Modify;
			})(deltaJs.Delta), (function (_deltaJs$ContainerProxy) {
				function ModifyProxy() {
					_classCallCheck(this, ModifyProxy);
		
					if (_deltaJs$ContainerProxy != null) {
						_deltaJs$ContainerProxy.apply(this, arguments);
					}
				}
		
				_inherits(ModifyProxy, _deltaJs$ContainerProxy);
		
				_createClass(ModifyProxy, [{
					key: 'processProxyArguments',
		
					//noinspection JSMethodCanBeStatic
					/**
		    * @param rawArgs {Array.<*>}
		    * @return {?{ options: Object, args: Array.<*> }}
		    */
					value: function processProxyArguments() {
						for (var _len2 = arguments.length, rawArgs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
							rawArgs[_key2] = arguments[_key2];
						}
		
						// rawArgs is parsed as (...options, path, ...args),
						// though path may also be passed as an option directly
						var options = {};
						do {
							if (rawArgs.length === 0) {
								throw new Error('The argument list for this Modify.Proxy method is insufficient.');
							}
							var arg = rawArgs.shift();
							if (typeof arg === 'string') {
								options.path = arg;
							} else {
								_extend$indent$t$oncePer$mapEqual.extend(options, arg);
							}
						} while (!options.path);
						return { options: options, args: rawArgs };
					}
				}, {
					key: 'addOperation',
		
					/**
		    * @param delta   {DeltaJs#Delta}
		    * @param options {{path: Path}}
		    * @return {DeltaJs#Proxy} - the deepest proxy created for this operation
		    */
					value: function addOperation(delta, options) {
						var path = options.path;
		
						if (!path.prop) {
							throw new Error('Operations on a Modify.Proxy need to have a non-empty path.');
						}
		
						/* create proxies */
						var deepestProxy;
						if (path.rest) {
							var newOptions = _extend$indent$t$oncePer$mapEqual.extend({}, options, { path: path.rest });
							var childProxy = this.addChildProxy(path.prop, new deltaJs.Delta.Modify());
							deepestProxy = childProxy.addOperation(delta, newOptions);
						} else {
							deepestProxy = this.addChildProxy(path.prop, delta);
						}
		
						// NOTE: Modify operations do not (yet) use any options
		
						/* return the deepest created proxy */
						return deepestProxy;
					}
				}, {
					key: 'delta',
		
					/**
		    * Dynamically compute and return the delta belonging to this proxy.
		    * @public
		    * @method
		    * @return the delta belonging to this proxy
		    */
					value: function delta() {
						var result = _get(Object.getPrototypeOf(ModifyProxy.prototype), 'delta', this).call(this);
						var _iteratorNormalCompletion4 = true;
						var _didIteratorError4 = false;
						var _iteratorError4 = undefined;
		
						try {
							for (var _iterator4 = this.childKeys()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
								var prop = _step4.value;
		
								result.subDeltas.set(prop, this.childDelta(prop));
							}
						} catch (err) {
							_didIteratorError4 = true;
							_iteratorError4 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion4 && _iterator4['return']) {
									_iterator4['return']();
								}
							} finally {
								if (_didIteratorError4) {
									throw _iteratorError4;
								}
							}
						}
		
						return result;
					}
				}]);
		
				return ModifyProxy;
			})(deltaJs.ContainerProxy));
		
			/* composition - introducing 'Modify' ***********************************************/
			deltaJs.newComposition(_extend$indent$t$oncePer$mapEqual.t('Modify', 'Modify'), function (d1, d2, opt) {
				var result = d1.clone();
				var _iteratorNormalCompletion5 = true;
				var _didIteratorError5 = false;
				var _iteratorError5 = undefined;
		
				try {
					for (var _iterator5 = d2.subDeltas.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
						var prop = _step5.value;
		
						result.subDeltas.set(prop, deltaJs.Delta.composed(result.subDeltas.get(prop), d2.subDeltas.get(prop), opt));
					}
				} catch (err) {
					_didIteratorError5 = true;
					_iteratorError5 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion5 && _iterator5['return']) {
							_iterator5['return']();
						}
					} finally {
						if (_didIteratorError5) {
							throw _iteratorError5;
						}
					}
				}
		
				return result;
			});
		
			/* equality ***********************************************/
			deltaJs.newEquality(_extend$indent$t$oncePer$mapEqual.t('Modify', 'Modify'), function (d1, d2) {
				return _extend$indent$t$oncePer$mapEqual.mapEqual(d1.subDeltas, d2.subDeltas, function (x, y) {
					return x.equals(y);
				});
			});
		
			/* commutation ***********************************************/
			deltaJs.newCommutation(_extend$indent$t$oncePer$mapEqual.t('Modify', 'Modify'), function (d1, d2, opt) {
				var _iteratorNormalCompletion6 = true;
				var _didIteratorError6 = false;
				var _iteratorError6 = undefined;
		
				try {
					for (var _iterator6 = d1.subDeltas.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
						var prop = _step6.value;
		
						if (d2.subDeltas.has(prop)) {
							var sub1 = d1.subDeltas.get(prop);
							var sub2 = d2.subDeltas.get(prop);
							if (!sub1.commutesWith(sub2, opt)) {
								return false;
							}
						}
					}
				} catch (err) {
					_didIteratorError6 = true;
					_iteratorError6 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion6 && _iterator6['return']) {
							_iterator6['return']();
						}
					} finally {
						if (_didIteratorError6) {
							throw _iteratorError6;
						}
					}
				}
		
				return true;
			});
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };
		
		var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
		
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		/* import internal stuff */
		
		var _isUndefined$isDefined$t$define_d$oncePer = __webpack_require__(3);
		
		var _WritableTarget$ReadableTarget$rt$wt = __webpack_require__(5);
		
		var _define_OperationTypes = __webpack_require__(9);
		
		var _define_OperationTypes2 = _interopRequireWildcard(_define_OperationTypes);
		
		var _define_Delta = __webpack_require__(10);
		
		var _define_Delta2 = _interopRequireWildcard(_define_Delta);
		
		var _define_Modify = __webpack_require__(12);
		
		var _define_Modify2 = _interopRequireWildcard(_define_Modify);
		
		exports['default'] = _isUndefined$isDefined$t$define_d$oncePer.oncePer('basic operations', function (deltaJs) {
		
			_define_OperationTypes2['default'](deltaJs);
			_define_Delta2['default'](deltaJs);
			_define_Modify2['default'](deltaJs);
		
			/* declaring the basic operation types **********************************************/
			deltaJs.newOperationType('NoOp', (function (_deltaJs$Delta) {
				function NoOp() {
					_classCallCheck(this, NoOp);
		
					if (_deltaJs$Delta != null) {
						_deltaJs$Delta.apply(this, arguments);
					}
				}
		
				_inherits(NoOp, _deltaJs$Delta);
		
				return NoOp;
			})(deltaJs.Delta));
			deltaJs.newOperationType('Add', (function (_deltaJs$Delta2) {
				function Add() {
					_classCallCheck(this, Add);
		
					if (_deltaJs$Delta2 != null) {
						_deltaJs$Delta2.apply(this, arguments);
					}
				}
		
				_inherits(Add, _deltaJs$Delta2);
		
				_createClass(Add, [{
					key: 'precondition',
					value: function precondition(target, _ref) {
						var weak = _ref.weak;
						return target instanceof _WritableTarget$ReadableTarget$rt$wt.WritableTarget && (weak || _isUndefined$isDefined$t$define_d$oncePer.isUndefined(target.value));
					}
				}, {
					key: 'applyTo',
					value: function applyTo(target) {
						target.value = this.arg;
					}
				}]);
		
				return Add;
			})(deltaJs.Delta));
			deltaJs.newOperationType('Remove', (function (_deltaJs$Delta3) {
				function Remove() {
					_classCallCheck(this, Remove);
		
					if (_deltaJs$Delta3 != null) {
						_deltaJs$Delta3.apply(this, arguments);
					}
				}
		
				_inherits(Remove, _deltaJs$Delta3);
		
				_createClass(Remove, [{
					key: 'precondition',
					value: function precondition(target, _ref2) {
						var weak = _ref2.weak;
						return target instanceof _WritableTarget$ReadableTarget$rt$wt.WritableTarget && (weak || _isUndefined$isDefined$t$define_d$oncePer.isDefined(target.value));
					}
				}, {
					key: 'applyTo',
					value: function applyTo(target) {
						target['delete']();
					}
				}]);
		
				return Remove;
			})(deltaJs.Delta));
			deltaJs.newOperationType('Forbid', (function (_deltaJs$Delta4) {
				function Forbid() {
					_classCallCheck(this, Forbid);
		
					if (_deltaJs$Delta4 != null) {
						_deltaJs$Delta4.apply(this, arguments);
					}
				}
		
				_inherits(Forbid, _deltaJs$Delta4);
		
				_createClass(Forbid, [{
					key: 'precondition',
					value: function precondition(target, _ref3) {
						var weak = _ref3.weak;
						return weak || _isUndefined$isDefined$t$define_d$oncePer.isUndefined(target.value);
					}
				}]);
		
				return Forbid;
			})(deltaJs.Delta));
			deltaJs.newOperationType('Replace', (function (_deltaJs$Delta5) {
				function Replace() {
					_classCallCheck(this, Replace);
		
					if (_deltaJs$Delta5 != null) {
						_deltaJs$Delta5.apply(this, arguments);
					}
				}
		
				_inherits(Replace, _deltaJs$Delta5);
		
				_createClass(Replace, [{
					key: 'precondition',
					value: function precondition(target, _ref4) {
						var weak = _ref4.weak;
						return target instanceof _WritableTarget$ReadableTarget$rt$wt.WritableTarget && (weak || _isUndefined$isDefined$t$define_d$oncePer.isDefined(target.value));
					}
				}, {
					key: 'applyTo',
					value: function applyTo(target) {
						target.value = this.arg;
					}
				}]);
		
				return Replace;
			})(deltaJs.Delta));
			deltaJs.newOperationType('Update', (function (_deltaJs$Delta6) {
				function Update() {
					_classCallCheck(this, Update);
		
					if (_deltaJs$Delta6 != null) {
						_deltaJs$Delta6.apply(this, arguments);
					}
				}
		
				_inherits(Update, _deltaJs$Delta6);
		
				_createClass(Update, [{
					key: 'precondition',
					value: function precondition(target, _ref5) {
						var weak = _ref5.weak;
						return target instanceof _WritableTarget$ReadableTarget$rt$wt.WritableTarget && (weak || _isUndefined$isDefined$t$define_d$oncePer.isDefined(target.value));
					}
				}, {
					key: 'applyTo',
					value: function applyTo(target) {
						target.value = this.arg(target.value);
					}
				}]);
		
				return Update;
			})(deltaJs.Delta));
		
			/* composition - introducing 'NoOp' *************************************************/
			deltaJs.newComposition(function (d1, d2) {
				return d1 instanceof deltaJs.Delta.NoOp;
			}, function (d1, d2) {
				return d2.clone();
			});
			deltaJs.newComposition(function (d1, d2) {
				return d2 instanceof deltaJs.Delta.NoOp;
			}, function (d1, d2) {
				return d1.clone();
			});
		
			/* utility function d */
			var d = _isUndefined$isDefined$t$define_d$oncePer.define_d(deltaJs);
		
			/* composition - introducing 'Add' **************************************************/
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Add', 'Modify'), d('Add', function (_ref6) {
				var d2 = _ref6.d2;
				var p1 = _ref6.p1;
				return d2.appliedTo(p1);
			}));
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Modify', 'Add'), false);
			deltaJs.newComposition(function (d1, d2) {
				return d2.type === 'Add';
			}, d('Add', function (_ref7) {
				var p2 = _ref7.p2;
				return p2;
			}), { weak: true });
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Add', 'Add'), false);
		
			/* composition - introducing 'Remove' ***********************************************/
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Modify', 'Remove'), d('Remove'));
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Add', 'Remove'), d('Forbid'));
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Remove', 'Modify'), false);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Remove', 'Add'), d('Replace', function (_ref8) {
				var p2 = _ref8.p2;
				return p2;
			}));
			deltaJs.newComposition(function (d1, d2) {
				return d2.type === 'Remove';
			}, d('Remove'), { weak: true });
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Remove', 'Remove'), false);
		
			/* composition - introducing 'Forbid' ***********************************************/
			deltaJs.newComposition(function (d1, d2) {
				return d1.type === 'Forbid';
			}, function (d1, d2) {
				return d2.clone();
			}, { weak: true }); // TODO: test
			deltaJs.newComposition(function (d1, d2) {
				return d2.type === 'Forbid';
			}, function (d1, d2) {
				return d1.clone();
			}, { weak: true }); // TODO: test
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Modify', 'Forbid'), false);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Add', 'Forbid'), false);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Remove', 'Forbid'), d('Remove'));
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Forbid', 'Modify'), false);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Forbid', 'Add'), d('Add', function (_ref9) {
				var p2 = _ref9.p2;
				return p2;
			}));
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Forbid', 'Remove'), false);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Forbid', 'Forbid'), d('Forbid'));
		
			/* composition - introducing 'Replace' **********************************************/
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Modify', 'Replace'), d('Replace', function (_ref10) {
				var p2 = _ref10.p2;
				return p2;
			}));
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Add', 'Replace'), d('Add', function (_ref11) {
				var p2 = _ref11.p2;
				return p2;
			}));
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Remove', 'Replace'), false);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Forbid', 'Replace'), false);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Replace', 'Modify'), d('Replace', function (_ref12) {
				var d2 = _ref12.d2;
				var p1 = _ref12.p1;
				return d2.appliedTo(p1);
			}));
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Replace', 'Add'), false);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Replace', 'Remove'), d('Remove'));
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Replace', 'Forbid'), false);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Replace', 'Replace'), d('Replace', function (_ref13) {
				var p2 = _ref13.p2;
				return p2;
			}));
		
			/* composition - introducing 'Update' ***********************************************/
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Modify', 'Update'), true);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Add', 'Update'), d('Add', function (_ref14) {
				var d2 = _ref14.d2;
				var p1 = _ref14.p1;
				return d2.appliedTo(p1);
			}));
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Remove', 'Update'), true);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Forbid', 'Update'), true);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Replace', 'Update'), d('Replace', function (_ref15) {
				var d2 = _ref15.d2;
				var p1 = _ref15.p1;
				return d2.appliedTo(p1);
			}));
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Update', 'Modify'), true);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Update', 'Add'), true);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Update', 'Remove'), d('Remove'));
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Update', 'Forbid'), true);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Update', 'Replace'), d('Replace', function (_ref16) {
				var p2 = _ref16.p2;
				return p2;
			}));
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer.t('Update', 'Update'), d('Update', function (_ref17) {
				var p1 = _ref17.p1;
				var p2 = _ref17.p2;
				return function (v) {
					return p2(p1(v));
				};
			}));
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
		
		var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };
		
		var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
		
		var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
		
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		/* import internal stuff */
		
		var _define_OperationTypes = __webpack_require__(9);
		
		var _define_OperationTypes2 = _interopRequireWildcard(_define_OperationTypes);
		
		var _define_Modify = __webpack_require__(12);
		
		var _define_Modify2 = _interopRequireWildcard(_define_Modify);
		
		var _define_basicOperations = __webpack_require__(13);
		
		var _define_basicOperations2 = _interopRequireWildcard(_define_basicOperations);
		
		var _define_Proxy = __webpack_require__(23);
		
		var _define_Proxy2 = _interopRequireWildcard(_define_Proxy);
		
		var _isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf = __webpack_require__(3);
		
		exports['default'] = _isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.oncePer('PutIntoArray', function (deltaJs) {
		
			_define_OperationTypes2['default'](deltaJs);
			_define_Modify2['default'](deltaJs);
			_define_basicOperations2['default'](deltaJs);
			_define_Proxy2['default'](deltaJs);
		
			/* declaring the array operation type ***********************************************/
			deltaJs.newOperationType('PutIntoArray', (function (_deltaJs$Delta) {
				function PutIntoArray() {
					for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
						args[_key] = arguments[_key];
					}
		
					_classCallCheck(this, PutIntoArray);
		
					_get(Object.getPrototypeOf(PutIntoArray.prototype), 'constructor', this).apply(this, args);
					this.values = this.arg ? Array.isArray(this.arg) ? this.arg : [this.arg] : [];
				}
		
				_inherits(PutIntoArray, _deltaJs$Delta);
		
				_createClass(PutIntoArray, [{
					key: 'clone',
					value: function clone() {
						var result = _get(Object.getPrototypeOf(PutIntoArray.prototype), 'clone', this).call(this);
						result.values = [].concat(_toConsumableArray(this.values));
						return result;
					}
				}, {
					key: 'precondition',
					value: function precondition(target, _ref) {
						var weak = _ref.weak;
						return weak || _isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.isDefined(target.value) && Array.isArray(target.value);
					}
				}, {
					key: 'applyTo',
					value: function applyTo(target) {
						var arr = target.value;
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;
		
						try {
							for (var _iterator = this.values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var _step$value = _step.value;
								var method = _step$value.method;
								var value = _step$value.value;
		
								switch (method) {
									case 'prepend':
										{
											arr.unshift(value);
										}break;
									case 'insert':
										{
											// 'insert' doesn't *have* to use a random position. Any position will do.
											//  E.g., its implementation could just be the same as for 'append'.
											//  Nonetheless, we use a random position to force the tests to be permissive.
											var position = Math.floor(Math.random() * (arr.length + 1));
											arr.splice(position, 0, value);
										}break;
									case 'append':
										{
											arr.push(value);
										}break;
								}
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator['return']) {
									_iterator['return']();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}
					}
				}, {
					key: 'methods',
					get: function () {
						return [];
					}
				}]);
		
				return PutIntoArray;
			})(deltaJs.Delta));
		
			/* Proxy methods ****************************************************************************/
			deltaJs.newProxyMethod('prepend', function (value) {
				return new deltaJs.Delta.PutIntoArray({ method: 'prepend', value: value });
			});
			deltaJs.newProxyMethod('insert', function (value) {
				return new deltaJs.Delta.PutIntoArray({ method: 'insert', value: value });
			});
			deltaJs.newProxyMethod('append', function (value) {
				return new deltaJs.Delta.PutIntoArray({ method: 'append', value: value });
			});
		
			/* composition *******************************************************************************/
			var d = _isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.define_d(deltaJs);
			deltaJs.newComposition(_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.t('Modify', 'PutIntoArray'), false);
			deltaJs.newComposition(_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.t('Add', 'PutIntoArray'), d('Add', function (_ref2) {
				var d2 = _ref2.d2;
				var p1 = _ref2.p1;
				return d2.appliedTo(p1);
			}));
			deltaJs.newComposition(_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.t('Remove', 'PutIntoArray'), false);
			deltaJs.newComposition(_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.t('Forbid', 'PutIntoArray'), false);
			deltaJs.newComposition(_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.t('Replace', 'PutIntoArray'), d('Replace', function (_ref3) {
				var d2 = _ref3.d2;
				var p1 = _ref3.p1;
				return d2.appliedTo(p1);
			}));
			deltaJs.newComposition(_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.t('Update', 'PutIntoArray'), true);
			deltaJs.newComposition(_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.t('PutIntoArray', 'Modify'), false);
			deltaJs.newComposition(_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.t('PutIntoArray', 'Add'), false);
			deltaJs.newComposition(_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.t('PutIntoArray', 'Remove'), d('Remove'));
			deltaJs.newComposition(_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.t('PutIntoArray', 'Forbid'), false);
			deltaJs.newComposition(_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.t('PutIntoArray', 'Replace'), d('Replace', function (_ref4) {
				var p2 = _ref4.p2;
				return p2;
			}));
			deltaJs.newComposition(_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.t('PutIntoArray', 'Update'), true);
			deltaJs.newComposition(_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.t('PutIntoArray', 'PutIntoArray'), function (d1, d2) {
				return new deltaJs.Delta.PutIntoArray([].concat(_toConsumableArray(d1.values), _toConsumableArray(d2.values)));
			});
		
			// TODO: Change 'append' and 'prepend' to follow any underlying partial order (delta model)
		
			/* refinement *******************************************************************************/
			deltaJs.newRefinement(_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.t('PutIntoArray', 'PutIntoArray'), function (d1, d2) {
				/* define operation equality */
				var eq = function eq(x, y) {
					return x.method === y.method && x.value === y.value;
				};
		
				/* both need to at least have the same operations (not necessarily in the same order) */
				if (!_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.arraysHaveSameElements(d1.values, d2.values, eq)) {
					return false;
				}
		
				/* appensions and prepensions need to be in the same order */
				if (!_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.arraysEqual(d1.values.filter(function (v) {
					return v.method === 'append';
				}), d2.values.filter(function (v) {
					return v.method === 'append';
				}), eq)) {
					return false;
				}
				if (!_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.arraysEqual(d1.values.filter(function (v) {
					return v.method === 'prepend';
				}), d2.values.filter(function (v) {
					return v.method === 'prepend';
				}), eq)) {
					return false;
				}
		
				/* insertions in 'd1' cannot come later than their counterparts in 'd2', */
				/* in the sense of appensions and prepensions that have come before it        */
				var appensionsAndPrepensionsSeen = [];
				for (var i = 0; i < d1.values.length; ++i) {
					if (d1.values[i].method === 'insert') {
						var ind = _isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.customIndexOf(d2.values, d1.values[i], eq);
						var appensionsAndPrepensionsToGo = [].concat(appensionsAndPrepensionsSeen);
						for (var j = 0; j <= ind; ++j) {
							var indd = _isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.customIndexOf(appensionsAndPrepensionsToGo, d2.values[j], eq);
							if (indd > -1) {
								appensionsAndPrepensionsToGo.splice(indd, 1);
							}
						}
						if (appensionsAndPrepensionsToGo.length > 0) {
							return false;
						}
					} else {
						appensionsAndPrepensionsSeen.push(d1.values[i]);
					}
				}
		
				/* OK, it's a refinement */
				return true;
			});
		
			/* weak commutation - allow two PutIntoFunction deltas to always commute in a weak context*/
			deltaJs.newCommutation(_isDefined$t$define_d$oncePer$arraysEqual$arraysHaveSameElements$customIndexOf.t('PutIntoArray', 'PutIntoArray'), function (d1, d2, opt) {
				return true;
			}, { weak: true });
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
		
		var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };
		
		var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
		
		var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
		
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		/* import internal stuff */
		
		var _define_OperationTypes = __webpack_require__(9);
		
		var _define_OperationTypes2 = _interopRequireWildcard(_define_OperationTypes);
		
		var _define_Modify = __webpack_require__(12);
		
		var _define_Modify2 = _interopRequireWildcard(_define_Modify);
		
		var _define_BasicOperations = __webpack_require__(13);
		
		var _define_BasicOperations2 = _interopRequireWildcard(_define_BasicOperations);
		
		var _define_Proxy = __webpack_require__(23);
		
		var _define_Proxy2 = _interopRequireWildcard(_define_Proxy);
		
		var _WritableTarget = __webpack_require__(5);
		
		var _isUndefined$isDefined$t$define_d$oncePer$arraysEqual = __webpack_require__(3);
		
		exports['default'] = _isUndefined$isDefined$t$define_d$oncePer$arraysEqual.oncePer('PutIntoFunction', function (deltaJs) {
		
			_define_OperationTypes2['default'](deltaJs);
			_define_Modify2['default'](deltaJs);
			_define_BasicOperations2['default'](deltaJs);
			_define_Proxy2['default'](deltaJs);
		
			/* a symbol under which function parts can be stored in public functions */
			var functionPartsSymbol = Symbol('DeltaJs:function-parts');
		
			/* declaring the function operation type */
			deltaJs.newOperationType('PutIntoFunction', (function (_deltaJs$Delta) {
				function PutIntoFunction() {
					for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
						args[_key] = arguments[_key];
					}
		
					_classCallCheck(this, PutIntoFunction);
		
					_get(Object.getPrototypeOf(PutIntoFunction.prototype), 'constructor', this).apply(this, args);
					this.values = this.arg ? Array.isArray(this.arg) ? this.arg : [this.arg] : [];
				}
		
				_inherits(PutIntoFunction, _deltaJs$Delta);
		
				_createClass(PutIntoFunction, [{
					key: 'clone',
					value: function clone() {
						var result = _get(Object.getPrototypeOf(PutIntoFunction.prototype), 'clone', this).call(this);
						result.values = [].concat(_toConsumableArray(this.values));
						return result;
					}
				}, {
					key: 'precondition',
					value: function precondition(target) {
						return _isUndefined$isDefined$t$define_d$oncePer$arraysEqual.isDefined(target.value) && typeof target.value === 'function' && (_isUndefined$isDefined$t$define_d$oncePer$arraysEqual.isDefined(target.value[functionPartsSymbol]) || target instanceof _WritableTarget.WritableTarget);
					}
				}, {
					key: 'applyTo',
					value: function applyTo(target) {
						if (_isUndefined$isDefined$t$define_d$oncePer$arraysEqual.isUndefined(target.value[functionPartsSymbol])) {
							var originalFn = target.value;
							var newFn = (function (_newFn) {
								function newFn(_x) {
									return _newFn.apply(this, arguments);
								}
		
								newFn.toString = function () {
									return _newFn.toString();
								};
		
								return newFn;
							})(function () {
								for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
									args[_key2] = arguments[_key2];
								}
		
								var result = undefined;
								var _iteratorNormalCompletion = true;
								var _didIteratorError = false;
								var _iteratorError = undefined;
		
								try {
									for (var _iterator = newFn[functionPartsSymbol][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
										var fn = _step.value;
		
										result = fn.apply(this, args);
									}
								} catch (err) {
									_didIteratorError = true;
									_iteratorError = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion && _iterator['return']) {
											_iterator['return']();
										}
									} finally {
										if (_didIteratorError) {
											throw _iteratorError;
										}
									}
								}
		
								return result;
							});
							newFn[functionPartsSymbol] = [function () {
								for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
									args[_key3] = arguments[_key3];
								}
		
								originalFn.apply(this, args);
							}];
							target.value = newFn;
						}
						var arr = target.value[functionPartsSymbol];
						var _iteratorNormalCompletion2 = true;
						var _didIteratorError2 = false;
						var _iteratorError2 = undefined;
		
						try {
							for (var _iterator2 = this.values[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
								var _step2$value = _step2.value;
								var method = _step2$value.method;
								var value = _step2$value.value;
		
								switch (method) {
									case 'prepend':
										{
											arr.unshift(value);
										}break;
									case 'insert':
										{
											// 'insert' doesn't *have* to use a random position. Any position will do.
											//  E.g., its implementation could just be the same as for 'append'.
											//  Nonetheless, we use a random position to force the tests to be permissive.
											var position = Math.floor(Math.random() * (arr.length + 1));
											arr.splice(position, 0, value);
										}break;
									case 'append':
										{
											arr.push(value);
										}break;
								}
							}
						} catch (err) {
							_didIteratorError2 = true;
							_iteratorError2 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion2 && _iterator2['return']) {
									_iterator2['return']();
								}
							} finally {
								if (_didIteratorError2) {
									throw _iteratorError2;
								}
							}
						}
					}
				}, {
					key: 'methods',
					get: function () {
						return [];
					}
				}]);
		
				return PutIntoFunction;
			})(deltaJs.Delta));
		
			/* Proxy methods ****************************************************************************/
			deltaJs.newProxyMethod('prepend', function (value) {
				return new deltaJs.Delta.PutIntoFunction({ method: 'prepend', value: value });
			});
			deltaJs.newProxyMethod('insert', function (value) {
				return new deltaJs.Delta.PutIntoFunction({ method: 'insert', value: value });
			});
			deltaJs.newProxyMethod('append', function (value) {
				return new deltaJs.Delta.PutIntoFunction({ method: 'append', value: value });
			});
		
			/* composition - introducing 'PutIntoFunction' **************************************************/
			var d = _isUndefined$isDefined$t$define_d$oncePer$arraysEqual.define_d(deltaJs);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer$arraysEqual.t('Modify', 'PutIntoFunction'), false);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer$arraysEqual.t('Add', 'PutIntoFunction'), d('Add', function (_ref) {
				var d2 = _ref.d2;
				var p1 = _ref.p1;
				return d2.appliedTo(p1);
			}));
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer$arraysEqual.t('Remove', 'PutIntoFunction'), false);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer$arraysEqual.t('Forbid', 'PutIntoFunction'), false);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer$arraysEqual.t('Replace', 'PutIntoFunction'), d('Replace', function (_ref2) {
				var d2 = _ref2.d2;
				var p1 = _ref2.p1;
				return d2.appliedTo(p1);
			}));
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer$arraysEqual.t('Update', 'PutIntoFunction'), true);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer$arraysEqual.t('PutIntoFunction', 'Modify'), false);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer$arraysEqual.t('PutIntoFunction', 'Add'), false);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer$arraysEqual.t('PutIntoFunction', 'Remove'), d('Remove'));
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer$arraysEqual.t('PutIntoFunction', 'Forbid'), false);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer$arraysEqual.t('PutIntoFunction', 'Replace'), d('Replace', function (_ref3) {
				var p2 = _ref3.p2;
				return p2;
			}));
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer$arraysEqual.t('PutIntoFunction', 'Update'), true);
			deltaJs.newComposition(_isUndefined$isDefined$t$define_d$oncePer$arraysEqual.t('PutIntoFunction', 'PutIntoFunction'), function (d1, d2) {
				return new deltaJs.Delta.PutIntoFunction([].concat(_toConsumableArray(d1.values), _toConsumableArray(d2.values)));
			});
		
			// TODO: Change 'append' and 'prepend' to follow any underlying partial order (delta model)
		
			/* equality */
			// TODO: refinement function instead of equals function (look at PutIntoArray.es6.js)
			deltaJs.newEquality(_isUndefined$isDefined$t$define_d$oncePer$arraysEqual.t('PutIntoFunction', 'PutIntoFunction'), function (d1, d2) {
				return _isUndefined$isDefined$t$define_d$oncePer$arraysEqual.arraysEqual(d1.values, d2.values, function (a, b) {
					return a.method === b.method && a.value && b.value;
				});
			});
		
			/* weak commutation - allow two PutIntoFunction deltas to always commute in a weak context*/
			deltaJs.newCommutation(_isUndefined$isDefined$t$define_d$oncePer$arraysEqual.t('PutIntoFunction', 'PutIntoFunction'), function (d1, d2) {
				return true;
			}, { weak: true });
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
		
		var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } };
		
		var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };
		
		var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
		
		var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
		
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		/* import external libraries */
		
		var _Graph = __webpack_require__(24);
		
		var _Graph2 = _interopRequireWildcard(_Graph);
		
		/* import internal stuff */
		
		var _extend$isDefined$indent$oncePer$s$t = __webpack_require__(3);
		
		var _Path = __webpack_require__(6);
		
		var _Path2 = _interopRequireWildcard(_Path);
		
		var _define_OperationTypes = __webpack_require__(9);
		
		var _define_OperationTypes2 = _interopRequireWildcard(_define_OperationTypes);
		
		var _define_Modify = __webpack_require__(12);
		
		var _define_Modify2 = _interopRequireWildcard(_define_Modify);
		
		var _define_ContainerProxy = __webpack_require__(20);
		
		var _define_ContainerProxy2 = _interopRequireWildcard(_define_ContainerProxy);
		
		var _ApplicationOrderCycle$UnresolvedDeltaConflict = __webpack_require__(7);
		
		exports['default'] = _extend$isDefined$indent$oncePer$s$t.oncePer('DeltaModel', function (deltaJs) {
		
			_define_OperationTypes2['default'](deltaJs);
			_define_ContainerProxy2['default'](deltaJs);
		
			//noinspection JSUnusedLocalSymbols
			deltaJs.newOperationType('DeltaModel', (function (_deltaJs$Delta) {
				function DeltaModel() {
					for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
						args[_key] = arguments[_key];
					}
		
					_classCallCheck(this, DeltaModel);
		
					_get(Object.getPrototypeOf(DeltaModel.prototype), 'constructor', this).apply(this, args);
					this.graph = new _Graph2['default']();
				}
		
				_inherits(DeltaModel, _deltaJs$Delta);
		
				_createClass(DeltaModel, [{
					key: 'clone',
					value: function clone() {
						var result = _get(Object.getPrototypeOf(DeltaModel.prototype), 'clone', this).call(this);
						result.graph = this.graph.clone(function (d) {
							return d.clone();
						});
						return result;
					}
				}, {
					key: '_assertNoUnresolvedConflicts',
					value: function _assertNoUnresolvedConflicts() {
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;
		
						try {
							for (var _iterator = this.conflicts()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var conflictInfo = _step.value;
		
								if (conflictInfo.conflictResolvingDeltas.size === 0) {
									throw new _ApplicationOrderCycle$UnresolvedDeltaConflict.UnresolvedDeltaConflict(conflictInfo.conflictingDeltas);
								}
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator['return']) {
									_iterator['return']();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}
					}
				}, {
					key: 'precondition',
					value: function precondition(target, options) {
						var _iteratorNormalCompletion2 = true;
						var _didIteratorError2 = false;
						var _iteratorError2 = undefined;
		
						try {
							for (var _iterator2 = this.graph.vertices()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
								var _step2$value = _slicedToArray(_step2.value, 2);
		
								var _name = _step2$value[0];
								var delta = _step2$value[1];
		
								if (!delta) {
									console.error('A delta called \'' + _name + '\' is expected, but was never loaded.');
								} else if ([].concat(_toConsumableArray(this.graph.verticesTo(_name))).length === 0) {
									// source vertices
									var judgment = delta.evaluatePrecondition(target, options);
									if (judgment !== true) {
										return judgment;
									}
								}
							}
						} catch (err) {
							_didIteratorError2 = true;
							_iteratorError2 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion2 && _iterator2['return']) {
									_iterator2['return']();
								}
							} finally {
								if (_didIteratorError2) {
									throw _iteratorError2;
								}
							}
						}
		
						return true;
					}
				}, {
					key: 'applyTo',
					value: function applyTo(target) {
						var options = arguments[1] === undefined ? {} : arguments[1];
		
						/* throw an exception if there are unresolved conflicts */
						this._assertNoUnresolvedConflicts();
		
						/* no unresolved conflicts: apply the delta model */
						var _iteratorNormalCompletion3 = true;
						var _didIteratorError3 = false;
						var _iteratorError3 = undefined;
		
						try {
							for (var _iterator3 = this.graph.vertices_topologically()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
								var _step3$value = _slicedToArray(_step3.value, 2);
		
								var subDelta = _step3$value[1];
		
								subDelta.applyTo(target, _extend$isDefined$indent$oncePer$s$t.extend({}, options, { weak: true }));
							}
						} catch (err) {
							_didIteratorError3 = true;
							_iteratorError3 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion3 && _iterator3['return']) {
									_iterator3['return']();
								}
							} finally {
								if (_didIteratorError3) {
									throw _iteratorError3;
								}
							}
						}
					}
				}, {
					key: 'toString',
					value: function toString() {
						var options = arguments[0] === undefined ? {} : arguments[0];
		
						var str = _get(Object.getPrototypeOf(DeltaModel.prototype), 'toString', this).call(this, options);
						if (this.graph.vertexCount() > 0) {
							var deltas = '';
							var _iteratorNormalCompletion4 = true;
							var _didIteratorError4 = false;
							var _iteratorError4 = undefined;
		
							try {
								for (var _iterator4 = this.graph.vertices_topologically()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
									var _step4$value = _slicedToArray(_step4.value, 2);
		
									var _name2 = _step4$value[0];
									var delta = _step4$value[1];
		
									deltas += '[' + _name2 + '] ' + delta.toString(options) + '\n';
								}
							} catch (err) {
								_didIteratorError4 = true;
								_iteratorError4 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion4 && _iterator4['return']) {
										_iterator4['return']();
									}
								} finally {
									if (_didIteratorError4) {
										throw _iteratorError4;
									}
								}
							}
		
							str += '\n' + _extend$isDefined$indent$oncePer$s$t.indent(deltas, 4);
						}
						return str;
					}
				}, {
					key: 'conflicts',
					value: function conflicts() {
						/* clone the graph */
						var g = this.graph.clone();
		
						/* source and sink keys */
						var sink = '(sink)';
						while (g.hasVertex(sink)) {
							sink = '' + sink + '\'';
						}
		
						/* create sink vertex, connect it to all other vertices */
						g.addNewVertex(sink, null);
						var _iteratorNormalCompletion5 = true;
						var _didIteratorError5 = false;
						var _iteratorError5 = undefined;
		
						try {
							for (var _iterator5 = g.vertices()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
								var _step5$value = _slicedToArray(_step5.value, 1);
		
								var _name3 = _step5$value[0];
		
								g.setVertex(_name3, null);
								if (_name3 !== sink) {
									g.ensureEdge(_name3, sink);
								}
							}
						} catch (err) {
							_didIteratorError5 = true;
							_iteratorError5 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion5 && _iterator5['return']) {
									_iterator5['return']();
								}
							} finally {
								if (_didIteratorError5) {
									throw _iteratorError5;
								}
							}
						}
		
						/* transitive reduction */
						g = g.transitiveReduction();
		
						/* find all pairs of 'incomparable' deltas, plus the closest deltas that are 'greater' than both */
						var resolutions = new Map(); // first -> second -> Set<possible-resolving-delta>
						var getResolutionsIn = (function (_getResolutionsIn) {
							function getResolutionsIn(_x) {
								return _getResolutionsIn.apply(this, arguments);
							}
		
							getResolutionsIn.toString = function () {
								return _getResolutionsIn.toString();
							};
		
							return getResolutionsIn;
						})(function (name) {
							if (g.vertexValue(name)) {
								return;
							}
							var ancestors = new Map(); // pred -> Set<ancestors-inc-pred>
							var _iteratorNormalCompletion6 = true;
							var _didIteratorError6 = false;
							var _iteratorError6 = undefined;
		
							try {
								for (var _iterator6 = g.verticesTo(name)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
									var _step6$value = _slicedToArray(_step6.value, 1);
		
									var pred = _step6$value[0];
		
									getResolutionsIn(pred);
									var additionalAncestors = new Set([pred]);
									var _iteratorNormalCompletion8 = true;
									var _didIteratorError8 = false;
									var _iteratorError8 = undefined;
		
									try {
										for (var _iterator8 = g.vertexValue(pred).values()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
											var ancSet = _step8.value;
											var _iteratorNormalCompletion9 = true;
											var _didIteratorError9 = false;
											var _iteratorError9 = undefined;
		
											try {
												for (var _iterator9 = ancSet.values()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
													var anc = _step9.value;
		
													additionalAncestors.add(anc);
												}
											} catch (err) {
												_didIteratorError9 = true;
												_iteratorError9 = err;
											} finally {
												try {
													if (!_iteratorNormalCompletion9 && _iterator9['return']) {
														_iterator9['return']();
													}
												} finally {
													if (_didIteratorError9) {
														throw _iteratorError9;
													}
												}
											}
										}
									} catch (err) {
										_didIteratorError8 = true;
										_iteratorError8 = err;
									} finally {
										try {
											if (!_iteratorNormalCompletion8 && _iterator8['return']) {
												_iterator8['return']();
											}
										} finally {
											if (_didIteratorError8) {
												throw _iteratorError8;
											}
										}
									}
		
									ancestors.set(pred, additionalAncestors);
								}
							} catch (err) {
								_didIteratorError6 = true;
								_iteratorError6 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion6 && _iterator6['return']) {
										_iterator6['return']();
									}
								} finally {
									if (_didIteratorError6) {
										throw _iteratorError6;
									}
								}
							}
		
							g.setVertex(name, ancestors);
							var _iteratorNormalCompletion7 = true;
							var _didIteratorError7 = false;
							var _iteratorError7 = undefined;
		
							try {
								for (var _iterator7 = ancestors.keys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
									var pred1 = _step7.value;
									var _iteratorNormalCompletion10 = true;
									var _didIteratorError10 = false;
									var _iteratorError10 = undefined;
		
									try {
										for (var _iterator10 = ancestors.keys()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
											var pred2 = _step10.value;
		
											if (pred1 < pred2) {
												var ancs1 = new Set(ancestors.get(pred1));
												var ancs2 = new Set(ancestors.get(pred2));
												var _iteratorNormalCompletion11 = true;
												var _didIteratorError11 = false;
												var _iteratorError11 = undefined;
		
												try {
													for (var _iterator11 = ancs1[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
														var anc1 = _step11.value;
														var _iteratorNormalCompletion13 = true;
														var _didIteratorError13 = false;
														var _iteratorError13 = undefined;
		
														try {
															for (var _iterator13 = ancs2[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
																var anc2 = _step13.value;
		
																if (anc1 === anc2) {
																	ancs1['delete'](anc1);
																	ancs2['delete'](anc2);
																}
															}
														} catch (err) {
															_didIteratorError13 = true;
															_iteratorError13 = err;
														} finally {
															try {
																if (!_iteratorNormalCompletion13 && _iterator13['return']) {
																	_iterator13['return']();
																}
															} finally {
																if (_didIteratorError13) {
																	throw _iteratorError13;
																}
															}
														}
													}
												} catch (err) {
													_didIteratorError11 = true;
													_iteratorError11 = err;
												} finally {
													try {
														if (!_iteratorNormalCompletion11 && _iterator11['return']) {
															_iterator11['return']();
														}
													} finally {
														if (_didIteratorError11) {
															throw _iteratorError11;
														}
													}
												}
		
												var _iteratorNormalCompletion12 = true;
												var _didIteratorError12 = false;
												var _iteratorError12 = undefined;
		
												try {
													for (var _iterator12 = ancs1[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
														var anc1 = _step12.value;
														var _iteratorNormalCompletion14 = true;
														var _didIteratorError14 = false;
														var _iteratorError14 = undefined;
		
														try {
															for (var _iterator14 = ancs2[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
																var anc2 = _step14.value;
		
																_extend$isDefined$indent$oncePer$s$t.s.apply(undefined, [resolutions].concat(_toConsumableArray([anc1, anc2].sort()))).add(name);
															}
														} catch (err) {
															_didIteratorError14 = true;
															_iteratorError14 = err;
														} finally {
															try {
																if (!_iteratorNormalCompletion14 && _iterator14['return']) {
																	_iterator14['return']();
																}
															} finally {
																if (_didIteratorError14) {
																	throw _iteratorError14;
																}
															}
														}
													}
												} catch (err) {
													_didIteratorError12 = true;
													_iteratorError12 = err;
												} finally {
													try {
														if (!_iteratorNormalCompletion12 && _iterator12['return']) {
															_iterator12['return']();
														}
													} finally {
														if (_didIteratorError12) {
															throw _iteratorError12;
														}
													}
												}
											}
										}
									} catch (err) {
										_didIteratorError10 = true;
										_iteratorError10 = err;
									} finally {
										try {
											if (!_iteratorNormalCompletion10 && _iterator10['return']) {
												_iterator10['return']();
											}
										} finally {
											if (_didIteratorError10) {
												throw _iteratorError10;
											}
										}
									}
								}
							} catch (err) {
								_didIteratorError7 = true;
								_iteratorError7 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion7 && _iterator7['return']) {
										_iterator7['return']();
									}
								} finally {
									if (_didIteratorError7) {
										throw _iteratorError7;
									}
								}
							}
						});
						getResolutionsIn(sink);
		
						/* out of the incomparable deltas, find those that are actually in conflict, and find any */
						var result = new Set();
						var _iteratorNormalCompletion15 = true;
						var _didIteratorError15 = false;
						var _iteratorError15 = undefined;
		
						try {
							for (var _iterator15 = resolutions.keys()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
								var first = _step15.value;
								var _iteratorNormalCompletion16 = true;
								var _didIteratorError16 = false;
								var _iteratorError16 = undefined;
		
								try {
									for (var _iterator16 = resolutions.get(first).keys()[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
										var second = _step16.value;
		
										var x = this.graph.vertexValue(first);
										var y = this.graph.vertexValue(second);
										if (!x.commutesWith(y, { weak: true })) {
											var conflictInfo = {
												conflictingDeltas: new Set([first, second]),
												conflictResolvingDeltas: new Set()
											};
											var _iteratorNormalCompletion17 = true;
											var _didIteratorError17 = false;
											var _iteratorError17 = undefined;
		
											try {
												for (var _iterator17 = resolutions.get(first).get(second)[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
													var nearestResolver = _step17.value;
		
													var _arr = [[nearestResolver]].concat(_toConsumableArray(g.verticesWithPathFrom(nearestResolver)));
		
													for (var _i = 0; _i < _arr.length; _i++) {
														var _arr$_i = _slicedToArray(_arr[_i], 1);
		
														var resolver = _arr$_i[0];
		
														var z = this.graph.vertexValue(resolver);
														if (resolver !== sink && z.resolves(x, y, { weak: true })) {
															conflictInfo.conflictResolvingDeltas.add(resolver);
														}
													}
												}
											} catch (err) {
												_didIteratorError17 = true;
												_iteratorError17 = err;
											} finally {
												try {
													if (!_iteratorNormalCompletion17 && _iterator17['return']) {
														_iterator17['return']();
													}
												} finally {
													if (_didIteratorError17) {
														throw _iteratorError17;
													}
												}
											}
		
											result.add(conflictInfo);
										}
									}
								} catch (err) {
									_didIteratorError16 = true;
									_iteratorError16 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion16 && _iterator16['return']) {
											_iterator16['return']();
										}
									} finally {
										if (_didIteratorError16) {
											throw _iteratorError16;
										}
									}
								}
							}
						} catch (err) {
							_didIteratorError15 = true;
							_iteratorError15 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion15 && _iterator15['return']) {
									_iterator15['return']();
								}
							} finally {
								if (_didIteratorError15) {
									throw _iteratorError15;
								}
							}
						}
		
						/* return the conflict results */
						return result;
					}
				}]);
		
				return DeltaModel;
			})(deltaJs.Delta), (function (_deltaJs$ContainerProxy) {
				function DeltaModelProxy() {
					for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
						args[_key2] = arguments[_key2];
					}
		
					_classCallCheck(this, DeltaModelProxy);
		
					_get(Object.getPrototypeOf(DeltaModelProxy.prototype), 'constructor', this).apply(this, args);
					this._childOptions = new Map(); // key -> options
					this._childApplicationConditions = new Map(); // key -> application-condition
				}
		
				_inherits(DeltaModelProxy, _deltaJs$ContainerProxy);
		
				_createClass(DeltaModelProxy, [{
					key: 'processProxyArguments',
		
					/**
		    * @public
		    * @method
		    * @param rawArgs {Array.<*>}
		    * @return {?{ options: Object, args: Array.<*> }}
		    */
					value: function processProxyArguments() {
						for (var _len3 = arguments.length, rawArgs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
							rawArgs[_key3] = arguments[_key3];
						}
		
						// rawArgs is parsed as (...options, name, ...options, path, ...args),
						// though name and/or path may also be passed as options directly
						var options = {};
						do {
							if (rawArgs.length === 0) {
								throw new Error('The argument list for this Modify.DeltaModel method is insufficient.');
							}
							var arg = rawArgs.shift();
							if (typeof arg === 'string') {
								if (!options.name) {
									options.name = arg;
								} else {
									options.path = arg;
								}
							} else {
								_extend$isDefined$indent$oncePer$s$t.extend(options, arg);
							}
						} while (!options.path || !options.name);
						return { options: options, args: rawArgs };
					}
				}, {
					key: 'addOperation',
		
					/**
		    * @public
		    * @method
		    * @param delta   {DeltaJs#Delta}
		    * @param options {{path: Path, name: string, feature: boolean}}
		    * @return {DeltaJs#Proxy}
		    */
					value: function addOperation(delta, options) {
						var path = options.path;
						var name = options.name;
						var feature = options.feature;
		
						/* create application condition and optional eponymous linked feature */
						if (!this._childApplicationConditions.has(name)) {
							var appCond = undefined;
							if (feature) {
								appCond = deltaJs.newFeature(name, options);
							} else {
								appCond = deltaJs.newFeature('delta__' + name, _extend$isDefined$indent$oncePer$s$t.extend({ hidden: true }, options));
							}
							if (_extend$isDefined$indent$oncePer$s$t.isDefined(options.resolves)) {
								appCond['if'](options.resolves);
								options = _extend$isDefined$indent$oncePer$s$t.extend({}, options, { feature: false });
							}
							if (_extend$isDefined$indent$oncePer$s$t.isDefined(options.requires)) {
								appCond.selects(options.requires);
							}
							if (feature || appCond.conditional) {
								delta.applicationCondition = appCond;
							}
							this._childApplicationConditions.set(name, appCond);
						}
		
						/* create proxies */
						var deepestProxy;
						if (path.prop) {
							var newOptions = _extend$isDefined$indent$oncePer$s$t.extend({}, options, { name: undefined });
							var childProxy = this.addChildProxy(name, new deltaJs.Delta.Modify());
							deepestProxy = childProxy.addOperation(delta, newOptions);
						} else {
							deepestProxy = this.addChildProxy(name, delta);
						}
		
						/* store options */
						if (!this._childOptions.has(name)) {
							this._childOptions.set(name, options);
						}
		
						/* return the deepest created proxy */
						return deepestProxy;
					}
				}, {
					key: 'delta',
		
					/**
		    * Dynamically compute and return the delta belonging to this proxy.
		    * @public
		    * @method
		    * @return the delta belonging to this proxy
		    */
					value: function delta() {
						var result = _get(Object.getPrototypeOf(DeltaModelProxy.prototype), 'delta', this).call(this);
						result.graph.clear();
						var _iteratorNormalCompletion18 = true;
						var _didIteratorError18 = false;
						var _iteratorError18 = undefined;
		
						try {
							for (var _iterator18 = this.childKeys()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
								var _name4 = _step18.value;
		
								var options = this._childOptions.get(_name4);
		
								/* delta in the graph */
								var delta = this.childDelta(_name4);
								result.graph.addVertex(_name4, delta);
		
								/* application order */
		
								var _arr2 = [].concat(_toConsumableArray(options.resolves || []), _toConsumableArray(options.after || []), _toConsumableArray(options.requires || []));
		
								for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
									var subName = _arr2[_i2];
									result.graph.createEdge(subName, _name4);
									var cycle = result.graph.cycle();
									if (cycle) {
										result.graph.removeExistingEdge(subName, _name4);
										throw new _ApplicationOrderCycle$UnresolvedDeltaConflict.ApplicationOrderCycle(cycle);
									}
								}
		
								/* application condition */
								if (options.feature || this._childApplicationConditions.get(_name4).conditional) {
									delta.applicationCondition = this._childApplicationConditions.get(_name4);
								}
							}
						} catch (err) {
							_didIteratorError18 = true;
							_iteratorError18 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion18 && _iterator18['return']) {
									_iterator18['return']();
								}
							} finally {
								if (_didIteratorError18) {
									throw _iteratorError18;
								}
							}
						}
		
						return result;
					}
				}]);
		
				return DeltaModelProxy;
			})(deltaJs.ContainerProxy));
		
			/* composition */
			// to compose delta models, we simply have one apply after the other
			// without any composability checks; in the future, this may become more clever
			deltaJs.newComposition(function (d1, d2) {
				return d1 instanceof deltaJs.Delta.DeltaModel || d2 instanceof deltaJs.Delta.DeltaModel;
			}, true);
		
			/* equality */
			deltaJs.newEquality(_extend$isDefined$indent$oncePer$s$t.t('DeltaModel', 'DeltaModel'), function (d1, d2) {
				var g1 = d1.graph.transitiveReduction();
				var g2 = d2.graph.transitiveReduction();
				return g1.equals(g2, function (x, y) {
					return x.equals(y);
				});
			});
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } };
		
		var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		/* import internal stuff */
		
		var _extend$a$assert$isUndefined$oncePer = __webpack_require__(3);
		
		var _ConstraintFailure = __webpack_require__(7);
		
		exports['default'] = _extend$a$assert$isUndefined$oncePer.oncePer('features', function (deltaJs) {
		
			_extend$a$assert$isUndefined$oncePer.oncePer(deltaJs.constructor, 'features', function (DeltaJs) {
		
				_extend$a$assert$isUndefined$oncePer.extend(DeltaJs.prototype, /** @lends DeltaJs.prototype */{
					/**
		    * @param name    {string}  - the name of the new feature
		    * @param options {object?} - the (optional) options for the new feature
		    * @return {DeltaJs#Feature} - the object representing the new feature
		    */
					newFeature: function newFeature(name) {
						var options = arguments[1] === undefined ? {} : arguments[1];
		
						/* sanity check*/
						_extend$a$assert$isUndefined$oncePer.assert(_extend$a$assert$isUndefined$oncePer.isUndefined(this.features[name]), 'A feature with the name \'' + name + '\' already exists.');
		
						/* create the new feature */
						return this.features[name] = new this.Feature(name, options);
					}
				});
			});
		
			/* given a 'user input' clause, normalize it */
			function _normalizeClause(input) {
				input = Array.isArray(input) ? input : [input];
				input = input.map(function (conj) {
					return conj instanceof deltaJs.Feature ? conj.name : conj;
				});
				return input;
			}
		
			/* code for the mutual selection of features */
			var _if = new Map(); // feature -> (arrays of arrays; disjunctive normal form)
			var _selected = new Map(); // feature -> Boolean
			function _addIf(feature) {
				var disjunct = arguments[1] === undefined ? [] : arguments[1];
		
				_conditionsUnsettled = true;
				if (disjunct === true) {
					_selected.set(feature, true);
				} else if (disjunct === false) {} else if (_if.get(feature) !== true) {
					_extend$a$assert$isUndefined$oncePer.a(_if, feature).push(_normalizeClause(disjunct));
				}
			}
			function _addSelects(feature, otherFeatures) {
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;
		
				try {
					for (var _iterator = _normalizeClause(otherFeatures)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var other = _step.value;
		
						_addIf(other, feature);
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator['return']) {
							_iterator['return']();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
			}
		
			/* code for constraints between features (enforced by errors) */
			var _onlyIf = new Map(); // feature -> (arrays of arrays; conjunctive normal form)
			var _allowed = new Map(); // feature -> Boolean
			function _addOnlyIf(feature) {
				var conjunct = arguments[1] === undefined ? [] : arguments[1];
		
				_conditionsUnsettled = true;
				if (conjunct === false) {
					_allowed.set(feature, false);
				} else if (conjunct === true) {} else if (_onlyIf.get(feature) !== false) {
					_extend$a$assert$isUndefined$oncePer.a(_onlyIf, feature).push(_normalizeClause(conjunct));
				}
			}
			function _addRequiredBy(feature, otherFeatures) {
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;
		
				try {
					for (var _iterator2 = _normalizeClause(otherFeatures)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var other = _step2.value;
		
						_addOnlyIf(other, feature);
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2['return']) {
							_iterator2['return']();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			}
		
			/* code for settling relations between features */
			var _conditionsUnsettled = false;
			function _settleConditions() {
				if (!_conditionsUnsettled) {
					return;
				}
				_conditionsUnsettled = false;
		
				/* fixed point computation of selected features (i.e., propagate them until there is no change) */
				var somethingChanged;
				do {
					somethingChanged = false;
					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = undefined;
		
					try {
						for (var _iterator3 = Object.keys(deltaJs.features)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
							var featureName = _step3.value;
		
							if (!_selected.get(featureName)) {
								/* if there are 'if' disjuncts that are selected, this feature is selected */
								if (_selected.has(featureName)) {
									_selected.set(featureName, false);
								}
								if ((_if.get(featureName) || []).some(function (disj) {
									return disj.every(function (conj) {
										return _selected.get(conj);
									});
								})) {
									_selected.set(featureName, true);
									somethingChanged = true;
								}
							}
						}
					} catch (err) {
						_didIteratorError3 = true;
						_iteratorError3 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion3 && _iterator3['return']) {
								_iterator3['return']();
							}
						} finally {
							if (_didIteratorError3) {
								throw _iteratorError3;
							}
						}
					}
				} while (somethingChanged);
		
				/* computation of allowed features */
				var _iteratorNormalCompletion4 = true;
				var _didIteratorError4 = false;
				var _iteratorError4 = undefined;
		
				try {
					for (var _iterator4 = Object.keys(deltaJs.features)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
						var featureName = _step4.value;
		
						/* if there are 'onlyIf' conjuncts that are excluded, this feature is excluded */
						_allowed.set(featureName, (_onlyIf.get(featureName) || []).every(function (conj) {
							return conj.some(function (disj) {
								return _selected.get(disj);
							});
						}));
					}
				} catch (err) {
					_didIteratorError4 = true;
					_iteratorError4 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion4 && _iterator4['return']) {
							_iterator4['return']();
						}
					} finally {
						if (_didIteratorError4) {
							throw _iteratorError4;
						}
					}
				}
			}
		
			/** {@public}{@class DeltaJs#Feature}
		  *
		  */
			deltaJs.Feature = (function () {
				function Feature(name) {
					var options = arguments[1] === undefined ? {} : arguments[1];
		
					_classCallCheck(this, Feature);
		
					/* set basic fields */
					this.name = name;
					this.options = options;
		
					/* update conditions */
					var _iteratorNormalCompletion5 = true;
					var _didIteratorError5 = false;
					var _iteratorError5 = undefined;
		
					try {
						for (var _iterator5 = Object.keys(options)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
							var option = _step5.value;
		
							this.addOption(option, options[option]);
						}
					} catch (err) {
						_didIteratorError5 = true;
						_iteratorError5 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion5 && _iterator5['return']) {
								_iterator5['return']();
							}
						} finally {
							if (_didIteratorError5) {
								throw _iteratorError5;
							}
						}
					}
				}
		
				_createClass(Feature, [{
					key: 'selected',
					get: function () {
						_settleConditions();
						if (_selected.get(this.name) && !_allowed.get(this.name)) {
							throw new _ConstraintFailure.ConstraintFailure(this);
						}
						return _selected.get(this.name);
					}
				}, {
					key: 'condition',
					get: function () {
						return _if.get(this.name);
					}
				}, {
					key: 'conditional',
					get: function () {
						return _extend$a$assert$isUndefined$oncePer.a(_if, this.name).length > 0;
					}
				}, {
					key: 'restricted',
					get: function () {
						return _extend$a$assert$isUndefined$oncePer.a(_onlyIf, this.name).length > 0;
					}
				}, {
					key: 'select',
					value: function select() {
						this['if'](true);
					}
				}]);
		
				return Feature;
			})();
		
			/* restrictions and connections */
			var FEATURE_CONNECTIONS = [['if', [_addIf]], // this selected by other
			['onlyIf', [_addOnlyIf]], // error if this but not other
			['selects', [_addSelects]], // other selected by this
			['requiredBy', [_addRequiredBy]], // error if other but not this
			['iff', [_addIf, _addOnlyIf]] // if and onlyIf
			];
			deltaJs.Feature.prototype.addOption = function (optionName, value) {
				var _iteratorNormalCompletion6 = true;
				var _didIteratorError6 = false;
				var _iteratorError6 = undefined;
		
				try {
					for (var _iterator6 = FEATURE_CONNECTIONS[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
						var _step6$value = _slicedToArray(_step6.value, 2);
		
						var connectionName = _step6$value[0];
						var methods = _step6$value[1];
		
						if (optionName === connectionName) {
							var _iteratorNormalCompletion7 = true;
							var _didIteratorError7 = false;
							var _iteratorError7 = undefined;
		
							try {
								for (var _iterator7 = methods[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
									var method = _step7.value;
									method(this.name, value);
								}
							} catch (err) {
								_didIteratorError7 = true;
								_iteratorError7 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion7 && _iterator7['return']) {
										_iterator7['return']();
									}
								} finally {
									if (_didIteratorError7) {
										throw _iteratorError7;
									}
								}
							}
						}
					}
				} catch (err) {
					_didIteratorError6 = true;
					_iteratorError6 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion6 && _iterator6['return']) {
							_iterator6['return']();
						}
					} finally {
						if (_didIteratorError6) {
							throw _iteratorError6;
						}
					}
				}
			};
			var _iteratorNormalCompletion8 = true;
			var _didIteratorError8 = false;
			var _iteratorError8 = undefined;
		
			try {
				var _loop = function () {
					_step8$value = _slicedToArray(_step8.value, 1);
					var name = _step8$value[0];
		
					deltaJs.Feature.prototype[name] = function (value) {
						this.addOption(name, value);
					};
				};
		
				for (var _iterator8 = FEATURE_CONNECTIONS[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
					var _step8$value;
		
					_loop();
				}
			} catch (err) {
				_didIteratorError8 = true;
				_iteratorError8 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion8 && _iterator8['return']) {
						_iterator8['return']();
					}
				} finally {
					if (_didIteratorError8) {
						throw _iteratorError8;
					}
				}
			}
		
			/* the features belonging to this DeltaJs instance */
			deltaJs.features = {}; // name -> Feature
		});
		module.exports = exports['default'];
	
		// change nothing
	
		// change nothing
	
	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
		
		var _defineProperty = function (obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: key == null || typeof Symbol == 'undefined' || key.constructor !== Symbol, configurable: true, writable: true }); };
		
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		/* import internal stuff */
		
		var _extend$oncePer = __webpack_require__(3);
		
		var _define_DeltaModel = __webpack_require__(16);
		
		var _define_DeltaModel2 = _interopRequireWildcard(_define_DeltaModel);
		
		exports['default'] = _extend$oncePer.oncePer('variation points', function (deltaJs) {
		
			_define_DeltaModel2['default'](deltaJs);
		
			_extend$oncePer.oncePer(deltaJs.constructor, 'variation points', function (DeltaJs) {
				_extend$oncePer.extend(DeltaJs.prototype, /** @lends DeltaJs.prototype */{
		
					/**
		    * This method indicates a variation point.
		    * @param name {string} - a hook by which operations from the core delta model can be applied
		    * @param val  {*}      - the initial value of this variation point
		    * @return {*} - the value of this variation point after applying the appropriate deltas
		    */
					vp: function vp(name, val) {
						var root = _defineProperty({}, name, val);
						this._deltaModelProxy.delta().applyTo(root, {
							restrictToProperty: name
						});
						return root[name];
					},
		
					/**
		    * A {DeltaJs} instance has one fundamental {DeltaJs#DeltaModel} instance, which is applied
		    * to any variation points that are encountered. This method is an alias to the eponymous
		    * method on that 'root' delta model. It returns the proxy that allows new delta operations
		    * to be added more easily. It presets the 'feature' option to 'true', but this can be
		    * overwritten manually.
		    * @return {DeltaJs#Proxy} - the proxy to this delta, for easily adding operations
		    */
					'do': function _do() {
						var _deltaModelProxy;
		
						for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
							args[_key] = arguments[_key];
						}
		
						return (_deltaModelProxy = this._deltaModelProxy)['do'].apply(_deltaModelProxy, [{ feature: true }].concat(args));
					}
		
				});
			});
		
			deltaJs._deltaModelProxy = new deltaJs.Delta.DeltaModel()['do']();
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };
		
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		/* import internal stuff */
		
		var _extend$isUndefined$oncePer = __webpack_require__(3);
		
		exports['default'] = _extend$isUndefined$oncePer.oncePer('application conditions', function (deltaJs) {
		
			_extend$isUndefined$oncePer.oncePer(deltaJs.constructor, 'application conditions', function () {
		
				_extend$isUndefined$oncePer.extend(deltaJs.constructor.prototype, {
					select: function select() {
						for (var _len = arguments.length, features = Array(_len), _key = 0; _key < _len; _key++) {
							features[_key] = arguments[_key];
						}
		
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;
		
						try {
							for (var _iterator = features[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var feature = _step.value;
		
								if (Array.isArray(feature)) {
									this.select.apply(this, _toConsumableArray(feature));
								} else if (this.features[feature]) {
									this.features[feature].select();
								} else {
									console.error('The feature \'' + feature + '\' is being selected, but it was never registered.');
								}
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator['return']) {
									_iterator['return']();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}
					}
				});
			});
		
			_extend$isUndefined$oncePer.extend(deltaJs.Delta.prototype, Object.defineProperties({}, {
				applicationCondition: {
					get: function () {
						return this._applicationCondition;
					},
					set: function (ac) {
						this._applicationCondition = ac;
					},
					configurable: true,
					enumerable: true
				},
				selected: {
					get: function () {
						return _extend$isUndefined$oncePer.isUndefined(this.applicationCondition) || this.applicationCondition.selected;
					},
					configurable: true,
					enumerable: true
				}
			}));
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
		
		var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };
		
		var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
		
		var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
		
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		/* import internal stuff */
		
		var _extend$a$isUndefined$oncePer = __webpack_require__(3);
		
		var _Path = __webpack_require__(6);
		
		var _Path2 = _interopRequireWildcard(_Path);
		
		var _define_Overloaded = __webpack_require__(11);
		
		var _define_Overloaded2 = _interopRequireWildcard(_define_Overloaded);
		
		var _define_Proxy = __webpack_require__(23);
		
		var _define_Proxy2 = _interopRequireWildcard(_define_Proxy);
		
		var _MultipleActiveProxiesError = __webpack_require__(7);
		
		exports['default'] = _extend$a$isUndefined$oncePer.oncePer('ContainerProxy', function (deltaJs) {
		
			_define_Proxy2['default'](deltaJs);
		
			_extend$a$isUndefined$oncePer.oncePer(deltaJs.constructor, 'ContainerProxy', function (DeltaJs) {
				_extend$a$isUndefined$oncePer.extend(DeltaJs.prototype, /** @lends DeltaJs.prototype */{
					/**
		    * @param method  {string}   - method name
		    * @param handler {function} - a function that takes method arguments, and returns a new `DeltaJs#Delta` instance
		    */
					newProxyMethod: function newProxyMethod(method, handler) {
						this.ContainerProxy.newProxyMethod(method, handler);
					}
				});
			});
		
			/* a Proxy class for container operation types like Modify and DeltaModel */
			deltaJs.ContainerProxy = (function (_deltaJs$Proxy) {
		
				// A Proxy instance exposes operation methods directly. Arguments
				// to those operations can be pre-supplied through the `do` method.
		
				function ContainerProxy() {
					var options = arguments[0] === undefined ? {} : arguments[0];
		
					_classCallCheck(this, ContainerProxy);
		
					_get(Object.getPrototypeOf(ContainerProxy.prototype), 'constructor', this).call(this, options);
					this._doArgs = [];
					this._original = this;
					this._children = new Map(); // key -> [proxies]
				}
		
				_inherits(ContainerProxy, _deltaJs$Proxy);
		
				_createClass(ContainerProxy, [{
					key: 'deactivate',
					value: function deactivate() {
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;
		
						try {
							for (var _iterator = this._children.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var key = _step.value;
		
								this.childProxy(key).deactivate();
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator['return']) {
									_iterator['return']();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}
		
						_get(Object.getPrototypeOf(ContainerProxy.prototype), 'deactivate', this).call(this);
					}
				}, {
					key: 'addChildProxy',
					value: function addChildProxy(key, delta) {
						/* get the current proxy for the given key */
						var current = this.childProxy(key);
		
						/* get / create delta proxy */
						var ProxyClass = delta.constructor.Proxy || deltaJs.Proxy;
						var proxy = new ProxyClass({ delta: delta, parent: this });
		
						/* return the current proxy if it, and the current proxy, are both Modify.Proxy */
						if (current instanceof deltaJs.Delta.Modify.Proxy && proxy instanceof deltaJs.Delta.Modify.Proxy) {
							return current;
						}
		
						/* we need a new proxy, so deactivate the current one */
						if (current) {
							current.deactivate();
						}
		
						/* create a new Proxy of the right class, remember it and return it */
						this._children.get(key).push(proxy);
						return proxy;
					}
				}, {
					key: 'childKeys',
					value: function childKeys() {
						return [].concat(_toConsumableArray(this._children.keys()));
					}
				}, {
					key: 'childProxies',
					// TODO: Is an iterable a good return value?
		
					value: function childProxies(key) {
						return _extend$a$isUndefined$oncePer.a(this._children, key);
					}
				}, {
					key: 'childProxy',
					value: function childProxy(key) {
						if (!this._children.has(key)) {
							this._children.set(key, []);
						}
						return this._children.get(key)[this._children.get(key).length - 1];
					}
				}, {
					key: 'childDelta',
					value: function childDelta(key) {
						var _deltaJs$Delta;
		
						var result = (_deltaJs$Delta = deltaJs.Delta).composed.apply(_deltaJs$Delta, _toConsumableArray(this.childProxies(key).map(function (proxy) {
							return proxy.delta();
						})));
						return result;
					}
				}, {
					key: 'do',
					value: function _do() {
						for (var _len = arguments.length, doArgs = Array(_len), _key = 0; _key < _len; _key++) {
							doArgs[_key] = arguments[_key];
						}
		
						/* is this proxy active? */
						if (!this.active) {
							throw new _MultipleActiveProxiesError.MultipleActiveProxiesError();
						}
		
						/* return a version of this Proxy with extra preloaded args */
						// note that this mixes prototypical inheritance
						// into the existing classical inheritance scheme
						var result = Object.create(this);
						result._doArgs = [].concat(_toConsumableArray(this._doArgs), doArgs);
						result._original = this._original;
						return result;
					}
				}, {
					key: '_do',
		
					////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
					value: function _do(method, doArgs) {
						/* is this proxy active? */
						if (!this.active) {
							throw new _MultipleActiveProxiesError.MultipleActiveProxiesError();
						}
		
						/* container-specific processing of arguments */
		
						var _processProxyArguments$apply = this.processProxyArguments.apply(this, _toConsumableArray(this._doArgs).concat(_toConsumableArray(doArgs)));
		
						var options = _processProxyArguments$apply.options;
						var args = _processProxyArguments$apply.args;
		
						/* if the options contain a path, reify it */
						if (typeof options.path === 'string') {
							options.path = new _Path2['default'](options.path);
						}
		
						/* the argument list is finished; create a new delta and put it in the right place */
						var delta = deltaJs.ContainerProxy._newDeltaByMethod(method, args);
						var proxy = this.addOperation(delta, options);
		
						/* return the right Proxy instance for chaining */
						return proxy instanceof deltaJs.ContainerProxy ? proxy : this;
					}
				}, {
					key: 'processProxyArguments',
		
					////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
					//noinspection JSCommentMatchesSignature
					/**
		    * Subclasses of `ContainerProxy` should implement this method to extract an
		    * options object, path and final argument list from a given 'raw' argument list.
		    * @abstract
		    * @protected
		    */
					value: function processProxyArguments() {
						throw new Error('A \'ContainerProxy\' subclass needs to implement the \'processProxyArguments\' method.');
					}
				}, {
					key: 'addOperation',
		
					//noinspection JSCommentMatchesSignature
					/** {@public}{@abstract}{@method}
		    * Subclasses of `ContainerProxy` should implement this method to add a given delta
		    * under a given path with the given options, and return its corresponding Proxy.
		    * @abstract
		    * @protected
		    */
					value: function addOperation() {
						throw new Error('A \'ContainerProxy\' subclass needs to implement the \'addOperation\' method.');
					}
				}], [{
					key: '_newDeltaByMethod',
		
					////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
					/**
		    * Create a delta based on a method-name and argument-list.
		    * If the method-name is overloaded, you'll automatically get
		    * an `Delta.Overloaded` instance.
		    *
		    * @param method {string}
		    * @param [args] {*}
		    * @return {DeltaJs#Delta}
		    */
					value: function _newDeltaByMethod(method, args) {
						var newDeltas = deltaJs.ContainerProxy._methodHandlers[method].map(function (handler) {
							return handler.apply(undefined, _toConsumableArray(args));
						});
						if (newDeltas.length === 1) {
							return newDeltas[0];
						} else {
							// newDeltas.length > 1
							_define_Overloaded2['default'](deltaJs);
							return new deltaJs.Delta.Overloaded(newDeltas);
						}
					}
				}, {
					key: 'newProxyMethod',
		
					/**
		    * @static
		    * @param method  {string}   - method name
		    * @param handler {function} - a function that takes method arguments, and returns a new `DeltaJs#Delta` instance
		    */
					value: function newProxyMethod(method, handler) {
		
						/* automatically populate the Proxy class with new operation method */
						if (_extend$a$isUndefined$oncePer.isUndefined(deltaJs.ContainerProxy.prototype[method])) {
							deltaJs.ContainerProxy.prototype[method] = function () {
								for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
									args[_key2] = arguments[_key2];
								}
		
								return this._do(method, args);
							};
						}
		
						/* register handlers for each method */
						_extend$a$isUndefined$oncePer.a(deltaJs.ContainerProxy, '_methodHandlers', method).push(handler);
					}
				}]);
		
				return ContainerProxy;
			})(deltaJs.Proxy);
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 21 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(global) {"use strict";
		
		if (global._babelPolyfill) {
		  throw new Error("only one instance of babel/polyfill is allowed");
		}
		global._babelPolyfill = true;
		
		__webpack_require__(25);
		
		__webpack_require__(26);
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 22 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
		
		var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };
		
		var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
		
		var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
		
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		/* import internal stuff */
		
		var _indent$oncePer$arraysEqual$t = __webpack_require__(3);
		
		var _define_OperationTypes = __webpack_require__(9);
		
		var _define_OperationTypes2 = _interopRequireWildcard(_define_OperationTypes);
		
		exports['default'] = _indent$oncePer$arraysEqual$t.oncePer('Composed', function (deltaJs) {
		
			_define_OperationTypes2['default'](deltaJs);
		
			// NOTE: Not importing the circular dependency deltaJs.Delta here.
			//       That file will import this one at the proper time.
		
			deltaJs.newOperationType('Composed', (function (_deltaJs$Delta) {
				function Composed() {
					for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
						args[_key] = arguments[_key];
					}
		
					_classCallCheck(this, Composed);
		
					_get(Object.getPrototypeOf(Composed.prototype), 'constructor', this).apply(this, args);
					this._components = this.arg || [];
					this.options = args[1] || {};
				}
		
				_inherits(Composed, _deltaJs$Delta);
		
				_createClass(Composed, [{
					key: 'clone',
					value: function clone() {
						var result = _get(Object.getPrototypeOf(Composed.prototype), 'clone', this).call(this);
						result._components = this._components.map(function (delta) {
							return delta.clone();
						});
						return result;
					}
				}, {
					key: 'applyTo',
					value: function applyTo(target) {
						var options = arguments[1] === undefined ? {} : arguments[1];
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;
		
						try {
							for (var _iterator = this._components[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var delta = _step.value;
		
								delta.applyTo(target, options);
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator['return']) {
									_iterator['return']();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}
					}
				}, {
					key: 'toString',
		
					/**
		    * @public
		    * @method
		    * @param options {object?}
		    * @return {string}
		    */
					value: function toString() {
						var options = arguments[0] === undefined ? {} : arguments[0];
		
						var str = _get(Object.getPrototypeOf(Composed.prototype), 'toString', this).call(this, options);
						if (this._components.length > 0) {
							var deltas = '';
							var _iteratorNormalCompletion2 = true;
							var _didIteratorError2 = false;
							var _iteratorError2 = undefined;
		
							try {
								for (var _iterator2 = this._components[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
									var delta = _step2.value;
		
									deltas += '• ' + delta.toString(options) + '\n';
								}
							} catch (err) {
								_didIteratorError2 = true;
								_iteratorError2 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion2 && _iterator2['return']) {
										_iterator2['return']();
									}
								} finally {
									if (_didIteratorError2) {
										throw _iteratorError2;
									}
								}
							}
		
							str += '\n' + _indent$oncePer$arraysEqual$t.indent(deltas, 4);
						}
						return str;
					}
				}, {
					key: 'precondition',
					value: function precondition(target, options) {
						if (this._components.length === 0) {
							return true;
						}
						return this._components[0].precondition(target, options);
					}
				}, {
					key: '_collapse',
					value: function _collapse() {
						var _this = this;
		
						/* flatten Composed that are inside Composed */
						this._components = (function () {
							var newComponents = [];
							var _iteratorNormalCompletion3 = true;
							var _didIteratorError3 = false;
							var _iteratorError3 = undefined;
		
							try {
								for (var _iterator3 = _this._components[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
									var delta = _step3.value;
		
									if (delta instanceof deltaJs.Delta.Composed) {
										delta._collapse();
										newComponents.push.apply(newComponents, _toConsumableArray(delta._components));
									} else {
										newComponents.push(delta);
									}
								}
							} catch (err) {
								_didIteratorError3 = true;
								_iteratorError3 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion3 && _iterator3['return']) {
										_iterator3['return']();
									}
								} finally {
									if (_didIteratorError3) {
										throw _iteratorError3;
									}
								}
							}
		
							return newComponents;
						})();
		
						/* compose neighbouring pairs where possible */
						var changed = undefined;
						do {
							changed = false;
							this._components = (function () {
								var newComponents = [];
								for (var i = 0; i < _this._components.length - 1; i += 1) {
									var composedPair = _this._components[i].composedWith(_this._components[i + 1], _this.options);
									if (composedPair instanceof deltaJs.Delta.Composed) {
										newComponents.push(_this._components[i]);
									} else {
										newComponents.push(composedPair);
										changed = true;
										i += 1;
									}
								}
								if (i === _this._components.length - 1) {
									newComponents.push(_this._components[i]);
								}
								return newComponents;
							})();
						} while (changed);
					}
				}, {
					key: 'methods',
					get: function () {
						return [];
					}
				}]);
		
				return Composed;
			})(deltaJs.Delta));
		
			/* composition */
			deltaJs.newComposition(function (d1, d2) {
				return d1 instanceof deltaJs.Delta.Composed || d2 instanceof deltaJs.Delta.Composed;
			}, function (d1, d2, opt) {
				var D1 = d1 instanceof deltaJs.Delta.Composed ? d1._components : [d1];
				var D2 = d2 instanceof deltaJs.Delta.Composed ? d2._components : [d2];
				var result = new deltaJs.Delta.Composed([].concat(_toConsumableArray(D1), _toConsumableArray(D2)), opt);
				result._collapse();
				return result;
			});
		
			/* equality */
			deltaJs.newEquality(_indent$oncePer$arraysEqual$t.t('Composed', 'Composed'), function (d1, d2) {
				return _indent$oncePer$arraysEqual$t.arraysEqual(d1._components, d2._components, function (x, y) {
					return x.equals(y);
				});
			});
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 23 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
		
		var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
		/* import internal stuff */
		
		var _extend$oncePer = __webpack_require__(3);
		
		var _define_Delta = __webpack_require__(10);
		
		var _define_Delta2 = _interopRequireWildcard(_define_Delta);
		
		exports['default'] = _extend$oncePer.oncePer('Proxy', function (deltaJs) {
		
			_define_Delta2['default'](deltaJs);
		
			deltaJs.Proxy = (function () {
				function Proxy() {
					var _ref2 = arguments[0] === undefined ? {} : arguments[0];
		
					var parent = _ref2.parent;
					var delta = _ref2.delta;
		
					_classCallCheck(this, Proxy);
		
					this._parent = parent;
					this._active = true;
					this._delta = delta;
				}
		
				_createClass(Proxy, [{
					key: 'delta',
					value: function delta() {
						return this._delta;
					}
				}, {
					key: 'active',
					get: function () {
						return this._active;
					}
				}, {
					key: 'deactivate',
					value: function deactivate() {
						this._active = false;
					}
				}]);
		
				return Proxy;
			})();
		
			_extend$oncePer.extend(deltaJs.Delta.prototype, {
		
				/** {@public}{@method}
		   * @param args {Array.<*>}
		   * @return {DeltaJs#Proxy}
		   */
				'do': function _do() {
					var _ref;
		
					for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
						args[_key] = arguments[_key];
					}
		
					var ProxyClass = this.constructor.Proxy;
					if (!ProxyClass) {
						throw new Error('Calling \'do\' on delta type \'' + this.type + '\', which has no Proxy interface.');
					}
					return (_ref = new ProxyClass({ delta: this }))['do'].apply(_ref, args);
				}
		
			});
		});
		module.exports = exports['default'];
	
	/***/ },
	/* 24 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		
		var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };
		
		var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };
		
		var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
		
		var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		"use strict";
		
		//  ////////////////////////////////////////////////////////////////////////////////////////////////
		//  // Graph class /////////////////////////////////////////////////////////////////////////////////
		//  ////////////////////////////////////////////////////////////////////////////////////////////////
		
		/**
		 * @public
		 * @class Graph
		 * @classdesc The main class of this library, to be used for representing a mathematical (di)graph.
		 */
		
		var Graph = (function () {
			function Graph() {
				_classCallCheck(this, Graph);
		
				this._vertices = new Map(); // Map.< string, * >
				this._edges = new Map(); // Map.< string, Map.<string, *> >
				this._reverseEdges = new Map(); // Map.< string, Set.<*> >
				this._vertexCount = 0;
				this._edgeCount = 0;
			}
		
			_createClass(Graph, [{
				key: "addNewVertex",
		
				//////////////////////////////
				////////// Vertices //////////
				//////////////////////////////
		
				////////// creating them //////////
		
				/**
		   * Add a new vertex to this graph.
		   * @throws {Graph.VertexExistsError} if a vertex with this key already exists
		   * @param  key    {string} the key with which to refer to this new vertex
		   * @param [value] {*}      the value to store in this new vertex
		   */
				value: function addNewVertex(key, value) {
					if (this.hasVertex(key)) {
						throw new Graph.VertexExistsError(key, this._vertices.get(key));
					}
					this._vertices.set(key, value);
					this._edges.set(key, new Map());
					this._reverseEdges.set(key, new Set());
					this._vertexCount += 1;
				}
			}, {
				key: "setVertex",
		
				/**
		   * Set the value of an existing vertex in this graph.
		   * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist
		   * @param  key    {string} the key belonging to the vertex
		   * @param [value] {*}      the value to store in this vertex
		   */
				value: function setVertex(key, value) {
					if (!this.hasVertex(key)) {
						throw new Graph.VertexNotExistsError(key);
					}
					this._vertices.set(key, value);
				}
			}, {
				key: "ensureVertex",
		
				/**
		   * Make sure a vertex with a specific key exists in this graph. If it already exists, nothing is done.
		   * If it does not yet exist, a new vertex is added with the given value.
		   * @param  key    {string} the key for the vertex
		   * @param [value] {*}      the value to store if a new vertex is added
		   */
				value: function ensureVertex(key, value) {
					if (!this.hasVertex(key)) {
						this.addNewVertex(key, value);
					}
				}
			}, {
				key: "addVertex",
		
				/**
		   * Add a new vertex to this graph. If a vertex with this key already exists,
		   * the value of that vertex is overwritten.
		   * @param  key    {string} the key with which to refer to this new vertex
		   * @param [value] {*}      the value to store in this new vertex
		   */
				value: function addVertex(key, value) {
					if (this.hasVertex(key)) {
						this.setVertex(key, value);
					} else {
						this.addNewVertex(key, value);
					}
				}
			}, {
				key: "removeExistingVertex",
		
				////////// removing them //////////
		
				/**
		   * Remove an existing vertex from this graph.
		   * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist
		   * @throws {Graph.HasConnectedEdgesError} if there are still edges connected to this vertex
		   * @param key {string} the key of the vertex to remove
		   */
				value: function removeExistingVertex(key) {
					if (!this.hasVertex(key)) {
						throw new Graph.VertexNotExistsError(key);
					}
					if (this._edges.get(key).size > 0 || this._reverseEdges.get(key).size > 0) {
						throw new Graph.HasConnectedEdgesError(key);
					}
					this._vertices["delete"](key);
					this._vertexCount -= 1;
				}
			}, {
				key: "destroyExistingVertex",
		
				/**
		   * Remove an existing vertex from this graph, as well as all edges connected to it.
		   * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist
		   * @param key {string} the key of the vertex to remove
		   */
				value: function destroyExistingVertex(key) {
					if (!this.hasVertex(key)) {
						throw new Graph.VertexNotExistsError(key);
					}
					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;
		
					try {
						for (var _iterator = this.verticesFrom(key)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							var _step$value = _slicedToArray(_step.value, 1);
		
							var to = _step$value[0];
		
							this.removeEdge(key, to);
						}
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator["return"]) {
								_iterator["return"]();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}
		
					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;
		
					try {
						for (var _iterator2 = this.verticesTo(key)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							var _step2$value = _slicedToArray(_step2.value, 1);
		
							var from = _step2$value[0];
		
							this.removeEdge(from, key);
						}
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
								_iterator2["return"]();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}
		
					this.removeExistingVertex(key);
				}
			}, {
				key: "removeVertex",
		
				/**
		   * Remove an existing vertex from this graph.
		   * If a vertex with this key does not exist, nothing happens.
		   * @throws {Graph.HasConnectedEdgesError} if there are still edges connected to this vertex
		   * @param key {string} the key of the vertex to remove
		   */
				value: function removeVertex(key) {
					if (this.hasVertex(key)) {
						this.removeExistingVertex(key);
					}
				}
			}, {
				key: "destroyVertex",
		
				/**
		   * Remove a vertex from this graph, as well as all edges connected to it.
		   * If a vertex with this key does not exist, nothing happens.
		   * @param key {string} the key of the vertex to remove
		   */
				value: function destroyVertex(key) {
					if (this.hasVertex(key)) {
						this.destroyExistingVertex(key);
					}
				}
			}, {
				key: "vertexCount",
		
				////////// querying them //////////
		
				/**
		   * @returns {number} the number of vertices in the whole graph
		   */
				value: function vertexCount() {
					return this._vertexCount;
				}
			}, {
				key: "hasVertex",
		
				/**
		   * Ask whether a vertex with a given key exists.
		   * @param key {string} the key to query
		   * @returns {boolean} whether there is a vertex with the given key
		   */
				value: function hasVertex(key) {
					return this._vertices.has(key);
				}
			}, {
				key: "vertexValue",
		
				/**
		   * Get the value associated with the vertex of a given key.
		   * @param key {string} the key to query
		   * @returns {*} the value associated with the vertex of the given key.
		   * Note that a return value of `undefined` can mean
		   *
		   * 1. that there is no such vertex, or
		   * 2. that the stored value is actually `undefined`.
		   *
		   * Use {@link Graph#hasVertex} to distinguish these cases.
		   */
				value: function vertexValue(key) {
					return this._vertices.get(key);
				}
			}, {
				key: "addNewEdge",
		
				///////////////////////////
				////////// Edges //////////
				///////////////////////////
		
				////////// adding them //////////
		
				/**
		   * Add a new edge to this graph.
		   * @throws {Graph.EdgeExistsError} if an edge between `from` and `to` already exists
		   * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph
		   * @param  from   {string} the key for the originating vertex
		   * @param  to     {string} the key for the terminating vertex
		   * @param [value] {*}      the value to store in this new edge
		   */
				value: function addNewEdge(from, to, value) {
					if (this.hasEdge(from, to)) {
						throw new Graph.EdgeExistsError(from, to, this.edgeValue(from, to));
					}
					if (!this.hasVertex(from)) {
						if (this.hasVertex(to)) {
							throw new Graph.VertexNotExistsError(from);
						} else {
							throw new Graph.VertexNotExistsError(from).v(to);
						}
					} else if (!this.hasVertex(to)) {
						throw new Graph.VertexNotExistsError(to);
					}
					this._edges.get(from).set(to, value);
					this._reverseEdges.get(to).add(from);
					this._edgeCount += 1;
				}
			}, {
				key: "createNewEdge",
		
				/**
		   * Add a new edge to this graph. If the `from` and/or `to` vertices do not yet exist
		   * in the graph, they are implicitly added with an `undefined` value.
		   * @throws {Graph.EdgeExistsError} if an edge between `from` and `to` already exists
		   * @param  from   {string} the key for the originating vertex
		   * @param  to     {string} the key for the terminating vertex
		   * @param [value] {*}      the value to store in this new edge
		   */
				value: function createNewEdge(from, to, value) {
					if (this.hasEdge(from, to)) {
						throw new Graph.EdgeExistsError(from, to, this.edgeValue(from, to));
					}
					this.ensureVertex(from);
					this.ensureVertex(to);
					this.addNewEdge(from, to, value);
				}
			}, {
				key: "setEdge",
		
				/**
		   * Set the value of an existing edge in this graph.
		   * @throws {Graph.EdgeNotExistsError} if an edge between `from` and `to` does not yet exist
		   * @param  from   {string} the key for the originating vertex
		   * @param  to     {string} the key for the terminating vertex
		   * @param [value] {*}      the value to store in this edge
		   */
				value: function setEdge(from, to, value) {
					if (!this.hasEdge(from, to)) {
						throw new Graph.EdgeNotExistsError(from, to);
					}
					this._edges.get(from).set(to, value);
				}
			}, {
				key: "spanEdge",
		
				/**
		   * Make sure an edge between the `from` and `to` vertices in this graph.
		   * If one already exists, nothing is done.
		   * If one does not yet exist, a new edge is added with the given value.
		   * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph
		   * @param  from   {string} the key for the originating vertex
		   * @param  to     {string} the key for the terminating vertex
		   * @param [value] {*}      the value to store if a new edge is added
		   */
				value: function spanEdge(from, to, value) {
					if (!this.hasVertex(from)) {
						if (this.hasVertex(to)) {
							throw new Graph.VertexNotExistsError(from);
						} else {
							throw new Graph.VertexNotExistsError(from).v(to);
						}
					} else if (!this.hasVertex(to)) {
						throw new Graph.VertexNotExistsError(to);
					}
					if (!this.hasEdge(from, to)) {
						this.addNewEdge(from, to, value);
					}
				}
			}, {
				key: "addEdge",
		
				/**
		   * Add a new edge to this graph. If an edge between `from` and `to` already exists,
		   * the value of that edge is overwritten.
		   * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph
		   * @param  from   {string} the key for the originating vertex
		   * @param  to     {string} the key for the terminating vertex
		   * @param [value] {*}      the value to store in this new edge
		   */
				value: function addEdge(from, to, value) {
					if (this.hasEdge(from, to)) {
						this.setEdge(from, to, value);
					} else {
						this.addNewEdge(from, to, value);
					}
				}
			}, {
				key: "ensureEdge",
		
				/**
		   * Make sure an edge between the `from` and `to` vertices exists in this graph.
		   * If it already exists, nothing is done.
		   * If it does not yet exist, a new edge is added with the given value.
		   * If the `from` and/or `to` vertices do not yet exist
		   * in the graph, they are implicitly added with an `undefined` value.
		   * @param  from   {string} the key for the originating vertex
		   * @param  to     {string} the key for the terminating vertex
		   * @param [value] {*}      the value to store if a new edge is added
		   */
				value: function ensureEdge(from, to, value) {
					if (!this.hasEdge(from, to)) {
						this.createNewEdge(from, to, value);
					}
				}
			}, {
				key: "createEdge",
		
				/**
		   * Add a new edge to this graph. If an edge between the `from` and `to`
		   * vertices already exists, the value of that edge is overwritten.
		   * If the `from` and/or `to` vertices do not yet exist
		   * in the graph, they are implicitly added with an `undefined` value.
		   * @param  from   {string} the key for the originating vertex
		   * @param  to     {string} the key for the terminating vertex
		   * @param [value] {*}      the value to store if a new edge is added
		   */
				value: function createEdge(from, to, value) {
					if (this.hasEdge(from, to)) {
						this.setEdge(from, to, value);
					} else {
						this.createNewEdge(from, to, value);
					}
				}
			}, {
				key: "removeExistingEdge",
		
				////////// removing them //////////
		
				/**
		   * Remove an existing edge from this graph.
		   * @throws {Graph.EdgeNotExistsError} if an edge between the `from` and `to` vertices doesn't exist
		   * @param from {string} the key for the originating vertex
		   * @param to   {string} the key for the terminating vertex
		   */
				value: function removeExistingEdge(from, to) {
					if (!this.hasEdge(from, to)) {
						throw new Graph.EdgeNotExistsError(from, to);
					}
					this._edges.get(from)["delete"](to);
					this._reverseEdges.get(to)["delete"](from);
					this._edgeCount -= 1;
				}
			}, {
				key: "removeEdge",
		
				/**
		   * Remove an edge from this graph.
		   * If an edge between the `from` and `to` vertices doesn't exist, nothing happens.
		   * @param from {string} the key for the originating vertex
		   * @param to   {string} the key for the terminating vertex
		   */
				value: function removeEdge(from, to) {
					if (this.hasEdge(from, to)) {
						this.removeExistingEdge(from, to);
					}
				}
			}, {
				key: "edgeCount",
		
				////////// querying them //////////
		
				/**
		   * @returns {number} the number of edges in the whole graph
		   */
				value: function edgeCount() {
					return this._edgeCount;
				}
			}, {
				key: "hasEdge",
		
				/**
		   * Ask whether an edge between given `from` and `to` vertices exist.
		   * @param from {string} the key for the originating vertex
		   * @param to   {string} the key for the terminating vertex
		   * @returns {boolean} whether there is an edge between the given `from` and `to` vertices
		   */
				value: function hasEdge(from, to) {
					return this.hasVertex(from) && this.hasVertex(to) && this._edges.has(from) && this._edges.get(from).has(to);
				}
			}, {
				key: "edgeValue",
		
				/**
		   * Get the value associated with the edge between given `from` and `to` vertices.
		   * @param from {string} the key for the originating vertex
		   * @param to   {string} the key for the terminating vertex
		   * @returns {*} the value associated with the edge between the given `from` and `to` vertices
		   * Note that a return value of `undefined` can mean
		   *
		   * 1. that there is no such edge, or
		   * 2. that the stored value is actually `undefined`.
		   *
		   * Use {@link Graph#hasEdge} to distinguish these cases.
		   */
				value: function edgeValue(from, to) {
					return this.hasEdge(from, to) ? this._edges.get(from).get(to) : undefined;
				}
			}, {
				key: "vertices",
		
				///////////////////////////////////////////////
				//////////// ES6 Iterable interfaces //////////
				///////////////////////////////////////////////
		
				/**
		   * Iterate over all vertices of the graph, in no particular order.
		   * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
		   * @example
		   * for (var it = graph.vertices(), keyVal = it.next(); !it.done;) {
		   *     var key   = keyVal[0],
		   *         value = keyVal[1];
		   *     // iterates over all vertices of the graph
		   * }
		   * @example
		   * // in ECMAScript 6, you can use a for..of loop
		   * for (let [key, value] of graph.vertices()) {
		   *     // iterates over all vertices of the graph
		   * }
		   * @see {@link Graph#@@iterator}
		   */
				value: regeneratorRuntime.mark(function vertices() {
					var done, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _step3$value, key, value;
		
					return regeneratorRuntime.wrap(function vertices$(context$2$0) {
						while (1) switch (context$2$0.prev = context$2$0.next) {
							case 0:
								done = new Set();
								_iteratorNormalCompletion3 = true;
								_didIteratorError3 = false;
								_iteratorError3 = undefined;
								context$2$0.prev = 4;
								_iterator3 = this._vertices[Symbol.iterator]();
		
							case 6:
								if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
									context$2$0.next = 17;
									break;
								}
		
								_step3$value = _slicedToArray(_step3.value, 2);
								key = _step3$value[0];
								value = _step3$value[1];
		
								if (!(this.hasVertex(key) && !done.has(key))) {
									context$2$0.next = 14;
									break;
								}
		
								done.add(key);
								context$2$0.next = 14;
								return [key, value];
		
							case 14:
								_iteratorNormalCompletion3 = true;
								context$2$0.next = 6;
								break;
		
							case 17:
								context$2$0.next = 23;
								break;
		
							case 19:
								context$2$0.prev = 19;
								context$2$0.t0 = context$2$0["catch"](4);
								_didIteratorError3 = true;
								_iteratorError3 = context$2$0.t0;
		
							case 23:
								context$2$0.prev = 23;
								context$2$0.prev = 24;
		
								if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
									_iterator3["return"]();
								}
		
							case 26:
								context$2$0.prev = 26;
		
								if (!_didIteratorError3) {
									context$2$0.next = 29;
									break;
								}
		
								throw _iteratorError3;
		
							case 29:
								return context$2$0.finish(26);
		
							case 30:
								return context$2$0.finish(23);
		
							case 31:
							case "end":
								return context$2$0.stop();
						}
					}, vertices, this, [[4, 19, 23, 31], [24,, 26, 30]]);
				})
			}, {
				key: Symbol.iterator,
		
				/**
		   * A {@link Graph} object is itself {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol|iterable},
		   * and serves as a short notation in ECMAScript 6 to iterate over all vertices in the graph, in no particular order.
		   * @method Graph#@@iterator
		   * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
		   * @example
		   * for (let [key, value] of graph) {
		   *     // iterates over all vertices of the graph
		   * }
		   * @see {@link Graph#vertices}
		   */
				value: function () {
					return this.vertices();
				}
			}, {
				key: "edges",
		
				/**
		   * Iterate over all edges of the graph, in no particular order.
		   * @returns { Iterator.<string, string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
		   * @example
		   * for (var it = graph.edges(), fromToVal = it.next(); !it.done;) {
		   *     var from  = fromToVal[0],
		   *         to    = fromToVal[1],
		   *         value = fromToVal[2];
		   *     // iterates over all edges of the graph
		   * }
		   * @example
		   * // in ECMAScript 6, you can use a for..of loop
		   * for (let [from, to, value] of graph.edges()) {
		   *     // iterates over all vertices of the graph
		   * }
		   */
				value: regeneratorRuntime.mark(function edges() {
					var done, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, from, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, to;
		
					return regeneratorRuntime.wrap(function edges$(context$2$0) {
						while (1) switch (context$2$0.prev = context$2$0.next) {
							case 0:
								done = new Map();
								_iteratorNormalCompletion4 = true;
								_didIteratorError4 = false;
								_iteratorError4 = undefined;
								context$2$0.prev = 4;
								_iterator4 = this._edges.keys()[Symbol.iterator]();
		
							case 6:
								if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
									context$2$0.next = 40;
									break;
								}
		
								from = _step4.value;
		
								if (!done.has(from)) {
									done.set(from, new Set());
								}
								_iteratorNormalCompletion5 = true;
								_didIteratorError5 = false;
								_iteratorError5 = undefined;
								context$2$0.prev = 12;
								_iterator5 = this._edges.get(from).keys()[Symbol.iterator]();
		
							case 14:
								if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
									context$2$0.next = 23;
									break;
								}
		
								to = _step5.value;
		
								if (!(this.hasEdge(from, to) && !done.get(from).has(to))) {
									context$2$0.next = 20;
									break;
								}
		
								done.get(from).add(to);
								context$2$0.next = 20;
								return [from, to, this._edges.get(from).get(to)];
		
							case 20:
								_iteratorNormalCompletion5 = true;
								context$2$0.next = 14;
								break;
		
							case 23:
								context$2$0.next = 29;
								break;
		
							case 25:
								context$2$0.prev = 25;
								context$2$0.t1 = context$2$0["catch"](12);
								_didIteratorError5 = true;
								_iteratorError5 = context$2$0.t1;
		
							case 29:
								context$2$0.prev = 29;
								context$2$0.prev = 30;
		
								if (!_iteratorNormalCompletion5 && _iterator5["return"]) {
									_iterator5["return"]();
								}
		
							case 32:
								context$2$0.prev = 32;
		
								if (!_didIteratorError5) {
									context$2$0.next = 35;
									break;
								}
		
								throw _iteratorError5;
		
							case 35:
								return context$2$0.finish(32);
		
							case 36:
								return context$2$0.finish(29);
		
							case 37:
								_iteratorNormalCompletion4 = true;
								context$2$0.next = 6;
								break;
		
							case 40:
								context$2$0.next = 46;
								break;
		
							case 42:
								context$2$0.prev = 42;
								context$2$0.t2 = context$2$0["catch"](4);
								_didIteratorError4 = true;
								_iteratorError4 = context$2$0.t2;
		
							case 46:
								context$2$0.prev = 46;
								context$2$0.prev = 47;
		
								if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
									_iterator4["return"]();
								}
		
							case 49:
								context$2$0.prev = 49;
		
								if (!_didIteratorError4) {
									context$2$0.next = 52;
									break;
								}
		
								throw _iteratorError4;
		
							case 52:
								return context$2$0.finish(49);
		
							case 53:
								return context$2$0.finish(46);
		
							case 54:
							case "end":
								return context$2$0.stop();
						}
					}, edges, this, [[4, 42, 46, 54], [12, 25, 29, 37], [30,, 32, 36], [47,, 49, 53]]);
				})
			}, {
				key: "verticesFrom",
		
				/**
		   * Iterate over the outgoing edges of a given vertex in the graph, in no particular order.
		   * @throws {Graph.VertexNotExistsError} if a vertex with the given `from` key does not exist
		   * @param from {string} the key of the vertex to take the outgoing edges from
		   * @returns { Iterator.<string, *, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
		   * @example
		   * for (var it = graph.verticesFrom(from), toVertexEdge = it.next(); !it.done;) {
		   *     var to          = toVertexEdge[0],
		   *         vertexValue = toVertexEdge[1],
		   *         edgeValue   = toVertexEdge[2];
		   *     // iterates over all outgoing vertices of the `from` vertex
		   * }
		   * @example
		   * // in ECMAScript 6, you can use a for..of loop
		   * for (let [to, vertexValue, edgeValue] of graph.verticesFrom(from)) {
		   *     // iterates over all outgoing edges of the `from` vertex
		   * }
		   */
				value: function verticesFrom(from) {
					if (!this.hasVertex(from)) {
						throw new Graph.VertexNotExistsError(from);
					}
					return this._verticesFrom(from);
				}
			}, {
				key: "_verticesFrom",
				value: regeneratorRuntime.mark(function _verticesFrom(from) {
					var done, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, to;
		
					return regeneratorRuntime.wrap(function _verticesFrom$(context$2$0) {
						while (1) switch (context$2$0.prev = context$2$0.next) {
							case 0:
								done = new Set();
								_iteratorNormalCompletion6 = true;
								_didIteratorError6 = false;
								_iteratorError6 = undefined;
								context$2$0.prev = 4;
								_iterator6 = this._edges.get(from).keys()[Symbol.iterator]();
		
							case 6:
								if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
									context$2$0.next = 15;
									break;
								}
		
								to = _step6.value;
		
								if (!(this.hasEdge(from, to) && !done.has(to))) {
									context$2$0.next = 12;
									break;
								}
		
								done.add(to);
								context$2$0.next = 12;
								return [to, this._vertices.get(to), this._edges.get(from).get(to)];
		
							case 12:
								_iteratorNormalCompletion6 = true;
								context$2$0.next = 6;
								break;
		
							case 15:
								context$2$0.next = 21;
								break;
		
							case 17:
								context$2$0.prev = 17;
								context$2$0.t3 = context$2$0["catch"](4);
								_didIteratorError6 = true;
								_iteratorError6 = context$2$0.t3;
		
							case 21:
								context$2$0.prev = 21;
								context$2$0.prev = 22;
		
								if (!_iteratorNormalCompletion6 && _iterator6["return"]) {
									_iterator6["return"]();
								}
		
							case 24:
								context$2$0.prev = 24;
		
								if (!_didIteratorError6) {
									context$2$0.next = 27;
									break;
								}
		
								throw _iteratorError6;
		
							case 27:
								return context$2$0.finish(24);
		
							case 28:
								return context$2$0.finish(21);
		
							case 29:
							case "end":
								return context$2$0.stop();
						}
					}, _verticesFrom, this, [[4, 17, 21, 29], [22,, 24, 28]]);
				})
			}, {
				key: "verticesTo",
		
				/**
		   * Iterate over the incoming edges of a given vertex in the graph, in no particular order.
		   * @throws {Graph.VertexNotExistsError} if a vertex with the given `to` key does not exist
		   * @param to {string} the key of the vertex to take the incoming edges from
		   * @returns { Iterator.<string, *, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
		   * @example
		   * for (var it = graph.verticesTo(to), fromVertexEdge = it.next(); !it.done;) {
		   *     var from        = fromVertexEdge[0],
		   *         vertexValue = fromVertexEdge[1],
		   *         edgeValue   = fromVertexEdge[2];
		   *     // iterates over all outgoing vertices of the `from` vertex
		   * }
		   * @example
		   * // in ECMAScript 6, you can use a for..of loop
		   * for (let [from, vertexValue, edgeValue] of graph.verticesTo(to)) {
		   *     // iterates over all incoming edges of the `to` vertex
		   * }
		   */
				value: function verticesTo(to) {
					if (!this.hasVertex(to)) {
						throw new Graph.VertexNotExistsError(to);
					}
					return this._verticesTo(to);
				}
			}, {
				key: "_verticesTo",
				value: regeneratorRuntime.mark(function _verticesTo(to) {
					var done, _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, from;
		
					return regeneratorRuntime.wrap(function _verticesTo$(context$2$0) {
						while (1) switch (context$2$0.prev = context$2$0.next) {
							case 0:
								done = new Set();
								_iteratorNormalCompletion7 = true;
								_didIteratorError7 = false;
								_iteratorError7 = undefined;
								context$2$0.prev = 4;
								_iterator7 = this._reverseEdges.get(to)[Symbol.iterator]();
		
							case 6:
								if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {
									context$2$0.next = 15;
									break;
								}
		
								from = _step7.value;
		
								if (!(this.hasEdge(from, to) && !done.has(from))) {
									context$2$0.next = 12;
									break;
								}
		
								done.add(from);
								context$2$0.next = 12;
								return [from, this._vertices.get(from), this._edges.get(from).get(to)];
		
							case 12:
								_iteratorNormalCompletion7 = true;
								context$2$0.next = 6;
								break;
		
							case 15:
								context$2$0.next = 21;
								break;
		
							case 17:
								context$2$0.prev = 17;
								context$2$0.t4 = context$2$0["catch"](4);
								_didIteratorError7 = true;
								_iteratorError7 = context$2$0.t4;
		
							case 21:
								context$2$0.prev = 21;
								context$2$0.prev = 22;
		
								if (!_iteratorNormalCompletion7 && _iterator7["return"]) {
									_iterator7["return"]();
								}
		
							case 24:
								context$2$0.prev = 24;
		
								if (!_didIteratorError7) {
									context$2$0.next = 27;
									break;
								}
		
								throw _iteratorError7;
		
							case 27:
								return context$2$0.finish(24);
		
							case 28:
								return context$2$0.finish(21);
		
							case 29:
							case "end":
								return context$2$0.stop();
						}
					}, _verticesTo, this, [[4, 17, 21, 29], [22,, 24, 28]]);
				})
			}, {
				key: "verticesWithPathFrom",
		
				/**
		   * Iterate over all vertices reachable from a given vertex in the graph, in no particular order.
		   * @throws {Graph.VertexNotExistsError} if a vertex with the given `from` key does not exist
		   * @param from {string} the key of the vertex to take the reachable vertices from
		   * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
		   * @example
		   * for (var it = graph.verticesWithPathFrom(from), keyValue = it.next(); !it.done;) {
		   *     var key   = keyValue[0],
		   *         value = keyValue[1];
		   *     // iterates over all vertices reachable from `from`
		   * }
		   * @example
		   * // in ECMAScript 6, you can use a for..of loop
		   * for (let [key, value] of graph.verticesWithPathFrom(from)) {
		   *     // iterates over all vertices reachable from `from`
		   * }
		   */
				value: function verticesWithPathFrom(from) {
					if (!this.hasVertex(from)) {
						throw new Graph.VertexNotExistsError(from);
					}
					return this._verticesWithPathFrom(from, new Set());
				}
			}, {
				key: "_verticesWithPathFrom",
				value: regeneratorRuntime.mark(function _verticesWithPathFrom(from, done) {
					var _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, to;
		
					return regeneratorRuntime.wrap(function _verticesWithPathFrom$(context$2$0) {
						while (1) switch (context$2$0.prev = context$2$0.next) {
							case 0:
								_iteratorNormalCompletion8 = true;
								_didIteratorError8 = false;
								_iteratorError8 = undefined;
								context$2$0.prev = 3;
								_iterator8 = this._edges.get(from).keys()[Symbol.iterator]();
		
							case 5:
								if (_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done) {
									context$2$0.next = 15;
									break;
								}
		
								to = _step8.value;
		
								if (!(this.hasEdge(from, to) && !done.has(to))) {
									context$2$0.next = 12;
									break;
								}
		
								done.add(to);
								context$2$0.next = 11;
								return [to, this._vertices.get(to)];
		
							case 11:
								return context$2$0.delegateYield(this._verticesWithPathFrom(to, done), "t5", 12);
		
							case 12:
								_iteratorNormalCompletion8 = true;
								context$2$0.next = 5;
								break;
		
							case 15:
								context$2$0.next = 21;
								break;
		
							case 17:
								context$2$0.prev = 17;
								context$2$0.t6 = context$2$0["catch"](3);
								_didIteratorError8 = true;
								_iteratorError8 = context$2$0.t6;
		
							case 21:
								context$2$0.prev = 21;
								context$2$0.prev = 22;
		
								if (!_iteratorNormalCompletion8 && _iterator8["return"]) {
									_iterator8["return"]();
								}
		
							case 24:
								context$2$0.prev = 24;
		
								if (!_didIteratorError8) {
									context$2$0.next = 27;
									break;
								}
		
								throw _iteratorError8;
		
							case 27:
								return context$2$0.finish(24);
		
							case 28:
								return context$2$0.finish(21);
		
							case 29:
							case "end":
								return context$2$0.stop();
						}
					}, _verticesWithPathFrom, this, [[3, 17, 21, 29], [22,, 24, 28]]);
				})
			}, {
				key: "verticesWithPathTo",
		
				/**
		   * Iterate over all vertices from which a given vertex in the graph can be reached, in no particular order.
		   * @throws {Graph.VertexNotExistsError} if a vertex with the given `to` key does not exist
		   * @param to {string} the key of the vertex to take the reachable vertices from
		   * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
		   * @example
		   * for (var it = graph.verticesWithPathTo(to), keyValue = it.next(); !it.done;) {
		   *     var key   = keyValue[0],
		   *         value = keyValue[1];
		   *     // iterates over all vertices from which `to` can be reached
		   * }
		   * @example
		   * // in ECMAScript 6, you can use a for..of loop
		   * for (let [key, value] of graph.verticesWithPathTo(to)) {
		   *     // iterates over all vertices from which `to` can be reached
		   * }
		   */
				value: function verticesWithPathTo(to) {
					if (!this.hasVertex(to)) {
						throw new Graph.VertexNotExistsError(to);
					}
					return this._verticesWithPathTo(to, new Set());
				}
			}, {
				key: "_verticesWithPathTo",
				value: regeneratorRuntime.mark(function _verticesWithPathTo(to, done) {
					var _iteratorNormalCompletion9, _didIteratorError9, _iteratorError9, _iterator9, _step9, from;
		
					return regeneratorRuntime.wrap(function _verticesWithPathTo$(context$2$0) {
						while (1) switch (context$2$0.prev = context$2$0.next) {
							case 0:
								_iteratorNormalCompletion9 = true;
								_didIteratorError9 = false;
								_iteratorError9 = undefined;
								context$2$0.prev = 3;
								_iterator9 = this._reverseEdges.get(to)[Symbol.iterator]();
		
							case 5:
								if (_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done) {
									context$2$0.next = 15;
									break;
								}
		
								from = _step9.value;
		
								if (!(this.hasEdge(from, to) && !done.has(from))) {
									context$2$0.next = 12;
									break;
								}
		
								done.add(from);
								context$2$0.next = 11;
								return [from, this._vertices.get(from)];
		
							case 11:
								return context$2$0.delegateYield(this._verticesWithPathTo(from, done), "t7", 12);
		
							case 12:
								_iteratorNormalCompletion9 = true;
								context$2$0.next = 5;
								break;
		
							case 15:
								context$2$0.next = 21;
								break;
		
							case 17:
								context$2$0.prev = 17;
								context$2$0.t8 = context$2$0["catch"](3);
								_didIteratorError9 = true;
								_iteratorError9 = context$2$0.t8;
		
							case 21:
								context$2$0.prev = 21;
								context$2$0.prev = 22;
		
								if (!_iteratorNormalCompletion9 && _iterator9["return"]) {
									_iterator9["return"]();
								}
		
							case 24:
								context$2$0.prev = 24;
		
								if (!_didIteratorError9) {
									context$2$0.next = 27;
									break;
								}
		
								throw _iteratorError9;
		
							case 27:
								return context$2$0.finish(24);
		
							case 28:
								return context$2$0.finish(21);
		
							case 29:
							case "end":
								return context$2$0.stop();
						}
					}, _verticesWithPathTo, this, [[3, 17, 21, 29], [22,, 24, 28]]);
				})
			}, {
				key: "vertices_topologically",
		
				/**
		   * Iterate over all vertices of the graph in topological order.
		   * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}
		   * @example
		   * for (var it = graph.vertices_topologically(), keyVal = it.next(); !it.done;) {
		   *     var key   = keyVal[0],
		   *         value = keyVal[1];
		   *     // iterates over all vertices of the graph in topological order
		   * }
		   * @example
		   * // in ECMAScript 6, you can use a for..of loop
		   * for (let [key, value] of graph.vertices_topologically()) {
		   *     // iterates over all vertices of the graph in topological order
		   * }
		   */
				value: regeneratorRuntime.mark(function vertices_topologically() {
					var marked2$0, visited, handled, _this, visit, _iteratorNormalCompletion11, _didIteratorError11, _iteratorError11, _iterator11, _step11, _step11$value, a;
		
					return regeneratorRuntime.wrap(function vertices_topologically$(context$2$0) {
						while (1) switch (context$2$0.prev = context$2$0.next) {
							case 0:
								visit = function visit(a) {
									var i, cycle, _iteratorNormalCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step10, _step10$value, b;
		
									return regeneratorRuntime.wrap(function visit$(context$3$0) {
										while (1) switch (context$3$0.prev = context$3$0.next) {
											case 0:
												visited.push(a);
												i = visited.indexOf(a);
		
												if (!(i !== visited.length - 1)) {
													context$3$0.next = 5;
													break;
												}
		
												cycle = visited.slice(i + 1).reverse();
												throw new Graph.CycleError(cycle);
		
											case 5:
												if (handled.has(a)) {
													context$3$0.next = 36;
													break;
												}
		
												_iteratorNormalCompletion10 = true;
												_didIteratorError10 = false;
												_iteratorError10 = undefined;
												context$3$0.prev = 9;
												_iterator10 = _this.verticesTo(a)[Symbol.iterator]();
		
											case 11:
												if (_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done) {
													context$3$0.next = 18;
													break;
												}
		
												_step10$value = _slicedToArray(_step10.value, 1);
												b = _step10$value[0];
												return context$3$0.delegateYield(visit(b), "t9", 15);
		
											case 15:
												_iteratorNormalCompletion10 = true;
												context$3$0.next = 11;
												break;
		
											case 18:
												context$3$0.next = 24;
												break;
		
											case 20:
												context$3$0.prev = 20;
												context$3$0.t10 = context$3$0["catch"](9);
												_didIteratorError10 = true;
												_iteratorError10 = context$3$0.t10;
		
											case 24:
												context$3$0.prev = 24;
												context$3$0.prev = 25;
		
												if (!_iteratorNormalCompletion10 && _iterator10["return"]) {
													_iterator10["return"]();
												}
		
											case 27:
												context$3$0.prev = 27;
		
												if (!_didIteratorError10) {
													context$3$0.next = 30;
													break;
												}
		
												throw _iteratorError10;
		
											case 30:
												return context$3$0.finish(27);
		
											case 31:
												return context$3$0.finish(24);
		
											case 32:
												if (!_this.hasVertex(a)) {
													context$3$0.next = 35;
													break;
												}
		
												context$3$0.next = 35;
												return [a, _this._vertices.get(a)];
		
											case 35:
												handled.add(a);
		
											case 36:
												visited.pop();
		
											case 37:
											case "end":
												return context$3$0.stop();
										}
									}, marked2$0[0], this, [[9, 20, 24, 32], [25,, 27, 31]]);
								};
		
								marked2$0 = [visit].map(regeneratorRuntime.mark);
								visited = [];
								handled = new Set();
								_this = this;
								_iteratorNormalCompletion11 = true;
								_didIteratorError11 = false;
								_iteratorError11 = undefined;
								context$2$0.prev = 8;
								_iterator11 = this.vertices()[Symbol.iterator]();
		
							case 10:
								if (_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done) {
									context$2$0.next = 18;
									break;
								}
		
								_step11$value = _slicedToArray(_step11.value, 1);
								a = _step11$value[0];
		
								if (handled.has(a)) {
									context$2$0.next = 15;
									break;
								}
		
								return context$2$0.delegateYield(visit(a), "t11", 15);
		
							case 15:
								_iteratorNormalCompletion11 = true;
								context$2$0.next = 10;
								break;
		
							case 18:
								context$2$0.next = 24;
								break;
		
							case 20:
								context$2$0.prev = 20;
								context$2$0.t12 = context$2$0["catch"](8);
								_didIteratorError11 = true;
								_iteratorError11 = context$2$0.t12;
		
							case 24:
								context$2$0.prev = 24;
								context$2$0.prev = 25;
		
								if (!_iteratorNormalCompletion11 && _iterator11["return"]) {
									_iterator11["return"]();
								}
		
							case 27:
								context$2$0.prev = 27;
		
								if (!_didIteratorError11) {
									context$2$0.next = 30;
									break;
								}
		
								throw _iteratorError11;
		
							case 30:
								return context$2$0.finish(27);
		
							case 31:
								return context$2$0.finish(24);
		
							case 32:
							case "end":
								return context$2$0.stop();
						}
					}, vertices_topologically, this, [[8, 20, 24, 32], [25,, 27, 31]]);
				})
			}, {
				key: "clearEdges",
		
				//////////////////////////////
				////////// Clearing //////////
				//////////////////////////////
		
				/**
		   * Remove all edges from the graph, but leave the vertices intact.
		   */
				value: function clearEdges() {
					var _iteratorNormalCompletion12 = true;
					var _didIteratorError12 = false;
					var _iteratorError12 = undefined;
		
					try {
						for (var _iterator12 = this.edges()[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
							var _step12$value = _slicedToArray(_step12.value, 2);
		
							var from = _step12$value[0];
							var to = _step12$value[1];
							this.removeEdge(from, to);
						}
					} catch (err) {
						_didIteratorError12 = true;
						_iteratorError12 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion12 && _iterator12["return"]) {
								_iterator12["return"]();
							}
						} finally {
							if (_didIteratorError12) {
								throw _iteratorError12;
							}
						}
					}
				}
			}, {
				key: "clear",
		
				/**
		   * Remove all edges and vertices from the graph, putting it back in its initial state.
		   */
				value: function clear() {
					var _iteratorNormalCompletion13 = true;
					var _didIteratorError13 = false;
					var _iteratorError13 = undefined;
		
					try {
						for (var _iterator13 = this.vertices()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
							var _step13$value = _slicedToArray(_step13.value, 1);
		
							var v = _step13$value[0];
							this.destroyVertex(v);
						}
					} catch (err) {
						_didIteratorError13 = true;
						_iteratorError13 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion13 && _iterator13["return"]) {
								_iterator13["return"]();
							}
						} finally {
							if (_didIteratorError13) {
								throw _iteratorError13;
							}
						}
					}
				}
			}, {
				key: "equals",
		
				////////////////////////////////////////
				////////// (Advanced) Queries //////////
				////////////////////////////////////////
		
				/**
		   * Ask whether this graph and another graph are equal.
		   * Two graphs are equal if they have the same vertices and the same edges.
		   * @param other {Graph} the other graph to compare this one to
		   * @param [eq] {function(*, *, string, ?string): boolean}
		   *     a custom equality function for stored values; defaults to `===`
		   *     comparison; The first two arguments are the two values to compare.
		   *     If they are vertex values, the third argument is the vertex key.
		   *     If they are edge values, the third and fourth argument are the
		   *     `from` and `to` keys respectively. (So you can test the fourth
		   *     argument to distinguish the two cases.)
		   * @returns {boolean} `true` if the two graphs are equal; `false` otherwise
		   */
				value: function equals() {
					var other = arguments[0] === undefined ? undefined : arguments[0];
					var eq = arguments[1] === undefined ? function (x, y, from, to) {
						return x === y;
					} : arguments[1];
		
					if (!(other instanceof Graph)) {
						return false;
					}
					if (this.vertexCount() !== other.vertexCount()) {
						return false;
					}
					if (this.edgeCount() !== other.edgeCount()) {
						return false;
					}
					var _iteratorNormalCompletion14 = true;
					var _didIteratorError14 = false;
					var _iteratorError14 = undefined;
		
					try {
						for (var _iterator14 = this.vertices()[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
							var _step14$value = _slicedToArray(_step14.value, 2);
		
							var key = _step14$value[0];
							var value = _step14$value[1];
		
							if (!other.hasVertex(key)) {
								return false;
							}
							if (!eq(value, other.vertexValue(key), key)) {
								return false;
							}
						}
					} catch (err) {
						_didIteratorError14 = true;
						_iteratorError14 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion14 && _iterator14["return"]) {
								_iterator14["return"]();
							}
						} finally {
							if (_didIteratorError14) {
								throw _iteratorError14;
							}
						}
					}
		
					var _iteratorNormalCompletion15 = true;
					var _didIteratorError15 = false;
					var _iteratorError15 = undefined;
		
					try {
						for (var _iterator15 = this.edges()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
							var _step15$value = _slicedToArray(_step15.value, 3);
		
							var from = _step15$value[0];
							var to = _step15$value[1];
							var value = _step15$value[2];
		
							if (!other.hasEdge(from, to)) {
								return false;
							}
							if (!eq(value, other.edgeValue(from, to), from, to)) {
								return false;
							}
						}
					} catch (err) {
						_didIteratorError15 = true;
						_iteratorError15 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion15 && _iterator15["return"]) {
								_iterator15["return"]();
							}
						} finally {
							if (_didIteratorError15) {
								throw _iteratorError15;
							}
						}
					}
		
					return true;
				}
			}, {
				key: "cycle",
		
				/**
		   * Find any directed cycle in this graph.
		   * @returns {?array} an array with the keys of a cycle in order;
		   *                   `null`, if there is no cycle
		   */
				value: function cycle() {
					var _this7 = this;
		
					var visited = []; // stack
					var handled = new Set();
		
					var visit = (function (_visit) {
						function visit(_x) {
							return _visit.apply(this, arguments);
						}
		
						visit.toString = function () {
							return _visit.toString();
						};
		
						return visit;
					})(function (a) {
						/* if a cycle is found, record it and return */
						var i = visited.indexOf(a);
						if (i >= 0) {
							return visited.slice(i);
						}
		
						/* if this vertex was already handled, no cycle can be found here */
						if (handled.has(a)) {
							return null;
						}
						handled.add(a);
		
						/* recursively visit successors to check for cycles */
						visited.push(a);
						var _iteratorNormalCompletion16 = true;
						var _didIteratorError16 = false;
						var _iteratorError16 = undefined;
		
						try {
							for (var _iterator16 = _this7.verticesFrom(a)[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
								var _step16$value = _slicedToArray(_step16.value, 1);
		
								var b = _step16$value[0];
		
								var result = visit(b);
								if (result) {
									return result;
								}
							}
						} catch (err) {
							_didIteratorError16 = true;
							_iteratorError16 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion16 && _iterator16["return"]) {
									_iterator16["return"]();
								}
							} finally {
								if (_didIteratorError16) {
									throw _iteratorError16;
								}
							}
						}
		
						visited.pop();
					});
		
					var _iteratorNormalCompletion17 = true;
					var _didIteratorError17 = false;
					var _iteratorError17 = undefined;
		
					try {
						for (var _iterator17 = this.vertices()[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
							var _step17$value = _slicedToArray(_step17.value, 1);
		
							var a = _step17$value[0];
		
							var result = visit(a);
							if (result) {
								return result;
							}
						}
					} catch (err) {
						_didIteratorError17 = true;
						_iteratorError17 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion17 && _iterator17["return"]) {
								_iterator17["return"]();
							}
						} finally {
							if (_didIteratorError17) {
								throw _iteratorError17;
							}
						}
					}
		
					return null;
				}
			}, {
				key: "hasCycle",
		
				/**
		   * Test whether this graph contains a directed cycle.
		   * @returns {boolean} whether this graph contains a directed cycle
		   */
				value: function hasCycle() {
					return !!this.cycle();
				}
			}, {
				key: "path",
		
				/**
		   * Find any path between a given pair of keys.
		   * @param from {string} the originating vertex
		   * @param to   {string} the terminating vertex
		   * @returns {?array} an array with the keys of the path found between the two vertices,
		   *                   including those two vertices themselves; `null` if no such path exists
		   */
				value: function path(from, to) {
					var _this8 = this;
		
					if (!this.hasVertex(from) || !this.hasVertex(to)) {
						return null;
					}
		
					var visited = [];
		
					/* recursive auxiliary function: find a path from 'current' to 'to' */
					var hasPathAux = (function (_hasPathAux) {
						function hasPathAux(_x2) {
							return _hasPathAux.apply(this, arguments);
						}
		
						hasPathAux.toString = function () {
							return _hasPathAux.toString();
						};
		
						return hasPathAux;
					})(function (current) {
						visited.push(current);
						if (_this8.hasEdge(current, to)) {
							return [].concat(visited, [to]);
						}
						var _iteratorNormalCompletion18 = true;
						var _didIteratorError18 = false;
						var _iteratorError18 = undefined;
		
						try {
							for (var _iterator18 = _this8.verticesFrom(current)[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
								var _step18$value = _slicedToArray(_step18.value, 1);
		
								var next = _step18$value[0];
		
								if (visited.indexOf(next) === -1) {
									var result = hasPathAux(next);
									if (result) {
										return result;
									}
								}
							}
						} catch (err) {
							_didIteratorError18 = true;
							_iteratorError18 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion18 && _iterator18["return"]) {
									_iterator18["return"]();
								}
							} finally {
								if (_didIteratorError18) {
									throw _iteratorError18;
								}
							}
						}
		
						visited.pop();
						return null;
					});
		
					return hasPathAux(from);
				}
			}, {
				key: "hasPath",
		
				/**
		   * Test whether there is a directed path between a given pair of keys.
		   * @param from {string} the originating vertex
		   * @param to   {string} the terminating vertex
		   * @returns {boolean} whether such a path exists
		   */
				value: function hasPath(from, to) {
					return !!this.path(from, to);
				}
			}, {
				key: "clone",
		
				/////////////////////////////
				////////// Cloning //////////
				/////////////////////////////
		
				/**
		   * Create a clone of this graph.
		   * @param [tr] {function(*, string, ?string): *}
		   *     a custom transformation function for stored values; defaults to
		   *     the identity function; The first argument is the value to clone.
		   *     If it is a vertex value, the third argument is the vertex key.
		   *     If it is an edge value, the third and fourth argument are the
		   *     `from` and `to` keys respectively. (So you can test the fourth
		   *     argument to distinguish the two cases.)
		   * @returns {Graph} a clone of this graph
		   */
				value: function clone() {
					var tr = arguments[0] === undefined ? function (v) {
						return v;
					} : arguments[0];
		
					var result = new Graph();
					var _iteratorNormalCompletion19 = true;
					var _didIteratorError19 = false;
					var _iteratorError19 = undefined;
		
					try {
						for (var _iterator19 = this.vertices()[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
							var _step19$value = _slicedToArray(_step19.value, 2);
		
							var key = _step19$value[0];
							var val = _step19$value[1];
		
							result.addVertex(key, tr(val, key));
						}
					} catch (err) {
						_didIteratorError19 = true;
						_iteratorError19 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion19 && _iterator19["return"]) {
								_iterator19["return"]();
							}
						} finally {
							if (_didIteratorError19) {
								throw _iteratorError19;
							}
						}
					}
		
					var _iteratorNormalCompletion20 = true;
					var _didIteratorError20 = false;
					var _iteratorError20 = undefined;
		
					try {
						for (var _iterator20 = this.edges()[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
							var _step20$value = _slicedToArray(_step20.value, 3);
		
							var from = _step20$value[0];
							var to = _step20$value[1];
							var val = _step20$value[2];
		
							result.addEdge(from, to, tr(val, from, to));
						}
					} catch (err) {
						_didIteratorError20 = true;
						_iteratorError20 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion20 && _iterator20["return"]) {
								_iterator20["return"]();
							}
						} finally {
							if (_didIteratorError20) {
								throw _iteratorError20;
							}
						}
					}
		
					return result;
				}
			}, {
				key: "transitiveReduction",
		
				/**
		   * Create a clone of this graph, but without any transitive edges.
		   * @param [tr] {function(*, string, ?string): *}
		   *     a custom transformation function for stored values; defaults to
		   *     the identity function; The first argument is the value to clone.
		   *     If it is a vertex value, the third argument is the vertex key.
		   *     If it is an edge value, the third and fourth argument are the
		   *     `from` and `to` keys respectively. (So you can test the fourth
		   *     argument to distinguish the two cases.)
		   * @returns {Graph} a clone of this graph
		   */
				value: function transitiveReduction() {
					var tr = arguments[0] === undefined ? function (v) {
						return v;
					} : arguments[0];
		
					var result = this.clone(tr);
					var _iteratorNormalCompletion21 = true;
					var _didIteratorError21 = false;
					var _iteratorError21 = undefined;
		
					try {
						for (var _iterator21 = this.vertices()[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
							var _step21$value = _slicedToArray(_step21.value, 1);
		
							var x = _step21$value[0];
							var _iteratorNormalCompletion22 = true;
							var _didIteratorError22 = false;
							var _iteratorError22 = undefined;
		
							try {
								for (var _iterator22 = this.vertices()[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
									var _step22$value = _slicedToArray(_step22.value, 1);
		
									var y = _step22$value[0];
		
									if (result.hasEdge(x, y)) {
										var _iteratorNormalCompletion23 = true;
										var _didIteratorError23 = false;
										var _iteratorError23 = undefined;
		
										try {
											for (var _iterator23 = this.vertices()[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
												var _step23$value = _slicedToArray(_step23.value, 1);
		
												var z = _step23$value[0];
		
												if (result.hasPath(y, z)) {
													result.removeEdge(x, z);
												}
											}
										} catch (err) {
											_didIteratorError23 = true;
											_iteratorError23 = err;
										} finally {
											try {
												if (!_iteratorNormalCompletion23 && _iterator23["return"]) {
													_iterator23["return"]();
												}
											} finally {
												if (_didIteratorError23) {
													throw _iteratorError23;
												}
											}
										}
									}
								}
							} catch (err) {
								_didIteratorError22 = true;
								_iteratorError22 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion22 && _iterator22["return"]) {
										_iterator22["return"]();
									}
								} finally {
									if (_didIteratorError22) {
										throw _iteratorError22;
									}
								}
							}
						}
					} catch (err) {
						_didIteratorError21 = true;
						_iteratorError21 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion21 && _iterator21["return"]) {
								_iterator21["return"]();
							}
						} finally {
							if (_didIteratorError21) {
								throw _iteratorError21;
							}
						}
					}
		
					return result;
				}
			}]);
		
			return Graph;
		})();
		
		exports["default"] = Graph;
		
		//  ////////////////////////////////////////////////////////////////////////////////////////////////
		//  // Errors //////////////////////////////////////////////////////////////////////////////////////
		//  ////////////////////////////////////////////////////////////////////////////////////////////////
		
		/**
		 * @class
		 * @classdesc This type of error is thrown when specific vertices are expected not to exist, but do.
		 * @extends Error
		 */
		Graph.VertexExistsError = (function (_Error) {
			function VertexExistsError(key, value) {
				_classCallCheck(this, VertexExistsError);
		
				var _this = new _Error();
		
				_this.__proto__ = VertexExistsError.prototype;
		
				/**
		   * the set of relevant vertices
		   * @public
		   * @constant vertices
		   * @memberof Graph.VertexExistsError
		   * @instance
		   * @type {Set.<{ key: string, value }>}
		   */
				_this.vertices = new Set();
				_this.v(key, value);
				return _this;
			}
		
			_inherits(VertexExistsError, _Error);
		
			_createClass(VertexExistsError, [{
				key: "v",
				value: function v(key, value) {
					this.vertices.add({ key: key, value: value });
					this._refreshMessage();
					return this;
				}
			}, {
				key: "_refreshMessage",
				value: function _refreshMessage() {
					var aVertices = this.vertices.size === 1 ? "a vertex" : "vertices";
					this.message = "This graph has " + aVertices + " '" + [].concat(_toConsumableArray(this.vertices)).map(function (v) {
						return v.key;
					}).join("', '") + "'";
				}
			}]);
		
			return VertexExistsError;
		})(Error);
		
		/**
		 * @class
		 * @classdesc This type of error is thrown when specific vertices are expected to exist, but don't.
		 * @extends Error
		 */
		Graph.VertexNotExistsError = (function (_Error2) {
			function VertexNotExistError(key) {
				_classCallCheck(this, VertexNotExistError);
		
				var _this2 = new _Error2();
		
				_this2.__proto__ = VertexNotExistError.prototype;
		
				/**
		   * the set of relevant vertices
		   * @public
		   * @constant vertices
		   * @memberof Graph.VertexNotExistsError
		   * @instance
		   * @type {Set.<{ key: string }>}
		   */
				_this2.vertices = new Set();
				_this2.v(key);
				return _this2;
			}
		
			_inherits(VertexNotExistError, _Error2);
		
			_createClass(VertexNotExistError, [{
				key: "v",
				value: function v(key) {
					this.vertices.add({ key: key });
					this._refreshMessage();
					return this;
				}
			}, {
				key: "_refreshMessage",
				value: function _refreshMessage() {
					var aVertices = this.vertices.size === 1 ? "a vertex" : "vertices";
					this.message = "This graph does not have " + aVertices + " '" + [].concat(_toConsumableArray(this.vertices)).map(function (v) {
						return v.key;
					}).join("', '") + "'";
				}
			}]);
		
			return VertexNotExistError;
		})(Error);
		
		/**
		 * @class
		 * @classdesc This type of error is thrown when specific edges are expected not to exist, but do.
		 * @extends Error
		 */
		Graph.EdgeExistsError = (function (_Error3) {
			function EdgeExistsError(from, to, value) {
				_classCallCheck(this, EdgeExistsError);
		
				var _this3 = new _Error3();
		
				_this3.__proto__ = EdgeExistsError.prototype;
		
				/**
		   * the set of relevant edges
		   * @public
		   * @constant edges
		   * @memberof Graph.EdgeExistsError
		   * @instance
		   * @type {Set.<{ from: string, to: string, value }>}
		   */
				_this3.edges = new Set();
				_this3.e(from, to, value);
				return _this3;
			}
		
			_inherits(EdgeExistsError, _Error3);
		
			_createClass(EdgeExistsError, [{
				key: "e",
				value: function e(from, to, value) {
					this.edges.add({ from: from, to: to, value: value });
					this._refreshMessage();
					return this;
				}
			}, {
				key: "_refreshMessage",
				value: function _refreshMessage() {
					var edges = [];
					var _iteratorNormalCompletion24 = true;
					var _didIteratorError24 = false;
					var _iteratorError24 = undefined;
		
					try {
						for (var _iterator24 = this.edges[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
							var _step24$value = _step24.value;
							var from = _step24$value.from;
							var to = _step24$value.to;
		
							edges.push("('" + from + "', '" + to + "')");
						}
					} catch (err) {
						_didIteratorError24 = true;
						_iteratorError24 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion24 && _iterator24["return"]) {
								_iterator24["return"]();
							}
						} finally {
							if (_didIteratorError24) {
								throw _iteratorError24;
							}
						}
					}
		
					var anEdges = edges.length === 1 ? "an edge" : "edges";
					this.message = "This graph has " + anEdges + " " + edges.join(", ");
				}
			}]);
		
			return EdgeExistsError;
		})(Error);
		
		/**
		 * @class
		 * @classdesc This type of error is thrown when specific edges are expected to exist, but don't.
		 * @extends Error
		 */
		Graph.EdgeNotExistsError = (function (_Error4) {
			function EdgeNotExistsError(from, to) {
				_classCallCheck(this, EdgeNotExistsError);
		
				var _this4 = new _Error4();
		
				_this4.__proto__ = EdgeNotExistsError.prototype;
		
				/**
		   * the set of relevant edges
		   * @public
		   * @constant edges
		   * @memberof Graph.EdgeNotExistsError
		   * @instance
		   * @type {Set.<{ from: string, to: string }>}
		   */
				_this4.edges = new Set();
				_this4.e(from, to);
				return _this4;
			}
		
			_inherits(EdgeNotExistsError, _Error4);
		
			_createClass(EdgeNotExistsError, [{
				key: "e",
				value: function e(from, to) {
					this.edges.add({ from: from, to: to });
					this._refreshMessage();
					return this;
				}
			}, {
				key: "_refreshMessage",
				value: function _refreshMessage() {
					var edges = [];
					var _iteratorNormalCompletion25 = true;
					var _didIteratorError25 = false;
					var _iteratorError25 = undefined;
		
					try {
						for (var _iterator25 = this.edges[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
							var _step25$value = _step25.value;
							var from = _step25$value.from;
							var to = _step25$value.to;
		
							edges.push("('" + from + "', '" + to + "')");
						}
					} catch (err) {
						_didIteratorError25 = true;
						_iteratorError25 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion25 && _iterator25["return"]) {
								_iterator25["return"]();
							}
						} finally {
							if (_didIteratorError25) {
								throw _iteratorError25;
							}
						}
					}
		
					var anEdges = edges.length === 1 ? "an edge" : "edges";
					this.message = "This graph does not have " + anEdges + " " + edges.join(", ");
				}
			}]);
		
			return EdgeNotExistsError;
		})(Error);
		
		/**
		 * @class
		 * @classdesc This type of error is thrown when a vertex is expected not to have connected edges, but does.
		 * @extends Error
		 */
		Graph.HasConnectedEdgesError = (function (_Error5) {
			function HasConnectedEdgesError(key) {
				_classCallCheck(this, HasConnectedEdgesError);
		
				var _this5 = new _Error5();
		
				_this5.__proto__ = HasConnectedEdgesError.prototype;
		
				/**
		   * the key of the relevant vertex
		   * @public
		   * @constant key
		   * @memberof Graph.HasConnectedEdgesError
		   * @instance
		   * @type {string}
		   */
				_this5.key = key;
				_this5.message = "The '" + key + "' vertex has connected edges";
				return _this5;
			}
		
			_inherits(HasConnectedEdgesError, _Error5);
		
			return HasConnectedEdgesError;
		})(Error);
		
		/**
		 * @class
		 * @classdesc This type of error is thrown when a graph is expected not to have a directed cycle, but does.
		 * @extends Error
		 */
		Graph.CycleError = (function (_Error6) {
			function CycleError(cycle) {
				_classCallCheck(this, CycleError);
		
				var _this6 = new _Error6();
		
				_this6.__proto__ = CycleError.prototype;
		
				/**
		   * the vertices involved in the cycle
		   * @public
		   * @constant cycle
		   * @memberof Graph.CycleError
		   * @instance
		   * @type {Array.<string>}
		   */
				_this6.cycle = cycle;
				_this6.message = "This graph contains a cycle: " + cycle;
				return _this6;
			}
		
			_inherits(CycleError, _Error6);
		
			return CycleError;
		})(Error);
		module.exports = exports["default"];
		// stack
	
	/***/ },
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {
	
		__webpack_require__(27);
		__webpack_require__(28);
		__webpack_require__(29);
		__webpack_require__(30);
		__webpack_require__(31);
		__webpack_require__(32);
		__webpack_require__(33);
		__webpack_require__(34);
		__webpack_require__(35);
		__webpack_require__(36);
		__webpack_require__(37);
		__webpack_require__(38);
		__webpack_require__(39);
		__webpack_require__(40);
		__webpack_require__(41);
		__webpack_require__(42);
		__webpack_require__(43);
		__webpack_require__(44);
		__webpack_require__(45);
		__webpack_require__(46);
		__webpack_require__(47);
		__webpack_require__(48);
		__webpack_require__(49);
		__webpack_require__(50);
		__webpack_require__(51);
		__webpack_require__(52);
		__webpack_require__(53);
		__webpack_require__(54);
		__webpack_require__(55);
		__webpack_require__(56);
		__webpack_require__(57);
		__webpack_require__(58);
		__webpack_require__(59);
		__webpack_require__(60);
		__webpack_require__(61);
		__webpack_require__(62);
		__webpack_require__(63);
		__webpack_require__(64);
		__webpack_require__(65);
		__webpack_require__(66);
		__webpack_require__(67);
		__webpack_require__(68);
		__webpack_require__(69);
		__webpack_require__(70);
		module.exports = __webpack_require__(71).core;
	
	/***/ },
	/* 26 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(global) {/**
		 * Copyright (c) 2014, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
		 * additional grant of patent rights can be found in the PATENTS file in
		 * the same directory.
		 */
		
		!(function(global) {
		  "use strict";
		
		  var hasOwn = Object.prototype.hasOwnProperty;
		  var undefined; // More compressible than void 0.
		  var iteratorSymbol =
		    typeof Symbol === "function" && Symbol.iterator || "@@iterator";
		
		  var inModule = typeof module === "object";
		  var runtime = global.regeneratorRuntime;
		  if (runtime) {
		    if (inModule) {
		      // If regeneratorRuntime is defined globally and we're in a module,
		      // make the exports object identical to regeneratorRuntime.
		      module.exports = runtime;
		    }
		    // Don't bother evaluating the rest of this file if the runtime was
		    // already defined globally.
		    return;
		  }
		
		  // Define the runtime globally (as expected by generated code) as either
		  // module.exports (if we're in a module) or a new, empty object.
		  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
		
		  function wrap(innerFn, outerFn, self, tryLocsList) {
		    // If outerFn provided, then outerFn.prototype instanceof Generator.
		    var generator = Object.create((outerFn || Generator).prototype);
		
		    generator._invoke = makeInvokeMethod(
		      innerFn, self || null,
		      new Context(tryLocsList || [])
		    );
		
		    return generator;
		  }
		  runtime.wrap = wrap;
		
		  // Try/catch helper to minimize deoptimizations. Returns a completion
		  // record like context.tryEntries[i].completion. This interface could
		  // have been (and was previously) designed to take a closure to be
		  // invoked without arguments, but in all the cases we care about we
		  // already have an existing method we want to call, so there's no need
		  // to create a new function object. We can even get away with assuming
		  // the method takes exactly one argument, since that happens to be true
		  // in every case, so we don't have to touch the arguments object. The
		  // only additional allocation required is the completion record, which
		  // has a stable shape and so hopefully should be cheap to allocate.
		  function tryCatch(fn, obj, arg) {
		    try {
		      return { type: "normal", arg: fn.call(obj, arg) };
		    } catch (err) {
		      return { type: "throw", arg: err };
		    }
		  }
		
		  var GenStateSuspendedStart = "suspendedStart";
		  var GenStateSuspendedYield = "suspendedYield";
		  var GenStateExecuting = "executing";
		  var GenStateCompleted = "completed";
		
		  // Returning this object from the innerFn has the same effect as
		  // breaking out of the dispatch switch statement.
		  var ContinueSentinel = {};
		
		  // Dummy constructor functions that we use as the .constructor and
		  // .constructor.prototype properties for functions that return Generator
		  // objects. For full spec compliance, you may wish to configure your
		  // minifier not to mangle the names of these two functions.
		  function Generator() {}
		  function GeneratorFunction() {}
		  function GeneratorFunctionPrototype() {}
		
		  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
		  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
		  GeneratorFunctionPrototype.constructor = GeneratorFunction;
		  GeneratorFunction.displayName = "GeneratorFunction";
		
		  runtime.isGeneratorFunction = function(genFun) {
		    var ctor = typeof genFun === "function" && genFun.constructor;
		    return ctor
		      ? ctor === GeneratorFunction ||
		        // For the native GeneratorFunction constructor, the best we can
		        // do is to check its .name property.
		        (ctor.displayName || ctor.name) === "GeneratorFunction"
		      : false;
		  };
		
		  runtime.mark = function(genFun) {
		    genFun.__proto__ = GeneratorFunctionPrototype;
		    genFun.prototype = Object.create(Gp);
		    return genFun;
		  };
		
		  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
		    return new Promise(function(resolve, reject) {
		      var generator = wrap(innerFn, outerFn, self, tryLocsList);
		      var callNext = step.bind(generator, "next");
		      var callThrow = step.bind(generator, "throw");
		
		      function step(method, arg) {
		        var record = tryCatch(generator[method], generator, arg);
		        if (record.type === "throw") {
		          reject(record.arg);
		          return;
		        }
		
		        var info = record.arg;
		        if (info.done) {
		          resolve(info.value);
		        } else {
		          Promise.resolve(info.value).then(callNext, callThrow);
		        }
		      }
		
		      callNext();
		    });
		  };
		
		  function makeInvokeMethod(innerFn, self, context) {
		    var state = GenStateSuspendedStart;
		
		    return function invoke(method, arg) {
		      if (state === GenStateExecuting) {
		        throw new Error("Generator is already running");
		      }
		
		      if (state === GenStateCompleted) {
		        // Be forgiving, per 25.3.3.3.3 of the spec:
		        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
		        return doneResult();
		      }
		
		      while (true) {
		        var delegate = context.delegate;
		        if (delegate) {
		          if (method === "return" ||
		              (method === "throw" && delegate.iterator[method] === undefined)) {
		            // A return or throw (when the delegate iterator has no throw
		            // method) always terminates the yield* loop.
		            context.delegate = null;
		
		            // If the delegate iterator has a return method, give it a
		            // chance to clean up.
		            var returnMethod = delegate.iterator["return"];
		            if (returnMethod) {
		              var record = tryCatch(returnMethod, delegate.iterator, arg);
		              if (record.type === "throw") {
		                // If the return method threw an exception, let that
		                // exception prevail over the original return or throw.
		                method = "throw";
		                arg = record.arg;
		                continue;
		              }
		            }
		
		            if (method === "return") {
		              // Continue with the outer return, now that the delegate
		              // iterator has been terminated.
		              continue;
		            }
		          }
		
		          var record = tryCatch(
		            delegate.iterator[method],
		            delegate.iterator,
		            arg
		          );
		
		          if (record.type === "throw") {
		            context.delegate = null;
		
		            // Like returning generator.throw(uncaught), but without the
		            // overhead of an extra function call.
		            method = "throw";
		            arg = record.arg;
		            continue;
		          }
		
		          // Delegate generator ran and handled its own exceptions so
		          // regardless of what the method was, we continue as if it is
		          // "next" with an undefined arg.
		          method = "next";
		          arg = undefined;
		
		          var info = record.arg;
		          if (info.done) {
		            context[delegate.resultName] = info.value;
		            context.next = delegate.nextLoc;
		          } else {
		            state = GenStateSuspendedYield;
		            return info;
		          }
		
		          context.delegate = null;
		        }
		
		        if (method === "next") {
		          if (state === GenStateSuspendedYield) {
		            context.sent = arg;
		          } else {
		            delete context.sent;
		          }
		
		        } else if (method === "throw") {
		          if (state === GenStateSuspendedStart) {
		            state = GenStateCompleted;
		            throw arg;
		          }
		
		          if (context.dispatchException(arg)) {
		            // If the dispatched exception was caught by a catch block,
		            // then let that catch block handle the exception normally.
		            method = "next";
		            arg = undefined;
		          }
		
		        } else if (method === "return") {
		          context.abrupt("return", arg);
		        }
		
		        state = GenStateExecuting;
		
		        var record = tryCatch(innerFn, self, context);
		        if (record.type === "normal") {
		          // If an exception is thrown from innerFn, we leave state ===
		          // GenStateExecuting and loop back for another invocation.
		          state = context.done
		            ? GenStateCompleted
		            : GenStateSuspendedYield;
		
		          var info = {
		            value: record.arg,
		            done: context.done
		          };
		
		          if (record.arg === ContinueSentinel) {
		            if (context.delegate && method === "next") {
		              // Deliberately forget the last sent value so that we don't
		              // accidentally pass it on to the delegate.
		              arg = undefined;
		            }
		          } else {
		            return info;
		          }
		
		        } else if (record.type === "throw") {
		          state = GenStateCompleted;
		          // Dispatch the exception by looping back around to the
		          // context.dispatchException(arg) call above.
		          method = "throw";
		          arg = record.arg;
		        }
		      }
		    };
		  }
		
		  function defineGeneratorMethod(method) {
		    Gp[method] = function(arg) {
		      return this._invoke(method, arg);
		    };
		  }
		  defineGeneratorMethod("next");
		  defineGeneratorMethod("throw");
		  defineGeneratorMethod("return");
		
		  Gp[iteratorSymbol] = function() {
		    return this;
		  };
		
		  Gp.toString = function() {
		    return "[object Generator]";
		  };
		
		  function pushTryEntry(locs) {
		    var entry = { tryLoc: locs[0] };
		
		    if (1 in locs) {
		      entry.catchLoc = locs[1];
		    }
		
		    if (2 in locs) {
		      entry.finallyLoc = locs[2];
		      entry.afterLoc = locs[3];
		    }
		
		    this.tryEntries.push(entry);
		  }
		
		  function resetTryEntry(entry) {
		    var record = entry.completion || {};
		    record.type = "normal";
		    delete record.arg;
		    entry.completion = record;
		  }
		
		  function Context(tryLocsList) {
		    // The root entry object (effectively a try statement without a catch
		    // or a finally block) gives us a place to store values thrown from
		    // locations where there is no enclosing try statement.
		    this.tryEntries = [{ tryLoc: "root" }];
		    tryLocsList.forEach(pushTryEntry, this);
		    this.reset();
		  }
		
		  runtime.keys = function(object) {
		    var keys = [];
		    for (var key in object) {
		      keys.push(key);
		    }
		    keys.reverse();
		
		    // Rather than returning an object with a next method, we keep
		    // things simple and return the next function itself.
		    return function next() {
		      while (keys.length) {
		        var key = keys.pop();
		        if (key in object) {
		          next.value = key;
		          next.done = false;
		          return next;
		        }
		      }
		
		      // To avoid creating an additional object, we just hang the .value
		      // and .done properties off the next function object itself. This
		      // also ensures that the minifier will not anonymize the function.
		      next.done = true;
		      return next;
		    };
		  };
		
		  function values(iterable) {
		    if (iterable) {
		      var iteratorMethod = iterable[iteratorSymbol];
		      if (iteratorMethod) {
		        return iteratorMethod.call(iterable);
		      }
		
		      if (typeof iterable.next === "function") {
		        return iterable;
		      }
		
		      if (!isNaN(iterable.length)) {
		        var i = -1, next = function next() {
		          while (++i < iterable.length) {
		            if (hasOwn.call(iterable, i)) {
		              next.value = iterable[i];
		              next.done = false;
		              return next;
		            }
		          }
		
		          next.value = undefined;
		          next.done = true;
		
		          return next;
		        };
		
		        return next.next = next;
		      }
		    }
		
		    // Return an iterator with no values.
		    return { next: doneResult };
		  }
		  runtime.values = values;
		
		  function doneResult() {
		    return { value: undefined, done: true };
		  }
		
		  Context.prototype = {
		    constructor: Context,
		
		    reset: function() {
		      this.prev = 0;
		      this.next = 0;
		      this.sent = undefined;
		      this.done = false;
		      this.delegate = null;
		
		      this.tryEntries.forEach(resetTryEntry);
		
		      // Pre-initialize at least 20 temporary variables to enable hidden
		      // class optimizations for simple generators.
		      for (var tempIndex = 0, tempName;
		           hasOwn.call(this, tempName = "t" + tempIndex) || tempIndex < 20;
		           ++tempIndex) {
		        this[tempName] = null;
		      }
		    },
		
		    stop: function() {
		      this.done = true;
		
		      var rootEntry = this.tryEntries[0];
		      var rootRecord = rootEntry.completion;
		      if (rootRecord.type === "throw") {
		        throw rootRecord.arg;
		      }
		
		      return this.rval;
		    },
		
		    dispatchException: function(exception) {
		      if (this.done) {
		        throw exception;
		      }
		
		      var context = this;
		      function handle(loc, caught) {
		        record.type = "throw";
		        record.arg = exception;
		        context.next = loc;
		        return !!caught;
		      }
		
		      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
		        var entry = this.tryEntries[i];
		        var record = entry.completion;
		
		        if (entry.tryLoc === "root") {
		          // Exception thrown outside of any try block that could handle
		          // it, so set the completion value of the entire function to
		          // throw the exception.
		          return handle("end");
		        }
		
		        if (entry.tryLoc <= this.prev) {
		          var hasCatch = hasOwn.call(entry, "catchLoc");
		          var hasFinally = hasOwn.call(entry, "finallyLoc");
		
		          if (hasCatch && hasFinally) {
		            if (this.prev < entry.catchLoc) {
		              return handle(entry.catchLoc, true);
		            } else if (this.prev < entry.finallyLoc) {
		              return handle(entry.finallyLoc);
		            }
		
		          } else if (hasCatch) {
		            if (this.prev < entry.catchLoc) {
		              return handle(entry.catchLoc, true);
		            }
		
		          } else if (hasFinally) {
		            if (this.prev < entry.finallyLoc) {
		              return handle(entry.finallyLoc);
		            }
		
		          } else {
		            throw new Error("try statement without catch or finally");
		          }
		        }
		      }
		    },
		
		    abrupt: function(type, arg) {
		      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
		        var entry = this.tryEntries[i];
		        if (entry.tryLoc <= this.prev &&
		            hasOwn.call(entry, "finallyLoc") &&
		            this.prev < entry.finallyLoc) {
		          var finallyEntry = entry;
		          break;
		        }
		      }
		
		      if (finallyEntry &&
		          (type === "break" ||
		           type === "continue") &&
		          finallyEntry.tryLoc <= arg &&
		          arg <= finallyEntry.finallyLoc) {
		        // Ignore the finally entry if control is not jumping to a
		        // location outside the try/catch block.
		        finallyEntry = null;
		      }
		
		      var record = finallyEntry ? finallyEntry.completion : {};
		      record.type = type;
		      record.arg = arg;
		
		      if (finallyEntry) {
		        this.next = finallyEntry.finallyLoc;
		      } else {
		        this.complete(record);
		      }
		
		      return ContinueSentinel;
		    },
		
		    complete: function(record, afterLoc) {
		      if (record.type === "throw") {
		        throw record.arg;
		      }
		
		      if (record.type === "break" ||
		          record.type === "continue") {
		        this.next = record.arg;
		      } else if (record.type === "return") {
		        this.rval = record.arg;
		        this.next = "end";
		      } else if (record.type === "normal" && afterLoc) {
		        this.next = afterLoc;
		      }
		
		      return ContinueSentinel;
		    },
		
		    finish: function(finallyLoc) {
		      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
		        var entry = this.tryEntries[i];
		        if (entry.finallyLoc === finallyLoc) {
		          return this.complete(entry.completion, entry.afterLoc);
		        }
		      }
		    },
		
		    "catch": function(tryLoc) {
		      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
		        var entry = this.tryEntries[i];
		        if (entry.tryLoc === tryLoc) {
		          var record = entry.completion;
		          if (record.type === "throw") {
		            var thrown = record.arg;
		            resetTryEntry(entry);
		          }
		          return thrown;
		        }
		      }
		
		      // The context.catch method must only be called with a location
		      // argument that corresponds to a known catch block.
		      throw new Error("illegal catch attempt");
		    },
		
		    delegateYield: function(iterable, resultName, nextLoc) {
		      this.delegate = {
		        iterator: values(iterable),
		        resultName: resultName,
		        nextLoc: nextLoc
		      };
		
		      return ContinueSentinel;
		    }
		  };
		})(
		  // Among the various tricks for obtaining a reference to the global
		  // object, this seems to be the most reliable technique that does not
		  // use indirect eval (which violates Content Security Policy).
		  typeof global === "object" ? global :
		  typeof window === "object" ? window :
		  typeof self === "object" ? self : this
		);
		
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $                = __webpack_require__(71)
		  , cof              = __webpack_require__(72)
		  , $def             = __webpack_require__(73)
		  , invoke           = __webpack_require__(74)
		  , arrayMethod      = __webpack_require__(75)
		  , IE_PROTO         = __webpack_require__(76).safe('__proto__')
		  , assert           = __webpack_require__(77)
		  , assertObject     = assert.obj
		  , ObjectProto      = Object.prototype
		  , A                = []
		  , slice            = A.slice
		  , indexOf          = A.indexOf
		  , classof          = cof.classof
		  , defineProperties = Object.defineProperties
		  , has              = $.has
		  , defineProperty   = $.setDesc
		  , getOwnDescriptor = $.getDesc
		  , isFunction       = $.isFunction
		  , toObject         = $.toObject
		  , toLength         = $.toLength
		  , IE8_DOM_DEFINE   = false;
		
		if(!$.DESC){
		  try {
		    IE8_DOM_DEFINE = defineProperty(document.createElement('div'), 'x',
		      {get: function(){ return 8; }}
		    ).x == 8;
		  } catch(e){ /* empty */ }
		  $.setDesc = function(O, P, Attributes){
		    if(IE8_DOM_DEFINE)try {
		      return defineProperty(O, P, Attributes);
		    } catch(e){ /* empty */ }
		    if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
		    if('value' in Attributes)assertObject(O)[P] = Attributes.value;
		    return O;
		  };
		  $.getDesc = function(O, P){
		    if(IE8_DOM_DEFINE)try {
		      return getOwnDescriptor(O, P);
		    } catch(e){ /* empty */ }
		    if(has(O, P))return $.desc(!ObjectProto.propertyIsEnumerable.call(O, P), O[P]);
		  };
		  defineProperties = function(O, Properties){
		    assertObject(O);
		    var keys   = $.getKeys(Properties)
		      , length = keys.length
		      , i = 0
		      , P;
		    while(length > i)$.setDesc(O, P = keys[i++], Properties[P]);
		    return O;
		  };
		}
		$def($def.S + $def.F * !$.DESC, 'Object', {
		  // 19.1.2.6 / 15.2.3.3 Object.getOwnPropertyDescriptor(O, P)
		  getOwnPropertyDescriptor: $.getDesc,
		  // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
		  defineProperty: $.setDesc,
		  // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
		  defineProperties: defineProperties
		});
		
		  // IE 8- don't enum bug keys
		var keys1 = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,' +
		            'toLocaleString,toString,valueOf').split(',')
		  // Additional keys for getOwnPropertyNames
		  , keys2 = keys1.concat('length', 'prototype')
		  , keysLen1 = keys1.length;
		
		// Create object with `null` prototype: use iframe Object with cleared prototype
		var createDict = function(){
		  // Thrash, waste and sodomy: IE GC bug
		  var iframe = document.createElement('iframe')
		    , i      = keysLen1
		    , gt     = '>'
		    , iframeDocument;
		  iframe.style.display = 'none';
		  $.html.appendChild(iframe);
		  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
		  // createDict = iframe.contentWindow.Object;
		  // html.removeChild(iframe);
		  iframeDocument = iframe.contentWindow.document;
		  iframeDocument.open();
		  iframeDocument.write('<script>document.F=Object</script' + gt);
		  iframeDocument.close();
		  createDict = iframeDocument.F;
		  while(i--)delete createDict.prototype[keys1[i]];
		  return createDict();
		};
		function createGetKeys(names, length){
		  return function(object){
		    var O      = toObject(object)
		      , i      = 0
		      , result = []
		      , key;
		    for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
		    // Don't enum bug & hidden keys
		    while(length > i)if(has(O, key = names[i++])){
		      ~indexOf.call(result, key) || result.push(key);
		    }
		    return result;
		  };
		}
		function isPrimitive(it){ return !$.isObject(it); }
		function Empty(){}
		$def($def.S, 'Object', {
		  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
		  getPrototypeOf: $.getProto = $.getProto || function(O){
		    O = Object(assert.def(O));
		    if(has(O, IE_PROTO))return O[IE_PROTO];
		    if(isFunction(O.constructor) && O instanceof O.constructor){
		      return O.constructor.prototype;
		    } return O instanceof Object ? ObjectProto : null;
		  },
		  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
		  getOwnPropertyNames: $.getNames = $.getNames || createGetKeys(keys2, keys2.length, true),
		  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
		  create: $.create = $.create || function(O, /*?*/Properties){
		    var result;
		    if(O !== null){
		      Empty.prototype = assertObject(O);
		      result = new Empty();
		      Empty.prototype = null;
		      // add "__proto__" for Object.getPrototypeOf shim
		      result[IE_PROTO] = O;
		    } else result = createDict();
		    return Properties === undefined ? result : defineProperties(result, Properties);
		  },
		  // 19.1.2.14 / 15.2.3.14 Object.keys(O)
		  keys: $.getKeys = $.getKeys || createGetKeys(keys1, keysLen1, false),
		  // 19.1.2.17 / 15.2.3.8 Object.seal(O)
		  seal: $.it, // <- cap
		  // 19.1.2.5 / 15.2.3.9 Object.freeze(O)
		  freeze: $.it, // <- cap
		  // 19.1.2.15 / 15.2.3.10 Object.preventExtensions(O)
		  preventExtensions: $.it, // <- cap
		  // 19.1.2.13 / 15.2.3.11 Object.isSealed(O)
		  isSealed: isPrimitive, // <- cap
		  // 19.1.2.12 / 15.2.3.12 Object.isFrozen(O)
		  isFrozen: isPrimitive, // <- cap
		  // 19.1.2.11 / 15.2.3.13 Object.isExtensible(O)
		  isExtensible: $.isObject // <- cap
		});
		
		// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
		$def($def.P, 'Function', {
		  bind: function(that /*, args... */){
		    var fn       = assert.fn(this)
		      , partArgs = slice.call(arguments, 1);
		    function bound(/* args... */){
		      var args = partArgs.concat(slice.call(arguments));
		      return invoke(fn, args, this instanceof bound ? $.create(fn.prototype) : that);
		    }
		    if(fn.prototype)bound.prototype = fn.prototype;
		    return bound;
		  }
		});
		
		// Fix for not array-like ES3 string
		function arrayMethodFix(fn){
		  return function(){
		    return fn.apply($.ES5Object(this), arguments);
		  };
		}
		if(!(0 in Object('z') && 'z'[0] == 'z')){
		  $.ES5Object = function(it){
		    return cof(it) == 'String' ? it.split('') : Object(it);
		  };
		}
		$def($def.P + $def.F * ($.ES5Object != Object), 'Array', {
		  slice: arrayMethodFix(slice),
		  join: arrayMethodFix(A.join)
		});
		
		// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
		$def($def.S, 'Array', {
		  isArray: function(arg){
		    return cof(arg) == 'Array';
		  }
		});
		function createArrayReduce(isRight){
		  return function(callbackfn, memo){
		    assert.fn(callbackfn);
		    var O      = toObject(this)
		      , length = toLength(O.length)
		      , index  = isRight ? length - 1 : 0
		      , i      = isRight ? -1 : 1;
		    if(arguments.length < 2)for(;;){
		      if(index in O){
		        memo = O[index];
		        index += i;
		        break;
		      }
		      index += i;
		      assert(isRight ? index >= 0 : length > index, 'Reduce of empty array with no initial value');
		    }
		    for(;isRight ? index >= 0 : length > index; index += i)if(index in O){
		      memo = callbackfn(memo, O[index], index, this);
		    }
		    return memo;
		  };
		}
		$def($def.P, 'Array', {
		  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
		  forEach: $.each = $.each || arrayMethod(0),
		  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
		  map: arrayMethod(1),
		  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
		  filter: arrayMethod(2),
		  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
		  some: arrayMethod(3),
		  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
		  every: arrayMethod(4),
		  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
		  reduce: createArrayReduce(false),
		  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
		  reduceRight: createArrayReduce(true),
		  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
		  indexOf: indexOf = indexOf || __webpack_require__(78)(false),
		  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
		  lastIndexOf: function(el, fromIndex /* = @[*-1] */){
		    var O      = toObject(this)
		      , length = toLength(O.length)
		      , index  = length - 1;
		    if(arguments.length > 1)index = Math.min(index, $.toInteger(fromIndex));
		    if(index < 0)index = toLength(length + index);
		    for(;index >= 0; index--)if(index in O)if(O[index] === el)return index;
		    return -1;
		  }
		});
		
		// 21.1.3.25 / 15.5.4.20 String.prototype.trim()
		$def($def.P, 'String', {trim: __webpack_require__(79)(/^\s*([\s\S]*\S)?\s*$/, '$1')});
		
		// 20.3.3.1 / 15.9.4.4 Date.now()
		$def($def.S, 'Date', {now: function(){
		  return +new Date;
		}});
		
		function lz(num){
		  return num > 9 ? num : '0' + num;
		}
		// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
		$def($def.P, 'Date', {toISOString: function(){
		  if(!isFinite(this))throw RangeError('Invalid time value');
		  var d = this
		    , y = d.getUTCFullYear()
		    , m = d.getUTCMilliseconds()
		    , s = y < 0 ? '-' : y > 9999 ? '+' : '';
		  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
		    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
		    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
		    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
		}});
		
		if(classof(function(){ return arguments; }()) == 'Object')cof.classof = function(it){
		  var tag = classof(it);
		  return tag == 'Object' && isFunction(it.callee) ? 'Arguments' : tag;
		};
	
	/***/ },
	/* 28 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		// ECMAScript 6 symbols shim
		var $        = __webpack_require__(71)
		  , setTag   = __webpack_require__(72).set
		  , uid      = __webpack_require__(76)
		  , $def     = __webpack_require__(73)
		  , keyOf    = __webpack_require__(80)
		  , has      = $.has
		  , hide     = $.hide
		  , getNames = $.getNames
		  , toObject = $.toObject
		  , Symbol   = $.g.Symbol
		  , Base     = Symbol
		  , setter   = false
		  , TAG      = uid.safe('tag')
		  , SymbolRegistry = {}
		  , AllSymbols     = {};
		
		function wrap(tag){
		  var sym = AllSymbols[tag] = $.set($.create(Symbol.prototype), TAG, tag);
		  $.DESC && setter && $.setDesc(Object.prototype, tag, {
		    configurable: true,
		    set: function(value){
		      hide(this, tag, value);
		    }
		  });
		  return sym;
		}
		
		// 19.4.1.1 Symbol([description])
		if(!$.isFunction(Symbol)){
		  Symbol = function Symbol(description){
		    if(this instanceof Symbol)throw TypeError('Symbol is not a constructor');
		    return wrap(uid(description));
		  };
		  hide(Symbol.prototype, 'toString', function(){
		    return this[TAG];
		  });
		}
		$def($def.G + $def.W, {Symbol: Symbol});
		
		var symbolStatics = {
		  // 19.4.2.1 Symbol.for(key)
		  'for': function(key){
		    return has(SymbolRegistry, key += '')
		      ? SymbolRegistry[key]
		      : SymbolRegistry[key] = Symbol(key);
		  },
		  // 19.4.2.5 Symbol.keyFor(sym)
		  keyFor: function keyFor(key){
		    return keyOf(SymbolRegistry, key);
		  },
		  pure: uid.safe,
		  set: $.set,
		  useSetter: function(){ setter = true; },
		  useSimple: function(){ setter = false; }
		};
		// 19.4.2.2 Symbol.hasInstance
		// 19.4.2.3 Symbol.isConcatSpreadable
		// 19.4.2.4 Symbol.iterator
		// 19.4.2.6 Symbol.match
		// 19.4.2.8 Symbol.replace
		// 19.4.2.9 Symbol.search
		// 19.4.2.10 Symbol.species
		// 19.4.2.11 Symbol.split
		// 19.4.2.12 Symbol.toPrimitive
		// 19.4.2.13 Symbol.toStringTag
		// 19.4.2.14 Symbol.unscopables
		$.each.call((
		    'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
		    'species,split,toPrimitive,toStringTag,unscopables'
		  ).split(','), function(it){
		    var sym = __webpack_require__(81)(it);
		    symbolStatics[it] = Symbol === Base ? sym : wrap(sym);
		  }
		);
		
		setter = true;
		
		$def($def.S, 'Symbol', symbolStatics);
		
		$def($def.S + $def.F * (Symbol != Base), 'Object', {
		  // 19.1.2.7 Object.getOwnPropertyNames(O)
		  getOwnPropertyNames: function getOwnPropertyNames(it){
		    var names = getNames(toObject(it)), result = [], key, i = 0;
		    while(names.length > i)has(AllSymbols, key = names[i++]) || result.push(key);
		    return result;
		  },
		  // 19.1.2.8 Object.getOwnPropertySymbols(O)
		  getOwnPropertySymbols: function getOwnPropertySymbols(it){
		    var names = getNames(toObject(it)), result = [], key, i = 0;
		    while(names.length > i)has(AllSymbols, key = names[i++]) && result.push(AllSymbols[key]);
		    return result;
		  }
		});
		
		setTag(Symbol, 'Symbol');
		// 20.2.1.9 Math[@@toStringTag]
		setTag(Math, 'Math', true);
		// 24.3.3 JSON[@@toStringTag]
		setTag($.g.JSON, 'JSON', true);
	
	/***/ },
	/* 29 */
	/***/ function(module, exports, __webpack_require__) {
	
		// 19.1.3.1 Object.assign(target, source)
		var $def = __webpack_require__(73);
		$def($def.S, 'Object', {assign: __webpack_require__(82)});
	
	/***/ },
	/* 30 */
	/***/ function(module, exports, __webpack_require__) {
	
		// 19.1.3.10 Object.is(value1, value2)
		var $def = __webpack_require__(73);
		$def($def.S, 'Object', {
		  is: function is(x, y){
		    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
		  }
		});
	
	/***/ },
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {
	
		// 19.1.3.19 Object.setPrototypeOf(O, proto)
		var $def = __webpack_require__(73);
		$def($def.S, 'Object', {setPrototypeOf: __webpack_require__(83).set});
	
	/***/ },
	/* 32 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		// 19.1.3.6 Object.prototype.toString()
		var $   = __webpack_require__(71)
		  , cof = __webpack_require__(72)
		  , tmp = {};
		tmp[__webpack_require__(81)('toStringTag')] = 'z';
		if($.FW && cof(tmp) != 'z')$.hide(Object.prototype, 'toString', function toString(){
		  return '[object ' + cof.classof(this) + ']';
		});
	
	/***/ },
	/* 33 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $        = __webpack_require__(71)
		  , $def     = __webpack_require__(73)
		  , isObject = $.isObject
		  , toObject = $.toObject;
		function wrapObjectMethod(METHOD, MODE){
		  var fn  = ($.core.Object || {})[METHOD] || Object[METHOD]
		    , f   = 0
		    , o   = {};
		  o[METHOD] = MODE == 1 ? function(it){
		    return isObject(it) ? fn(it) : it;
		  } : MODE == 2 ? function(it){
		    return isObject(it) ? fn(it) : true;
		  } : MODE == 3 ? function(it){
		    return isObject(it) ? fn(it) : false;
		  } : MODE == 4 ? function getOwnPropertyDescriptor(it, key){
		    return fn(toObject(it), key);
		  } : MODE == 5 ? function getPrototypeOf(it){
		    return fn(Object($.assertDefined(it)));
		  } : function(it){
		    return fn(toObject(it));
		  };
		  try {
		    fn('z');
		  } catch(e){
		    f = 1;
		  }
		  $def($def.S + $def.F * f, 'Object', o);
		}
		wrapObjectMethod('freeze', 1);
		wrapObjectMethod('seal', 1);
		wrapObjectMethod('preventExtensions', 1);
		wrapObjectMethod('isFrozen', 2);
		wrapObjectMethod('isSealed', 2);
		wrapObjectMethod('isExtensible', 3);
		wrapObjectMethod('getOwnPropertyDescriptor', 4);
		wrapObjectMethod('getPrototypeOf', 5);
		wrapObjectMethod('keys');
		wrapObjectMethod('getOwnPropertyNames');
	
	/***/ },
	/* 34 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var $    = __webpack_require__(71)
		  , NAME = 'name'
		  , setDesc = $.setDesc
		  , FunctionProto = Function.prototype;
		// 19.2.4.2 name
		NAME in FunctionProto || $.FW && $.DESC && setDesc(FunctionProto, NAME, {
		  configurable: true,
		  get: function(){
		    var match = String(this).match(/^\s*function ([^ (]*)/)
		      , name  = match ? match[1] : '';
		    $.has(this, NAME) || setDesc(this, NAME, $.desc(5, name));
		    return name;
		  },
		  set: function(value){
		    $.has(this, NAME) || setDesc(this, NAME, $.desc(0, value));
		  }
		});
	
	/***/ },
	/* 35 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var $          = __webpack_require__(71)
		  , isObject   = $.isObject
		  , isFunction = $.isFunction
		  , NUMBER     = 'Number'
		  , Number     = $.g[NUMBER]
		  , Base       = Number
		  , proto      = Number.prototype;
		function toPrimitive(it){
		  var fn, val;
		  if(isFunction(fn = it.valueOf) && !isObject(val = fn.call(it)))return val;
		  if(isFunction(fn = it.toString) && !isObject(val = fn.call(it)))return val;
		  throw TypeError("Can't convert object to number");
		}
		function toNumber(it){
		  if(isObject(it))it = toPrimitive(it);
		  if(typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48){
		    var binary = false;
		    switch(it.charCodeAt(1)){
		      case 66 : case 98  : binary = true;
		      case 79 : case 111 : return parseInt(it.slice(2), binary ? 2 : 8);
		    }
		  } return +it;
		}
		if($.FW && !(Number('0o1') && Number('0b1'))){
		  Number = function Number(it){
		    return this instanceof Number ? new Base(toNumber(it)) : toNumber(it);
		  };
		  $.each.call($.DESC ? $.getNames(Base) : (
		      // ES3:
		      'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
		      // ES6 (in case, if modules with ES6 Number statics required before):
		      'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
		      'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
		    ).split(','), function(key){
		      if($.has(Base, key) && !$.has(Number, key)){
		        $.setDesc(Number, key, $.getDesc(Base, key));
		      }
		    }
		  );
		  Number.prototype = proto;
		  proto.constructor = Number;
		  $.hide($.g, NUMBER, Number);
		}
	
	/***/ },
	/* 36 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $     = __webpack_require__(71)
		  , $def  = __webpack_require__(73)
		  , abs   = Math.abs
		  , floor = Math.floor
		  , _isFinite = $.g.isFinite
		  , MAX_SAFE_INTEGER = 0x1fffffffffffff; // pow(2, 53) - 1 == 9007199254740991;
		function isInteger(it){
		  return !$.isObject(it) && _isFinite(it) && floor(it) === it;
		}
		$def($def.S, 'Number', {
		  // 20.1.2.1 Number.EPSILON
		  EPSILON: Math.pow(2, -52),
		  // 20.1.2.2 Number.isFinite(number)
		  isFinite: function isFinite(it){
		    return typeof it == 'number' && _isFinite(it);
		  },
		  // 20.1.2.3 Number.isInteger(number)
		  isInteger: isInteger,
		  // 20.1.2.4 Number.isNaN(number)
		  isNaN: function isNaN(number){
		    return number != number;
		  },
		  // 20.1.2.5 Number.isSafeInteger(number)
		  isSafeInteger: function isSafeInteger(number){
		    return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;
		  },
		  // 20.1.2.6 Number.MAX_SAFE_INTEGER
		  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
		  // 20.1.2.10 Number.MIN_SAFE_INTEGER
		  MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,
		  // 20.1.2.12 Number.parseFloat(string)
		  parseFloat: parseFloat,
		  // 20.1.2.13 Number.parseInt(string, radix)
		  parseInt: parseInt
		});
	
	/***/ },
	/* 37 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Infinity = 1 / 0
		  , $def  = __webpack_require__(73)
		  , E     = Math.E
		  , pow   = Math.pow
		  , abs   = Math.abs
		  , exp   = Math.exp
		  , log   = Math.log
		  , sqrt  = Math.sqrt
		  , ceil  = Math.ceil
		  , floor = Math.floor
		  , EPSILON   = pow(2, -52)
		  , EPSILON32 = pow(2, -23)
		  , MAX32     = pow(2, 127) * (2 - EPSILON32)
		  , MIN32     = pow(2, -126);
		function roundTiesToEven(n){
		  return n + 1 / EPSILON - 1 / EPSILON;
		}
		
		// 20.2.2.28 Math.sign(x)
		function sign(x){
		  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
		}
		// 20.2.2.5 Math.asinh(x)
		function asinh(x){
		  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
		}
		// 20.2.2.14 Math.expm1(x)
		function expm1(x){
		  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
		}
		
		$def($def.S, 'Math', {
		  // 20.2.2.3 Math.acosh(x)
		  acosh: function acosh(x){
		    return (x = +x) < 1 ? NaN : isFinite(x) ? log(x / E + sqrt(x + 1) * sqrt(x - 1) / E) + 1 : x;
		  },
		  // 20.2.2.5 Math.asinh(x)
		  asinh: asinh,
		  // 20.2.2.7 Math.atanh(x)
		  atanh: function atanh(x){
		    return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
		  },
		  // 20.2.2.9 Math.cbrt(x)
		  cbrt: function cbrt(x){
		    return sign(x = +x) * pow(abs(x), 1 / 3);
		  },
		  // 20.2.2.11 Math.clz32(x)
		  clz32: function clz32(x){
		    return (x >>>= 0) ? 31 - floor(log(x + 0.5) * Math.LOG2E) : 32;
		  },
		  // 20.2.2.12 Math.cosh(x)
		  cosh: function cosh(x){
		    return (exp(x = +x) + exp(-x)) / 2;
		  },
		  // 20.2.2.14 Math.expm1(x)
		  expm1: expm1,
		  // 20.2.2.16 Math.fround(x)
		  fround: function fround(x){
		    var $abs  = abs(x)
		      , $sign = sign(x)
		      , a, result;
		    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
		    a = (1 + EPSILON32 / EPSILON) * $abs;
		    result = a - (a - $abs);
		    if(result > MAX32 || result != result)return $sign * Infinity;
		    return $sign * result;
		  },
		  // 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
		  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
		    var sum  = 0
		      , len1 = arguments.length
		      , len2 = len1
		      , args = Array(len1)
		      , larg = -Infinity
		      , arg;
		    while(len1--){
		      arg = args[len1] = +arguments[len1];
		      if(arg == Infinity || arg == -Infinity)return Infinity;
		      if(arg > larg)larg = arg;
		    }
		    larg = arg || 1;
		    while(len2--)sum += pow(args[len2] / larg, 2);
		    return larg * sqrt(sum);
		  },
		  // 20.2.2.18 Math.imul(x, y)
		  imul: function imul(x, y){
		    var UInt16 = 0xffff
		      , xn = +x
		      , yn = +y
		      , xl = UInt16 & xn
		      , yl = UInt16 & yn;
		    return 0 | xl * yl + ((UInt16 & xn >>> 16) * yl + xl * (UInt16 & yn >>> 16) << 16 >>> 0);
		  },
		  // 20.2.2.20 Math.log1p(x)
		  log1p: function log1p(x){
		    return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
		  },
		  // 20.2.2.21 Math.log10(x)
		  log10: function log10(x){
		    return log(x) / Math.LN10;
		  },
		  // 20.2.2.22 Math.log2(x)
		  log2: function log2(x){
		    return log(x) / Math.LN2;
		  },
		  // 20.2.2.28 Math.sign(x)
		  sign: sign,
		  // 20.2.2.30 Math.sinh(x)
		  sinh: function sinh(x){
		    return abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
		  },
		  // 20.2.2.33 Math.tanh(x)
		  tanh: function tanh(x){
		    var a = expm1(x = +x)
		      , b = expm1(-x);
		    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
		  },
		  // 20.2.2.34 Math.trunc(x)
		  trunc: function trunc(it){
		    return (it > 0 ? floor : ceil)(it);
		  }
		});
	
	/***/ },
	/* 38 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $def    = __webpack_require__(73)
		  , toIndex = __webpack_require__(71).toIndex
		  , fromCharCode = String.fromCharCode;
		
		$def($def.S, 'String', {
		  // 21.1.2.2 String.fromCodePoint(...codePoints)
		  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
		    var res = []
		      , len = arguments.length
		      , i   = 0
		      , code;
		    while(len > i){
		      code = +arguments[i++];
		      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
		      res.push(code < 0x10000
		        ? fromCharCode(code)
		        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
		      );
		    } return res.join('');
		  }
		});
	
	/***/ },
	/* 39 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $    = __webpack_require__(71)
		  , $def = __webpack_require__(73);
		
		$def($def.S, 'String', {
		  // 21.1.2.4 String.raw(callSite, ...substitutions)
		  raw: function raw(callSite){
		    var tpl = $.toObject(callSite.raw)
		      , len = $.toLength(tpl.length)
		      , sln = arguments.length
		      , res = []
		      , i   = 0;
		    while(len > i){
		      res.push(String(tpl[i++]));
		      if(i < sln)res.push(String(arguments[i]));
		    } return res.join('');
		  }
		});
	
	/***/ },
	/* 40 */
	/***/ function(module, exports, __webpack_require__) {
	
		var set   = __webpack_require__(71).set
		  , at    = __webpack_require__(84)(true)
		  , ITER  = __webpack_require__(76).safe('iter')
		  , $iter = __webpack_require__(85)
		  , step  = $iter.step;
		
		// 21.1.3.27 String.prototype[@@iterator]()
		$iter.std(String, 'String', function(iterated){
		  set(this, ITER, {o: String(iterated), i: 0});
		// 21.1.5.2.1 %StringIteratorPrototype%.next()
		}, function(){
		  var iter  = this[ITER]
		    , O     = iter.o
		    , index = iter.i
		    , point;
		  if(index >= O.length)return step(1);
		  point = at.call(O, index);
		  iter.i += point.length;
		  return step(0, point);
		});
	
	/***/ },
	/* 41 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $def = __webpack_require__(73);
		$def($def.P, 'String', {
		  // 21.1.3.3 String.prototype.codePointAt(pos)
		  codePointAt: __webpack_require__(84)(false)
		});
	
	/***/ },
	/* 42 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var $    = __webpack_require__(71)
		  , cof  = __webpack_require__(72)
		  , $def = __webpack_require__(73)
		  , toLength = $.toLength;
		
		$def($def.P, 'String', {
		  // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
		  endsWith: function endsWith(searchString /*, endPosition = @length */){
		    if(cof(searchString) == 'RegExp')throw TypeError();
		    var that = String($.assertDefined(this))
		      , endPosition = arguments[1]
		      , len = toLength(that.length)
		      , end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
		    searchString += '';
		    return that.slice(end - searchString.length, end) === searchString;
		  }
		});
	
	/***/ },
	/* 43 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var $    = __webpack_require__(71)
		  , cof  = __webpack_require__(72)
		  , $def = __webpack_require__(73);
		
		$def($def.P, 'String', {
		  // 21.1.3.7 String.prototype.includes(searchString, position = 0)
		  includes: function includes(searchString /*, position = 0 */){
		    if(cof(searchString) == 'RegExp')throw TypeError();
		    return !!~String($.assertDefined(this)).indexOf(searchString, arguments[1]);
		  }
		});
	
	/***/ },
	/* 44 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var $    = __webpack_require__(71)
		  , $def = __webpack_require__(73);
		
		$def($def.P, 'String', {
		  // 21.1.3.13 String.prototype.repeat(count)
		  repeat: function repeat(count){
		    var str = String($.assertDefined(this))
		      , res = ''
		      , n   = $.toInteger(count);
		    if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
		    for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
		    return res;
		  }
		});
	
	/***/ },
	/* 45 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var $    = __webpack_require__(71)
		  , cof  = __webpack_require__(72)
		  , $def = __webpack_require__(73);
		
		$def($def.P, 'String', {
		  // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
		  startsWith: function startsWith(searchString /*, position = 0 */){
		    if(cof(searchString) == 'RegExp')throw TypeError();
		    var that  = String($.assertDefined(this))
		      , index = $.toLength(Math.min(arguments[1], that.length));
		    searchString += '';
		    return that.slice(index, index + searchString.length) === searchString;
		  }
		});
	
	/***/ },
	/* 46 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $     = __webpack_require__(71)
		  , ctx   = __webpack_require__(86)
		  , $def  = __webpack_require__(73)
		  , $iter = __webpack_require__(85)
		  , stepCall = $iter.stepCall;
		$def($def.S + $def.F * !__webpack_require__(87)(function(iter){ Array.from(iter); }), 'Array', {
		  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
		  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
		    var O       = Object($.assertDefined(arrayLike))
		      , mapfn   = arguments[1]
		      , mapping = mapfn !== undefined
		      , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined
		      , index   = 0
		      , length, result, step, iterator;
		    if($iter.is(O)){
		      iterator = $iter.get(O);
		      // strange IE quirks mode bug -> use typeof instead of isFunction
		      result   = new (typeof this == 'function' ? this : Array);
		      for(; !(step = iterator.next()).done; index++){
		        result[index] = mapping ? stepCall(iterator, f, [step.value, index], true) : step.value;
		      }
		    } else {
		      // strange IE quirks mode bug -> use typeof instead of isFunction
		      result = new (typeof this == 'function' ? this : Array)(length = $.toLength(O.length));
		      for(; length > index; index++){
		        result[index] = mapping ? f(O[index], index) : O[index];
		      }
		    }
		    result.length = index;
		    return result;
		  }
		});
	
	/***/ },
	/* 47 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $def = __webpack_require__(73);
		$def($def.S, 'Array', {
		  // 22.1.2.3 Array.of( ...items)
		  of: function of(/* ...args */){
		    var index  = 0
		      , length = arguments.length
		      // strange IE quirks mode bug -> use typeof instead of isFunction
		      , result = new (typeof this == 'function' ? this : Array)(length);
		    while(length > index)result[index] = arguments[index++];
		    result.length = length;
		    return result;
		  }
		});
	
	/***/ },
	/* 48 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $          = __webpack_require__(71)
		  , setUnscope = __webpack_require__(88)
		  , ITER       = __webpack_require__(76).safe('iter')
		  , $iter      = __webpack_require__(85)
		  , step       = $iter.step
		  , Iterators  = $iter.Iterators;
		
		// 22.1.3.4 Array.prototype.entries()
		// 22.1.3.13 Array.prototype.keys()
		// 22.1.3.29 Array.prototype.values()
		// 22.1.3.30 Array.prototype[@@iterator]()
		$iter.std(Array, 'Array', function(iterated, kind){
		  $.set(this, ITER, {o: $.toObject(iterated), i: 0, k: kind});
		// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
		}, function(){
		  var iter  = this[ITER]
		    , O     = iter.o
		    , kind  = iter.k
		    , index = iter.i++;
		  if(!O || index >= O.length){
		    iter.o = undefined;
		    return step(1);
		  }
		  if(kind == 'key'  )return step(0, index);
		  if(kind == 'value')return step(0, O[index]);
		  return step(0, [index, O[index]]);
		}, 'value');
		
		// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
		Iterators.Arguments = Iterators.Array;
		
		setUnscope('keys');
		setUnscope('values');
		setUnscope('entries');
	
	/***/ },
	/* 49 */
	/***/ function(module, exports, __webpack_require__) {
	
		__webpack_require__(89)(Array);
	
	/***/ },
	/* 50 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var $       = __webpack_require__(71)
		  , $def    = __webpack_require__(73)
		  , toIndex = $.toIndex;
		$def($def.P, 'Array', {
		  // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
		  copyWithin: function copyWithin(target/* = 0 */, start /* = 0, end = @length */){
		    var O     = Object($.assertDefined(this))
		      , len   = $.toLength(O.length)
		      , to    = toIndex(target, len)
		      , from  = toIndex(start, len)
		      , end   = arguments[2]
		      , fin   = end === undefined ? len : toIndex(end, len)
		      , count = Math.min(fin - from, len - to)
		      , inc   = 1;
		    if(from < to && to < from + count){
		      inc  = -1;
		      from = from + count - 1;
		      to   = to   + count - 1;
		    }
		    while(count-- > 0){
		      if(from in O)O[to] = O[from];
		      else delete O[to];
		      to   += inc;
		      from += inc;
		    } return O;
		  }
		});
		__webpack_require__(88)('copyWithin');
	
	/***/ },
	/* 51 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var $       = __webpack_require__(71)
		  , $def    = __webpack_require__(73)
		  , toIndex = $.toIndex;
		$def($def.P, 'Array', {
		  // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
		  fill: function fill(value /*, start = 0, end = @length */){
		    var O      = Object($.assertDefined(this))
		      , length = $.toLength(O.length)
		      , index  = toIndex(arguments[1], length)
		      , end    = arguments[2]
		      , endPos = end === undefined ? length : toIndex(end, length);
		    while(endPos > index)O[index++] = value;
		    return O;
		  }
		});
		__webpack_require__(88)('fill');
	
	/***/ },
	/* 52 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $def = __webpack_require__(73);
		$def($def.P, 'Array', {
		  // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
		  find: __webpack_require__(75)(5)
		});
		__webpack_require__(88)('find');
	
	/***/ },
	/* 53 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $def = __webpack_require__(73);
		$def($def.P, 'Array', {
		  // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
		  findIndex: __webpack_require__(75)(6)
		});
		__webpack_require__(88)('findIndex');
	
	/***/ },
	/* 54 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $      = __webpack_require__(71)
		  , cof    = __webpack_require__(72)
		  , RegExp = $.g.RegExp
		  , Base   = RegExp
		  , proto  = RegExp.prototype;
		if($.FW && $.DESC){
		  // RegExp allows a regex with flags as the pattern
		  if(!function(){try{ return RegExp(/a/g, 'i') == '/a/i'; }catch(e){ /* empty */ }}()){
		    RegExp = function RegExp(pattern, flags){
		      return new Base(cof(pattern) == 'RegExp' && flags !== undefined
		        ? pattern.source : pattern, flags);
		    };
		    $.each.call($.getNames(Base), function(key){
		      key in RegExp || $.setDesc(RegExp, key, {
		        configurable: true,
		        get: function(){ return Base[key]; },
		        set: function(it){ Base[key] = it; }
		      });
		    });
		    proto.constructor = RegExp;
		    RegExp.prototype = proto;
		    $.hide($.g, 'RegExp', RegExp);
		  }
		  // 21.2.5.3 get RegExp.prototype.flags()
		  if(/./g.flags != 'g')$.setDesc(proto, 'flags', {
		    configurable: true,
		    get: __webpack_require__(79)(/^.*\/(\w*)$/, '$1')
		  });
		}
		__webpack_require__(89)(RegExp);
	
	/***/ },
	/* 55 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var $       = __webpack_require__(71)
		  , ctx     = __webpack_require__(86)
		  , cof     = __webpack_require__(72)
		  , $def    = __webpack_require__(73)
		  , assert  = __webpack_require__(77)
		  , $iter   = __webpack_require__(85)
		  , SPECIES = __webpack_require__(81)('species')
		  , RECORD  = __webpack_require__(76).safe('record')
		  , forOf   = $iter.forOf
		  , PROMISE = 'Promise'
		  , global  = $.g
		  , process = global.process
		  , asap    = process && process.nextTick || __webpack_require__(90).set
		  , P       = global[PROMISE]
		  , Base    = P
		  , isFunction     = $.isFunction
		  , isObject       = $.isObject
		  , assertFunction = assert.fn
		  , assertObject   = assert.obj
		  , test;
		
		// helpers
		function getConstructor(C){
		  var S = assertObject(C)[SPECIES];
		  return S != undefined ? S : C;
		}
		function isThenable(it){
		  var then;
		  if(isObject(it))then = it.then;
		  return isFunction(then) ? then : false;
		}
		function isUnhandled(promise){
		  var record = promise[RECORD]
		    , chain  = record.c
		    , i      = 0
		    , react;
		  if(record.h)return false;
		  while(chain.length > i){
		    react = chain[i++];
		    if(react.fail || !isUnhandled(react.P))return false;
		  } return true;
		}
		function notify(record, isReject){
		  var chain = record.c;
		  if(isReject || chain.length)asap(function(){
		    var promise = record.p
		      , value   = record.v
		      , ok      = record.s == 1
		      , i       = 0;
		    if(isReject && isUnhandled(promise)){
		      setTimeout(function(){
		        if(isUnhandled(promise)){
		          if(cof(process) == 'process'){
		            process.emit('unhandledRejection', value, promise);
		          } else if(global.console && isFunction(console.error)){
		            console.error('Unhandled promise rejection', value);
		          }
		        }
		      }, 1e3);
		    } else while(chain.length > i)!function(react){
		      var cb = ok ? react.ok : react.fail
		        , ret, then;
		      try {
		        if(cb){
		          if(!ok)record.h = true;
		          ret = cb === true ? value : cb(value);
		          if(ret === react.P){
		            react.rej(TypeError(PROMISE + '-chain cycle'));
		          } else if(then = isThenable(ret)){
		            then.call(ret, react.res, react.rej);
		          } else react.res(ret);
		        } else react.rej(value);
		      } catch(err){
		        react.rej(err);
		      }
		    }(chain[i++]);
		    chain.length = 0;
		  });
		}
		function $reject(value){
		  var record = this;
		  if(record.d)return;
		  record.d = true;
		  record = record.r || record; // unwrap
		  record.v = value;
		  record.s = 2;
		  notify(record, true);
		}
		function $resolve(value){
		  var record = this
		    , then, wrapper;
		  if(record.d)return;
		  record.d = true;
		  record = record.r || record; // unwrap
		  try {
		    if(then = isThenable(value)){
		      wrapper = {r: record, d: false}; // wrap
		      then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
		    } else {
		      record.v = value;
		      record.s = 1;
		      notify(record);
		    }
		  } catch(err){
		    $reject.call(wrapper || {r: record, d: false}, err); // wrap
		  }
		}
		
		// constructor polyfill
		if(!(isFunction(P) && isFunction(P.resolve) && P.resolve(test = new P(function(){})) == test)){
		  // 25.4.3.1 Promise(executor)
		  P = function Promise(executor){
		    assertFunction(executor);
		    var record = {
		      p: assert.inst(this, P, PROMISE),       // <- promise
		      c: [],                                  // <- chain
		      s: 0,                                   // <- state
		      d: false,                               // <- done
		      v: undefined,                           // <- value
		      h: false                                // <- handled rejection
		    };
		    $.hide(this, RECORD, record);
		    try {
		      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
		    } catch(err){
		      $reject.call(record, err);
		    }
		  };
		  $.mix(P.prototype, {
		    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
		    then: function then(onFulfilled, onRejected){
		      var S = assertObject(assertObject(this).constructor)[SPECIES];
		      var react = {
		        ok:   isFunction(onFulfilled) ? onFulfilled : true,
		        fail: isFunction(onRejected)  ? onRejected  : false
		      };
		      var promise = react.P = new (S != undefined ? S : P)(function(res, rej){
		        react.res = assertFunction(res);
		        react.rej = assertFunction(rej);
		      });
		      var record = this[RECORD];
		      record.c.push(react);
		      record.s && notify(record);
		      return promise;
		    },
		    // 25.4.5.1 Promise.prototype.catch(onRejected)
		    'catch': function(onRejected){
		      return this.then(undefined, onRejected);
		    }
		  });
		}
		
		// export
		$def($def.G + $def.W + $def.F * (P != Base), {Promise: P});
		cof.set(P, PROMISE);
		__webpack_require__(89)(P);
		
		// statics
		$def($def.S, PROMISE, {
		  // 25.4.4.5 Promise.reject(r)
		  reject: function reject(r){
		    return new (getConstructor(this))(function(res, rej){
		      rej(r);
		    });
		  },
		  // 25.4.4.6 Promise.resolve(x)
		  resolve: function resolve(x){
		    return isObject(x) && RECORD in x && $.getProto(x) === this.prototype
		      ? x : new (getConstructor(this))(function(res){
		        res(x);
		      });
		  }
		});
		$def($def.S + $def.F * !__webpack_require__(87)(function(iter){
		  P.all(iter)['catch'](function(){});
		}), PROMISE, {
		  // 25.4.4.1 Promise.all(iterable)
		  all: function all(iterable){
		    var C      = getConstructor(this)
		      , values = [];
		    return new C(function(res, rej){
		      forOf(iterable, false, values.push, values);
		      var remaining = values.length
		        , results   = Array(remaining);
		      if(remaining)$.each.call(values, function(promise, index){
		        C.resolve(promise).then(function(value){
		          results[index] = value;
		          --remaining || res(results);
		        }, rej);
		      });
		      else res(results);
		    });
		  },
		  // 25.4.4.4 Promise.race(iterable)
		  race: function race(iterable){
		    var C = getConstructor(this);
		    return new C(function(res, rej){
		      forOf(iterable, false, function(promise){
		        C.resolve(promise).then(res, rej);
		      });
		    });
		  }
		});
	
	/***/ },
	/* 56 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var strong = __webpack_require__(91);
		
		// 23.1 Map Objects
		__webpack_require__(92)('Map', {
		  // 23.1.3.6 Map.prototype.get(key)
		  get: function get(key){
		    var entry = strong.getEntry(this, key);
		    return entry && entry.v;
		  },
		  // 23.1.3.9 Map.prototype.set(key, value)
		  set: function set(key, value){
		    return strong.def(this, key === 0 ? 0 : key, value);
		  }
		}, strong, true);
	
	/***/ },
	/* 57 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var strong = __webpack_require__(91);
		
		// 23.2 Set Objects
		__webpack_require__(92)('Set', {
		  // 23.2.3.1 Set.prototype.add(value)
		  add: function add(value){
		    return strong.def(this, value = value === 0 ? 0 : value, value);
		  }
		}, strong);
	
	/***/ },
	/* 58 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var $         = __webpack_require__(71)
		  , weak      = __webpack_require__(93)
		  , leakStore = weak.leakStore
		  , ID        = weak.ID
		  , WEAK      = weak.WEAK
		  , has       = $.has
		  , isObject  = $.isObject
		  , isFrozen  = Object.isFrozen || $.core.Object.isFrozen
		  , tmp       = {};
		
		// 23.3 WeakMap Objects
		var WeakMap = __webpack_require__(92)('WeakMap', {
		  // 23.3.3.3 WeakMap.prototype.get(key)
		  get: function get(key){
		    if(isObject(key)){
		      if(isFrozen(key))return leakStore(this).get(key);
		      if(has(key, WEAK))return key[WEAK][this[ID]];
		    }
		  },
		  // 23.3.3.5 WeakMap.prototype.set(key, value)
		  set: function set(key, value){
		    return weak.def(this, key, value);
		  }
		}, weak, true, true);
		
		// IE11 WeakMap frozen keys fix
		if($.FW && new WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
		  $.each.call(['delete', 'has', 'get', 'set'], function(key){
		    var method = WeakMap.prototype[key];
		    WeakMap.prototype[key] = function(a, b){
		      // store frozen objects on leaky map
		      if(isObject(a) && isFrozen(a)){
		        var result = leakStore(this)[key](a, b);
		        return key == 'set' ? this : result;
		      // store all the rest on native weakmap
		      } return method.call(this, a, b);
		    };
		  });
		}
	
	/***/ },
	/* 59 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var weak = __webpack_require__(93);
		
		// 23.4 WeakSet Objects
		__webpack_require__(92)('WeakSet', {
		  // 23.4.3.1 WeakSet.prototype.add(value)
		  add: function add(value){
		    return weak.def(this, value, true);
		  }
		}, weak, false, true);
	
	/***/ },
	/* 60 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $         = __webpack_require__(71)
		  , $def      = __webpack_require__(73)
		  , setProto  = __webpack_require__(83)
		  , $iter     = __webpack_require__(85)
		  , ITER      = __webpack_require__(76).safe('iter')
		  , step      = $iter.step
		  , assert    = __webpack_require__(77)
		  , isObject  = $.isObject
		  , getDesc   = $.getDesc
		  , setDesc   = $.setDesc
		  , getProto  = $.getProto
		  , apply     = Function.apply
		  , assertObject  = assert.obj
		  , _isExtensible = Object.isExtensible || $.it;
		function Enumerate(iterated){
		  var keys = [], key;
		  for(key in iterated)keys.push(key);
		  $.set(this, ITER, {o: iterated, a: keys, i: 0});
		}
		$iter.create(Enumerate, 'Object', function(){
		  var iter = this[ITER]
		    , keys = iter.a
		    , key;
		  do {
		    if(iter.i >= keys.length)return step(1);
		  } while(!((key = keys[iter.i++]) in iter.o));
		  return step(0, key);
		});
		
		function wrap(fn){
		  return function(it){
		    assertObject(it);
		    try {
		      fn.apply(undefined, arguments);
		      return true;
		    } catch(e){
		      return false;
		    }
		  };
		}
		
		function get(target, propertyKey/*, receiver*/){
		  var receiver = arguments.length < 3 ? target : arguments[2]
		    , desc = getDesc(assertObject(target), propertyKey), proto;
		  if(desc)return $.has(desc, 'value')
		    ? desc.value
		    : desc.get === undefined
		      ? undefined
		      : desc.get.call(receiver);
		  return isObject(proto = getProto(target))
		    ? get(proto, propertyKey, receiver)
		    : undefined;
		}
		function set(target, propertyKey, V/*, receiver*/){
		  var receiver = arguments.length < 4 ? target : arguments[3]
		    , ownDesc  = getDesc(assertObject(target), propertyKey)
		    , existingDescriptor, proto;
		  if(!ownDesc){
		    if(isObject(proto = getProto(target))){
		      return set(proto, propertyKey, V, receiver);
		    }
		    ownDesc = $.desc(0);
		  }
		  if($.has(ownDesc, 'value')){
		    if(ownDesc.writable === false || !isObject(receiver))return false;
		    existingDescriptor = getDesc(receiver, propertyKey) || $.desc(0);
		    existingDescriptor.value = V;
		    setDesc(receiver, propertyKey, existingDescriptor);
		    return true;
		  }
		  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
		}
		
		var reflect = {
		  // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
		  apply: __webpack_require__(86)(Function.call, apply, 3),
		  // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
		  construct: function construct(target, argumentsList /*, newTarget*/){
		    var proto    = assert.fn(arguments.length < 3 ? target : arguments[2]).prototype
		      , instance = $.create(isObject(proto) ? proto : Object.prototype)
		      , result   = apply.call(target, instance, argumentsList);
		    return isObject(result) ? result : instance;
		  },
		  // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
		  defineProperty: wrap(setDesc),
		  // 26.1.4 Reflect.deleteProperty(target, propertyKey)
		  deleteProperty: function deleteProperty(target, propertyKey){
		    var desc = getDesc(assertObject(target), propertyKey);
		    return desc && !desc.configurable ? false : delete target[propertyKey];
		  },
		  // 26.1.5 Reflect.enumerate(target)
		  enumerate: function enumerate(target){
		    return new Enumerate(assertObject(target));
		  },
		  // 26.1.6 Reflect.get(target, propertyKey [, receiver])
		  get: get,
		  // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
		  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
		    return getDesc(assertObject(target), propertyKey);
		  },
		  // 26.1.8 Reflect.getPrototypeOf(target)
		  getPrototypeOf: function getPrototypeOf(target){
		    return getProto(assertObject(target));
		  },
		  // 26.1.9 Reflect.has(target, propertyKey)
		  has: function has(target, propertyKey){
		    return propertyKey in target;
		  },
		  // 26.1.10 Reflect.isExtensible(target)
		  isExtensible: function isExtensible(target){
		    return !!_isExtensible(assertObject(target));
		  },
		  // 26.1.11 Reflect.ownKeys(target)
		  ownKeys: __webpack_require__(94),
		  // 26.1.12 Reflect.preventExtensions(target)
		  preventExtensions: wrap(Object.preventExtensions || $.it),
		  // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
		  set: set
		};
		// 26.1.14 Reflect.setPrototypeOf(target, proto)
		if(setProto)reflect.setPrototypeOf = function setPrototypeOf(target, proto){
		  setProto.check(target, proto);
		  try {
		    setProto.set(target, proto);
		    return true;
		  } catch(e){
		    return false;
		  }
		};
		
		$def($def.G, {Reflect: {}});
		$def($def.S, 'Reflect', reflect);
	
	/***/ },
	/* 61 */
	/***/ function(module, exports, __webpack_require__) {
	
		// https://github.com/domenic/Array.prototype.includes
		var $def = __webpack_require__(73);
		$def($def.P, 'Array', {
		  includes: __webpack_require__(78)(true)
		});
		__webpack_require__(88)('includes');
	
	/***/ },
	/* 62 */
	/***/ function(module, exports, __webpack_require__) {
	
		// https://github.com/mathiasbynens/String.prototype.at
		var $def = __webpack_require__(73);
		$def($def.P, 'String', {
		  at: __webpack_require__(84)(true)
		});
	
	/***/ },
	/* 63 */
	/***/ function(module, exports, __webpack_require__) {
	
		// https://gist.github.com/kangax/9698100
		var $def = __webpack_require__(73);
		$def($def.S, 'RegExp', {
		  escape: __webpack_require__(79)(/([\\\-[\]{}()*+?.,^$|])/g, '\\$1', true)
		});
	
	/***/ },
	/* 64 */
	/***/ function(module, exports, __webpack_require__) {
	
		// https://gist.github.com/WebReflection/9353781
		var $       = __webpack_require__(71)
		  , $def    = __webpack_require__(73)
		  , ownKeys = __webpack_require__(94);
		
		$def($def.S, 'Object', {
		  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
		    var O      = $.toObject(object)
		      , result = {};
		    $.each.call(ownKeys(O), function(key){
		      $.setDesc(result, key, $.desc(0, $.getDesc(O, key)));
		    });
		    return result;
		  }
		});
	
	/***/ },
	/* 65 */
	/***/ function(module, exports, __webpack_require__) {
	
		// http://goo.gl/XkBrjD
		var $    = __webpack_require__(71)
		  , $def = __webpack_require__(73);
		function createObjectToArray(isEntries){
		  return function(object){
		    var O      = $.toObject(object)
		      , keys   = $.getKeys(O)
		      , length = keys.length
		      , i      = 0
		      , result = Array(length)
		      , key;
		    if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];
		    else while(length > i)result[i] = O[keys[i++]];
		    return result;
		  };
		}
		$def($def.S, 'Object', {
		  values:  createObjectToArray(false),
		  entries: createObjectToArray(true)
		});
	
	/***/ },
	/* 66 */
	/***/ function(module, exports, __webpack_require__) {
	
		// https://github.com/DavidBruant/Map-Set.prototype.toJSON
		var $def  = __webpack_require__(73)
		  , forOf = __webpack_require__(85).forOf;
		$def($def.P, 'Set', {
		  toJSON: function(){
		    var arr = [];
		    forOf(this, false, arr.push, arr);
		    return arr;
		  }
		});
	
	/***/ },
	/* 67 */
	/***/ function(module, exports, __webpack_require__) {
	
		// JavaScript 1.6 / Strawman array statics shim
		var $       = __webpack_require__(71)
		  , $def    = __webpack_require__(73)
		  , $Array  = $.core.Array || Array
		  , statics = {};
		function setStatics(keys, length){
		  $.each.call(keys.split(','), function(key){
		    if(length == undefined && key in $Array)statics[key] = $Array[key];
		    else if(key in [])statics[key] = __webpack_require__(86)(Function.call, [][key], length);
		  });
		}
		setStatics('pop,reverse,shift,keys,values,entries', 1);
		setStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
		setStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
		           'reduce,reduceRight,copyWithin,fill,turn');
		$def($def.S, 'Array', statics);
	
	/***/ },
	/* 68 */
	/***/ function(module, exports, __webpack_require__) {
	
		// ie9- setTimeout & setInterval additional parameters fix
		var $         = __webpack_require__(71)
		  , $def      = __webpack_require__(73)
		  , invoke    = __webpack_require__(74)
		  , partial   = __webpack_require__(95)
		  , navigator = $.g.navigator
		  , MSIE      = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
		function wrap(set){
		  return MSIE ? function(fn, time /*, ...args */){
		    return set(invoke(
		      partial,
		      [].slice.call(arguments, 2),
		      $.isFunction(fn) ? fn : Function(fn)
		    ), time);
		  } : set;
		}
		$def($def.G + $def.B + $def.F * MSIE, {
		  setTimeout:  wrap($.g.setTimeout),
		  setInterval: wrap($.g.setInterval)
		});
	
	/***/ },
	/* 69 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $def  = __webpack_require__(73)
		  , $task = __webpack_require__(90);
		$def($def.G + $def.B, {
		  setImmediate:   $task.set,
		  clearImmediate: $task.clear
		});
	
	/***/ },
	/* 70 */
	/***/ function(module, exports, __webpack_require__) {
	
		__webpack_require__(48);
		var $           = __webpack_require__(71)
		  , Iterators   = __webpack_require__(85).Iterators
		  , ITERATOR    = __webpack_require__(81)('iterator')
		  , ArrayValues = Iterators.Array
		  , NodeList    = $.g.NodeList;
		if($.FW && NodeList && !(ITERATOR in NodeList.prototype)){
		  $.hide(NodeList.prototype, ITERATOR, ArrayValues);
		}
		Iterators.NodeList = ArrayValues;
	
	/***/ },
	/* 71 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var global = typeof self != 'undefined' ? self : Function('return this')()
		  , core   = {}
		  , defineProperty = Object.defineProperty
		  , hasOwnProperty = {}.hasOwnProperty
		  , ceil  = Math.ceil
		  , floor = Math.floor
		  , max   = Math.max
		  , min   = Math.min;
		// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
		var DESC = !!function(){
		  try {
		    return defineProperty({}, 'a', {get: function(){ return 2; }}).a == 2;
		  } catch(e){ /* empty */ }
		}();
		var hide = createDefiner(1);
		// 7.1.4 ToInteger
		function toInteger(it){
		  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
		}
		function desc(bitmap, value){
		  return {
		    enumerable  : !(bitmap & 1),
		    configurable: !(bitmap & 2),
		    writable    : !(bitmap & 4),
		    value       : value
		  };
		}
		function simpleSet(object, key, value){
		  object[key] = value;
		  return object;
		}
		function createDefiner(bitmap){
		  return DESC ? function(object, key, value){
		    return $.setDesc(object, key, desc(bitmap, value)); // eslint-disable-line no-use-before-define
		  } : simpleSet;
		}
		
		function isObject(it){
		  return it !== null && (typeof it == 'object' || typeof it == 'function');
		}
		function isFunction(it){
		  return typeof it == 'function';
		}
		function assertDefined(it){
		  if(it == undefined)throw TypeError("Can't call method on  " + it);
		  return it;
		}
		
		var $ = module.exports = __webpack_require__(96)({
		  g: global,
		  core: core,
		  html: global.document && document.documentElement,
		  // http://jsperf.com/core-js-isobject
		  isObject:   isObject,
		  isFunction: isFunction,
		  it: function(it){
		    return it;
		  },
		  that: function(){
		    return this;
		  },
		  // 7.1.4 ToInteger
		  toInteger: toInteger,
		  // 7.1.15 ToLength
		  toLength: function(it){
		    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
		  },
		  toIndex: function(index, length){
		    index = toInteger(index);
		    return index < 0 ? max(index + length, 0) : min(index, length);
		  },
		  has: function(it, key){
		    return hasOwnProperty.call(it, key);
		  },
		  create:     Object.create,
		  getProto:   Object.getPrototypeOf,
		  DESC:       DESC,
		  desc:       desc,
		  getDesc:    Object.getOwnPropertyDescriptor,
		  setDesc:    defineProperty,
		  getKeys:    Object.keys,
		  getNames:   Object.getOwnPropertyNames,
		  getSymbols: Object.getOwnPropertySymbols,
		  // Dummy, fix for not array-like ES3 string in es5 module
		  assertDefined: assertDefined,
		  ES5Object: Object,
		  toObject: function(it){
		    return $.ES5Object(assertDefined(it));
		  },
		  hide: hide,
		  def: createDefiner(0),
		  set: global.Symbol ? simpleSet : hide,
		  mix: function(target, src){
		    for(var key in src)hide(target, key, src[key]);
		    return target;
		  },
		  each: [].forEach
		});
		if(typeof __e != 'undefined')__e = core;
		if(typeof __g != 'undefined')__g = global;
	
	/***/ },
	/* 72 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $        = __webpack_require__(71)
		  , TAG      = __webpack_require__(81)('toStringTag')
		  , toString = {}.toString;
		function cof(it){
		  return toString.call(it).slice(8, -1);
		}
		cof.classof = function(it){
		  var O, T;
		  return it == undefined ? it === undefined ? 'Undefined' : 'Null'
		    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T : cof(O);
		};
		cof.set = function(it, tag, stat){
		  if(it && !$.has(it = stat ? it : it.prototype, TAG))$.hide(it, TAG, tag);
		};
		module.exports = cof;
	
	/***/ },
	/* 73 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $          = __webpack_require__(71)
		  , global     = $.g
		  , core       = $.core
		  , isFunction = $.isFunction;
		function ctx(fn, that){
		  return function(){
		    return fn.apply(that, arguments);
		  };
		}
		global.core = core;
		// type bitmap
		$def.F = 1;  // forced
		$def.G = 2;  // global
		$def.S = 4;  // static
		$def.P = 8;  // proto
		$def.B = 16; // bind
		$def.W = 32; // wrap
		function $def(type, name, source){
		  var key, own, out, exp
		    , isGlobal = type & $def.G
		    , target   = isGlobal ? global : type & $def.S
		        ? global[name] : (global[name] || {}).prototype
		    , exports  = isGlobal ? core : core[name] || (core[name] = {});
		  if(isGlobal)source = name;
		  for(key in source){
		    // contains in native
		    own = !(type & $def.F) && target && key in target;
		    // export native or passed
		    out = (own ? target : source)[key];
		    // bind timers to global for call from export context
		    if(type & $def.B && own)exp = ctx(out, global);
		    else exp = type & $def.P && isFunction(out) ? ctx(Function.call, out) : out;
		    // extend global
		    if(target && !own){
		      if(isGlobal)target[key] = out;
		      else delete target[key] && $.hide(target, key, out);
		    }
		    // export
		    if(exports[key] != out)$.hide(exports, key, exp);
		  }
		}
		module.exports = $def;
	
	/***/ },
	/* 74 */
	/***/ function(module, exports, __webpack_require__) {
	
		// Fast apply
		// http://jsperf.lnkit.com/fast-apply/5
		module.exports = function(fn, args, that){
		  var un = that === undefined;
		  switch(args.length){
		    case 0: return un ? fn()
		                      : fn.call(that);
		    case 1: return un ? fn(args[0])
		                      : fn.call(that, args[0]);
		    case 2: return un ? fn(args[0], args[1])
		                      : fn.call(that, args[0], args[1]);
		    case 3: return un ? fn(args[0], args[1], args[2])
		                      : fn.call(that, args[0], args[1], args[2]);
		    case 4: return un ? fn(args[0], args[1], args[2], args[3])
		                      : fn.call(that, args[0], args[1], args[2], args[3]);
		    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])
		                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);
		  } return              fn.apply(that, args);
		};
	
	/***/ },
	/* 75 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		// 0 -> Array#forEach
		// 1 -> Array#map
		// 2 -> Array#filter
		// 3 -> Array#some
		// 4 -> Array#every
		// 5 -> Array#find
		// 6 -> Array#findIndex
		var $   = __webpack_require__(71)
		  , ctx = __webpack_require__(86);
		module.exports = function(TYPE){
		  var IS_MAP        = TYPE == 1
		    , IS_FILTER     = TYPE == 2
		    , IS_SOME       = TYPE == 3
		    , IS_EVERY      = TYPE == 4
		    , IS_FIND_INDEX = TYPE == 6
		    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX;
		  return function(callbackfn/*, that = undefined */){
		    var O      = Object($.assertDefined(this))
		      , self   = $.ES5Object(O)
		      , f      = ctx(callbackfn, arguments[1], 3)
		      , length = $.toLength(self.length)
		      , index  = 0
		      , result = IS_MAP ? Array(length) : IS_FILTER ? [] : undefined
		      , val, res;
		    for(;length > index; index++)if(NO_HOLES || index in self){
		      val = self[index];
		      res = f(val, index, O);
		      if(TYPE){
		        if(IS_MAP)result[index] = res;            // map
		        else if(res)switch(TYPE){
		          case 3: return true;                    // some
		          case 5: return val;                     // find
		          case 6: return index;                   // findIndex
		          case 2: result.push(val);               // filter
		        } else if(IS_EVERY)return false;          // every
		      }
		    }
		    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
		  };
		};
	
	/***/ },
	/* 76 */
	/***/ function(module, exports, __webpack_require__) {
	
		var sid = 0;
		function uid(key){
		  return 'Symbol(' + key + ')_' + (++sid + Math.random()).toString(36);
		}
		uid.safe = __webpack_require__(71).g.Symbol || uid;
		module.exports = uid;
	
	/***/ },
	/* 77 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $ = __webpack_require__(71);
		function assert(condition, msg1, msg2){
		  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);
		}
		assert.def = $.assertDefined;
		assert.fn = function(it){
		  if(!$.isFunction(it))throw TypeError(it + ' is not a function!');
		  return it;
		};
		assert.obj = function(it){
		  if(!$.isObject(it))throw TypeError(it + ' is not an object!');
		  return it;
		};
		assert.inst = function(it, Constructor, name){
		  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
		  return it;
		};
		module.exports = assert;
	
	/***/ },
	/* 78 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		// false -> Array#indexOf
		// true  -> Array#includes
		var $ = __webpack_require__(71);
		module.exports = function(IS_INCLUDES){
		  return function(el /*, fromIndex = 0 */){
		    var O      = $.toObject(this)
		      , length = $.toLength(O.length)
		      , index  = $.toIndex(arguments[1], length)
		      , value;
		    if(IS_INCLUDES && el != el)while(length > index){
		      value = O[index++];
		      if(value != value)return true;
		    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
		      if(O[index] === el)return IS_INCLUDES || index;
		    } return !IS_INCLUDES && -1;
		  };
		};
	
	/***/ },
	/* 79 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		module.exports = function(regExp, replace, isStatic){
		  var replacer = replace === Object(replace) ? function(part){
		    return replace[part];
		  } : replace;
		  return function(it){
		    return String(isStatic ? it : this).replace(regExp, replacer);
		  };
		};
	
	/***/ },
	/* 80 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $ = __webpack_require__(71);
		module.exports = function(object, el){
		  var O      = $.toObject(object)
		    , keys   = $.getKeys(O)
		    , length = keys.length
		    , index  = 0
		    , key;
		  while(length > index)if(O[key = keys[index++]] === el)return key;
		};
	
	/***/ },
	/* 81 */
	/***/ function(module, exports, __webpack_require__) {
	
		var global = __webpack_require__(71).g
		  , store  = {};
		module.exports = function(name){
		  return store[name] || (store[name] =
		    global.Symbol && global.Symbol[name] || __webpack_require__(76).safe('Symbol.' + name));
		};
	
	/***/ },
	/* 82 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $ = __webpack_require__(71);
		// 19.1.2.1 Object.assign(target, source, ...)
		/*eslint-disable no-unused-vars */
		module.exports = Object.assign || function assign(target, source){
		/*eslint-enable no-unused-vars */
		  var T = Object($.assertDefined(target))
		    , l = arguments.length
		    , i = 1;
		  while(l > i){
		    var S      = $.ES5Object(arguments[i++])
		      , keys   = $.getKeys(S)
		      , length = keys.length
		      , j      = 0
		      , key;
		    while(length > j)T[key = keys[j++]] = S[key];
		  }
		  return T;
		};
	
	/***/ },
	/* 83 */
	/***/ function(module, exports, __webpack_require__) {
	
		// Works with __proto__ only. Old v8 can't work with null proto objects.
		/*eslint-disable no-proto */
		var $      = __webpack_require__(71)
		  , assert = __webpack_require__(77);
		function check(O, proto){
		  assert.obj(O);
		  assert(proto === null || $.isObject(proto), proto, ": can't set as prototype!");
		}
		module.exports = {
		  set: Object.setPrototypeOf || ('__proto__' in {} // eslint-disable-line
		    ? function(buggy, set){
		        try {
		          set = __webpack_require__(86)(Function.call, $.getDesc(Object.prototype, '__proto__').set, 2);
		          set({}, []);
		        } catch(e){ buggy = true; }
		        return function setPrototypeOf(O, proto){
		          check(O, proto);
		          if(buggy)O.__proto__ = proto;
		          else set(O, proto);
		          return O;
		        };
		      }()
		    : undefined),
		  check: check
		};
	
	/***/ },
	/* 84 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		// true  -> String#at
		// false -> String#codePointAt
		var $ = __webpack_require__(71);
		module.exports = function(TO_STRING){
		  return function(pos){
		    var s = String($.assertDefined(this))
		      , i = $.toInteger(pos)
		      , l = s.length
		      , a, b;
		    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
		    a = s.charCodeAt(i);
		    return a < 0xd800 || a > 0xdbff || i + 1 === l
		      || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
		        ? TO_STRING ? s.charAt(i) : a
		        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
		  };
		};
	
	/***/ },
	/* 85 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var $                 = __webpack_require__(71)
		  , ctx               = __webpack_require__(86)
		  , cof               = __webpack_require__(72)
		  , $def              = __webpack_require__(73)
		  , assertObject      = __webpack_require__(77).obj
		  , SYMBOL_ITERATOR   = __webpack_require__(81)('iterator')
		  , FF_ITERATOR       = '@@iterator'
		  , Iterators         = {}
		  , IteratorPrototype = {};
		// Safari has byggy iterators w/o `next`
		var BUGGY = 'keys' in [] && !('next' in [].keys());
		// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
		setIterator(IteratorPrototype, $.that);
		function setIterator(O, value){
		  $.hide(O, SYMBOL_ITERATOR, value);
		  // Add iterator for FF iterator protocol
		  if(FF_ITERATOR in [])$.hide(O, FF_ITERATOR, value);
		}
		function defineIterator(Constructor, NAME, value, DEFAULT){
		  var proto = Constructor.prototype
		    , iter  = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT] || value;
		  // Define iterator
		  if($.FW)setIterator(proto, iter);
		  if(iter !== value){
		    var iterProto = $.getProto(iter.call(new Constructor));
		    // Set @@toStringTag to native iterators
		    cof.set(iterProto, NAME + ' Iterator', true);
		    // FF fix
		    if($.FW)$.has(proto, FF_ITERATOR) && setIterator(iterProto, $.that);
		  }
		  // Plug for library
		  Iterators[NAME] = iter;
		  // FF & v8 fix
		  Iterators[NAME + ' Iterator'] = $.that;
		  return iter;
		}
		function getIterator(it){
		  var Symbol  = $.g.Symbol
		    , ext     = it[Symbol && Symbol.iterator || FF_ITERATOR]
		    , getIter = ext || it[SYMBOL_ITERATOR] || Iterators[cof.classof(it)];
		  return assertObject(getIter.call(it));
		}
		function closeIterator(iterator){
		  var ret = iterator['return'];
		  if(ret !== undefined)assertObject(ret.call(iterator));
		}
		function stepCall(iterator, fn, value, entries){
		  try {
		    return entries ? fn(assertObject(value)[0], value[1]) : fn(value);
		  } catch(e){
		    closeIterator(iterator);
		    throw e;
		  }
		}
		var $iter = module.exports = {
		  BUGGY: BUGGY,
		  Iterators: Iterators,
		  prototype: IteratorPrototype,
		  step: function(done, value){
		    return {value: value, done: !!done};
		  },
		  stepCall: stepCall,
		  close: closeIterator,
		  is: function(it){
		    var O      = Object(it)
		      , Symbol = $.g.Symbol
		      , SYM    = Symbol && Symbol.iterator || FF_ITERATOR;
		    return SYM in O || SYMBOL_ITERATOR in O || $.has(Iterators, cof.classof(O));
		  },
		  get: getIterator,
		  set: setIterator,
		  create: function(Constructor, NAME, next, proto){
		    Constructor.prototype = $.create(proto || $iter.prototype, {next: $.desc(1, next)});
		    cof.set(Constructor, NAME + ' Iterator');
		  },
		  define: defineIterator,
		  std: function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE){
		    function createIter(kind){
		      return function(){
		        return new Constructor(this, kind);
		      };
		    }
		    $iter.create(Constructor, NAME, next);
		    var entries = createIter('key+value')
		      , values  = createIter('value')
		      , proto   = Base.prototype
		      , methods, key;
		    if(DEFAULT == 'value')values = defineIterator(Base, NAME, values, 'values');
		    else entries = defineIterator(Base, NAME, entries, 'entries');
		    if(DEFAULT){
		      methods = {
		        entries: entries,
		        keys:    IS_SET ? values : createIter('key'),
		        values:  values
		      };
		      $def($def.P + $def.F * BUGGY, NAME, methods);
		      if(FORCE)for(key in methods){
		        if(!(key in proto))$.hide(proto, key, methods[key]);
		      }
		    }
		  },
		  forOf: function(iterable, entries, fn, that){
		    var iterator = getIterator(iterable)
		      , f = ctx(fn, that, entries ? 2 : 1)
		      , step;
		    while(!(step = iterator.next()).done){
		      if(stepCall(iterator, f, step.value, entries) === false){
		        return closeIterator(iterator);
		      }
		    }
		  }
		};
	
	/***/ },
	/* 86 */
	/***/ function(module, exports, __webpack_require__) {
	
		// Optional / simple context binding
		var assertFunction = __webpack_require__(77).fn;
		module.exports = function(fn, that, length){
		  assertFunction(fn);
		  if(~length && that === undefined)return fn;
		  switch(length){
		    case 1: return function(a){
		      return fn.call(that, a);
		    };
		    case 2: return function(a, b){
		      return fn.call(that, a, b);
		    };
		    case 3: return function(a, b, c){
		      return fn.call(that, a, b, c);
		    };
		  } return function(/* ...args */){
		      return fn.apply(that, arguments);
		    };
		};
	
	/***/ },
	/* 87 */
	/***/ function(module, exports, __webpack_require__) {
	
		var SYMBOL_ITERATOR = __webpack_require__(81)('iterator')
		  , SAFE_CLOSING    = false;
		try {
		  var riter = [7][SYMBOL_ITERATOR]();
		  riter['return'] = function(){ SAFE_CLOSING = true; };
		  Array.from(riter, function(){ throw 2; });
		} catch(e){ /* empty */ }
		module.exports = function(exec){
		  if(!SAFE_CLOSING)return false;
		  var safe = false;
		  try {
		    var arr  = [7]
		      , iter = arr[SYMBOL_ITERATOR]();
		    iter.next = function(){ safe = true; };
		    arr[SYMBOL_ITERATOR] = function(){ return iter; };
		    exec(arr);
		  } catch(e){ /* empty */ }
		  return safe;
		};
	
	/***/ },
	/* 88 */
	/***/ function(module, exports, __webpack_require__) {
	
		// 22.1.3.31 Array.prototype[@@unscopables]
		var $           = __webpack_require__(71)
		  , UNSCOPABLES = __webpack_require__(81)('unscopables');
		if($.FW && !(UNSCOPABLES in []))$.hide(Array.prototype, UNSCOPABLES, {});
		module.exports = function(key){
		  if($.FW)[][UNSCOPABLES][key] = true;
		};
	
	/***/ },
	/* 89 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $ = __webpack_require__(71);
		module.exports = function(C){
		  if($.DESC && $.FW)$.setDesc(C, __webpack_require__(81)('species'), {
		    configurable: true,
		    get: $.that
		  });
		};
	
	/***/ },
	/* 90 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var $      = __webpack_require__(71)
		  , ctx    = __webpack_require__(86)
		  , cof    = __webpack_require__(72)
		  , invoke = __webpack_require__(74)
		  , global             = $.g
		  , isFunction         = $.isFunction
		  , html               = $.html
		  , document           = global.document
		  , process            = global.process
		  , setTask            = global.setImmediate
		  , clearTask          = global.clearImmediate
		  , postMessage        = global.postMessage
		  , addEventListener   = global.addEventListener
		  , MessageChannel     = global.MessageChannel
		  , counter            = 0
		  , queue              = {}
		  , ONREADYSTATECHANGE = 'onreadystatechange'
		  , defer, channel, port;
		function run(){
		  var id = +this;
		  if($.has(queue, id)){
		    var fn = queue[id];
		    delete queue[id];
		    fn();
		  }
		}
		function listner(event){
		  run.call(event.data);
		}
		// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
		if(!isFunction(setTask) || !isFunction(clearTask)){
		  setTask = function(fn){
		    var args = [], i = 1;
		    while(arguments.length > i)args.push(arguments[i++]);
		    queue[++counter] = function(){
		      invoke(isFunction(fn) ? fn : Function(fn), args);
		    };
		    defer(counter);
		    return counter;
		  };
		  clearTask = function(id){
		    delete queue[id];
		  };
		  // Node.js 0.8-
		  if(cof(process) == 'process'){
		    defer = function(id){
		      process.nextTick(ctx(run, id, 1));
		    };
		  // Modern browsers, skip implementation for WebWorkers
		  // IE8 has postMessage, but it's sync & typeof its postMessage is object
		  } else if(addEventListener && isFunction(postMessage) && !global.importScripts){
		    defer = function(id){
		      postMessage(id, '*');
		    };
		    addEventListener('message', listner, false);
		  // WebWorkers
		  } else if(isFunction(MessageChannel)){
		    channel = new MessageChannel;
		    port    = channel.port2;
		    channel.port1.onmessage = listner;
		    defer = ctx(port.postMessage, port, 1);
		  // IE8-
		  } else if(document && ONREADYSTATECHANGE in document.createElement('script')){
		    defer = function(id){
		      html.appendChild(document.createElement('script'))[ONREADYSTATECHANGE] = function(){
		        html.removeChild(this);
		        run.call(id);
		      };
		    };
		  // Rest old browsers
		  } else {
		    defer = function(id){
		      setTimeout(ctx(run, id, 1), 0);
		    };
		  }
		}
		module.exports = {
		  set:   setTask,
		  clear: clearTask
		};
	
	/***/ },
	/* 91 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var $        = __webpack_require__(71)
		  , ctx      = __webpack_require__(86)
		  , safe     = __webpack_require__(76).safe
		  , assert   = __webpack_require__(77)
		  , $iter    = __webpack_require__(85)
		  , has      = $.has
		  , set      = $.set
		  , isObject = $.isObject
		  , hide     = $.hide
		  , step     = $iter.step
		  , isFrozen = Object.isFrozen || $.core.Object.isFrozen
		  , ID       = safe('id')
		  , O1       = safe('O1')
		  , LAST     = safe('last')
		  , FIRST    = safe('first')
		  , ITER     = safe('iter')
		  , SIZE     = $.DESC ? safe('size') : 'size'
		  , id       = 0;
		
		function fastKey(it, create){
		  // return primitive with prefix
		  if(!isObject(it))return (typeof it == 'string' ? 'S' : 'P') + it;
		  // can't set id to frozen object
		  if(isFrozen(it))return 'F';
		  if(!has(it, ID)){
		    // not necessary to add id
		    if(!create)return 'E';
		    // add missing object id
		    hide(it, ID, ++id);
		  // return object id with prefix
		  } return 'O' + it[ID];
		}
		
		function getEntry(that, key){
		  // fast case
		  var index = fastKey(key), entry;
		  if(index != 'F')return that[O1][index];
		  // frozen object case
		  for(entry = that[FIRST]; entry; entry = entry.n){
		    if(entry.k == key)return entry;
		  }
		}
		
		module.exports = {
		  getConstructor: function(NAME, IS_MAP, ADDER){
		    function C(iterable){
		      var that = assert.inst(this, C, NAME);
		      set(that, O1, $.create(null));
		      set(that, SIZE, 0);
		      set(that, LAST, undefined);
		      set(that, FIRST, undefined);
		      if(iterable != undefined)$iter.forOf(iterable, IS_MAP, that[ADDER], that);
		    }
		    $.mix(C.prototype, {
		      // 23.1.3.1 Map.prototype.clear()
		      // 23.2.3.2 Set.prototype.clear()
		      clear: function clear(){
		        for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){
		          entry.r = true;
		          if(entry.p)entry.p = entry.p.n = undefined;
		          delete data[entry.i];
		        }
		        that[FIRST] = that[LAST] = undefined;
		        that[SIZE] = 0;
		      },
		      // 23.1.3.3 Map.prototype.delete(key)
		      // 23.2.3.4 Set.prototype.delete(value)
		      'delete': function(key){
		        var that  = this
		          , entry = getEntry(that, key);
		        if(entry){
		          var next = entry.n
		            , prev = entry.p;
		          delete that[O1][entry.i];
		          entry.r = true;
		          if(prev)prev.n = next;
		          if(next)next.p = prev;
		          if(that[FIRST] == entry)that[FIRST] = next;
		          if(that[LAST] == entry)that[LAST] = prev;
		          that[SIZE]--;
		        } return !!entry;
		      },
		      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
		      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
		      forEach: function forEach(callbackfn /*, that = undefined */){
		        var f = ctx(callbackfn, arguments[1], 3)
		          , entry;
		        while(entry = entry ? entry.n : this[FIRST]){
		          f(entry.v, entry.k, this);
		          // revert to the last existing entry
		          while(entry && entry.r)entry = entry.p;
		        }
		      },
		      // 23.1.3.7 Map.prototype.has(key)
		      // 23.2.3.7 Set.prototype.has(value)
		      has: function has(key){
		        return !!getEntry(this, key);
		      }
		    });
		    if($.DESC)$.setDesc(C.prototype, 'size', {
		      get: function(){
		        return assert.def(this[SIZE]);
		      }
		    });
		    return C;
		  },
		  def: function(that, key, value){
		    var entry = getEntry(that, key)
		      , prev, index;
		    // change existing entry
		    if(entry){
		      entry.v = value;
		    // create new entry
		    } else {
		      that[LAST] = entry = {
		        i: index = fastKey(key, true), // <- index
		        k: key,                        // <- key
		        v: value,                      // <- value
		        p: prev = that[LAST],          // <- previous entry
		        n: undefined,                  // <- next entry
		        r: false                       // <- removed
		      };
		      if(!that[FIRST])that[FIRST] = entry;
		      if(prev)prev.n = entry;
		      that[SIZE]++;
		      // add to index
		      if(index != 'F')that[O1][index] = entry;
		    } return that;
		  },
		  getEntry: getEntry,
		  getIterConstructor: function(){
		    return function(iterated, kind){
		      set(this, ITER, {o: iterated, k: kind});
		    };
		  },
		  next: function(){
		    var iter  = this[ITER]
		      , kind  = iter.k
		      , entry = iter.l;
		    // revert to the last existing entry
		    while(entry && entry.r)entry = entry.p;
		    // get next entry
		    if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){
		      // or finish the iteration
		      iter.o = undefined;
		      return step(1);
		    }
		    // return step by kind
		    if(kind == 'key'  )return step(0, entry.k);
		    if(kind == 'value')return step(0, entry.v);
		    return step(0, [entry.k, entry.v]);
		  }
		};
	
	/***/ },
	/* 92 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var $     = __webpack_require__(71)
		  , $def  = __webpack_require__(73)
		  , $iter = __webpack_require__(85)
		  , assertInstance = __webpack_require__(77).inst;
		
		module.exports = function(NAME, methods, common, IS_MAP, isWeak){
		  var Base  = $.g[NAME]
		    , C     = Base
		    , ADDER = IS_MAP ? 'set' : 'add'
		    , proto = C && C.prototype
		    , O     = {};
		  function fixMethod(KEY, CHAIN){
		    var method = proto[KEY];
		    if($.FW)proto[KEY] = function(a, b){
		      var result = method.call(this, a === 0 ? 0 : a, b);
		      return CHAIN ? this : result;
		    };
		  }
		  if(!$.isFunction(C) || !(isWeak || !$iter.BUGGY && proto.forEach && proto.entries)){
		    // create collection constructor
		    C = common.getConstructor(NAME, IS_MAP, ADDER);
		    $.mix(C.prototype, methods);
		  } else {
		    var inst  = new C
		      , chain = inst[ADDER](isWeak ? {} : -0, 1)
		      , buggyZero;
		    // wrap for init collections from iterable
		    if(!__webpack_require__(87)(function(iter){ new C(iter); })){ // eslint-disable-line no-new
		      C = function(iterable){
		        assertInstance(this, C, NAME);
		        var that = new Base;
		        if(iterable != undefined)$iter.forOf(iterable, IS_MAP, that[ADDER], that);
		        return that;
		      };
		      C.prototype = proto;
		      if($.FW)proto.constructor = C;
		    }
		    isWeak || inst.forEach(function(val, key){
		      buggyZero = 1 / key === -Infinity;
		    });
		    // fix converting -0 key to +0
		    if(buggyZero){
		      fixMethod('delete');
		      fixMethod('has');
		      IS_MAP && fixMethod('get');
		    }
		    // + fix .add & .set for chaining
		    if(buggyZero || chain !== inst)fixMethod(ADDER, true);
		  }
		
		  __webpack_require__(72).set(C, NAME);
		  __webpack_require__(89)(C);
		
		  O[NAME] = C;
		  $def($def.G + $def.W + $def.F * (C != Base), O);
		
		  // add .keys, .values, .entries, [@@iterator]
		  // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
		  if(!isWeak)$iter.std(
		    C, NAME,
		    common.getIterConstructor(), common.next,
		    IS_MAP ? 'key+value' : 'value' , !IS_MAP, true
		  );
		
		  return C;
		};
	
	/***/ },
	/* 93 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var $         = __webpack_require__(71)
		  , safe      = __webpack_require__(76).safe
		  , assert    = __webpack_require__(77)
		  , forOf     = __webpack_require__(85).forOf
		  , _has      = $.has
		  , isObject  = $.isObject
		  , hide      = $.hide
		  , isFrozen  = Object.isFrozen || $.core.Object.isFrozen
		  , id        = 0
		  , ID        = safe('id')
		  , WEAK      = safe('weak')
		  , LEAK      = safe('leak')
		  , method    = __webpack_require__(75)
		  , find      = method(5)
		  , findIndex = method(6);
		function findFrozen(store, key){
		  return find.call(store.array, function(it){
		    return it[0] === key;
		  });
		}
		// fallback for frozen keys
		function leakStore(that){
		  return that[LEAK] || hide(that, LEAK, {
		    array: [],
		    get: function(key){
		      var entry = findFrozen(this, key);
		      if(entry)return entry[1];
		    },
		    has: function(key){
		      return !!findFrozen(this, key);
		    },
		    set: function(key, value){
		      var entry = findFrozen(this, key);
		      if(entry)entry[1] = value;
		      else this.array.push([key, value]);
		    },
		    'delete': function(key){
		      var index = findIndex.call(this.array, function(it){
		        return it[0] === key;
		      });
		      if(~index)this.array.splice(index, 1);
		      return !!~index;
		    }
		  })[LEAK];
		}
		
		module.exports = {
		  getConstructor: function(NAME, IS_MAP, ADDER){
		    function C(iterable){
		      $.set(assert.inst(this, C, NAME), ID, id++);
		      if(iterable != undefined)forOf(iterable, IS_MAP, this[ADDER], this);
		    }
		    $.mix(C.prototype, {
		      // 23.3.3.2 WeakMap.prototype.delete(key)
		      // 23.4.3.3 WeakSet.prototype.delete(value)
		      'delete': function(key){
		        if(!isObject(key))return false;
		        if(isFrozen(key))return leakStore(this)['delete'](key);
		        return _has(key, WEAK) && _has(key[WEAK], this[ID]) && delete key[WEAK][this[ID]];
		      },
		      // 23.3.3.4 WeakMap.prototype.has(key)
		      // 23.4.3.4 WeakSet.prototype.has(value)
		      has: function has(key){
		        if(!isObject(key))return false;
		        if(isFrozen(key))return leakStore(this).has(key);
		        return _has(key, WEAK) && _has(key[WEAK], this[ID]);
		      }
		    });
		    return C;
		  },
		  def: function(that, key, value){
		    if(isFrozen(assert.obj(key))){
		      leakStore(that).set(key, value);
		    } else {
		      _has(key, WEAK) || hide(key, WEAK, {});
		      key[WEAK][that[ID]] = value;
		    } return that;
		  },
		  leakStore: leakStore,
		  WEAK: WEAK,
		  ID: ID
		};
	
	/***/ },
	/* 94 */
	/***/ function(module, exports, __webpack_require__) {
	
		var $            = __webpack_require__(71)
		  , assertObject = __webpack_require__(77).obj;
		module.exports = function ownKeys(it){
		  assertObject(it);
		  return $.getSymbols ? $.getNames(it).concat($.getSymbols(it)) : $.getNames(it);
		};
	
	/***/ },
	/* 95 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		var $      = __webpack_require__(71)
		  , invoke = __webpack_require__(74)
		  , assertFunction = __webpack_require__(77).fn;
		module.exports = function(/* ...pargs */){
		  var fn     = assertFunction(this)
		    , length = arguments.length
		    , pargs  = Array(length)
		    , i      = 0
		    , _      = $.path._
		    , holder = false;
		  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
		  return function(/* ...args */){
		    var that    = this
		      , _length = arguments.length
		      , j = 0, k = 0, args;
		    if(!holder && !_length)return invoke(fn, pargs, that);
		    args = pargs.slice();
		    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
		    while(_length > k)args.push(arguments[k++]);
		    return invoke(fn, args, that);
		  };
		};
	
	/***/ },
	/* 96 */
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = function($){
		  $.FW   = true;
		  $.path = $.g;
		  return $;
		};
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=delta.full.js.map

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(88).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(87).setImmediate, __webpack_require__(87).clearImmediate))

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            currentQueue[queueIndex].run();
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (!draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define(factory);
		else if(typeof exports === 'object')
			exports["Graph"] = factory();
		else
			root["Graph"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ({
	
	/***/ 0:
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = __webpack_require__(90);
	
	
	/***/ },
	
	/***/ 11:
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		//  ////////////////////////////////////////////////////////////////////////////////////////////////
		//  // Symbols for private members /////////////////////////////////////////////////////////////////
		//  ////////////////////////////////////////////////////////////////////////////////////////////////
		
		window.__graphjs__private__ = window.__graphjs__private__ || {};
		
		var _options = window.__graphjs__private__._options || Symbol("options");
		exports._options = _options;
		var _vertices = window.__graphjs__private__._vertices || Symbol("vertices");
		exports._vertices = _vertices;
		var _edges = window.__graphjs__private__._edges || Symbol("edges");
		exports._edges = _edges;
		var _reverseEdges = window.__graphjs__private__._reverseEdges || Symbol("reverse edges");
		exports._reverseEdges = _reverseEdges;
		var _sources = window.__graphjs__private__._sources || Symbol("sources");
		exports._sources = _sources;
		var _sinks = window.__graphjs__private__._sinks || Symbol("sinks");
		exports._sinks = _sinks;
		var _edgeCount = window.__graphjs__private__._edgeCount || Symbol("edge count");
		exports._edgeCount = _edgeCount;
		var _extractTwoArgs = window.__graphjs__private__._extractTwoArgs || Symbol("extract ([a, b]) or (a, b) arguments");
		exports._extractTwoArgs = _extractTwoArgs;
		var _extractThreeArgs = window.__graphjs__private__._extractThreeArgs || Symbol("extract ([[a, b], c]), ([a, b], c) or (a, b, c) arguments");
		exports._extractThreeArgs = _extractThreeArgs;
		var _listeners = window.__graphjs__private__._listeners || Symbol("listeners");
		exports._listeners = _listeners;
		var _trigger = window.__graphjs__private__._trigger || Symbol("trigger");
		exports._trigger = _trigger;
		var _verticesFrom = window.__graphjs__private__._verticesFrom || Symbol("vertices from");
		exports._verticesFrom = _verticesFrom;
		var _verticesTo = window.__graphjs__private__._verticesTo || Symbol("vertices to");
		exports._verticesTo = _verticesTo;
		var _edgesFrom = window.__graphjs__private__._edgesFrom || Symbol("edges from");
		exports._edgesFrom = _edgesFrom;
		var _edgesTo = window.__graphjs__private__._edgesTo || Symbol("edges to");
		exports._edgesTo = _edgesTo;
		var _verticesWithPathTo = window.__graphjs__private__._verticesWithPathTo || Symbol("vertices with path to");
		exports._verticesWithPathTo = _verticesWithPathTo;
		var _verticesWithPathFrom = window.__graphjs__private__._verticesWithPathFrom || Symbol("vertices with path from");
		exports._verticesWithPathFrom = _verticesWithPathFrom;
		var _paths = window.__graphjs__private__._paths || Symbol("paths");
		exports._paths = _paths;
		var _expectVertices = window.__graphjs__private__._expectVertices || Symbol("expect vertices");
		exports._expectVertices = _expectVertices;
		var _expectVerticesAbsent = window.__graphjs__private__._expectVerticesAbsent || Symbol("expect vertex absent");
		exports._expectVerticesAbsent = _expectVerticesAbsent;
		var _expectEdges = window.__graphjs__private__._expectEdges || Symbol("expect edge");
		exports._expectEdges = _expectEdges;
		var _expectEdgesAbsent = window.__graphjs__private__._expectEdgesAbsent || Symbol("expect edge absent");
		exports._expectEdgesAbsent = _expectEdgesAbsent;
		var _expectNoConnectedEdges = window.__graphjs__private__._expectNoConnectedEdges || Symbol("expect no connected edges");
		
		exports._expectNoConnectedEdges = _expectNoConnectedEdges;
		Object.assign(window.__graphjs__private__, {
			_options: _options,
			_vertices: _vertices,
			_edges: _edges,
			_reverseEdges: _reverseEdges,
			_sources: _sources,
			_sinks: _sinks,
			_edgeCount: _edgeCount,
			_extractTwoArgs: _extractTwoArgs,
			_extractThreeArgs: _extractThreeArgs,
			_listeners: _listeners,
			_trigger: _trigger,
			_verticesFrom: _verticesFrom,
			_verticesTo: _verticesTo,
			_edgesFrom: _edgesFrom,
			_edgesTo: _edgesTo,
			_verticesWithPathTo: _verticesWithPathTo,
			_verticesWithPathFrom: _verticesWithPathFrom,
			_paths: _paths,
			_expectVertices: _expectVertices,
			_expectVerticesAbsent: _expectVerticesAbsent,
			_expectEdges: _expectEdges,
			_expectEdgesAbsent: _expectEdgesAbsent,
			_expectNoConnectedEdges: _expectNoConnectedEdges
		});
	
	/***/ },
	
	/***/ 90:
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
		
		var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
		    property = _x2,
		    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
		
		//  ////////////////////////////////////////////////////////////////////////////////////////////////
		//  // Graph.GraphOO ///////////////////////////////////////////////////////////////////////////////
		//  ////////////////////////////////////////////////////////////////////////////////////////////////
		
		exports["default"] = addGraphOO;
		
		function _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }
		
		var _options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges = __webpack_require__(11);
		
		function addGraphOO(Graph) {
		
			var _vertexObjects = Symbol("vertex objects");
			var _edgeObjects = Symbol("edge objects");
			var _init = Symbol("init");
		
			/**
		  * @class Graph.GraphOO
		  * @extends Graph
		  * @classdesc A subclass of Graph, in which vertices and edges are represented by smart objects.
		  *            `GraphOO` instances are fully backwards-compatible, and can stand in for `Graph`
		  *            instances in any context.
		  * @see {@link Graph}
		  */
			return Graph.GraphOO = (function (_Graph) {
				function GraphOO() {
					_classCallCheck(this, GraphOO);
		
					if (_Graph != null) {
						_Graph.apply(this, arguments);
					}
				}
		
				_inherits(GraphOO, _Graph);
		
				_createClass(GraphOO, [{
					key: _init,
					value: function () {
						var _this2 = this;
		
						if (!this[_vertexObjects]) {
							(function () {
								_this2[_vertexObjects] = new Map();
								_this2[_edgeObjects] = new Map();
		
								var thisGraph = _this2;
		
								/**
		       * @class Graph.GraphOO#Vertex
		       * @classdesc A class for representing vertices in a `GraphOO` instance.
		       */
								var VertexSuperclass = _this2[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._options].VertexSuperclass || Object;
								var vertexSuperArguments = _this2[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._options].vertexSuperArguments || function () {
									for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
										args[_key] = arguments[_key];
									}
		
									return args;
								};
								_this2.Vertex = (function (_VertexSuperclass) {
									function Vertex(key, value) {
										_classCallCheck(this, Vertex);
		
										_get(Object.getPrototypeOf(Vertex.prototype), "constructor", this).apply(this, vertexSuperArguments(key, value));
										this[0] = key;
										this[1] = value;
										if (!thisGraph[_vertexObjects].has(key)) {
											thisGraph[_vertexObjects].set(key, this);
											thisGraph.addNewVertex(key, value);
										}
									}
		
									_inherits(Vertex, _VertexSuperclass);
		
									_createClass(Vertex, [{
										key: "length",
										get: function () {
											return 2;
										}
									}, {
										key: Symbol.iterator,
										value: function () {
											var marked6$0 = [iterator].map(regeneratorRuntime.mark);
		
											// overly verbose because jsdoc doesn't parse *[Symbol.iterator]() notation
											function iterator() {
												return regeneratorRuntime.wrap(function iterator$(context$7$0) {
													while (1) switch (context$7$0.prev = context$7$0.next) {
														case 0:
															context$7$0.next = 2;
															return this[0];
		
														case 2:
															context$7$0.next = 4;
															return this[1];
		
														case 4:
														case "end":
															return context$7$0.stop();
													}
												}, marked6$0[0], this);
											}
											return iterator.apply(this);
										}
									}, {
										key: "graph",
										get: function () {
											return thisGraph;
										}
									}, {
										key: "key",
										get: function () {
											return this[0];
										}
									}, {
										key: "value",
										get: function () {
											return this[1];
										},
										set: function (value) {
											return this.set(value);
										}
									}, {
										key: "set",
										value: function set(value) {
											return thisGraph.setVertex(this.key, value);
										}
									}, {
										key: "remove",
										value: function remove() {
											return thisGraph.removeVertex(this.key);
										}
									}, {
										key: "destroy",
										value: function destroy() {
											return thisGraph.destroyVertex(this.key);
										}
									}, {
										key: "verticesFrom",
										value: function verticesFrom() {
											return thisGraph.verticesFrom(this.key);
										}
									}, {
										key: "verticesTo",
										value: function verticesTo() {
											return thisGraph.verticesTo(this.key);
										}
									}, {
										key: "edgesFrom",
										value: function edgesFrom() {
											return thisGraph.edgesFrom(this.key);
										}
									}, {
										key: "edgesTo",
										value: function edgesTo() {
											return thisGraph.edgesTo(this.key);
										}
									}, {
										key: "verticesWithPathFrom",
										value: function verticesWithPathFrom() {
											return thisGraph.verticesWithPathFrom(this.key);
										}
									}, {
										key: "verticesWithPathTo",
										value: function verticesWithPathTo() {
											return thisGraph.verticesWithPathTo(this.key);
										}
									}, {
										key: "pathTo",
										value: function pathTo(to) {
											return thisGraph.path(this.key, to);
										}
									}, {
										key: "pathFrom",
										value: function pathFrom(from) {
											return thisGraph.path(from, this.key);
										}
									}, {
										key: "pathsTo",
										value: function pathsTo(to) {
											return thisGraph.paths(this.key, to);
										}
									}, {
										key: "pathsFrom",
										value: function pathsFrom(from) {
											return thisGraph.paths(from, this.key);
										}
									}, {
										key: "hasPathTo",
										value: function hasPathTo(to) {
											return thisGraph.hasPath(this.key, to);
										}
									}, {
										key: "hasPathFrom",
										value: function hasPathFrom(from) {
											return thisGraph.hasPath(from, this.key);
										}
									}, {
										key: "outDegree",
										value: function outDegree() {
											return thisGraph.outDegree(this.key);
										}
									}, {
										key: "inDegree",
										value: function inDegree() {
											return thisGraph.inDegree(this.key);
										}
									}, {
										key: "degree",
										value: function degree() {
											return thisGraph.degree(this.key);
										}
									}]);
		
									return Vertex;
								})(VertexSuperclass);
		
								/**
		       * @class Graph.GraphOO#Edge
		       * @classdesc A class for representing edges in a `GraphOO` instance.
		       */
								var EdgeSuperclass = _this2[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._options].EdgeSuperclass || Object;
								var edgeSuperArguments = _this2[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._options].edgeSuperArguments || function () {
									for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
										args[_key2] = arguments[_key2];
									}
		
									return args;
								};
								_this2.Edge = (function (_EdgeSuperclass) {
									function Edge(from, to, value) {
										_classCallCheck(this, Edge);
		
										_get(Object.getPrototypeOf(Edge.prototype), "constructor", this).apply(this, edgeSuperArguments(from, to, value));
										this[0] = [from, to];
										this[1] = value;
										if (!thisGraph[_edgeObjects].has(from)) {
											thisGraph[_edgeObjects].set(from, new Map());
										}
										if (!thisGraph[_edgeObjects].get(from).has(to)) {
											thisGraph[_edgeObjects].get(from).set(to, this);
											thisGraph.addNewEdge(from, to, value);
										}
										this._source = thisGraph.vertex(from);
										this._target = thisGraph.vertex(to);
									}
		
									_inherits(Edge, _EdgeSuperclass);
		
									_createClass(Edge, [{
										key: "length",
										get: function () {
											return 2;
										}
									}, {
										key: Symbol.iterator,
										value: function () {
											var marked6$0 = [iterator].map(regeneratorRuntime.mark);
		
											// overly verbose because jsdoc doesn't parse *[Symbol.iterator]() notation
											function iterator() {
												return regeneratorRuntime.wrap(function iterator$(context$7$0) {
													while (1) switch (context$7$0.prev = context$7$0.next) {
														case 0:
															context$7$0.next = 2;
															return this[0];
		
														case 2:
															context$7$0.next = 4;
															return this[1];
		
														case 4:
														case "end":
															return context$7$0.stop();
													}
												}, marked6$0[0], this);
											}
											return iterator.apply(this);
										}
									}, {
										key: "graph",
										get: function () {
											return thisGraph;
										}
									}, {
										key: "key",
										get: function () {
											return this[0];
										}
									}, {
										key: "from",
										get: function () {
											return this[0][0];
										}
									}, {
										key: "to",
										get: function () {
											return this[0][1];
										}
									}, {
										key: "value",
										get: function () {
											return this[1];
										},
										set: function (value) {
											return this.set(value);
										}
									}, {
										key: "source",
										get: function () {
											return this._source;
										}
									}, {
										key: "target",
										get: function () {
											return this._target;
										}
									}, {
										key: "set",
										value: function set(value) {
											return thisGraph.setEdge(this.key, value);
										}
									}, {
										key: "remove",
										value: function remove() {
											return thisGraph.removeExistingEdge(this.key);
										}
									}]);
		
									return Edge;
								})(EdgeSuperclass);
							})();
						}
					}
				}, {
					key: "addNewVertex",
		
					////////////////////////////////////////
					////////// Overriding Methods //////////
					////////////////////////////////////////
		
					value: function addNewVertex(key, value) {
						this[_init]();
		
						var _Graph$_extractTwoArgs = Graph[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._extractTwoArgs](key, value);
		
						var _Graph$_extractTwoArgs2 = _slicedToArray(_Graph$_extractTwoArgs, 2);
		
						key = _Graph$_extractTwoArgs2[0];
						value = _Graph$_extractTwoArgs2[1];
		
						this[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._expectVerticesAbsent](key);
						if (!this[_vertexObjects].has(key)) {
							this[_vertexObjects].set(key, null);
							this[_vertexObjects].set(key, new this.Vertex(key, value));
						}
						this[_edgeObjects].set(key, new Map());
						return _get(Object.getPrototypeOf(GraphOO.prototype), "addNewVertex", this).call(this, key, value);
					}
				}, {
					key: "setVertex",
					value: function setVertex(key, value) {
						this[_init]();
		
						var _Graph$_extractTwoArgs3 = Graph[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._extractTwoArgs](key, value);
		
						var _Graph$_extractTwoArgs32 = _slicedToArray(_Graph$_extractTwoArgs3, 2);
		
						key = _Graph$_extractTwoArgs32[0];
						value = _Graph$_extractTwoArgs32[1];
		
						this[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._expectVertices](key);
						this[_vertexObjects].get(key)[1] = value;
						return _get(Object.getPrototypeOf(GraphOO.prototype), "setVertex", this).call(this, key, value);
					}
				}, {
					key: "removeExistingVertex",
					value: function removeExistingVertex(key) {
						this[_init]();
						this[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._expectVertices](key);
						this[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._expectNoConnectedEdges](key);
						this[_vertexObjects]["delete"](key);
						return _get(Object.getPrototypeOf(GraphOO.prototype), "removeExistingVertex", this).call(this, key);
					}
				}, {
					key: "vertex",
					value: function vertex(key) {
						this[_init]();
						this[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._expectVertices](key);
						return this[_vertexObjects].get(key);
					}
				}, {
					key: "addNewEdge",
					value: function addNewEdge(from, to, value) {
						this[_init]();
		
						var _Graph$_extractThreeArgs = Graph[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._extractThreeArgs](from, to, value);
		
						var _Graph$_extractThreeArgs2 = _slicedToArray(_Graph$_extractThreeArgs, 3);
		
						from = _Graph$_extractThreeArgs2[0];
						to = _Graph$_extractThreeArgs2[1];
						value = _Graph$_extractThreeArgs2[2];
		
						this[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._expectEdgesAbsent]([from, to]);
						this[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._expectVertices](from, to);
						if (!this[_edgeObjects].get(from).has(to)) {
							this[_edgeObjects].get(from).set(to, null);
							this[_edgeObjects].get(from).set(to, new this.Edge(from, to, value));
						}
						return _get(Object.getPrototypeOf(GraphOO.prototype), "addNewEdge", this).call(this, from, to, value);
					}
				}, {
					key: "setEdge",
					value: function setEdge(from, to, value) {
						this[_init]();
		
						var _Graph$_extractThreeArgs3 = Graph[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._extractThreeArgs](from, to, value);
		
						var _Graph$_extractThreeArgs32 = _slicedToArray(_Graph$_extractThreeArgs3, 3);
		
						from = _Graph$_extractThreeArgs32[0];
						to = _Graph$_extractThreeArgs32[1];
						value = _Graph$_extractThreeArgs32[2];
		
						this[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._expectEdges]([from, to]);
						this[_edgeObjects].get(from).get(to)[1] = value;
						return _get(Object.getPrototypeOf(GraphOO.prototype), "setEdge", this).call(this, from, to, value);
					}
				}, {
					key: "removeExistingEdge",
					value: function removeExistingEdge(from, to) {
						this[_init]();
		
						var _Graph$_extractTwoArgs4 = Graph[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._extractTwoArgs](from, to);
		
						var _Graph$_extractTwoArgs42 = _slicedToArray(_Graph$_extractTwoArgs4, 2);
		
						from = _Graph$_extractTwoArgs42[0];
						to = _Graph$_extractTwoArgs42[1];
		
						this[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._expectEdges]([from, to]);
						this[_edgeObjects].get(from)["delete"](to);
						return _get(Object.getPrototypeOf(GraphOO.prototype), "removeExistingEdge", this).call(this, from, to);
					}
				}, {
					key: "edge",
					value: function edge(from, to) {
						this[_init]();
		
						var _Graph$_extractTwoArgs5 = Graph[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._extractTwoArgs](from, to);
		
						var _Graph$_extractTwoArgs52 = _slicedToArray(_Graph$_extractTwoArgs5, 2);
		
						from = _Graph$_extractTwoArgs52[0];
						to = _Graph$_extractTwoArgs52[1];
		
						this[_options$_extractTwoArgs$_extractThreeArgs$_expectVertices$_expectVerticesAbsent$_expectEdges$_expectEdgesAbsent$_expectNoConnectedEdges._expectEdges]([from, to]);
						return this[_edgeObjects].get(from).get(to);
					}
				}]);
		
				return GraphOO;
			})(Graph);
		}
		
		module.exports = exports["default"];
	
	/***/ }
	
	/******/ })
	});
	;
	//# sourceMappingURL=addGraphOO.js.map

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
		value: true
	});
	
	var _get = function get(_x11, _x12, _x13) { var _again = true; _function: while (_again) { var object = _x11, property = _x12, receiver = _x13; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x11 = parent; _x12 = property; _x13 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	var _bind = Function.prototype.bind;
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }
	
	function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _privateEs6Js = __webpack_require__(93);
	
	//  ////////////////////////////////////////////////////////////////////////////////////////////////
	//  // JSDoc stuff /////////////////////////////////////////////////////////////////////////////////
	//  ////////////////////////////////////////////////////////////////////////////////////////////////
	
	/**
	 * an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol};
	 * Note that ES6 offers nice syntax for dealing with iterators.
	 * @typedef {Object} Iterator
	 * @property {function(): { done: boolean, value: * }} next - a zero arguments function that returns an object `{ done, value }`
	 *                                                            <ul><li>If `done === false`, then `value` is the next value in the iterated sequence.</li>
	 *                                                                <li>If `done === true`, the iterator is past the end of the iterated sequence.   </li></ul>
	 */
	
	//  ////////////////////////////////////////////////////////////////////////////////////////////////
	//  // Graph class /////////////////////////////////////////////////////////////////////////////////
	//  ////////////////////////////////////////////////////////////////////////////////////////////////
	
	/**
	 * @class Graph
	 * @classdesc The main class of this library, to be used for representing a mathematical (di)graph.
	 *
	 * @description Constructor arguments can be used to supply initial vertices and edges.
	 * @param parts {...Array}
	 *        a short notation for vertices and edges to initially add to the graph;
	 *        A vertex should be an array of the form `[key, value]`.
	 *        An edge should be an array of the form `[[from, to], value]`.
	 *        Later values of vertices or edges in this list will overwrite earlier
	 *        values, but vertices need not precede their edges. Vertices that are
	 *        connected but store no value need not be listed at all.
	 * @example
	 * var map = new Graph(
	 *     ['Amsterdam',             { population: 825000 }], // vertex
	 *     ['Leiden',                { population: 122000 }], // vertex
	 *     [['Amsterdam', 'Leiden'], { distance:   "40km" }]  // edge
	 * );
	 */
	
	var Graph = (function () {
		function Graph() {
			for (var _len = arguments.length, parts = Array(_len), _key = 0; _key < _len; _key++) {
				parts[_key] = arguments[_key];
			}
	
			_classCallCheck(this, Graph);
	
			/* storage */
			this[_privateEs6Js._vertices] = new Map(); // Map.< string, * >
			this[_privateEs6Js._edges] = new Map(); // Map.< string, Map.<string, *> >
	
			/* bookkeeping */
			this[_privateEs6Js._reverseEdges] = new Map(); // Map.< string, Set.<*> >
			this[_privateEs6Js._sources] = new Set(); // Set.< string >
			this[_privateEs6Js._sinks] = new Set(); // Set.< string >
			this[_privateEs6Js._edgeCount] = 0;
	
			/* listeners */
			this[_privateEs6Js._listeners] = new Map();
	
			/* graph options */
			this[_privateEs6Js._options] = {};
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;
	
			try {
				for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var part = _step.value;
	
					if (!(part instanceof Array) && part instanceof Object) {
						Object.assign(this[_privateEs6Js._options], part);
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator['return']) {
						_iterator['return']();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
	
			/* add vertices and values from constructor arguments */
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;
	
			try {
				for (var _iterator2 = parts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var part = _step2.value;
	
					if (part instanceof Array) {
						var _part = _slicedToArray(part, 2);
	
						var key = _part[0];
						var value = _part[1];
	
						if (Array.isArray(key)) {
							/////////////// an edge
							this.createEdge(key, value);
						} else {
							//////////////////////////////// a vertex
							this.addVertex(key, value);
						}
					}
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2['return']) {
						_iterator2['return']();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		}
	
		_createClass(Graph, [{
			key: 'on',
	
			/////////////////////////////////////
			////////// Event Handling //////////
			/////////////////////////////////////
	
			/**
	   * Register an event handler.
	   * @param event   {string}   the event to listen for
	   * @param handler {Function} the function to call for each such event fired, receiving its corresponding value
	   */
			value: function on(event, handler) {
				if (!this[_privateEs6Js._listeners].has(event)) {
					this[_privateEs6Js._listeners].set(event, new Set());
				}
				this[_privateEs6Js._listeners].get(event).add(handler);
			}
		}, {
			key: 'off',
	
			/**
	   * Deregister a previously registered event handler.
	   * @param event   {string}   the event used to originally register a handler
	   * @param handler {Function} the handler originally registered
	   */
			value: function off(event, handler) {
				if (this[_privateEs6Js._listeners].has(event)) {
					this[_privateEs6Js._listeners].get(event)['delete'](handler);
				}
			}
		}, {
			key: _privateEs6Js._trigger,
			value: function (event, value) {
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;
	
				try {
					for (var _iterator3 = (this[_privateEs6Js._listeners].get(event) || [])[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var handler = _step3.value;
	
						handler(value);
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3['return']) {
							_iterator3['return']();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}
			}
		}, {
			key: 'addNewVertex',
	
			/**
	   * An event that is triggered just after a vertex is added to this graph.
	   * Handlers receive the new vertex `[key, value]` as an argument.
	   * @event vertex-added
	   * @memberof Graph
	   * @instance
	   * @see {@link Graph#on}
	   * @see {@link Graph#off}
	   */
			/**
	   * An event that is triggered just after a vertex is removed from this graph.
	   * Handlers receive the vertex key as an argument.
	   * @event vertex-removed
	   * @memberof Graph
	   * @instance
	   * @see {@link Graph#on}
	   * @see {@link Graph#off}
	   */
			/**
	   * An event that is triggered after a vertex in this graph is modified.
	   * It is also triggered after any {@link #Graph#event_vertex-added|"vertex-added"} event.
	   * Handlers receive the vertex `[key, value]` as an argument.
	   * @event vertex-modified
	   * @memberof Graph
	   * @instance
	   * @see {@link Graph#on}
	   * @see {@link Graph#off}
	   */
			/**
	   * An event that is triggered just after an edge is added to this graph.
	   * Handlers receive the new edge `[[from, to], value]` as an argument.
	   * @event edge-added
	   * @memberof Graph
	   * @instance
	   * @see {@link Graph#on}
	   * @see {@link Graph#off}
	   */
			/**
	   * An event that is triggered just after an edge is removed from this graph.
	   * Handlers receive the edge key `[from, to]` as an argument.
	   * @event edge-removed
	   * @memberof Graph
	   * @instance
	   * @see {@link Graph#on}
	   * @see {@link Graph#off}
	   */
			/**
	   * An event that is triggered after an edge in this graph is modified.
	   * It is also triggered after any {@link #Graph#event_edge-added|"edge-added"} event.
	   * Handlers receive the edge `[[from, to], value]` as an argument.
	   * @event edge-modified
	   * @memberof Graph
	   * @instance
	   * @see {@link Graph#on}
	   * @see {@link Graph#off}
	   */
	
			//////////////////////////////
			////////// Vertices //////////
			//////////////////////////////
	
			////////// creating them //////////
	
			/**
	   * Add a new vertex to this graph.
	   * @throws {Graph.VertexExistsError} if a vertex with this key already exists
	   * @param  key    {string} the key with which to refer to this new vertex
	   * @param [value] {*}      the value to store in this new vertex
	   */ // TODO: allow [key, value] array to be given as argument in docs
			value: function addNewVertex(key, value) {
				var _Graph$_extractTwoArgs = Graph[_privateEs6Js._extractTwoArgs](key, value);
	
				var _Graph$_extractTwoArgs2 = _slicedToArray(_Graph$_extractTwoArgs, 2);
	
				key = _Graph$_extractTwoArgs2[0];
				value = _Graph$_extractTwoArgs2[1];
	
				this[_privateEs6Js._expectVerticesAbsent](key);
				this[_privateEs6Js._vertices].set(key, value);
				this[_privateEs6Js._edges].set(key, new Map());
				this[_privateEs6Js._reverseEdges].set(key, new Set());
				this[_privateEs6Js._sources].add(key);
				this[_privateEs6Js._sinks].add(key);
				this[_privateEs6Js._trigger]('vertex-added', this.vertex(key));
				this[_privateEs6Js._trigger]('vertex-modified', this.vertex(key));
			}
		}, {
			key: 'setVertex',
	
			/**
	   * Set the value of an existing vertex in this graph.
	   * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist
	   * @param  key    {string} the key belonging to the vertex
	   * @param [value] {*}      the value to store in this vertex
	   */ // TODO: allow [key, value] array to be given as argument in docs
			value: function setVertex(key, value) {
				var _Graph$_extractTwoArgs3 = Graph[_privateEs6Js._extractTwoArgs](key, value);
	
				var _Graph$_extractTwoArgs32 = _slicedToArray(_Graph$_extractTwoArgs3, 2);
	
				key = _Graph$_extractTwoArgs32[0];
				value = _Graph$_extractTwoArgs32[1];
	
				this[_privateEs6Js._expectVertices](key);
				this[_privateEs6Js._vertices].set(key, value);
				this[_privateEs6Js._trigger]('vertex-modified', this.vertex(key));
			}
		}, {
			key: 'ensureVertex',
	
			/**
	   * Make sure a vertex with a specific key exists in this graph. If it already exists,
	   * do nothing. If it does not yet exist, add a new vertex with the given value.
	   * @param  key    {string} the key for the vertex
	   * @param [value] {*}      the value to store if a new vertex is added
	   */ // TODO: allow [key, value] array to be given as argument in docs
			value: function ensureVertex(key, value) {
				var _Graph$_extractTwoArgs4 = Graph[_privateEs6Js._extractTwoArgs](key, value);
	
				var _Graph$_extractTwoArgs42 = _slicedToArray(_Graph$_extractTwoArgs4, 2);
	
				key = _Graph$_extractTwoArgs42[0];
				value = _Graph$_extractTwoArgs42[1];
	
				if (!this.hasVertex(key)) {
					this.addNewVertex(key, value);
				}
			}
		}, {
			key: 'addVertex',
	
			/**
	   * Add a new vertex to this graph. If a vertex with this key already exists,
	   * the value of that vertex is overwritten.
	   * @param  key    {string} the key with which to refer to this new vertex
	   * @param [value] {*}      the value to store in this new vertex
	   */ // TODO: allow [key, value] array to be given as argument in docs
			value: function addVertex(key, value) {
				var _Graph$_extractTwoArgs5 = Graph[_privateEs6Js._extractTwoArgs](key, value);
	
				var _Graph$_extractTwoArgs52 = _slicedToArray(_Graph$_extractTwoArgs5, 2);
	
				key = _Graph$_extractTwoArgs52[0];
				value = _Graph$_extractTwoArgs52[1];
	
				if (this.hasVertex(key)) {
					this.setVertex(key, value);
				} else {
					this.addNewVertex(key, value);
				}
			}
		}, {
			key: 'removeExistingVertex',
	
			////////// removing them //////////
	
			/**
	   * Remove an existing vertex from this graph.
	   * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist
	   * @throws {Graph.HasConnectedEdgesError} if there are still edges connected to this vertex
	   * @param key {string} the key of the vertex to remove
	   */
			value: function removeExistingVertex(key) {
				this[_privateEs6Js._expectVertices](key);
				this[_privateEs6Js._expectNoConnectedEdges](key);
				this[_privateEs6Js._vertices]['delete'](key);
				this[_privateEs6Js._sources]['delete'](key);
				this[_privateEs6Js._sinks]['delete'](key);
				this[_privateEs6Js._trigger]('vertex-removed', key);
			}
		}, {
			key: 'destroyExistingVertex',
	
			/**
	   * Remove an existing vertex from this graph, as well as all edges connected to it.
	   * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist
	   * @param key {string} the key of the vertex to remove
	   */
			value: function destroyExistingVertex(key) {
				this[_privateEs6Js._expectVertices](key);
				var _iteratorNormalCompletion4 = true;
				var _didIteratorError4 = false;
				var _iteratorError4 = undefined;
	
				try {
					for (var _iterator4 = this.verticesFrom(key)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
						var _step4$value = _slicedToArray(_step4.value, 1);
	
						var to = _step4$value[0];
						this.removeEdge(key, to);
					}
				} catch (err) {
					_didIteratorError4 = true;
					_iteratorError4 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion4 && _iterator4['return']) {
							_iterator4['return']();
						}
					} finally {
						if (_didIteratorError4) {
							throw _iteratorError4;
						}
					}
				}
	
				var _iteratorNormalCompletion5 = true;
				var _didIteratorError5 = false;
				var _iteratorError5 = undefined;
	
				try {
					for (var _iterator5 = this.verticesTo(key)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
						var _step5$value = _slicedToArray(_step5.value, 1);
	
						var from = _step5$value[0];
						this.removeEdge(from, key);
					}
				} catch (err) {
					_didIteratorError5 = true;
					_iteratorError5 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion5 && _iterator5['return']) {
							_iterator5['return']();
						}
					} finally {
						if (_didIteratorError5) {
							throw _iteratorError5;
						}
					}
				}
	
				this.removeExistingVertex(key);
			}
		}, {
			key: 'removeVertex',
	
			/**
	   * Remove an existing vertex from this graph.
	   * If a vertex with this key does not exist, nothing happens.
	   * @throws {Graph.HasConnectedEdgesError} if there are still edges connected to this vertex
	   * @param key {string} the key of the vertex to remove
	   */
			value: function removeVertex(key) {
				if (this.hasVertex(key)) {
					this.removeExistingVertex(key);
				}
			}
		}, {
			key: 'destroyVertex',
	
			/**
	   * Remove a vertex from this graph, as well as all edges connected to it.
	   * If a vertex with this key does not exist, nothing happens.
	   * @param key {string} the key of the vertex to remove
	   */
			value: function destroyVertex(key) {
				if (this.hasVertex(key)) {
					this.destroyExistingVertex(key);
				}
			}
		}, {
			key: 'vertexCount',
	
			////////// querying them //////////
	
			/**
	   * @returns {number} the number of vertices in the whole graph
	   */
			value: function vertexCount() {
				return this[_privateEs6Js._vertices].size;
			}
		}, {
			key: 'hasVertex',
	
			/**
	   * Ask whether a vertex with a given key exists.
	   * @param key {string} the key to query
	   * @returns {boolean} whether there is a vertex with the given key
	   */
			value: function hasVertex(key) {
				return this[_privateEs6Js._vertices].has(key);
			}
		}, {
			key: 'vertex',
	
			/**
	   * Get the key/value pair representing the vertex with the given `key`.
	   * @param key {string} the key to query
	   * @throws {Graph.VertexNotExistsError} if the `key` vertex does not exist in the graph
	   * @returns {Array} a `[key, value]` shaped array representing the vertex
	   */
			value: function vertex(key) {
				this[_privateEs6Js._expectVertices](key);
				return [key, this.vertexValue(key)];
			}
		}, {
			key: 'vertexValue',
	
			/**
	   * Get the value associated with the vertex of a given `key`.
	   * @param key {string} the key to query
	   * @returns {*} the value associated with the vertex of the given key.
	   * Note that a return value of `undefined` can mean
	   *
	   * 1. that there is no such vertex, or
	   * 2. that the stored value is actually `undefined`.
	   *
	   * Use {@link Graph#hasVertex} to distinguish these cases.
	   */
			value: function vertexValue(key) {
				return this[_privateEs6Js._vertices].get(key);
			}
		}, {
			key: 'addNewEdge',
	
			///////////////////////////
			////////// Edges //////////
			///////////////////////////
	
			////////// adding them //////////
	
			/**
	   * Add a new edge to this graph.
	   * @throws {Graph.EdgeExistsError} if an edge between `from` and `to` already exists
	   * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph
	   * @param  from   {string} the key for the originating vertex
	   * @param  to     {string} the key for the terminating vertex
	   * @param [value] {*}      the value to store in this new edge
	   */ // TODO: allow [from, to], value array to be given as argument in docss; or [[from, to], value] as single argument
			value: function addNewEdge(from, to, value) {
				var _Graph$_extractThreeArgs = Graph[_privateEs6Js._extractThreeArgs](from, to, value);
	
				var _Graph$_extractThreeArgs2 = _slicedToArray(_Graph$_extractThreeArgs, 3);
	
				from = _Graph$_extractThreeArgs2[0];
				to = _Graph$_extractThreeArgs2[1];
				value = _Graph$_extractThreeArgs2[2];
	
				this[_privateEs6Js._expectEdgesAbsent]([from, to]);
				this[_privateEs6Js._expectVertices](from, to);
				this[_privateEs6Js._edges].get(from).set(to, value);
				this[_privateEs6Js._reverseEdges].get(to).add(from);
				this[_privateEs6Js._edgeCount] += 1;
				this[_privateEs6Js._sources]['delete'](to);
				this[_privateEs6Js._sinks]['delete'](from);
				this[_privateEs6Js._trigger]('edge-added', this.edge(from, to));
				this[_privateEs6Js._trigger]('edge-modified', this.edge(from, to));
			}
		}, {
			key: 'createNewEdge',
	
			/**
	   * Add a new edge to this graph. If the `from` and/or `to` vertices do not yet exist
	   * in the graph, they are implicitly added with an `undefined` value.
	   * @throws {Graph.EdgeExistsError} if an edge between `from` and `to` already exists
	   * @param  from   {string} the key for the originating vertex
	   * @param  to     {string} the key for the terminating vertex
	   * @param [value] {*}      the value to store in this new edge
	   */ // TODO: allow [from, to], value array to be given as argument in docss; or [[from, to], value] as single argument
			value: function createNewEdge(from, to, value) {
				var _Graph$_extractThreeArgs3 = Graph[_privateEs6Js._extractThreeArgs](from, to, value);
	
				var _Graph$_extractThreeArgs32 = _slicedToArray(_Graph$_extractThreeArgs3, 3);
	
				from = _Graph$_extractThreeArgs32[0];
				to = _Graph$_extractThreeArgs32[1];
				value = _Graph$_extractThreeArgs32[2];
	
				this[_privateEs6Js._expectEdgesAbsent]([from, to]);
				this.ensureVertex(from);
				this.ensureVertex(to);
				this.addNewEdge(from, to, value);
			}
		}, {
			key: 'setEdge',
	
			/**
	   * Set the value of an existing edge in this graph.
	   * @throws {Graph.EdgeNotExistsError} if an edge between `from` and `to` does not yet exist
	   * @param  from   {string} the key for the originating vertex
	   * @param  to     {string} the key for the terminating vertex
	   * @param [value] {*}      the value to store in this edge
	   */ // TODO: allow [from, to], value array to be given as argument in docss; or [[from, to], value] as single argument
			value: function setEdge(from, to, value) {
				var _Graph$_extractThreeArgs4 = Graph[_privateEs6Js._extractThreeArgs](from, to, value);
	
				var _Graph$_extractThreeArgs42 = _slicedToArray(_Graph$_extractThreeArgs4, 3);
	
				from = _Graph$_extractThreeArgs42[0];
				to = _Graph$_extractThreeArgs42[1];
				value = _Graph$_extractThreeArgs42[2];
	
				this[_privateEs6Js._expectEdges]([from, to]);
				this[_privateEs6Js._edges].get(from).set(to, value);
				this[_privateEs6Js._trigger]('edge-modified', this.edge(from, to));
			}
		}, {
			key: 'spanEdge',
	
			/**
	   * Make sure an edge between the `from` and `to` vertices in this graph.
	   * If one already exists, nothing is done.
	   * If one does not yet exist, a new edge is added with the given value.
	   * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph
	   * @param  from   {string} the key for the originating vertex
	   * @param  to     {string} the key for the terminating vertex
	   * @param [value] {*}      the value to store if a new edge is added
	   */ // TODO: allow [from, to], value array to be given as argument in docss; or [[from, to], value] as single argument
			value: function spanEdge(from, to, value) {
				var _Graph$_extractThreeArgs5 = Graph[_privateEs6Js._extractThreeArgs](from, to, value);
	
				var _Graph$_extractThreeArgs52 = _slicedToArray(_Graph$_extractThreeArgs5, 3);
	
				from = _Graph$_extractThreeArgs52[0];
				to = _Graph$_extractThreeArgs52[1];
				value = _Graph$_extractThreeArgs52[2];
	
				this[_privateEs6Js._expectVertices](from, to);
				if (!this.hasEdge(from, to)) {
					this.addNewEdge(from, to, value);
				}
			}
		}, {
			key: 'addEdge',
	
			/**
	   * Add a new edge to this graph. If an edge between `from` and `to` already exists,
	   * the value of that edge is overwritten.
	   * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph
	   * @param  from   {string} the key for the originating vertex
	   * @param  to     {string} the key for the terminating vertex
	   * @param [value] {*}      the value to store in this new edge
	   */ // TODO: allow [from, to], value array to be given as argument in docss; or [[from, to], value] as single argument
			value: function addEdge(from, to, value) {
				var _Graph$_extractThreeArgs6 = Graph[_privateEs6Js._extractThreeArgs](from, to, value);
	
				var _Graph$_extractThreeArgs62 = _slicedToArray(_Graph$_extractThreeArgs6, 3);
	
				from = _Graph$_extractThreeArgs62[0];
				to = _Graph$_extractThreeArgs62[1];
				value = _Graph$_extractThreeArgs62[2];
	
				if (this.hasEdge(from, to)) {
					this.setEdge(from, to, value);
				} else {
					this.addNewEdge(from, to, value);
				}
			}
		}, {
			key: 'ensureEdge',
	
			/**
	   * Make sure an edge between the `from` and `to` vertices exists in this graph.
	   * If it already exists, nothing is done.
	   * If it does not yet exist, a new edge is added with the given value.
	   * If the `from` and/or `to` vertices do not yet exist
	   * in the graph, they are implicitly added with an `undefined` value.
	   * @param  from   {string} the key for the originating vertex
	   * @param  to     {string} the key for the terminating vertex
	   * @param [value] {*}      the value to store if a new edge is added
	   */ // TODO: allow [from, to], value array to be given as argument in docss; or [[from, to], value] as single argument
			value: function ensureEdge(from, to, value) {
				var _Graph$_extractThreeArgs7 = Graph[_privateEs6Js._extractThreeArgs](from, to, value);
	
				var _Graph$_extractThreeArgs72 = _slicedToArray(_Graph$_extractThreeArgs7, 3);
	
				from = _Graph$_extractThreeArgs72[0];
				to = _Graph$_extractThreeArgs72[1];
				value = _Graph$_extractThreeArgs72[2];
	
				if (!this.hasEdge(from, to)) {
					this.createNewEdge(from, to, value);
				}
			}
		}, {
			key: 'createEdge',
	
			/**
	   * Add a new edge to this graph. If an edge between the `from` and `to`
	   * vertices already exists, the value of that edge is overwritten.
	   * If the `from` and/or `to` vertices do not yet exist
	   * in the graph, they are implicitly added with an `undefined` value.
	   * @param  from   {string} the key for the originating vertex
	   * @param  to     {string} the key for the terminating vertex
	   * @param [value] {*}      the value to store if a new edge is added
	   */ // TODO: allow [from, to], value array to be given as argument in docss; or [[from, to], value] as single argument
			value: function createEdge(from, to, value) {
				var _Graph$_extractThreeArgs8 = Graph[_privateEs6Js._extractThreeArgs](from, to, value);
	
				var _Graph$_extractThreeArgs82 = _slicedToArray(_Graph$_extractThreeArgs8, 3);
	
				from = _Graph$_extractThreeArgs82[0];
				to = _Graph$_extractThreeArgs82[1];
				value = _Graph$_extractThreeArgs82[2];
	
				if (this.hasEdge(from, to)) {
					this.setEdge(from, to, value);
				} else {
					this.createNewEdge(from, to, value);
				}
			}
		}, {
			key: 'removeExistingEdge',
	
			////////// removing them //////////
	
			/**
	   * Remove an existing edge from this graph.
	   * @throws {Graph.EdgeNotExistsError} if an edge between the `from` and `to` vertices doesn't exist
	   * @param from {string} the key for the originating vertex
	   * @param to   {string} the key for the terminating vertex
	   */ // TODO: allow [from, to] array to be given as argument in docs
			value: function removeExistingEdge(from, to) {
				var _Graph$_extractTwoArgs6 = Graph[_privateEs6Js._extractTwoArgs](from, to);
	
				var _Graph$_extractTwoArgs62 = _slicedToArray(_Graph$_extractTwoArgs6, 2);
	
				from = _Graph$_extractTwoArgs62[0];
				to = _Graph$_extractTwoArgs62[1];
	
				this[_privateEs6Js._expectEdges]([from, to]);
				this[_privateEs6Js._edges].get(from)['delete'](to);
				this[_privateEs6Js._reverseEdges].get(to)['delete'](from);
				this[_privateEs6Js._edgeCount] -= 1;
				if (this.inDegree(to) === 0) {
					this[_privateEs6Js._sources].add(to);
				}
				if (this.outDegree(from) === 0) {
					this[_privateEs6Js._sinks].add(from);
				}
				this[_privateEs6Js._trigger]('edge-removed', [from, to]);
			}
		}, {
			key: 'removeEdge',
	
			/**
	   * Remove an edge from this graph.
	   * If an edge between the `from` and `to` vertices doesn't exist, nothing happens.
	   * @param from {string} the key for the originating vertex
	   * @param to   {string} the key for the terminating vertex
	   */ // TODO: allow [from, to] array to be given as argument in docs
			value: function removeEdge(from, to) {
				var _Graph$_extractTwoArgs7 = Graph[_privateEs6Js._extractTwoArgs](from, to);
	
				var _Graph$_extractTwoArgs72 = _slicedToArray(_Graph$_extractTwoArgs7, 2);
	
				from = _Graph$_extractTwoArgs72[0];
				to = _Graph$_extractTwoArgs72[1];
	
				if (this.hasEdge(from, to)) {
					this.removeExistingEdge(from, to);
				}
			}
		}, {
			key: 'edgeCount',
	
			////////// querying them //////////
	
			/**
	   * @returns {number} the number of edges in the whole graph
	   */
			value: function edgeCount() {
				return this[_privateEs6Js._edgeCount];
			}
		}, {
			key: 'hasEdge',
	
			/**
	   * Ask whether an edge between given `from` and `to` vertices exist.
	   * @param from {string} the key for the originating vertex
	   * @param to   {string} the key for the terminating vertex
	   * @returns {boolean} whether there is an edge between the given `from` and `to` vertices
	   */ // TODO: allow [from, to] array to be given as argument in docs
			value: function hasEdge(from, to) {
				var _Graph$_extractTwoArgs8 = Graph[_privateEs6Js._extractTwoArgs](from, to);
	
				var _Graph$_extractTwoArgs82 = _slicedToArray(_Graph$_extractTwoArgs8, 2);
	
				from = _Graph$_extractTwoArgs82[0];
				to = _Graph$_extractTwoArgs82[1];
	
				return this.hasVertex(from) && this.hasVertex(to) && this[_privateEs6Js._edges].has(from) && this[_privateEs6Js._edges].get(from).has(to);
			}
		}, {
			key: 'edge',
	
			/**
	   * Get the key/value pair representing the edge between the given `from` and `to`.
	   * @param from {string} the key for the originating vertex
	   * @param to   {string} the key for the terminating vertex
	   * @returns {Array} a `[[from, to], value]` shaped array representing the edge
	   */ // TODO: allow [from, to] array to be given as argument in docs
			value: function edge(from, to) {
				var _Graph$_extractTwoArgs9 = Graph[_privateEs6Js._extractTwoArgs](from, to);
	
				var _Graph$_extractTwoArgs92 = _slicedToArray(_Graph$_extractTwoArgs9, 2);
	
				from = _Graph$_extractTwoArgs92[0];
				to = _Graph$_extractTwoArgs92[1];
	
				this[_privateEs6Js._expectEdges]([from, to]);
				return [[from, to], this.edgeValue(from, to)];
			}
		}, {
			key: 'edgeValue',
	
			/**
	   * Get the value associated with the edge between given `from` and `to` vertices.
	   * @param from {string} the key for the originating vertex
	   * @param to   {string} the key for the terminating vertex
	   * @returns {*} the value associated with the edge between the given `from` and `to` vertices
	   * Note that a return value of `undefined` can mean
	   *
	   * 1. that there is no such edge, or
	   * 2. that the stored value is actually `undefined`.
	   *
	   * Use {@link Graph#hasEdge} to distinguish these cases.
	   */ // TODO: allow [from, to] array to be given as argument in docs
			value: function edgeValue(from, to) {
				var _Graph$_extractTwoArgs10 = Graph[_privateEs6Js._extractTwoArgs](from, to);
	
				var _Graph$_extractTwoArgs102 = _slicedToArray(_Graph$_extractTwoArgs10, 2);
	
				from = _Graph$_extractTwoArgs102[0];
				to = _Graph$_extractTwoArgs102[1];
	
				return this.hasEdge(from, to) ? this[_privateEs6Js._edges].get(from).get(to) : undefined;
			}
		}, {
			key: 'vertices',
	
			///////////////////////////////////////////////
			//////////// ES6 Iterable interfaces //////////
			///////////////////////////////////////////////
	
			/**
	   * Iterate over all vertices of the graph, in no particular order.
	   * @returns {Iterator} an ES6 iterator yielding vertices
	   * @example
	   * for (var it = graph.vertices(), kv; !(kv = it.next()).done;) {
	   *     var key   = kv.value[0],
	   *         value = kv.value[1];
	   *     // iterates over all vertices of the graph
	   * }
	   * @example
	   * // in ECMAScript 6, you can use a for..of loop
	   * for (let [key, value] of graph.vertices()) {
	   *     // iterates over all vertices of the graph
	   * }
	   * @see {@link Graph#@@iterator}
	   */
			value: regeneratorRuntime.mark(function vertices() {
				var done, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, _step6$value, key;
	
				return regeneratorRuntime.wrap(function vertices$(context$2$0) {
					while (1) switch (context$2$0.prev = context$2$0.next) {
						case 0:
							done = new Set();
							_iteratorNormalCompletion6 = true;
							_didIteratorError6 = false;
							_iteratorError6 = undefined;
							context$2$0.prev = 4;
							_iterator6 = this[_privateEs6Js._vertices][Symbol.iterator]();
	
						case 6:
							if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
								context$2$0.next = 16;
								break;
							}
	
							_step6$value = _slicedToArray(_step6.value, 1);
							key = _step6$value[0];
	
							if (!(this.hasVertex(key) && !done.has(key))) {
								context$2$0.next = 13;
								break;
							}
	
							done.add(key);
							context$2$0.next = 13;
							return this.vertex(key);
	
						case 13:
							_iteratorNormalCompletion6 = true;
							context$2$0.next = 6;
							break;
	
						case 16:
							context$2$0.next = 22;
							break;
	
						case 18:
							context$2$0.prev = 18;
							context$2$0.t0 = context$2$0['catch'](4);
							_didIteratorError6 = true;
							_iteratorError6 = context$2$0.t0;
	
						case 22:
							context$2$0.prev = 22;
							context$2$0.prev = 23;
	
							if (!_iteratorNormalCompletion6 && _iterator6['return']) {
								_iterator6['return']();
							}
	
						case 25:
							context$2$0.prev = 25;
	
							if (!_didIteratorError6) {
								context$2$0.next = 28;
								break;
							}
	
							throw _iteratorError6;
	
						case 28:
							return context$2$0.finish(25);
	
						case 29:
							return context$2$0.finish(22);
	
						case 30:
						case 'end':
							return context$2$0.stop();
					}
				}, vertices, this, [[4, 18, 22, 30], [23,, 25, 29]]);
			})
		}, {
			key: Symbol.iterator,
	
			/**
	   * A {@link Graph} object is itself {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol|iterable},
	   * and serves as a short notation in ECMAScript 6 to iterate over all vertices in the graph, in no particular order.
	   * @method Graph#@@iterator
	   * @returns {Iterator} an ES6 iterator yielding vertices
	   * @example
	   * for (let [key, value] of graph) {
	   *     // iterates over all vertices of the graph
	   * }
	   * @see {@link Graph#vertices}
	   */
			value: function () {
				return this.vertices();
			}
		}, {
			key: 'edges',
	
			/**
	   * Iterate over all edges of the graph, in no particular order.
	   * @returns {Iterator} an ES6 iterator yielding edges
	   * @example
	   * for (var it = graph.edges(), kv; !(kv = it.next()).done;) {
	   *     var from  = kv.value[0][0],
	   *         to    = kv.value[0][1],
	   *         value = kv.value[1];
	   *     // iterates over all edges of the graph
	   * }
	   * @example
	   * // in ECMAScript 6, you can use a for..of loop
	   * for (let [[from, to], value] of graph.edges()) {
	   *     // iterates over all vertices of the graph
	   * }
	   */
			value: regeneratorRuntime.mark(function edges() {
				var done, _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, from, _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, to;
	
				return regeneratorRuntime.wrap(function edges$(context$2$0) {
					while (1) switch (context$2$0.prev = context$2$0.next) {
						case 0:
							done = new Map();
							_iteratorNormalCompletion7 = true;
							_didIteratorError7 = false;
							_iteratorError7 = undefined;
							context$2$0.prev = 4;
							_iterator7 = this[_privateEs6Js._edges].keys()[Symbol.iterator]();
	
						case 6:
							if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {
								context$2$0.next = 40;
								break;
							}
	
							from = _step7.value;
	
							done.set(from, new Set());
							_iteratorNormalCompletion8 = true;
							_didIteratorError8 = false;
							_iteratorError8 = undefined;
							context$2$0.prev = 12;
							_iterator8 = this[_privateEs6Js._edges].get(from).keys()[Symbol.iterator]();
	
						case 14:
							if (_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done) {
								context$2$0.next = 23;
								break;
							}
	
							to = _step8.value;
	
							if (!(!done.get(from).has(to) && this.hasEdge(from, to))) {
								context$2$0.next = 20;
								break;
							}
	
							done.get(from).add(to);
							context$2$0.next = 20;
							return this.edge(from, to);
	
						case 20:
							_iteratorNormalCompletion8 = true;
							context$2$0.next = 14;
							break;
	
						case 23:
							context$2$0.next = 29;
							break;
	
						case 25:
							context$2$0.prev = 25;
							context$2$0.t0 = context$2$0['catch'](12);
							_didIteratorError8 = true;
							_iteratorError8 = context$2$0.t0;
	
						case 29:
							context$2$0.prev = 29;
							context$2$0.prev = 30;
	
							if (!_iteratorNormalCompletion8 && _iterator8['return']) {
								_iterator8['return']();
							}
	
						case 32:
							context$2$0.prev = 32;
	
							if (!_didIteratorError8) {
								context$2$0.next = 35;
								break;
							}
	
							throw _iteratorError8;
	
						case 35:
							return context$2$0.finish(32);
	
						case 36:
							return context$2$0.finish(29);
	
						case 37:
							_iteratorNormalCompletion7 = true;
							context$2$0.next = 6;
							break;
	
						case 40:
							context$2$0.next = 46;
							break;
	
						case 42:
							context$2$0.prev = 42;
							context$2$0.t1 = context$2$0['catch'](4);
							_didIteratorError7 = true;
							_iteratorError7 = context$2$0.t1;
	
						case 46:
							context$2$0.prev = 46;
							context$2$0.prev = 47;
	
							if (!_iteratorNormalCompletion7 && _iterator7['return']) {
								_iterator7['return']();
							}
	
						case 49:
							context$2$0.prev = 49;
	
							if (!_didIteratorError7) {
								context$2$0.next = 52;
								break;
							}
	
							throw _iteratorError7;
	
						case 52:
							return context$2$0.finish(49);
	
						case 53:
							return context$2$0.finish(46);
	
						case 54:
						case 'end':
							return context$2$0.stop();
					}
				}, edges, this, [[4, 42, 46, 54], [12, 25, 29, 37], [30,, 32, 36], [47,, 49, 53]]);
			})
		}, {
			key: 'verticesFrom',
	
			/**
	   * Iterate over the vertices directly reachable from a given vertex in the graph, in no particular order.
	   * @throws {Graph.VertexNotExistsError} if a vertex with the given `from` key does not exist
	   * @param key {string} the key of the vertex to take the outgoing edges from
	   * @returns {Iterator} an ES6 iterator yielding vertices
	   * @example
	   * for (var it = graph.verticesFrom(from), kv; !(kv = it.next()).done;) {
	   *     var to    = kv.value[0],
	   *         value = kv.value[1];
	   *     // iterates over all outgoing vertices of the `from` vertex
	   * }
	   * @example
	   * // in ECMAScript 6, you can use a for..of loop
	   * for (let [to, value] of graph.verticesFrom(from)) {
	   *     // iterates over all outgoing vertices of the `from` vertex
	   * }
	   */
			value: function verticesFrom(key) {
				this[_privateEs6Js._expectVertices](key);
				return this[_privateEs6Js._verticesFrom](key);
			}
		}, {
			key: _privateEs6Js._verticesFrom,
			value: regeneratorRuntime.mark(function callee$1$0(from) {
				var done, _iteratorNormalCompletion9, _didIteratorError9, _iteratorError9, _iterator9, _step9, to;
	
				return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
					while (1) switch (context$2$0.prev = context$2$0.next) {
						case 0:
							done = new Set();
							_iteratorNormalCompletion9 = true;
							_didIteratorError9 = false;
							_iteratorError9 = undefined;
							context$2$0.prev = 4;
							_iterator9 = this[_privateEs6Js._edges].get(from).keys()[Symbol.iterator]();
	
						case 6:
							if (_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done) {
								context$2$0.next = 15;
								break;
							}
	
							to = _step9.value;
	
							if (!(!done.has(to) && this.hasEdge(from, to))) {
								context$2$0.next = 12;
								break;
							}
	
							done.add(to);
							context$2$0.next = 12;
							return this.vertex(to);
	
						case 12:
							_iteratorNormalCompletion9 = true;
							context$2$0.next = 6;
							break;
	
						case 15:
							context$2$0.next = 21;
							break;
	
						case 17:
							context$2$0.prev = 17;
							context$2$0.t0 = context$2$0['catch'](4);
							_didIteratorError9 = true;
							_iteratorError9 = context$2$0.t0;
	
						case 21:
							context$2$0.prev = 21;
							context$2$0.prev = 22;
	
							if (!_iteratorNormalCompletion9 && _iterator9['return']) {
								_iterator9['return']();
							}
	
						case 24:
							context$2$0.prev = 24;
	
							if (!_didIteratorError9) {
								context$2$0.next = 27;
								break;
							}
	
							throw _iteratorError9;
	
						case 27:
							return context$2$0.finish(24);
	
						case 28:
							return context$2$0.finish(21);
	
						case 29:
						case 'end':
							return context$2$0.stop();
					}
				}, callee$1$0, this, [[4, 17, 21, 29], [22,, 24, 28]]);
			})
		}, {
			key: 'verticesTo',
	
			/**
	   * Iterate over the vertices from which a given vertex in the graph is directly reachable, in no particular order.
	   * @throws {Graph.VertexNotExistsError} if a vertex with the given `to` key does not exist
	   * @param key {string} the key of the vertex to take the incoming edges from
	   * @returns {Iterator} an ES6 iterator yielding vertices
	   * @example
	   * for (var it = graph.verticesTo(to), kv; !(kv = it.next()).done;) {
	   *     var from  = kv.value[0],
	   *         value = kv.value[1];
	   *     // iterates over all outgoing vertices of the `to` vertex
	   * }
	   * @example
	   * // in ECMAScript 6, you can use a for..of loop
	   * for (let [from, value] of graph.verticesTo(to)) {
	   *     // iterates over all incoming vertices of the `to` vertex
	   * }
	   */
			value: function verticesTo(key) {
				this[_privateEs6Js._expectVertices](key);
				return this[_privateEs6Js._verticesTo](key);
			}
		}, {
			key: _privateEs6Js._verticesTo,
			value: regeneratorRuntime.mark(function callee$1$0(to) {
				var done, _iteratorNormalCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step10, from;
	
				return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
					while (1) switch (context$2$0.prev = context$2$0.next) {
						case 0:
							done = new Set();
							_iteratorNormalCompletion10 = true;
							_didIteratorError10 = false;
							_iteratorError10 = undefined;
							context$2$0.prev = 4;
							_iterator10 = this[_privateEs6Js._reverseEdges].get(to)[Symbol.iterator]();
	
						case 6:
							if (_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done) {
								context$2$0.next = 15;
								break;
							}
	
							from = _step10.value;
	
							if (!(!done.has(from) && this.hasEdge(from, to))) {
								context$2$0.next = 12;
								break;
							}
	
							done.add(from);
							context$2$0.next = 12;
							return this.vertex(from);
	
						case 12:
							_iteratorNormalCompletion10 = true;
							context$2$0.next = 6;
							break;
	
						case 15:
							context$2$0.next = 21;
							break;
	
						case 17:
							context$2$0.prev = 17;
							context$2$0.t0 = context$2$0['catch'](4);
							_didIteratorError10 = true;
							_iteratorError10 = context$2$0.t0;
	
						case 21:
							context$2$0.prev = 21;
							context$2$0.prev = 22;
	
							if (!_iteratorNormalCompletion10 && _iterator10['return']) {
								_iterator10['return']();
							}
	
						case 24:
							context$2$0.prev = 24;
	
							if (!_didIteratorError10) {
								context$2$0.next = 27;
								break;
							}
	
							throw _iteratorError10;
	
						case 27:
							return context$2$0.finish(24);
	
						case 28:
							return context$2$0.finish(21);
	
						case 29:
						case 'end':
							return context$2$0.stop();
					}
				}, callee$1$0, this, [[4, 17, 21, 29], [22,, 24, 28]]);
			})
		}, {
			key: 'edgesFrom',
	
			/**
	   * Iterate over the outgoing edges of a given vertex in the graph, in no particular order.
	   * @throws {Graph.VertexNotExistsError} if a vertex with the given `from` key does not exist
	   * @param key {string} the key of the vertex to take the outgoing edges from
	   * @returns {Iterator} an ES6 iterator yielding edges
	   * @example
	   * for (var it = graph.edgesFrom(from), kv; !(kv = it.next()).done;) {
	   *     var from  = kv.value[0][0],
	   *         to    = kv.value[0][1],
	   *         value = kv.value[1];
	   *     // iterates over all outgoing edges of the `from` vertex
	   * }
	   * @example
	   * // in ECMAScript 6, you can use a for..of loop
	   * for (let [[from, to], value] of graph.edgesFrom(from)) {
	   *     // iterates over all outgoing edges of the `from` vertex
	   * }
	   */
			value: function edgesFrom(key) {
				this[_privateEs6Js._expectVertices](key);
				return this[_privateEs6Js._edgesFrom](key);
			}
		}, {
			key: _privateEs6Js._edgesFrom,
			value: regeneratorRuntime.mark(function callee$1$0(from) {
				var done, _iteratorNormalCompletion11, _didIteratorError11, _iteratorError11, _iterator11, _step11, to;
	
				return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
					while (1) switch (context$2$0.prev = context$2$0.next) {
						case 0:
							done = new Set();
							_iteratorNormalCompletion11 = true;
							_didIteratorError11 = false;
							_iteratorError11 = undefined;
							context$2$0.prev = 4;
							_iterator11 = this[_privateEs6Js._edges].get(from).keys()[Symbol.iterator]();
	
						case 6:
							if (_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done) {
								context$2$0.next = 15;
								break;
							}
	
							to = _step11.value;
	
							if (!(!done.has(to) && this.hasEdge(from, to))) {
								context$2$0.next = 12;
								break;
							}
	
							done.add(to);
							context$2$0.next = 12;
							return this.edge(from, to);
	
						case 12:
							_iteratorNormalCompletion11 = true;
							context$2$0.next = 6;
							break;
	
						case 15:
							context$2$0.next = 21;
							break;
	
						case 17:
							context$2$0.prev = 17;
							context$2$0.t0 = context$2$0['catch'](4);
							_didIteratorError11 = true;
							_iteratorError11 = context$2$0.t0;
	
						case 21:
							context$2$0.prev = 21;
							context$2$0.prev = 22;
	
							if (!_iteratorNormalCompletion11 && _iterator11['return']) {
								_iterator11['return']();
							}
	
						case 24:
							context$2$0.prev = 24;
	
							if (!_didIteratorError11) {
								context$2$0.next = 27;
								break;
							}
	
							throw _iteratorError11;
	
						case 27:
							return context$2$0.finish(24);
	
						case 28:
							return context$2$0.finish(21);
	
						case 29:
						case 'end':
							return context$2$0.stop();
					}
				}, callee$1$0, this, [[4, 17, 21, 29], [22,, 24, 28]]);
			})
		}, {
			key: 'edgesTo',
	
			/**
	   * Iterate over the incoming edges of a given vertex in the graph, in no particular order.
	   * @throws {Graph.VertexNotExistsError} if a vertex with the given `to` key does not exist
	   * @param key {string} the key of the vertex to take the incoming edges from
	   * @returns {Iterator} an ES6 iterator yielding edges
	   * @example
	   * for (var it = graph.edgesTo(to), kv; !(kv = it.next()).done;) {
	   *     var from  = kv.value[0][0],
	   *         to    = kv.value[0][1],
	   *         value = kv.value[1];
	   *     // iterates over all incoming edges of the `to` vertex
	   * }
	   * @example
	   * // in ECMAScript 6, you can use a for..of loop
	   * for (let [[from, to], value] of graph.edgesTo(to)) {
	   *     // iterates over all incoming edges of the `to` vertex
	   * }
	   */
			value: function edgesTo(key) {
				this[_privateEs6Js._expectVertices](key);
				return this[_privateEs6Js._edgesTo](key);
			}
		}, {
			key: _privateEs6Js._edgesTo,
			value: regeneratorRuntime.mark(function callee$1$0(to) {
				var done, _iteratorNormalCompletion12, _didIteratorError12, _iteratorError12, _iterator12, _step12, from;
	
				return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
					while (1) switch (context$2$0.prev = context$2$0.next) {
						case 0:
							done = new Set();
							_iteratorNormalCompletion12 = true;
							_didIteratorError12 = false;
							_iteratorError12 = undefined;
							context$2$0.prev = 4;
							_iterator12 = this[_privateEs6Js._reverseEdges].get(to)[Symbol.iterator]();
	
						case 6:
							if (_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done) {
								context$2$0.next = 15;
								break;
							}
	
							from = _step12.value;
	
							if (!(!done.has(from) && this.hasEdge(from, to))) {
								context$2$0.next = 12;
								break;
							}
	
							done.add(from);
							context$2$0.next = 12;
							return this.edge(from, to);
	
						case 12:
							_iteratorNormalCompletion12 = true;
							context$2$0.next = 6;
							break;
	
						case 15:
							context$2$0.next = 21;
							break;
	
						case 17:
							context$2$0.prev = 17;
							context$2$0.t0 = context$2$0['catch'](4);
							_didIteratorError12 = true;
							_iteratorError12 = context$2$0.t0;
	
						case 21:
							context$2$0.prev = 21;
							context$2$0.prev = 22;
	
							if (!_iteratorNormalCompletion12 && _iterator12['return']) {
								_iterator12['return']();
							}
	
						case 24:
							context$2$0.prev = 24;
	
							if (!_didIteratorError12) {
								context$2$0.next = 27;
								break;
							}
	
							throw _iteratorError12;
	
						case 27:
							return context$2$0.finish(24);
	
						case 28:
							return context$2$0.finish(21);
	
						case 29:
						case 'end':
							return context$2$0.stop();
					}
				}, callee$1$0, this, [[4, 17, 21, 29], [22,, 24, 28]]);
			})
		}, {
			key: 'verticesWithPathFrom',
	
			/**
	   * Iterate over all vertices reachable from a given vertex in the graph, in no particular order.
	   * @throws {Graph.VertexNotExistsError} if a vertex with the given `from` key does not exist
	   * @param from {string} the key of the vertex to take the reachable vertices from
	   * @returns {Iterator} an ES6 iterator yielding vertices
	   * @example
	   * for (var it = graph.verticesWithPathFrom(from), kv; !(kv = it.next()).done;) {
	   *     var key   = kv.value[0],
	   *         value = kv.value[1];
	   *     // iterates over all vertices reachable from `from`
	   * }
	   * @example
	   * // in ECMAScript 6, you can use a for..of loop
	   * for (let [key, value] of graph.verticesWithPathFrom(from)) {
	   *     // iterates over all vertices reachable from `from`
	   * }
	   */
			value: function verticesWithPathFrom(from) {
				this[_privateEs6Js._expectVertices](from);
				return this[_privateEs6Js._verticesWithPathFrom](from, new Set());
			}
		}, {
			key: _privateEs6Js._verticesWithPathFrom,
			value: regeneratorRuntime.mark(function callee$1$0(from, done) {
				var _iteratorNormalCompletion13, _didIteratorError13, _iteratorError13, _iterator13, _step13, _step13$value, to;
	
				return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
					while (1) switch (context$2$0.prev = context$2$0.next) {
						case 0:
							_iteratorNormalCompletion13 = true;
							_didIteratorError13 = false;
							_iteratorError13 = undefined;
							context$2$0.prev = 3;
							_iterator13 = this.verticesFrom(from)[Symbol.iterator]();
	
						case 5:
							if (_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done) {
								context$2$0.next = 16;
								break;
							}
	
							_step13$value = _slicedToArray(_step13.value, 1);
							to = _step13$value[0];
	
							if (!(!done.has(to) && this.hasEdge(from, to))) {
								context$2$0.next = 13;
								break;
							}
	
							done.add(to);
							context$2$0.next = 12;
							return this.vertex(to);
	
						case 12:
							return context$2$0.delegateYield(this[_privateEs6Js._verticesWithPathFrom](to, done), 't0', 13);
	
						case 13:
							_iteratorNormalCompletion13 = true;
							context$2$0.next = 5;
							break;
	
						case 16:
							context$2$0.next = 22;
							break;
	
						case 18:
							context$2$0.prev = 18;
							context$2$0.t1 = context$2$0['catch'](3);
							_didIteratorError13 = true;
							_iteratorError13 = context$2$0.t1;
	
						case 22:
							context$2$0.prev = 22;
							context$2$0.prev = 23;
	
							if (!_iteratorNormalCompletion13 && _iterator13['return']) {
								_iterator13['return']();
							}
	
						case 25:
							context$2$0.prev = 25;
	
							if (!_didIteratorError13) {
								context$2$0.next = 28;
								break;
							}
	
							throw _iteratorError13;
	
						case 28:
							return context$2$0.finish(25);
	
						case 29:
							return context$2$0.finish(22);
	
						case 30:
						case 'end':
							return context$2$0.stop();
					}
				}, callee$1$0, this, [[3, 18, 22, 30], [23,, 25, 29]]);
			})
		}, {
			key: 'verticesWithPathTo',
	
			/**
	   * Iterate over all vertices from which a given vertex in the graph can be reached, in no particular order.
	   * @throws {Graph.VertexNotExistsError} if a vertex with the given `to` key does not exist
	   * @param to {string} the key of the vertex to take the reachable vertices from
	   * @returns {Iterator} an ES6 iterator yielding vertices
	   * @example
	   * for (var it = graph.verticesWithPathTo(to), kv; !(kv = it.next()).done;) {
	   *     var key   = kv.value[0],
	   *         value = kv.value[1];
	   *     // iterates over all vertices from which `to` can be reached
	   * }
	   * @example
	   * // in ECMAScript 6, you can use a for..of loop
	   * for (let [key, value] of graph.verticesWithPathTo(to)) {
	   *     // iterates over all vertices from which `to` can be reached
	   * }
	   */
			value: function verticesWithPathTo(to) {
				this[_privateEs6Js._expectVertices](to);
				return this[_privateEs6Js._verticesWithPathTo](to, new Set());
			}
		}, {
			key: _privateEs6Js._verticesWithPathTo,
			value: regeneratorRuntime.mark(function callee$1$0(to, done) {
				var _iteratorNormalCompletion14, _didIteratorError14, _iteratorError14, _iterator14, _step14, _step14$value, from;
	
				return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
					while (1) switch (context$2$0.prev = context$2$0.next) {
						case 0:
							_iteratorNormalCompletion14 = true;
							_didIteratorError14 = false;
							_iteratorError14 = undefined;
							context$2$0.prev = 3;
							_iterator14 = this.verticesTo(to)[Symbol.iterator]();
	
						case 5:
							if (_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done) {
								context$2$0.next = 16;
								break;
							}
	
							_step14$value = _slicedToArray(_step14.value, 1);
							from = _step14$value[0];
	
							if (!(!done.has(from) && this.hasEdge(from, to))) {
								context$2$0.next = 13;
								break;
							}
	
							done.add(from);
							context$2$0.next = 12;
							return this.vertex(from);
	
						case 12:
							return context$2$0.delegateYield(this[_privateEs6Js._verticesWithPathTo](from, done), 't0', 13);
	
						case 13:
							_iteratorNormalCompletion14 = true;
							context$2$0.next = 5;
							break;
	
						case 16:
							context$2$0.next = 22;
							break;
	
						case 18:
							context$2$0.prev = 18;
							context$2$0.t1 = context$2$0['catch'](3);
							_didIteratorError14 = true;
							_iteratorError14 = context$2$0.t1;
	
						case 22:
							context$2$0.prev = 22;
							context$2$0.prev = 23;
	
							if (!_iteratorNormalCompletion14 && _iterator14['return']) {
								_iterator14['return']();
							}
	
						case 25:
							context$2$0.prev = 25;
	
							if (!_didIteratorError14) {
								context$2$0.next = 28;
								break;
							}
	
							throw _iteratorError14;
	
						case 28:
							return context$2$0.finish(25);
	
						case 29:
							return context$2$0.finish(22);
	
						case 30:
						case 'end':
							return context$2$0.stop();
					}
				}, callee$1$0, this, [[3, 18, 22, 30], [23,, 25, 29]]);
			})
		}, {
			key: 'sources',
	
			/**
	   * Iterate over all vertices that have no incoming edges, in no particular order.
	   * @returns {Iterator} an ES6 iterator yielding vertices
	   * @example
	   * for (var it = graph.sources(), kv; !(kv = it.next()).done;) {
	   *     var key   = kv.value[0],
	   *         value = kv.value[1];
	   *     // iterates over all vertices with no incoming edges
	   * }
	   * @example
	   * // in ECMAScript 6, you can use a for..of loop
	   * for (let [key, value] of graph.sources()) {
	   *     // iterates over all vertices with no incoming edges
	   * }
	   */
			value: regeneratorRuntime.mark(function sources() {
				var done, _iteratorNormalCompletion15, _didIteratorError15, _iteratorError15, _iterator15, _step15, key;
	
				return regeneratorRuntime.wrap(function sources$(context$2$0) {
					while (1) switch (context$2$0.prev = context$2$0.next) {
						case 0:
							done = new Set();
							_iteratorNormalCompletion15 = true;
							_didIteratorError15 = false;
							_iteratorError15 = undefined;
							context$2$0.prev = 4;
							_iterator15 = this[_privateEs6Js._sources][Symbol.iterator]();
	
						case 6:
							if (_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done) {
								context$2$0.next = 15;
								break;
							}
	
							key = _step15.value;
	
							if (!(this.hasVertex(key) && !done.has(key))) {
								context$2$0.next = 12;
								break;
							}
	
							done.add(key);
							context$2$0.next = 12;
							return this.vertex(key);
	
						case 12:
							_iteratorNormalCompletion15 = true;
							context$2$0.next = 6;
							break;
	
						case 15:
							context$2$0.next = 21;
							break;
	
						case 17:
							context$2$0.prev = 17;
							context$2$0.t0 = context$2$0['catch'](4);
							_didIteratorError15 = true;
							_iteratorError15 = context$2$0.t0;
	
						case 21:
							context$2$0.prev = 21;
							context$2$0.prev = 22;
	
							if (!_iteratorNormalCompletion15 && _iterator15['return']) {
								_iterator15['return']();
							}
	
						case 24:
							context$2$0.prev = 24;
	
							if (!_didIteratorError15) {
								context$2$0.next = 27;
								break;
							}
	
							throw _iteratorError15;
	
						case 27:
							return context$2$0.finish(24);
	
						case 28:
							return context$2$0.finish(21);
	
						case 29:
						case 'end':
							return context$2$0.stop();
					}
				}, sources, this, [[4, 17, 21, 29], [22,, 24, 28]]);
			})
		}, {
			key: 'sinks',
	
			/**
	   * Iterate over all vertices that have no outgoing edges, in no particular order.
	   * @returns {Iterator} an ES6 iterator yielding vertices
	   * @example
	   * for (var it = graph.sinks(), kv; !(kv = it.next()).done;) {
	   *     var key   = kv.value[0],
	   *         value = kv.value[1];
	   *     // iterates over all vertices with no outgoing edges
	   * }
	   * @example
	   * // in ECMAScript 6, you can use a for..of loop
	   * for (let [key, value] of graph.sinks()) {
	   *     // iterates over all vertices with no outgoing edges
	   * }
	   */
			value: regeneratorRuntime.mark(function sinks() {
				var done, _iteratorNormalCompletion16, _didIteratorError16, _iteratorError16, _iterator16, _step16, key;
	
				return regeneratorRuntime.wrap(function sinks$(context$2$0) {
					while (1) switch (context$2$0.prev = context$2$0.next) {
						case 0:
							done = new Set();
							_iteratorNormalCompletion16 = true;
							_didIteratorError16 = false;
							_iteratorError16 = undefined;
							context$2$0.prev = 4;
							_iterator16 = this[_privateEs6Js._sinks][Symbol.iterator]();
	
						case 6:
							if (_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done) {
								context$2$0.next = 15;
								break;
							}
	
							key = _step16.value;
	
							if (!(this.hasVertex(key) && !done.has(key))) {
								context$2$0.next = 12;
								break;
							}
	
							done.add(key);
							context$2$0.next = 12;
							return this.vertex(key);
	
						case 12:
							_iteratorNormalCompletion16 = true;
							context$2$0.next = 6;
							break;
	
						case 15:
							context$2$0.next = 21;
							break;
	
						case 17:
							context$2$0.prev = 17;
							context$2$0.t0 = context$2$0['catch'](4);
							_didIteratorError16 = true;
							_iteratorError16 = context$2$0.t0;
	
						case 21:
							context$2$0.prev = 21;
							context$2$0.prev = 22;
	
							if (!_iteratorNormalCompletion16 && _iterator16['return']) {
								_iterator16['return']();
							}
	
						case 24:
							context$2$0.prev = 24;
	
							if (!_didIteratorError16) {
								context$2$0.next = 27;
								break;
							}
	
							throw _iteratorError16;
	
						case 27:
							return context$2$0.finish(24);
	
						case 28:
							return context$2$0.finish(21);
	
						case 29:
						case 'end':
							return context$2$0.stop();
					}
				}, sinks, this, [[4, 17, 21, 29], [22,, 24, 28]]);
			})
		}, {
			key: 'set',
	
			////////////////////////////////////////
			////////// Setting & Clearing //////////
			////////////////////////////////////////
	
			/**
	   * Set this graph to become equal to another graph, so that it has
	   * all the same vertices and edges. It emits only those signals
	   * that are strictly necessary.
	   * @param other {Graph} the graph copy to this graph
	   */
			value: function set(other) {
				var _iteratorNormalCompletion17 = true;
				var _didIteratorError17 = false;
				var _iteratorError17 = undefined;
	
				try {
					for (var _iterator17 = this.edges()[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
						var _step17$value = _slicedToArray(_step17.value, 2);
	
						var key = _step17$value[0];
						var value = _step17$value[1];
	
						if (!other.hasEdge(key)) {
							this.removeExistingEdge(key);
						} else if (value !== other.edgeValue(key)) {
							this.setEdge(key, other.edgeValue(key));
						}
					}
				} catch (err) {
					_didIteratorError17 = true;
					_iteratorError17 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion17 && _iterator17['return']) {
							_iterator17['return']();
						}
					} finally {
						if (_didIteratorError17) {
							throw _iteratorError17;
						}
					}
				}
	
				var _iteratorNormalCompletion18 = true;
				var _didIteratorError18 = false;
				var _iteratorError18 = undefined;
	
				try {
					for (var _iterator18 = this.vertices()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
						var _step18$value = _slicedToArray(_step18.value, 2);
	
						var key = _step18$value[0];
						var value = _step18$value[1];
	
						if (!other.hasVertex(key)) {
							this.removeExistingVertex(key);
						} else if (value !== other.vertexValue(key)) {
							this.setVertex(key, other.vertexValue(key));
						}
					}
				} catch (err) {
					_didIteratorError18 = true;
					_iteratorError18 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion18 && _iterator18['return']) {
							_iterator18['return']();
						}
					} finally {
						if (_didIteratorError18) {
							throw _iteratorError18;
						}
					}
				}
	
				var _iteratorNormalCompletion19 = true;
				var _didIteratorError19 = false;
				var _iteratorError19 = undefined;
	
				try {
					for (var _iterator19 = other.vertices()[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
						var _step19$value = _slicedToArray(_step19.value, 2);
	
						var key = _step19$value[0];
						var value = _step19$value[1];
	
						if (!this.hasVertex(key)) {
							this.addNewVertex(key, value);
						}
					}
				} catch (err) {
					_didIteratorError19 = true;
					_iteratorError19 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion19 && _iterator19['return']) {
							_iterator19['return']();
						}
					} finally {
						if (_didIteratorError19) {
							throw _iteratorError19;
						}
					}
				}
	
				var _iteratorNormalCompletion20 = true;
				var _didIteratorError20 = false;
				var _iteratorError20 = undefined;
	
				try {
					for (var _iterator20 = other.edges()[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
						var _step20$value = _slicedToArray(_step20.value, 2);
	
						var key = _step20$value[0];
						var value = _step20$value[1];
	
						if (!this.hasEdge(key)) {
							this.addNewEdge(key, value);
						}
					}
				} catch (err) {
					_didIteratorError20 = true;
					_iteratorError20 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion20 && _iterator20['return']) {
							_iterator20['return']();
						}
					} finally {
						if (_didIteratorError20) {
							throw _iteratorError20;
						}
					}
				}
			}
		}, {
			key: 'clearEdges',
	
			/**
	   * Remove all edges from the graph, but leave the vertices intact.
	   */
			value: function clearEdges() {
				var _iteratorNormalCompletion21 = true;
				var _didIteratorError21 = false;
				var _iteratorError21 = undefined;
	
				try {
					for (var _iterator21 = this.edges()[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
						var _step21$value = _slicedToArray(_step21.value, 1);
	
						var key = _step21$value[0];
						this.removeEdge(key);
					}
				} catch (err) {
					_didIteratorError21 = true;
					_iteratorError21 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion21 && _iterator21['return']) {
							_iterator21['return']();
						}
					} finally {
						if (_didIteratorError21) {
							throw _iteratorError21;
						}
					}
				}
			}
		}, {
			key: 'clear',
	
			/**
	   * Remove all edges and vertices from the graph, putting it back in its initial state.
	   */
			value: function clear() {
				var _iteratorNormalCompletion22 = true;
				var _didIteratorError22 = false;
				var _iteratorError22 = undefined;
	
				try {
					for (var _iterator22 = this.vertices()[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
						var _step22$value = _slicedToArray(_step22.value, 1);
	
						var key = _step22$value[0];
						this.destroyVertex(key);
					}
				} catch (err) {
					_didIteratorError22 = true;
					_iteratorError22 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion22 && _iterator22['return']) {
							_iterator22['return']();
						}
					} finally {
						if (_didIteratorError22) {
							throw _iteratorError22;
						}
					}
				}
			}
		}, {
			key: 'equals',
	
			////////////////////////////////////////
			////////// (Advanced) Queries //////////
			////////////////////////////////////////
	
			/**
	   * Ask whether `this` graph and a given `other` graph are equal.
	   * Two graphs are equal if they have the same vertices and the same edges.
	   * @param other {Graph} the other graph to compare to `this` one
	   * @param [eqV] {function(*, *, string): boolean}
	   *     a custom equality function for values stored in vertices;
	   *     defaults to `===` comparison; The first two arguments are the
	   *     values to compare. The third is the corresponding `key`.
	   * @param [eqE] {function(*, *, Array): boolean}
	   *     a custom equality function for values stored in edges;
	   *     defaults to the function given for `eqV`; The first two arguments
	   *     are the values to compare. The third is the corresponding
	   *     `[from, to]` key.
	   * @returns {boolean} `true` if the two graphs are equal; `false` otherwise
	   */
			value: function equals(other) {
				var eqV = arguments[1] === undefined ? function (x, y) {
					return x === y;
				} : arguments[1];
				var eqE = arguments[2] === undefined ? eqV : arguments[2];
				return (function () {
					if (!(other instanceof Graph)) {
						return false;
					}
					if (this.vertexCount() !== other.vertexCount()) {
						return false;
					}
					if (this.edgeCount() !== other.edgeCount()) {
						return false;
					}
					var _iteratorNormalCompletion23 = true;
					var _didIteratorError23 = false;
					var _iteratorError23 = undefined;
	
					try {
						for (var _iterator23 = this.vertices()[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
							var _step23$value = _slicedToArray(_step23.value, 2);
	
							var key = _step23$value[0];
							var value = _step23$value[1];
	
							if (!other.hasVertex(key)) {
								return false;
							}
							if (!eqV(value, other.vertexValue(key), key)) {
								return false;
							}
						}
					} catch (err) {
						_didIteratorError23 = true;
						_iteratorError23 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion23 && _iterator23['return']) {
								_iterator23['return']();
							}
						} finally {
							if (_didIteratorError23) {
								throw _iteratorError23;
							}
						}
					}
	
					var _iteratorNormalCompletion24 = true;
					var _didIteratorError24 = false;
					var _iteratorError24 = undefined;
	
					try {
						for (var _iterator24 = this.edges()[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
							var _step24$value = _slicedToArray(_step24.value, 2);
	
							var key = _step24$value[0];
							var value = _step24$value[1];
	
							if (!other.hasEdge(key)) {
								return false;
							}
							if (!eqE(value, other.edgeValue(key), key)) {
								return false;
							}
						}
					} catch (err) {
						_didIteratorError24 = true;
						_iteratorError24 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion24 && _iterator24['return']) {
								_iterator24['return']();
							}
						} finally {
							if (_didIteratorError24) {
								throw _iteratorError24;
							}
						}
					}
	
					return true;
				}).apply(this, arguments);
			}
		}, {
			key: 'cycles',
	
			/**
	   * Iterate over all simple directed cycles in this graph, in no particular order.
	   * If you mutate the graph in between iterations, behavior of the iterator
	   * becomes unspecified. (So, don't.)
	   * @returns {Iterator} an ES6 iterator yielding arrays containing the vertex keys describing a cycle;
	   *                     These arrays will contain each vertex key only once — even the first/last one.
	   * @example
	   * for (var it = graph.cycles(), kv; !(kv = it.next()).done;) {
	   *     var cycle = kv.value;
	   *     // iterates over all cycles of the graph
	   * }
	   * @example
	   * // in ECMAScript 6, you can use a for..of loop
	   * for (let cycle of graph.cycles()) {
	   *     // iterates over all cycles of the graph
	   * }
	   */
			value: regeneratorRuntime.mark(function cycles() {
				var marked2$0, pointStack, markedStack, mark, _this, backtrack, _iteratorNormalCompletion25, _didIteratorError25, _iteratorError25, _iterator25, _step25, _step25$value, a;
	
				return regeneratorRuntime.wrap(function cycles$(context$2$0) {
					while (1) switch (context$2$0.prev = context$2$0.next) {
						case 0:
							backtrack = function backtrack(v) {
								var out = arguments[1] === undefined ? {} : arguments[1];
	
								var _arr, _i, _arr$_i, w, o, u;
	
								return regeneratorRuntime.wrap(function backtrack$(context$3$0) {
									while (1) switch (context$3$0.prev = context$3$0.next) {
										case 0:
											pointStack.push(v);
											mark.add(v);
											markedStack.push(v);
											_arr = [].concat(_toConsumableArray(_this.verticesFrom(v)));
											_i = 0;
	
										case 5:
											if (!(_i < _arr.length)) {
												context$3$0.next = 23;
												break;
											}
	
											_arr$_i = _slicedToArray(_arr[_i], 1);
											w = _arr$_i[0];
	
											if (!(w < pointStack[0])) {
												context$3$0.next = 10;
												break;
											}
	
											return context$3$0.abrupt('continue', 20);
	
										case 10:
											if (!(w === pointStack[0])) {
												context$3$0.next = 16;
												break;
											}
	
											context$3$0.next = 13;
											return [].concat(pointStack);
	
										case 13:
											out.found = true;
											context$3$0.next = 20;
											break;
	
										case 16:
											if (mark.has(w)) {
												context$3$0.next = 20;
												break;
											}
	
											o = {};
											return context$3$0.delegateYield(backtrack(w, o), 't0', 19);
	
										case 19:
											out.found = out.found || o.found;
	
										case 20:
											_i++;
											context$3$0.next = 5;
											break;
	
										case 23:
											if (out.found) {
												u = undefined;
	
												do {
													u = markedStack.pop();
													mark['delete'](u);
												} while (u !== v);
											}
											pointStack.pop();
	
										case 25:
										case 'end':
											return context$3$0.stop();
									}
								}, marked2$0[0], this);
							};
	
							marked2$0 = [backtrack].map(regeneratorRuntime.mark);
							pointStack = [];
							markedStack = undefined, mark = undefined;
							_this = this;
							_iteratorNormalCompletion25 = true;
							_didIteratorError25 = false;
							_iteratorError25 = undefined;
							context$2$0.prev = 8;
							_iterator25 = this.vertices()[Symbol.iterator]();
	
						case 10:
							if (_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done) {
								context$2$0.next = 19;
								break;
							}
	
							_step25$value = _slicedToArray(_step25.value, 1);
							a = _step25$value[0];
	
							markedStack = [];
							mark = new Set();
							return context$2$0.delegateYield(backtrack(a), 't0', 16);
	
						case 16:
							_iteratorNormalCompletion25 = true;
							context$2$0.next = 10;
							break;
	
						case 19:
							context$2$0.next = 25;
							break;
	
						case 21:
							context$2$0.prev = 21;
							context$2$0.t1 = context$2$0['catch'](8);
							_didIteratorError25 = true;
							_iteratorError25 = context$2$0.t1;
	
						case 25:
							context$2$0.prev = 25;
							context$2$0.prev = 26;
	
							if (!_iteratorNormalCompletion25 && _iterator25['return']) {
								_iterator25['return']();
							}
	
						case 28:
							context$2$0.prev = 28;
	
							if (!_didIteratorError25) {
								context$2$0.next = 31;
								break;
							}
	
							throw _iteratorError25;
	
						case 31:
							return context$2$0.finish(28);
	
						case 32:
							return context$2$0.finish(25);
	
						case 33:
						case 'end':
							return context$2$0.stop();
					}
				}, cycles, this, [[8, 21, 25, 33], [26,, 28, 32]]);
			})
		}, {
			key: 'cycle',
	
			/**
	   * Find any directed cycle in this graph.
	   * @returns {?Array} an array containing the vertex keys describing the cycle; `null`, if there is no cycle;
	   *                   The array will contain each vertex key only once — even the first/last one.
	   */
			value: function cycle() {
				var result = this.cycles().next();
				return result.done ? null : result.value;
			}
		}, {
			key: 'hasCycle',
	
			/**
	   * Test whether this graph contains a directed cycle.
	   * @returns {boolean} whether this graph contains any directed cycle
	   */
			value: function hasCycle() {
				return !this.cycles().next().done;
			}
		}, {
			key: 'paths',
	
			/**
	   * Iterate over all paths between two given keys in this graph, in no particular order.
	   * If you mutate the graph in between iterations, behavior of the iterator
	   * becomes unspecified. (So, don't.)
	   * @param from {string} the key for the originating vertex
	   * @param to   {string} the key for the terminating vertex
	   * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph
	   * @returns {Iterator} an ES6 iterator yielding arrays containing the vertex-keys describing the path
	   * @example
	   * for (var it = graph.paths(from, to), kv; !(kv = it.next()).done;) {
	   *     var path = kv.value;
	   *     // iterates over all paths between `from` and `to` in the graph
	   * }
	   * @example
	   * // in ECMAScript 6, you can use a for..of loop
	   * for (let path of graph.paths(from, to)) {
	   *     // iterates over all paths between `from` and `to` in the graph
	   * }
	   */ // TODO: allow [from, to] array to be given as argument in docs
			value: function paths(from, to) {
				var _Graph$_extractTwoArgs11 = Graph[_privateEs6Js._extractTwoArgs](from, to);
	
				var _Graph$_extractTwoArgs112 = _slicedToArray(_Graph$_extractTwoArgs11, 2);
	
				from = _Graph$_extractTwoArgs112[0];
				to = _Graph$_extractTwoArgs112[1];
	
				this[_privateEs6Js._expectVertices](from, to);
				return this[_privateEs6Js._paths](from, to);
			}
		}, {
			key: _privateEs6Js._paths,
			value: regeneratorRuntime.mark(function callee$1$0(from, to) {
				var marked2$0, stack, _this, pathsFromPrefix;
	
				return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
					while (1) switch (context$2$0.prev = context$2$0.next) {
						case 0:
							pathsFromPrefix = function pathsFromPrefix(current) {
								var _iteratorNormalCompletion26, _didIteratorError26, _iteratorError26, _iterator26, _step26, _step26$value, next;
	
								return regeneratorRuntime.wrap(function pathsFromPrefix$(context$3$0) {
									while (1) switch (context$3$0.prev = context$3$0.next) {
										case 0:
											stack.push(current);
											_iteratorNormalCompletion26 = true;
											_didIteratorError26 = false;
											_iteratorError26 = undefined;
											context$3$0.prev = 4;
											_iterator26 = _this.verticesFrom(current)[Symbol.iterator]();
	
										case 6:
											if (_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done) {
												context$3$0.next = 19;
												break;
											}
	
											_step26$value = _slicedToArray(_step26.value, 1);
											next = _step26$value[0];
	
											if (!(next === to)) {
												context$3$0.next = 14;
												break;
											}
	
											context$3$0.next = 12;
											return [].concat(stack, [to]);
	
										case 12:
											context$3$0.next = 16;
											break;
	
										case 14:
											if (!(stack.indexOf(next) === -1)) {
												context$3$0.next = 16;
												break;
											}
	
											return context$3$0.delegateYield(pathsFromPrefix(next), 't0', 16);
	
										case 16:
											_iteratorNormalCompletion26 = true;
											context$3$0.next = 6;
											break;
	
										case 19:
											context$3$0.next = 25;
											break;
	
										case 21:
											context$3$0.prev = 21;
											context$3$0.t1 = context$3$0['catch'](4);
											_didIteratorError26 = true;
											_iteratorError26 = context$3$0.t1;
	
										case 25:
											context$3$0.prev = 25;
											context$3$0.prev = 26;
	
											if (!_iteratorNormalCompletion26 && _iterator26['return']) {
												_iterator26['return']();
											}
	
										case 28:
											context$3$0.prev = 28;
	
											if (!_didIteratorError26) {
												context$3$0.next = 31;
												break;
											}
	
											throw _iteratorError26;
	
										case 31:
											return context$3$0.finish(28);
	
										case 32:
											return context$3$0.finish(25);
	
										case 33:
											stack.pop();
	
										case 34:
										case 'end':
											return context$3$0.stop();
									}
								}, marked2$0[0], this, [[4, 21, 25, 33], [26,, 28, 32]]);
							};
	
							marked2$0 = [pathsFromPrefix].map(regeneratorRuntime.mark);
							stack = [];
							_this = this;
							return context$2$0.delegateYield(pathsFromPrefix(from), 't0', 5);
	
						case 5:
						case 'end':
							return context$2$0.stop();
					}
				}, callee$1$0, this);
			})
		}, {
			key: 'path',
	
			/**
	   * Find any path between a given pair of keys.
	   * @param from {string} the originating vertex
	   * @param to   {string} the terminating vertex
	   * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph
	   * @returns {?Array} an array with the keys of the path found between the two vertices,
	   *                   including those two vertices themselves; `null` if no such path exists
	   */ // TODO: allow [from, to] array to be given as argument in docs
			value: function path(from, to) {
				var result = this.paths(from, to).next();
				return result.done ? null : result.value;
			}
		}, {
			key: 'hasPath',
	
			/**
	   * Test whether there is a directed path between a given pair of keys.
	   * @param from {string} the originating vertex
	   * @param to   {string} the terminating vertex
	   * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph
	   * @returns {boolean} whether such a path exists
	   */ // TODO: allow [from, to] array to be given as argument in docs
			value: function hasPath(from, to) {
				return !this.paths(from, to).next().done;
			}
		}, {
			key: 'outDegree',
	
			/**
	   * Get the number of edges going out of a given vertex.
	   * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist
	   * @param key {string} the key of the vertex to query
	   * @returns {number} the number of edges going out of the `key` vertex
	   */
			value: function outDegree(key) {
				this[_privateEs6Js._expectVertices](key);
				return this[_privateEs6Js._edges].get(key).size;
			}
		}, {
			key: 'inDegree',
	
			/**
	   * Get the number of edges coming into a given vertex.
	   * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist
	   * @param key {string} the key of the vertex to query
	   * @returns {number} the number of edges coming into the `key` vertex
	   */
			value: function inDegree(key) {
				this[_privateEs6Js._expectVertices](key);
				return this[_privateEs6Js._reverseEdges].get(key).size;
			}
		}, {
			key: 'degree',
	
			/**
	   * Get the number of edges connected to a given vertex.
	   * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist
	   * @param key {string} the key of the vertex to query
	   * @returns {number} the number of edges connected to the `key` vertex
	   */
			value: function degree(key) {
				return this.outDegree(key) + this.inDegree(key);
			}
		}, {
			key: 'mergeIn',
	
			///////////////////////////////////////
			////////// Cloning and stuff //////////
			///////////////////////////////////////
	
			/**
	   * Merge another graph into this graph.
	   * @param other {Graph} the other graph to merge into this one
	   * @param [mV] {function(*, *, string): *}
	   *     a custom merge function for values stored in vertices;
	   *     defaults to choosing the second value over the first; The first and
	   *     second arguments are the vertex values of `this` graph and the
	   *     `other` graph respectively. The third is the corresponding `key`.
	   * @param [mE] {function(*, *, Array): *}
	   *     a custom merge function for values stored in edges;
	   *     defaults to whichever of the two values is not `undefined`,
	   *     giving preference to that of the other graph; The first and
	   *     second arguments are the edge values of `this` graph and the
	   *     `other` graph respectively. The third is the
	   *     corresponding `[from, to]` key.
	   */
			value: function mergeIn(other) {
				var mV = arguments[1] === undefined ? function (v1, v2) {
					return v2;
				} : arguments[1];
				var mE = arguments[2] === undefined ? mV : arguments[2];
				return (function () {
					var _iteratorNormalCompletion27 = true;
					var _didIteratorError27 = false;
					var _iteratorError27 = undefined;
	
					try {
						for (var _iterator27 = other.vertices()[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
							var _step27$value = _slicedToArray(_step27.value, 2);
	
							var key = _step27$value[0];
							var value = _step27$value[1];
	
							this.addVertex(key, mV(this.vertexValue(key), value, key));
						}
					} catch (err) {
						_didIteratorError27 = true;
						_iteratorError27 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion27 && _iterator27['return']) {
								_iterator27['return']();
							}
						} finally {
							if (_didIteratorError27) {
								throw _iteratorError27;
							}
						}
					}
	
					var _iteratorNormalCompletion28 = true;
					var _didIteratorError28 = false;
					var _iteratorError28 = undefined;
	
					try {
						for (var _iterator28 = other.edges()[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
							var _step28$value = _slicedToArray(_step28.value, 2);
	
							var key = _step28$value[0];
							var value = _step28$value[1];
	
							this.addEdge(key, mE(this.edgeValue(key), value, key));
						}
					} catch (err) {
						_didIteratorError28 = true;
						_iteratorError28 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion28 && _iterator28['return']) {
								_iterator28['return']();
							}
						} finally {
							if (_didIteratorError28) {
								throw _iteratorError28;
							}
						}
					}
				}).apply(this, arguments);
			}
		}, {
			key: 'clone',
	
			/**
	   * Create a clone of this graph.
	   * @param [trV] {function(*, string): *}
	   *     a custom transformation function for values stored in vertices;
	   *     defaults to the identity function; The first argument is the
	   *     value to clone. The second is the corresponding `key`.
	   * @param [trE] {function(*, Array): *}
	   *     a custom transformation function for values stored in edges;
	   *     defaults to the function given for `trV`; The first argument
	   *     is the value to clone. The second is the corresponding
	   *     `[from, to]` key.
	   * @returns {Graph} a clone of this graph
	   */
			value: function clone() {
				var trV = arguments[0] === undefined ? function (v) {
					return v;
				} : arguments[0];
				var trE = arguments[1] === undefined ? trV : arguments[1];
				return (function () {
					var result = new Graph();
					result.mergeIn(this, function (v1, v2) {
						return trV(v2);
					}, function (v1, v2) {
						return trE(v2);
					});
					return result;
				}).apply(this, arguments);
			}
		}, {
			key: 'transitiveReduction',
	
			/**
	   * Create a clone of this graph, but without any transitive edges.
	   * @param [trV] {function(*, string): *}
	   *     a custom transformation function for values stored in vertices;
	   *     defaults to the identity function; The first argument is the
	   *     value to clone. The second is the corresponding `key`.
	   * @param [trE] {function(*, Array): *}
	   *     a custom transformation function for values stored in edges;
	   *     defaults to the function given for `trV`; The first argument
	   *     is the value to clone. The second is the corresponding
	   *     `[from, to]` key.
	   * @returns {Graph} a clone of this graph with all transitive edges removed
	   */
			value: function transitiveReduction(trV, trE) {
				// argument defaults are handled in `clone`
				var result = this.clone(trV, trE);
				var _iteratorNormalCompletion29 = true;
				var _didIteratorError29 = false;
				var _iteratorError29 = undefined;
	
				try {
					for (var _iterator29 = this.vertices()[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
						var _step29$value = _slicedToArray(_step29.value, 1);
	
						var x = _step29$value[0];
						var _iteratorNormalCompletion30 = true;
						var _didIteratorError30 = false;
						var _iteratorError30 = undefined;
	
						try {
							for (var _iterator30 = this.vertices()[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
								var _step30$value = _slicedToArray(_step30.value, 1);
	
								var y = _step30$value[0];
	
								if (result.hasEdge(x, y)) {
									var _iteratorNormalCompletion31 = true;
									var _didIteratorError31 = false;
									var _iteratorError31 = undefined;
	
									try {
										for (var _iterator31 = this.vertices()[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {
											var _step31$value = _slicedToArray(_step31.value, 1);
	
											var z = _step31$value[0];
	
											if (result.hasPath(y, z)) result.removeEdge(x, z);
										}
									} catch (err) {
										_didIteratorError31 = true;
										_iteratorError31 = err;
									} finally {
										try {
											if (!_iteratorNormalCompletion31 && _iterator31['return']) {
												_iterator31['return']();
											}
										} finally {
											if (_didIteratorError31) {
												throw _iteratorError31;
											}
										}
									}
								}
							}
						} catch (err) {
							_didIteratorError30 = true;
							_iteratorError30 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion30 && _iterator30['return']) {
									_iterator30['return']();
								}
							} finally {
								if (_didIteratorError30) {
									throw _iteratorError30;
								}
							}
						}
					}
				} catch (err) {
					_didIteratorError29 = true;
					_iteratorError29 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion29 && _iterator29['return']) {
							_iterator29['return']();
						}
					} finally {
						if (_didIteratorError29) {
							throw _iteratorError29;
						}
					}
				}
	
				return result;
			}
		}, {
			key: 'contractPaths',
	
			/**
	   * This method replaces stretches of non-branching directed pathway into single edges.
	   * More specifically, it identifies all 'nexus' vertices in the graph and preserves them.
	   * It then removes all other vertices and all edges from the graph, then inserts edges
	   * between nexuses that summarize the connectivity that was there before.
	   *
	   * A nexus is any vertex that is *not* characterized by '1 edge in, 1 edge out'.
	   * A custom `isNexus` function may be provided to manually select additional vertices
	   * that should be preserved as nexus.
	   * @param [isNexus] {function(string, *): boolean}
	   *                  a predicate for identifying additional vertices that should be treated as nexus;
	   *                  It receives a `key` and `value` associated to a vertex and should return
	   *                  true if and only if that vertex should be a nexus.
	   * @throws {Graph.BranchlessCycleError} if the graph contains a cycle with no branches or nexuses
	   */
			value: function contractPaths() {
				var _this2 = this;
	
				var _ref = arguments[0] === undefined ? {} : arguments[0];
	
				var isNexus = _ref.isNexus;
	
				/* defaults */
				if (!isNexus) {
					isNexus = function () {
						return false;
					};
				}
	
				/* what makes a a vertex a nexus (start/end-point) */
				var nexuses = new Set([].concat(_toConsumableArray(this.vertices())).filter(function (_ref2) {
					var _ref22 = _slicedToArray(_ref2, 2);
	
					var key = _ref22[0];
					var val = _ref22[1];
					return _this2.outDegree(key) !== 1 || _this2.inDegree(key) !== 1 || isNexus(key, val);
				}).map(function (_ref3) {
					var _ref32 = _slicedToArray(_ref3, 1);
	
					var key = _ref32[0];
					return key;
				}));
	
				/* error if there is a branch-less cycle */
				{
					var _iteratorNormalCompletion34;
	
					var _didIteratorError34;
	
					var _iteratorError34;
	
					var _iterator34, _step34;
	
					(function () {
						var unhandledVertices = new Set([].concat(_toConsumableArray(_this2.vertices())).map(function (_ref4) {
							var _ref42 = _slicedToArray(_ref4, 1);
	
							var key = _ref42[0];
							return key;
						}));
						var checkForBlCycle = function checkForBlCycle(key) {
							if (!unhandledVertices.has(key)) {
								return;
							}
							unhandledVertices['delete'](key);
							var _iteratorNormalCompletion32 = true;
							var _didIteratorError32 = false;
							var _iteratorError32 = undefined;
	
							try {
								for (var _iterator32 = _this2.verticesFrom(key)[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
									var _step32$value = _slicedToArray(_step32.value, 1);
	
									var next = _step32$value[0];
									checkForBlCycle(next);
								}
							} catch (err) {
								_didIteratorError32 = true;
								_iteratorError32 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion32 && _iterator32['return']) {
										_iterator32['return']();
									}
								} finally {
									if (_didIteratorError32) {
										throw _iteratorError32;
									}
								}
							}
	
							var _iteratorNormalCompletion33 = true;
							var _didIteratorError33 = false;
							var _iteratorError33 = undefined;
	
							try {
								for (var _iterator33 = _this2.verticesTo(key)[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {
									var _step33$value = _slicedToArray(_step33.value, 1);
	
									var next = _step33$value[0];
									checkForBlCycle(next);
								}
							} catch (err) {
								_didIteratorError33 = true;
								_iteratorError33 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion33 && _iterator33['return']) {
										_iterator33['return']();
									}
								} finally {
									if (_didIteratorError33) {
										throw _iteratorError33;
									}
								}
							}
						};
						_iteratorNormalCompletion34 = true;
						_didIteratorError34 = false;
						_iteratorError34 = undefined;
	
						try {
							for (_iterator34 = nexuses[Symbol.iterator](); !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {
								var key = _step34.value;
								checkForBlCycle(key);
							}
						} catch (err) {
							_didIteratorError34 = true;
							_iteratorError34 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion34 && _iterator34['return']) {
									_iterator34['return']();
								}
							} finally {
								if (_didIteratorError34) {
									throw _iteratorError34;
								}
							}
						}
	
						if (unhandledVertices.size > 0) {
							var startingKey = unhandledVertices.values().next().value,
							    cycle = [],
							    current = startingKey;
							do {
								cycle.push(current);
								current = _this2.verticesFrom(current).next().value[0];
							} while (current !== startingKey);
							throw new Graph.BranchlessCycleError(cycle);
						}
					})();
				}
	
				/* bookkeeping */
				var contractionsToAdd = new Map();
	
				/* register the path starting with the given edge */
				var startPath = function startPath(start, next, backwards) {
					/* functions to help branch on `backwards` */
					var fromTo = function fromTo() {
						var strt = arguments[0] === undefined ? start : arguments[0];
						var nxt = arguments[1] === undefined ? next : arguments[1];
						return backwards ? [nxt, strt] : [strt, nxt];
					};
					var verticesNext = function verticesNext(v) {
						return backwards ? _this2.verticesTo(v) : _this2.verticesFrom(v);
					};
	
					/* bookkeeping */
					var verticesToRemove = new Set();
					var edgesToRemove = new Set();
					var path = new _this2.constructor();
	
					/* process the start of the path */
					path.addVertex(start, _this2.vertexValue(start));
					path.addVertex(next, _this2.vertexValue(next));
					path.addNewEdge.apply(path, _toConsumableArray(fromTo()).concat([_this2.edgeValue.apply(_this2, _toConsumableArray(fromTo()))]));
					edgesToRemove.add(fromTo());
	
					/* process as [current, next] moves across the path */
					var current = undefined;
					while (!nexuses.has(next)) {
						var _ref5 = [next, verticesNext(next).next().value[0]];
						current = _ref5[0];
						next = _ref5[1];
	
						path.addVertex(next, _this2.vertexValue(next));
						path.addNewEdge.apply(path, _toConsumableArray(fromTo(current, next)).concat([_this2.edgeValue.apply(_this2, _toConsumableArray(fromTo(current, next)))]));
						verticesToRemove.add(current);
						edgesToRemove.add(fromTo(current, next));
					}
	
					/* register new path contraction */
					if (!contractionsToAdd.get(fromTo()[0])) {
						contractionsToAdd.set(fromTo()[0], new Map());
					}
					if (!contractionsToAdd.get(fromTo()[0]).get(fromTo()[1])) {
						contractionsToAdd.get(fromTo()[0]).set(fromTo()[1], new _this2.constructor());
					}
					contractionsToAdd.get(fromTo()[0]).get(fromTo()[1]).mergeIn(path);
	
					/* remove old edges and vertices */
					var _iteratorNormalCompletion35 = true;
					var _didIteratorError35 = false;
					var _iteratorError35 = undefined;
	
					try {
						for (var _iterator35 = edgesToRemove[Symbol.iterator](), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {
							var key = _step35.value;
							_this2.removeExistingEdge.apply(_this2, _toConsumableArray(key));
						}
					} catch (err) {
						_didIteratorError35 = true;
						_iteratorError35 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion35 && _iterator35['return']) {
								_iterator35['return']();
							}
						} finally {
							if (_didIteratorError35) {
								throw _iteratorError35;
							}
						}
					}
	
					var _iteratorNormalCompletion36 = true;
					var _didIteratorError36 = false;
					var _iteratorError36 = undefined;
	
					try {
						for (var _iterator36 = verticesToRemove[Symbol.iterator](), _step36; !(_iteratorNormalCompletion36 = (_step36 = _iterator36.next()).done); _iteratorNormalCompletion36 = true) {
							var key = _step36.value;
							_this2.destroyExistingVertex(key);
						}
					} catch (err) {
						_didIteratorError36 = true;
						_iteratorError36 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion36 && _iterator36['return']) {
								_iterator36['return']();
							}
						} finally {
							if (_didIteratorError36) {
								throw _iteratorError36;
							}
						}
					}
				};
	
				/* process paths starting at all nexus points */
				var _iteratorNormalCompletion37 = true;
				var _didIteratorError37 = false;
				var _iteratorError37 = undefined;
	
				try {
					for (var _iterator37 = nexuses[Symbol.iterator](), _step37; !(_iteratorNormalCompletion37 = (_step37 = _iterator37.next()).done); _iteratorNormalCompletion37 = true) {
						var first = _step37.value;
						var _iteratorNormalCompletion39 = true;
						var _didIteratorError39 = false;
						var _iteratorError39 = undefined;
	
						try {
							for (var _iterator39 = this.verticesFrom(first)[Symbol.iterator](), _step39; !(_iteratorNormalCompletion39 = (_step39 = _iterator39.next()).done); _iteratorNormalCompletion39 = true) {
								var _step39$value = _slicedToArray(_step39.value, 1);
	
								var next = _step39$value[0];
								startPath(first, next, false);
							}
						} catch (err) {
							_didIteratorError39 = true;
							_iteratorError39 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion39 && _iterator39['return']) {
									_iterator39['return']();
								}
							} finally {
								if (_didIteratorError39) {
									throw _iteratorError39;
								}
							}
						}
	
						var _iteratorNormalCompletion40 = true;
						var _didIteratorError40 = false;
						var _iteratorError40 = undefined;
	
						try {
							for (var _iterator40 = this.verticesTo(first)[Symbol.iterator](), _step40; !(_iteratorNormalCompletion40 = (_step40 = _iterator40.next()).done); _iteratorNormalCompletion40 = true) {
								var _step40$value = _slicedToArray(_step40.value, 1);
	
								var next = _step40$value[0];
								startPath(first, next, true);
							}
						} catch (err) {
							_didIteratorError40 = true;
							_iteratorError40 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion40 && _iterator40['return']) {
									_iterator40['return']();
								}
							} finally {
								if (_didIteratorError40) {
									throw _iteratorError40;
								}
							}
						}
					}
				} catch (err) {
					_didIteratorError37 = true;
					_iteratorError37 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion37 && _iterator37['return']) {
							_iterator37['return']();
						}
					} finally {
						if (_didIteratorError37) {
							throw _iteratorError37;
						}
					}
				}
	
				/* add the replacement edges */
				var _iteratorNormalCompletion38 = true;
				var _didIteratorError38 = false;
				var _iteratorError38 = undefined;
	
				try {
					for (var _iterator38 = contractionsToAdd[Symbol.iterator](), _step38; !(_iteratorNormalCompletion38 = (_step38 = _iterator38.next()).done); _iteratorNormalCompletion38 = true) {
						var _step38$value = _slicedToArray(_step38.value, 2);
	
						var from = _step38$value[0];
						var toVal = _step38$value[1];
						var _iteratorNormalCompletion41 = true;
						var _didIteratorError41 = false;
						var _iteratorError41 = undefined;
	
						try {
							for (var _iterator41 = toVal[Symbol.iterator](), _step41; !(_iteratorNormalCompletion41 = (_step41 = _iterator41.next()).done); _iteratorNormalCompletion41 = true) {
								var _step41$value = _slicedToArray(_step41.value, 2);
	
								var to = _step41$value[0];
								var rememberedPath = _step41$value[1];
	
								this.addNewEdge(from, to, rememberedPath);
							}
						} catch (err) {
							_didIteratorError41 = true;
							_iteratorError41 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion41 && _iterator41['return']) {
									_iterator41['return']();
								}
							} finally {
								if (_didIteratorError41) {
									throw _iteratorError41;
								}
							}
						}
					}
				} catch (err) {
					_didIteratorError38 = true;
					_iteratorError38 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion38 && _iterator38['return']) {
							_iterator38['return']();
						}
					} finally {
						if (_didIteratorError38) {
							throw _iteratorError38;
						}
					}
				}
			}
		}, {
			key: _privateEs6Js._expectVertices,
	
			////////////////////////////////
			////////// Assertions //////////
			////////////////////////////////
	
			value: function () {
				var _this3 = this;
	
				for (var _len2 = arguments.length, keys = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
					keys[_key2] = arguments[_key2];
				}
	
				var missingVertices = keys.filter(function (k) {
					return !_this3.hasVertex(k);
				});
				if (missingVertices.length) {
					throw new (_bind.apply(Graph.VertexNotExistsError, [null].concat(_toConsumableArray(missingVertices))))();
				}
			}
		}, {
			key: _privateEs6Js._expectVerticesAbsent,
			value: function () {
				var _this4 = this;
	
				for (var _len3 = arguments.length, keys = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
					keys[_key3] = arguments[_key3];
				}
	
				var presentVertices = keys.filter(function (k) {
					return _this4.hasVertex(k);
				});
				if (presentVertices.length) {
					throw new (_bind.apply(Graph.VertexExistsError, [null].concat(_toConsumableArray(presentVertices.map(function (key) {
						return _this4.vertex(key);
					})))))();
				}
			}
		}, {
			key: _privateEs6Js._expectEdges,
			value: function () {
				var _this5 = this;
	
				for (var _len4 = arguments.length, keys = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
					keys[_key4] = arguments[_key4];
				}
	
				var absentEdges = keys.filter(function (k) {
					return !_this5.hasEdge.apply(_this5, _toConsumableArray(k));
				});
				if (absentEdges.length) {
					throw new (_bind.apply(Graph.EdgeNotExistsError, [null].concat(_toConsumableArray(absentEdges))))();
				}
			}
		}, {
			key: _privateEs6Js._expectEdgesAbsent,
			value: function () {
				var _this6 = this;
	
				for (var _len5 = arguments.length, keys = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
					keys[_key5] = arguments[_key5];
				}
	
				var presentEdges = keys.filter(function (k) {
					return _this6.hasEdge.apply(_this6, _toConsumableArray(k));
				});
				if (presentEdges.length) {
					throw new (_bind.apply(Graph.EdgeExistsError, [null].concat(_toConsumableArray(presentEdges.map(function (key) {
						return _this6.edge(key);
					})))))();
				}
			}
		}, {
			key: _privateEs6Js._expectNoConnectedEdges,
			value: function (key) {
				var edges = [];
				var _iteratorNormalCompletion42 = true;
				var _didIteratorError42 = false;
				var _iteratorError42 = undefined;
	
				try {
					for (var _iterator42 = this.verticesFrom(key)[Symbol.iterator](), _step42; !(_iteratorNormalCompletion42 = (_step42 = _iterator42.next()).done); _iteratorNormalCompletion42 = true) {
						var _step42$value = _slicedToArray(_step42.value, 1);
	
						var to = _step42$value[0];
						edges.push(this.edge(key, to));
					}
				} catch (err) {
					_didIteratorError42 = true;
					_iteratorError42 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion42 && _iterator42['return']) {
							_iterator42['return']();
						}
					} finally {
						if (_didIteratorError42) {
							throw _iteratorError42;
						}
					}
				}
	
				var _iteratorNormalCompletion43 = true;
				var _didIteratorError43 = false;
				var _iteratorError43 = undefined;
	
				try {
					for (var _iterator43 = this.verticesTo(key)[Symbol.iterator](), _step43; !(_iteratorNormalCompletion43 = (_step43 = _iterator43.next()).done); _iteratorNormalCompletion43 = true) {
						var _step43$value = _slicedToArray(_step43.value, 1);
	
						var from = _step43$value[0];
						edges.push(this.edge(from, key));
					}
				} catch (err) {
					_didIteratorError43 = true;
					_iteratorError43 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion43 && _iterator43['return']) {
							_iterator43['return']();
						}
					} finally {
						if (_didIteratorError43) {
							throw _iteratorError43;
						}
					}
				}
	
				if (edges.length) {
					throw new (_bind.apply(Graph.HasConnectedEdgesError, [null].concat([key], edges)))();
				}
			}
		}], [{
			key: _privateEs6Js._extractTwoArgs,
	
			////////////////////////////////////////////////////////
			////////// Static private convenience methods //////////
			////////////////////////////////////////////////////////
	
			value: function (a, b) {
				return Array.isArray(a) ? a : [a, b];
			}
		}, {
			key: _privateEs6Js._extractThreeArgs,
			value: function (a, b, c) {
				if (Array.isArray(a)) {
					var _temp = [].concat(_toConsumableArray(a), [b]);
	
					var _temp2 = _slicedToArray(_temp, 3);
	
					a = _temp2[0];
					b = _temp2[1];
					c = _temp2[2];
					_temp;
				}
				if (Array.isArray(a)) {
					var _temp3 = [].concat(_toConsumableArray(a), [b]);
	
					var _temp32 = _slicedToArray(_temp3, 3);
	
					a = _temp32[0];
					b = _temp32[1];
					c = _temp32[2];
					_temp3;
				}
				return [a, b, c];
			}
		}, {
			key: 'plugin',
	
			////////////////////////////
			////////// Mixins //////////
			////////////////////////////
	
			/**
	   * Install a new instance method for the `Graph` class.
	   * @static
	   * @param [name]    {string  } the name of the new instance method; defaults to `method.name`
	   * @param method    {function} a function taking a graph as its first argument
	   * @param [context] {object  } an optional object to refer to when using `this` inside the given `method`
	   */
			value: function plugin(name, method, context) {
				if (typeof name === 'function' && typeof name.name === 'string') {
					var _temp4 = [name.name, name, method];
					name = _temp4[0];
					method = _temp4[1];
					context = _temp4[2];
					_temp4;
				}
				if (typeof name === 'string') {
					if (typeof method === 'function') {
						Object.assign(this.prototype, _defineProperty({}, name, function () {
							for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
								args[_key6] = arguments[_key6];
							}
	
							return method.apply(context, [this].concat(args));
						}));
					} else {
						this.prototype[name] = method; // document ability to add non-function values
					}
				} else {
					var obj = name;
					var _context = method;
					var _iteratorNormalCompletion44 = true;
					var _didIteratorError44 = false;
					var _iteratorError44 = undefined;
	
					try {
						for (var _iterator44 = Object.keys(obj)[Symbol.iterator](), _step44; !(_iteratorNormalCompletion44 = (_step44 = _iterator44.next()).done); _iteratorNormalCompletion44 = true) {
							var _name = _step44.value;
	
							this.plugin(_name, obj[_name], _context || obj);
						}
					} catch (err) {
						_didIteratorError44 = true;
						_iteratorError44 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion44 && _iterator44['return']) {
								_iterator44['return']();
							}
						} finally {
							if (_didIteratorError44) {
								throw _iteratorError44;
							}
						}
					}
				}
			}
		}]);
	
		return Graph;
	})();
	
	exports['default'] = Graph;
	
	//  ////////////////////////////////////////////////////////////////////////////////////////////////
	//  // Errors //////////////////////////////////////////////////////////////////////////////////////
	//  ////////////////////////////////////////////////////////////////////////////////////////////////
	
	/**
	 * @class
	 * @classdesc This type of error is thrown when specific vertices are expected not to exist, but do.
	 * @extends Error
	 */
	Graph.VertexExistsError = (function (_Error) {
		function VertexExistsError() {
			for (var _len7 = arguments.length, vertices = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
				vertices[_key7] = arguments[_key7];
			}
	
			_classCallCheck(this, VertexExistsError);
	
			_get(Object.getPrototypeOf(VertexExistsError.prototype), 'constructor', this).call(this);
			/**
	   * the set of relevant vertices as `[key, value]` shaped arrays
	   * @public
	   * @constant vertices
	   * @memberof Graph.VertexExistsError
	   * @instance
	   * @type {Set.<Array>}
	   */
			this.vertices = new Set(vertices);
			this.message = 'This graph has ' + (this.vertices.size === 1 ? 'a vertex' : 'vertices') + ' \'' + [].concat(_toConsumableArray(this.vertices)).map(function (_ref6) {
				var _ref62 = _slicedToArray(_ref6, 1);
	
				var key = _ref62[0];
				return key;
			}).join('\', \'') + '\'';
		}
	
		_inherits(VertexExistsError, _Error);
	
		return VertexExistsError;
	})(Error);
	
	/**
	 * @class
	 * @classdesc This type of error is thrown when specific vertices are expected to exist, but don't.
	 * @extends Error
	 */
	Graph.VertexNotExistsError = (function (_Error2) {
		function VertexNotExistsError() {
			for (var _len8 = arguments.length, keys = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
				keys[_key8] = arguments[_key8];
			}
	
			_classCallCheck(this, VertexNotExistsError);
	
			_get(Object.getPrototypeOf(VertexNotExistsError.prototype), 'constructor', this).call(this);
			/**
	   * the set of relevant vertex keys
	   * @public
	   * @constant vertices
	   * @memberof Graph.VertexNotExistsError
	   * @instance
	   * @type {Set.<string>}
	   */
			this.vertices = new Set(keys);
			this.message = 'This graph does not have ' + (this.vertices.size === 1 ? 'a vertex' : 'vertices') + ' \'' + [].concat(_toConsumableArray(this.vertices)).join('\', \'') + '\'';
		}
	
		_inherits(VertexNotExistsError, _Error2);
	
		return VertexNotExistsError;
	})(Error);
	
	/**
	 * @class
	 * @classdesc This type of error is thrown when specific edges are expected not to exist, but do.
	 * @extends Error
	 */
	Graph.EdgeExistsError = (function (_Error3) {
		function EdgeExistsError() {
			for (var _len9 = arguments.length, edges = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
				edges[_key9] = arguments[_key9];
			}
	
			_classCallCheck(this, EdgeExistsError);
	
			_get(Object.getPrototypeOf(EdgeExistsError.prototype), 'constructor', this).call(this);
			/**
	   * the set of relevant edges as `[[from, to], value]` shaped arrays
	   * @public
	   * @constant edges
	   * @memberof Graph.EdgeExistsError
	   * @instance
	   * @type {Set.<Array>}
	   */
			this.edges = new Set(edges);
			this.message = 'This graph has ' + (this.edges.size === 1 ? 'an edge' : 'edges') + ' ' + [].concat(_toConsumableArray(this.edges)).map(function (_ref7) {
				var _ref72 = _slicedToArray(_ref7, 1);
	
				var key = _ref72[0];
				return '[' + key + ']';
			}).join(', ');
		}
	
		_inherits(EdgeExistsError, _Error3);
	
		return EdgeExistsError;
	})(Error);
	
	/**
	 * @class
	 * @classdesc This type of error is thrown when specific edges are expected to exist, but don't.
	 * @extends Error
	 */
	Graph.EdgeNotExistsError = (function (_Error4) {
		function EdgeNotExistsError() {
			for (var _len10 = arguments.length, edges = Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
				edges[_key10] = arguments[_key10];
			}
	
			_classCallCheck(this, EdgeNotExistsError);
	
			_get(Object.getPrototypeOf(EdgeNotExistsError.prototype), 'constructor', this).call(this);
			/**
	   * the set of relevant edge keys as `[from, to]` shaped arrays
	   * @public
	   * @constant edges
	   * @memberof Graph.EdgeNotExistsError
	   * @instance
	   * @type {Set.<Array.<string>>}
	   */
			this.edges = new Set(edges);
			this.message = 'This graph does not have ' + (this.edges.size === 1 ? 'an edge' : 'edges') + ' ' + [].concat(_toConsumableArray(this.edges)).map(function (_ref8) {
				var _ref82 = _slicedToArray(_ref8, 1);
	
				var key = _ref82[0];
				return '[' + key + ']';
			}).join(', ');
		}
	
		_inherits(EdgeNotExistsError, _Error4);
	
		return EdgeNotExistsError;
	})(Error);
	
	/**
	 * @class
	 * @classdesc This type of error is thrown when a vertex is expected not to have any connected edges, but does.
	 * @extends Graph.EdgeExistsError
	 */
	Graph.HasConnectedEdgesError = (function (_Graph$EdgeExistsError) {
		function HasConnectedEdgesError(key) {
			for (var _len11 = arguments.length, edges = Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
				edges[_key11 - 1] = arguments[_key11];
			}
	
			_classCallCheck(this, HasConnectedEdgesError);
	
			_get(Object.getPrototypeOf(HasConnectedEdgesError.prototype), 'constructor', this).apply(this, edges);
			/**
	   * the key of the vertex that has connected edges
	   * @public
	   * @constant vertex
	   * @memberof Graph.HasConnectedEdgesError
	   * @instance
	   * @type {string}
	   */
			this.vertex = key;
			this.message = 'The \'' + key + '\' vertex has connected ' + (this.edges.size === 1 ? 'an edge' : 'edges') + ' ' + [].concat(_toConsumableArray(this.edges)).map(function (_ref9) {
				var _ref92 = _slicedToArray(_ref9, 1);
	
				var key = _ref92[0];
				return '[' + key + ']';
			}).join(', ');
		}
	
		_inherits(HasConnectedEdgesError, _Graph$EdgeExistsError);
	
		return HasConnectedEdgesError;
	})(Graph.EdgeExistsError);
	
	/**
	 * @class
	 * @classdesc This type of error is thrown when a graph is expected not to have a directed cycle, but does.
	 * @extends Error
	 */
	Graph.CycleError = (function (_Error5) {
		function CycleError(cycle) {
			_classCallCheck(this, CycleError);
	
			_get(Object.getPrototypeOf(CycleError.prototype), 'constructor', this).call(this);
			/**
	   * the vertices involved in the cycle, in order but with an unspecified starting point
	   * @public
	   * @constant cycle
	   * @memberof Graph.CycleError
	   * @instance
	   * @type {Array.<string>}
	   */
			this.cycle = cycle;
			this.message = 'This graph contains a cycle: ' + cycle;
		}
	
		_inherits(CycleError, _Error5);
	
		return CycleError;
	})(Error);
	
	/**
	 * @class
	 * @classdesc This type of error is thrown when a graph is expected not to have a branch-less directed cycle, but does.
	 * @extends Graph.CycleError
	 */
	Graph.BranchlessCycleError = (function (_Graph$CycleError) {
		function BranchlessCycleError(cycle) {
			_classCallCheck(this, BranchlessCycleError);
	
			_get(Object.getPrototypeOf(BranchlessCycleError.prototype), 'constructor', this).call(this, cycle);
			this.message = 'This graph contains a branch-less cycle: ' + cycle;
		}
	
		_inherits(BranchlessCycleError, _Graph$CycleError);
	
		return BranchlessCycleError;
	})(Graph.CycleError);
	module.exports = exports['default'];

	// This algorithm is based on the following article:
	// Enumeration of the elementary circuits of a directed graph
	// R. Tarjan, SIAM Journal on Computing, 2 (1973), pp. 211-216
	// http://dx.doi.org/10.1137/0202017
	// -----
	// TODO: implement the improved version as defined by Johnson:
	// Finding all the elementary circuits of a directed graph.
	// D. B. Johnson, SIAM Journal on Computing 4, no. 1, 77-84, 1975.
	// http://dx.doi.org/10.1137/0204007

	/* bookkeeping */

	/* the main recursive backtracking algorithm */
	// if a simple cycle continuing the partial path on the pointStack has been found

	/* start backtracking from each vertex in the graph */

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
		"use strict";
	
		var _nextId = 0;
	
		return function uniqueId(prefix) {
			return "" + (prefix || "unique-id") + "-" + _nextId++;
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	//  ////////////////////////////////////////////////////////////////////////////////////////////////
	//  // Symbols for private members /////////////////////////////////////////////////////////////////
	//  ////////////////////////////////////////////////////////////////////////////////////////////////
	
	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	window.__graphjs__private__ = window.__graphjs__private__ || {};
	
	var _options = window.__graphjs__private__._options || Symbol("options");
	exports._options = _options;
	var _vertices = window.__graphjs__private__._vertices || Symbol("vertices");
	exports._vertices = _vertices;
	var _edges = window.__graphjs__private__._edges || Symbol("edges");
	exports._edges = _edges;
	var _reverseEdges = window.__graphjs__private__._reverseEdges || Symbol("reverse edges");
	exports._reverseEdges = _reverseEdges;
	var _sources = window.__graphjs__private__._sources || Symbol("sources");
	exports._sources = _sources;
	var _sinks = window.__graphjs__private__._sinks || Symbol("sinks");
	exports._sinks = _sinks;
	var _edgeCount = window.__graphjs__private__._edgeCount || Symbol("edge count");
	exports._edgeCount = _edgeCount;
	var _extractTwoArgs = window.__graphjs__private__._extractTwoArgs || Symbol("extract ([a, b]) or (a, b) arguments");
	exports._extractTwoArgs = _extractTwoArgs;
	var _extractThreeArgs = window.__graphjs__private__._extractThreeArgs || Symbol("extract ([[a, b], c]), ([a, b], c) or (a, b, c) arguments");
	exports._extractThreeArgs = _extractThreeArgs;
	var _listeners = window.__graphjs__private__._listeners || Symbol("listeners");
	exports._listeners = _listeners;
	var _trigger = window.__graphjs__private__._trigger || Symbol("trigger");
	exports._trigger = _trigger;
	var _verticesFrom = window.__graphjs__private__._verticesFrom || Symbol("vertices from");
	exports._verticesFrom = _verticesFrom;
	var _verticesTo = window.__graphjs__private__._verticesTo || Symbol("vertices to");
	exports._verticesTo = _verticesTo;
	var _edgesFrom = window.__graphjs__private__._edgesFrom || Symbol("edges from");
	exports._edgesFrom = _edgesFrom;
	var _edgesTo = window.__graphjs__private__._edgesTo || Symbol("edges to");
	exports._edgesTo = _edgesTo;
	var _verticesWithPathTo = window.__graphjs__private__._verticesWithPathTo || Symbol("vertices with path to");
	exports._verticesWithPathTo = _verticesWithPathTo;
	var _verticesWithPathFrom = window.__graphjs__private__._verticesWithPathFrom || Symbol("vertices with path from");
	exports._verticesWithPathFrom = _verticesWithPathFrom;
	var _paths = window.__graphjs__private__._paths || Symbol("paths");
	exports._paths = _paths;
	var _expectVertices = window.__graphjs__private__._expectVertices || Symbol("expect vertices");
	exports._expectVertices = _expectVertices;
	var _expectVerticesAbsent = window.__graphjs__private__._expectVerticesAbsent || Symbol("expect vertex absent");
	exports._expectVerticesAbsent = _expectVerticesAbsent;
	var _expectEdges = window.__graphjs__private__._expectEdges || Symbol("expect edge");
	exports._expectEdges = _expectEdges;
	var _expectEdgesAbsent = window.__graphjs__private__._expectEdgesAbsent || Symbol("expect edge absent");
	exports._expectEdgesAbsent = _expectEdgesAbsent;
	var _expectNoConnectedEdges = window.__graphjs__private__._expectNoConnectedEdges || Symbol("expect no connected edges");
	
	exports._expectNoConnectedEdges = _expectNoConnectedEdges;
	Object.assign(window.__graphjs__private__, {
		_options: _options,
		_vertices: _vertices,
		_edges: _edges,
		_reverseEdges: _reverseEdges,
		_sources: _sources,
		_sinks: _sinks,
		_edgeCount: _edgeCount,
		_extractTwoArgs: _extractTwoArgs,
		_extractThreeArgs: _extractThreeArgs,
		_listeners: _listeners,
		_trigger: _trigger,
		_verticesFrom: _verticesFrom,
		_verticesTo: _verticesTo,
		_edgesFrom: _edgesFrom,
		_edgesTo: _edgesTo,
		_verticesWithPathTo: _verticesWithPathTo,
		_verticesWithPathFrom: _verticesWithPathFrom,
		_paths: _paths,
		_expectVertices: _expectVertices,
		_expectVerticesAbsent: _expectVerticesAbsent,
		_expectEdges: _expectEdges,
		_expectEdgesAbsent: _expectEdgesAbsent,
		_expectNoConnectedEdges: _expectNoConnectedEdges
	});

/***/ }
/******/ ]);
//# sourceMappingURL=example2.js.map